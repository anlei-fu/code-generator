Creating procedure FD_P_WRITE_LOG
prompt =================================
prompt
create or replace procedure fd_account.fd_p_write_log(p_obj_name in varchar2,
                                           p_sql_err  in varchar2,
                                           p_err_lev  in varchar2 default 'error') as
  pragma autonomous_transaction; --自治事务
  l_out_error varchar2(1000);
begin

  insert into fd_system_log
    (log_id, object_name, error_desc, trace, error_level)
  values
    (seq_system_log_id.nextval,
     substrb(p_obj_name, 1, 100),
     substrb(p_sql_err, 1, 1000),
     substrb(nvl(dbms_utility.format_error_backtrace,
                 dbms_utility.format_call_stack),
             0,
             1000),
     p_err_lev);

  commit;
exception
  when others then
    rollback;
    l_out_error := to_char(sqlerrm);
    return;
end;
/

prompt
prompt Creating procedure FD_P_WRITE_HANDLE_LOG
prompt ========================================
prompt
create or replace procedure fd_account.fd_p_write_handle_log(v_handle_module varchar2,
                                                  v_handle_user   varchar2,
                                                  v_handle_params varchar2) as
  pragma autonomous_transaction; --自治事务
begin
  ---1.记录操作日志
  insert into fd_system_handle_log
    (log_id, handle_module, handle_user, handle_time, handle_params)
  values
    (seq_system_handle_log_id.nextval,
     v_handle_module,
     v_handle_user,
     sysdate,
     v_handle_params);

  commit;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_write_handle_log', sqlerrm, 1);
    return;
end;
/

prompt
prompt Creating function CZTH_P_TRADE_RV
prompt =================================
prompt
create or replace function fd_account.czth_p_trade_rv(v_down_channel_no varchar2,
                                           v_up_channel_no   varchar2,
                                           v_draw_amount     number,
                                           v_service_rate    number,
                                           v_subsidy         number,
                                           v_bill_type       number,
                                           v_business_type   number,
                                           v_create_user     varchar2,
                                           v_memo            varchar2)
  return varchar2 is
  ----------------充值特惠交易平账--------------
  PRAGMA AUTONOMOUS_TRANSACTION;
  l_result          varchar2(32);
  l_down_account_id number;
  l_up_account_id   number;
  l_company_id      number;
  l_fund_id         number;
begin
  ---1.检查充值特惠上下游渠道
  l_result := czth_f_trade_rv_check(v_down_channel_no,
                                    v_up_channel_no,
                                    l_down_account_id,
                                    l_up_account_id,
                                    l_company_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---2.下游交易平账
  l_result := fd_f_manual_down_rv_trade(v_down_channel_no,
                                        l_down_account_id,
                                        (v_draw_amount - v_subsidy),
                                        (v_draw_amount - v_subsidy),
                                        v_business_type,
                                        v_bill_type,
                                        v_create_user,
                                        v_memo,
                                        null,
                                        l_fund_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---3.上游交易平账
  l_result := fd_f_manual_up_rv_trade(v_up_channel_no,
                                      l_up_account_id,
                                      v_draw_amount,
                                      v_draw_amount,
                                      v_business_type,
                                      v_bill_type,
                                      v_create_user,
                                      v_memo,
                                      l_fund_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---4.充值特惠平账记录添加
  l_result := czth_f_trade_rv_add(v_down_channel_no,
                                  l_down_account_id,
                                  v_up_channel_no,
                                  l_up_account_id,
                                  l_company_id,
                                  v_draw_amount,
                                  v_service_rate,
                                  v_subsidy,
                                  v_bill_type,
                                  v_business_type,
                                  v_memo);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---5.记录操作日志
  fd_p_write_handle_log('充值特惠交易平账',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_up_channel_no=' || v_up_channel_no ||
                        ',v_draw_amount=' || v_draw_amount));

  commit;
  return pkg_error_code.success;
exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_up_trade_rv', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function DK_F_ADJUST_DOWN_SETTLE_CHECK
prompt ===============================================
prompt
create or replace function fd_account.dk_f_adjust_down_settle_check(v_record_id   number,
                                                         v_adjust_days number)
  return varchar2 is
  -------------检查加款记录、账户、余额、手续费--------------
  l_record_count number;
  l_change_time  date;
begin
  ---1. 检查加款记录、账户及余额
  select count(1), max(t.change_time)
    into l_record_count, l_change_time
    from dk_trade_down_settle t
   inner join dk_base_down_account f on t.account_id = f.account_id
   inner join fd_bank_cash_fund b on t.bank_fund_id = b.service_id
   inner join fd_bank_account_info a on b.account_id = a.account_id
   where t.record_id = v_record_id
     and t.add_type = pkg_down_manual_change_type.add_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and b.has_adjust = pkg_sys_boolean.isfalse
     and t.change_amount = b.change_amount;

  if (l_record_count != 1 and l_record_count != 2) then
    return pkg_error_code.data_error;
  end if;

  if l_change_time < (trunc(sysdate) - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_ADJUST_DOWN_SETTLE_HANDLE
prompt ================================================
prompt
create or replace function fd_account.dk_f_adjust_down_settle_handle(v_record_id   number,
                                                          v_create_user varchar2,
                                                          v_memo        varchar2)
  return varchar2 is
  -------------下游结算红冲--------------
  --->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  --= 因目前手续费不明确,手续费相关逻辑去掉
  ---<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

  l_pay_account_id  number;
  l_bank_fund_id    number;
  l_bank_account_id number;
  l_change_amount   number;
  l_inner_balance   number;
  l_bank_balance    number;
  l_fund_main_id    number;
  l_fund_service_id number;
  l_bank_batch_id   number; ---加款记录的统一流水编号---查询需要红冲的银行卡变动记录
  l_handle_batch_id number; ---红冲加款的统一流水号
  l_change_time     date;
begin
  --================获取相关记录数据================
  ---1. 获取实体卡资金变动编号
  select t.bank_fund_id, t.account_id, t.change_amount, t.change_time
    into l_bank_batch_id, l_pay_account_id, l_change_amount, l_change_time
    from dk_trade_down_settle t
   where t.record_id = v_record_id;

  ---2. 获取手续费变动记录编号
  select t.account_id, t.record_id
    into l_bank_account_id, l_bank_fund_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.change_type = pkg_bank_fund_change_type.minus_amount -->>>>>>>>>>> 由原来的 add 改成了 minus
     and t.use_type = pkg_bank_use_type.dk_down_settle --<<<<<<<<<<<<<< 这里要和原来扣款的枚举一致 yangdj 20161019
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  --===================手续费记录红冲====================
  ---1. 锁实体卡账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;

  ---2.修改实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + l_change_amount), -->>>>>>>>>>>>>>>>> 由原来的 -，修改为 +
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_bank_account_id;

  ---2.1获取红冲加款的统一流水号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  --=====================银行卡记录红冲=============================
  ---1.红冲实体卡下游加款记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0 - l_change_amount),
           (l_bank_balance + l_change_amount), -->>>>>>>>>>>>>>>>> 由原来的 -，修改为 +
           sysdate,
           v_create_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id,
           t.remark_name
      from fd_bank_cash_fund t
     where t.record_id = l_bank_fund_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---2.修改原记录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_bank_fund_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --=================渠道账户红冲===================
  ---1. 锁下游支付账户
  select t.inner_balance
    into l_inner_balance
    from dk_base_down_account t
   where t.account_id = l_pay_account_id
     for update;

  ---2.更新账户余额
  update dk_base_down_account t
     set t.inner_balance  = l_inner_balance - l_change_amount, --->>>>>>>>>>>>>> 这里没有变化,负：欠商户的结算款 增多
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_pay_account_id;

  ---3.红冲手工加款记录
  select seq_trade_down_fund_id.nextval into l_fund_main_id from dual;
  select seq_trade_down_fund_id.nextval into l_fund_service_id from dual;

  insert into dk_trade_down_settle
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
    select l_fund_main_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           0,
           pkg_down_manual_change_type.red_recharge,
           (0 - l_change_amount),
           sysdate,
           (l_inner_balance - l_change_amount),
           v_create_user,
           t.partner_account,
           v_memo
      from dk_trade_down_settle t
     where t.record_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---4.修改原加款记录状态
  update dk_trade_down_settle t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.红冲资金变动中手工加款记录
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
    select l_fund_main_id,
           t.dk_order_id,
           t.channel_no,
           t.account_id,
           t.trade_order_no,
           t.ext_order_no,
           t.order_source,
           sysdate,
           t.order_time,
           t.change_type,
           (0 - l_change_amount),
           (l_inner_balance - l_change_amount),
           v_memo
      from dk_trade_down_fund t
     where t.record_id = v_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_ADJUST_SETTLE_REPORT
prompt ===========================================
prompt
create or replace function fd_account.dk_f_adjust_settle_report(v_settle_report_id number,
                                                     v_fund_batch_id    number)
  return varchar2 is
  ----------------后付结算记录还原----------------
begin

  update dk_reprot_channel_settle t
     set t.settle_status  = pkg_dk_report_settle_status.wait,
         t.settle_deal_id = 0,
         t.settle_user    = null,
         t.settle_time    = null,
         t.settle_memo    = null
   where t.id = v_settle_report_id
     and t.settle_status = pkg_dk_report_settle_status.complete
     and t.settle_deal_id = v_fund_batch_id;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_ADJUST_UP_SETTLE_CHECK
prompt =============================================
prompt
create or replace function fd_account.dk_f_adjust_up_settle_check(v_record_id   number,
                                                    v_adjust_days number)
  return varchar2 is
  -------------检查加款记录、账户、余额、手续费--------------
  l_record_count number;
  l_change_time  date;
begin
  ---1. 检查加款记录、账户及余额
  select count(1), max(t.change_time)
    into l_record_count, l_change_time
    from dk_trade_up_settle t
   inner join dk_base_up_account f on t.account_id = f.account_id
   inner join fd_bank_cash_fund b on t.bank_fund_id = b.service_id
   inner join fd_bank_account_info a on b.account_id = a.account_id
   where t.record_id = v_record_id
     and t.manual_change_type = pkg_up_manual_change_type.add_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and b.has_adjust = pkg_sys_boolean.isfalse
     and t.change_amount = b.change_amount;

  if (l_record_count != 1 and l_record_count != 2) then
    return pkg_error_code.data_error;
  end if;

  if l_change_time < (sysdate - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_ADJUST_UP_SETTLE_HANDLE
prompt ==============================================
prompt
create or replace function fd_account.dk_f_adjust_up_settle_handle(v_record_id   number,
                                                        v_create_user varchar2,
                                                        v_memo        varchar2)
  return varchar2 is
  -------------上游手工加款红冲--------------
  l_pay_account_id       number;
  l_settle_change_amount number;
  l_bank_batch_id        number; ---加款记录的统一流水编号---查询需要红冲的银行卡变动记录
  l_bank_account_id      number;
  l_inner_balance        number;
  l_bank_balance         number;
  l_fund_record_id       number;
  l_handle_batch_id      number; ---红冲加款的统一流水号
  l_bank_fund_id         number;
  l_change_time          date;
begin
  --===============获取相关记录数据=================

  ---1. 获取加款数据
  select t.account_id, t.change_amount, t.bank_fund_id, t.change_time
    into l_pay_account_id,
         l_settle_change_amount,
         l_bank_batch_id,
         l_change_time
    from dk_trade_up_settle t
   where t.record_id = v_record_id;

  ---2. 获取实体卡加款记录数据
  select t.account_id, t.record_id
    into l_bank_account_id, l_bank_fund_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.use_type = pkg_bank_use_type.dk_up_settle 
     and t.change_type = pkg_bank_fund_change_type.add_amount ----->>>>>>>>> 原先是 minus_amount 
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  --=================实体卡手续费记录红冲====================
  ---1. 锁实体卡账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;

  ---2.更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - l_settle_change_amount), --->>>>>>> 由 + 变成 -
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_bank_account_id;

  ---2.1获取数据红冲对应的统一流水编号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  --========================实体卡加款记录红冲=============================
  ---1.红冲实体卡下游加款记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0 - t.change_amount),
           (l_bank_balance - l_settle_change_amount), --->>>>>>>>>>>>> 由 + 变成 -
           sysdate,
           v_create_user,
           t.change_type,
           pkg_bank_use_type.up_add, -- TODO:??
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id,
           t.remark_name
      from fd_bank_cash_fund t
     where t.record_id = l_bank_fund_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---2.修改原实体卡加款纪录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_bank_fund_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --========================渠道账户记录红冲==============================
  ---1. 锁上游支付账户
  select t.inner_balance
    into l_inner_balance
    from dk_base_up_account t
   where t.account_id = l_pay_account_id
     for update;

  ---2.修改渠道账户余额
  update dk_base_up_account t
     set t.inner_balance  = (l_inner_balance - l_settle_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_pay_account_id;

  ---4.红冲手工加款记录
  select seq_trade_up_fund_id.nextval into l_fund_record_id from dual;

  insert into dk_trade_up_settle
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
    select l_fund_record_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           pkg_sys_boolean.istrue,
           pkg_up_manual_change_type.red_recharge,
           (0 - t.change_amount),
           sysdate,
           (l_inner_balance - l_settle_change_amount),
           v_create_user,
           t.partner_account,
           v_memo
      from dk_trade_up_settle t
     where t.record_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.修改原加款记录状态
  update dk_trade_up_settle t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---6.红冲资金变动中手工加款记录
  insert into dk_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
    select l_fund_record_id,
           t.up_channel_no,
           t.up_account_id,
           t.up_company_id,
           (0 - t.up_draw_amount),
           (0 - t.up_real_amount),
           sysdate,
           pkg_up_fund_change_type.add_amount, -- TODO:??
           (l_inner_balance - l_settle_change_amount),
           v_memo
      from dk_trade_up_fund t
     where t.record_id = v_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_AUTO_COMMI_PROFIT_SYNC
prompt =============================================
prompt
create or replace function fd_account.dk_f_auto_commi_profit_sync(v_merge_date date)
  return varchar2 is
  ---------------同步sp佣金利润报表数据-------------
  l_commi_profit_count number;
begin
  ---1.检查佣金利润未同步数据是否存在,不存在返回成功
  select count(1)
    into l_commi_profit_count
    from dk_report_commi_profit_daily t
   where t.snap_time = v_merge_date
     and t.add_status = pkg_commi_profit_add_status.complate
     and t.sync_status = pkg_report_sync_status.wait;

  if l_commi_profit_count = 0 then
    return pkg_error_code.success;
  end if;

  ---2.数据存在，将等待同步的数据改为正在同步
  update dk_report_commi_profit_daily t
     set t.sync_status = pkg_report_sync_status.syncing
   where t.snap_time = v_merge_date
     and t.add_status = pkg_commi_profit_add_status.complate
     and t.sync_status = pkg_report_sync_status.wait;

  if sql%rowcount != l_commi_profit_count then
    return pkg_error_code.data_error;
  end if;

  ---3.将正在同步的数据同步到财务报表数据中
  insert into fd_report_commi_profit_daily
    (record_id,
     company_id,
     channel_no,
     account_id,
     channel_type,
     business_type,
     bill_type,
     total_unit,
     total_face,
     draw_amount,
     real_amount,
     commission,
     profits,
     service_fee,
     refund_total_unit,
     refund_total_face,
     refund_draw_amount,
     refund_real_amount,
     refund_commission,
     refund_profits,
     refund_service_fee,
     up_many_face,
     up_many_amount,
     snap_time,
     add_status,
     statistics_type,
     channel_name,
     account_name,
     channel_source_system)
    select seq_report_commi_profit_id.nextval,
           t.company_id,
           t.channel_no,
           t.account_id,
           decode(t.channel_type,
                  pkg_channel_type.up_channel,
                  pkg_channel_type.down_channel,
                  pkg_channel_type.down_channel,
                  pkg_channel_type.up_channel,
                  t.channel_type),
           t.business_type,
           t.bill_type,
           t.total_unit,
           t.total_face,
           t.draw_amount +
           decode(t.channel_type, pkg_channel_type.down_channel, 1, -1) *
           nvl(t.sys_cost, 0), ---系统垫付金额算到扣款中
           t.real_amount +
           decode(t.channel_type, pkg_channel_type.down_channel, 1, -1) *
           nvl(t.sys_cost, 0),
           t.commission,
           t.profits -
           decode(t.channel_type, pkg_channel_type.down_channel, 1, -1) *
           nvl(t.sys_cost, 0),
           t.service_fee,
           t.refund_total_unit,
           t.refund_total_face,
           t.refund_draw_amount,
           t.refund_real_amount,
           t.refund_commission,
           t.refund_profits,
           t.refund_service_fee,
           0,
           0,
           t.snap_time,
           t.add_status,
           t.statistics_type,
           t.channel_name,
           t.account_name,
           t.channel_source_system
      from dk_report_commi_profit_daily t
     where t.snap_time = v_merge_date
       and t.sync_status = pkg_report_sync_status.syncing;

  if sql%rowcount != l_commi_profit_count then
    return pkg_error_code.data_error;
  end if;

  ---4.将已同步的数据标记为同步完成
  update dk_report_commi_profit_daily t
     set t.sync_status = pkg_report_sync_status.complate
   where t.snap_time = v_merge_date
     and t.sync_status = pkg_report_sync_status.syncing;

  if sql%rowcount != l_commi_profit_count then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_AUTO_ZERO_BALANCE_SYNC
prompt =============================================
prompt
create or replace function fd_account.dk_f_auto_zero_balance_sync(v_merge_date date)
  return varchar2 is
  -----------------sp报表同步财务报表---------------
  l_zero_balance_count number;
begin
  ---1.检查是否有等待同步的数据，不存在返回成功
  select count(1)
    into l_zero_balance_count
    from dk_report_zero_balance t
   where t.record_date = v_merge_date
     and t.sync_status = pkg_report_sync_status.wait;

  if l_zero_balance_count = 0 then
    return pkg_error_code.success;
  end if;

  ---2.数据存在，将等待同步的数据改为正在同步
  update dk_report_zero_balance t
     set t.sync_status = pkg_report_sync_status.syncing
   where t.record_date = v_merge_date
     and t.sync_status = pkg_report_sync_status.wait;

  if sql%rowcount != l_zero_balance_count then
    return pkg_error_code.data_error;
  end if;

  ---3.将正在同步的数据同步到财务报表
  insert into fd_report_zero_balance
    (record_id,
     record_date,
     created_time,
     account_type,
     account_id,
     channel_no,
     balance,
     account_name,
     channel_name,
     query_balance,
     channel_status,
     account_status,
     company_id,
     down_first_face,
     down_first_amount,
     channel_source_system,
     channel_classif)
    select seq_report_zero_balance_id.nextval,
           t.record_date,
           t.created_time,
           decode(t.account_type,
                  pkg_report_zero_acc_type.up_channel,
                  pkg_report_zero_acc_type.down_channel,
                  pkg_report_zero_acc_type.down_channel,
                  pkg_report_zero_acc_type.up_channel,
                  pkg_report_zero_acc_type.down_commi_account,
                  pkg_report_zero_acc_type.up_commi_account,
                  pkg_report_zero_acc_type.up_commi_account,
                  pkg_report_zero_acc_type.down_commi_account,
                  t.account_type),
           t.account_id,
           t.channel_no,
           t.balance,
           t.account_name,
           t.channel_name,
           t.query_balance,
           t.channel_status,
           t.account_status,
           t.company_id,
           t.down_first_face,
           t.down_first_amount,
           t.channel_source_system,
           decode(t.channel_classif,
                  pkg_dk_channel_classification.sp,
                  pkg_business_type.DK_Dianbo,
                  pkg_business_type.DK_Recharge_Card)
      from dk_report_zero_balance t
     where t.record_date = v_merge_date
       and t.sync_status = pkg_report_sync_status.syncing;

  if sql%rowcount != l_zero_balance_count then
    return pkg_error_code.data_error;
  end if;

  ---4.将同步的数据标记为同步完成
  update dk_report_zero_balance t
     set t.sync_status = pkg_report_sync_status.complate
   where t.record_date = v_merge_date
     and t.sync_status = pkg_report_sync_status.syncing;

  if sql%rowcount != l_zero_balance_count then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_BANK_COMMISION_CHECK
prompt ===========================================
prompt
create or replace function fd_account.dk_f_bank_commision_check(v_channel_no      varchar2,
                                                     v_channel_type    number,
                                                     v_bank_account_id number,
                                                     v_commission      number,
                                                     v_service_fee     number)
  return varchar2 is
  ------------------获取并检查结算参数------------------
  l_bank_balance    number;
  l_commi_balance   number;
  l_bank_company_id number;
begin
  ---0.检查佣金
  if v_commission <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---1.检查银行卡
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id;

  ---2.检查渠道
  if v_channel_type = pkg_channel_type.up_channel then
  
    select t.commi_balance
      into l_commi_balance
      from dk_base_up_channel t
     where t.channel_no = v_channel_no
       and t.company_id = l_bank_company_id;
  
    if (v_commission + v_service_fee) > l_bank_balance then
      return pkg_error_code.balance_low;
    end if;
  elsif v_channel_type = pkg_channel_type.down_channel then
  
    select t.commi_balance
      into l_commi_balance
      from dk_base_down_channel t
     where t.channel_no = v_channel_no
       and t.company_id = l_bank_company_id;
  else
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_BANK_COMMISION_SETTLE
prompt ============================================
prompt
create or replace function fd_account.dk_f_bank_commision_settle(v_channel_no      varchar2,
                                                      v_channel_type    number,
                                                      v_bank_account_id number,
                                                      v_commission      number,
                                                      v_commi_month     varchar2,
                                                      v_service_fee     number,
                                                      v_settle_user     varchar2,
                                                      v_memo            varchar2)
  return varchar2 is
  ----------------代扣佣金结算-----------------
  l_bank_balance     number;
  l_bank_end_balance number;
  l_bank_change_type number;
  l_bank_use_type    number;
  l_bank_batch_id    number;
  l_company_id       number;
  l_channel_name     varchar2(100);
  l_commi_balance    number;
begin
  ---1.锁银行卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---2.修改银行卡余额
  if v_channel_type = pkg_channel_type.down_channel then
    l_bank_end_balance := l_bank_balance + v_commission - v_service_fee;
    l_bank_change_type := pkg_bank_fund_change_type.add_amount;
    l_bank_use_type    := pkg_bank_use_type.down_commission;
  
    select t.channel_name
      into l_channel_name
      from dk_base_down_channel t
     where t.channel_no = v_channel_no;
  else
    l_bank_end_balance := l_bank_balance - v_commission - v_service_fee;
    l_bank_change_type := pkg_bank_fund_change_type.minus_amount;
    l_bank_use_type    := pkg_bank_use_type.up_commission;
  
    select t.channel_name
      into l_channel_name
      from dk_base_up_channel t
     where t.channel_no = v_channel_no;
  end if;

  update fd_bank_account_info t
     set t.balance        = l_bank_end_balance,
         t.last_edit_user = v_settle_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---3.添加银行卡流水
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  if v_service_fee > 0 then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       0,
       l_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_settle_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       pkg_sys_boolean.isfalse,
       l_channel_name,
       '-',
       v_memo,
       l_bank_batch_id);
  end if;

  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     0,
     l_company_id,
     v_commission,
     l_bank_end_balance,
     sysdate,
     v_settle_user,
     l_bank_change_type,
     l_bank_use_type,
     pkg_sys_boolean.isfalse,
     l_channel_name,
     '-',
     v_memo,
     l_bank_batch_id);

  if v_channel_type = pkg_channel_type.down_channel then
    ---4.下游渠道扣佣金
    select t.commi_balance
      into l_commi_balance
      from dk_base_down_channel t
     where t.channel_no = v_channel_no
       for update;
  
    if v_commission > l_commi_balance then
      return pkg_error_code.balance_low;
    end if;
  
    update dk_base_down_channel t
       set t.commi_balance  = (l_commi_balance - v_commission),
           t.last_edit_user = v_settle_user,
           t.last_edit_time = sysdate
     where t.channel_no = v_channel_no;
  else
    ---5.上游渠道扣佣金
    select t.commi_balance
      into l_commi_balance
      from dk_base_up_channel t
     where t.channel_no = v_channel_no
       for update;
  
    if v_commission > l_commi_balance then
      return pkg_error_code.balance_low;
    end if;
  
    update dk_base_up_channel t
       set t.commi_balance  = (l_commi_balance - v_commission),
           t.last_edit_user = v_settle_user,
           t.last_edit_time = sysdate
     where t.channel_no = v_channel_no;
  
  end if;

  ---6.添加佣金结算记录
  insert into dk_trade_commission_settle
    (report_id,
     channel_no,
     channel_type,
     commission,
     settle_month,
     settle_status,
     settle_user,
     settle_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     settle_type,
     commi_balance)
  values
    (seq_trade_commission_settle_id.nextval,
     v_channel_no,
     v_channel_type,
     v_commission,
     to_date(v_commi_month, 'yyyymmddhh24miss'),
     pkg_sys_boolean.istrue,
     v_settle_user,
     sysdate,
     pkg_sys_boolean.isfalse,
     0,
     l_bank_batch_id,
     pkg_commi_settle_type.settle,
     (l_commi_balance - v_commission));

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_CHANNEL_COMPANY_CHECK
prompt ============================================
prompt
create or replace function fd_account.dk_f_channel_company_check(v_down_channel_no varchar2,
                                                      v_up_channel_no   varchar2)
  return varchar2 is
  ---------------------收卡公司检查-----------------------
  l_down_company_id number;
  l_up_company_id   number;
begin
  select t.company_id
    into l_down_company_id
    from dk_base_down_channel t
   where t.channel_no = v_down_channel_no;

  select t.company_id
    into l_up_company_id
    from dk_base_up_channel t
   where t.channel_no = v_up_channel_no;

  if l_down_company_id != l_up_company_id then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_CHANNEL_SETTLE_ADD
prompt =========================================
prompt
create or replace function fd_account.dk_f_channel_settle_add(v_change_start_time date,
                                                   v_change_end_time   date)
  return varchar2 is
  -------------渠道结算记录添加--------------
  l_up_change_count   number;
  l_down_change_count number;
begin
  ---1.添加渠道上游结算记录
  insert into dk_reprot_channel_settle
    (id,
     channel_no,
     channel_type,
     settle_data_time,
     settle_batch_id,
     settle_amount,
     settle_status)
    select seq_dk_chennel_settle_id.nextval,
           tab.up_channel_no,
           pkg_channel_type.up_channel,
           tab.order_time,
           tab.channel_settle_batch_id,
           tab.settle_amount,
           decode(tab.payment_type,
                  pkg_dk_channel_payment_type.prepay,
                  pkg_dk_report_settle_status.noneed,
                  pkg_dk_report_settle_status.wait)
      from (select trunc(t.order_time) order_time,
                   t.channel_settle_batch_id,
                   t.up_channel_no,
                   max(c.payment_type) payment_type,
                   sum(decode(t.change_type,
                              pkg_up_fund_change_type.debit_amount,
                              1,
                              -1) * t.up_draw_amount) settle_amount
              from dk_trade_up_fund t
             inner join dk_base_up_channel c on t.up_channel_no =
                                                c.channel_no
                                            and c.classification =
                                                pkg_dk_channel_classification.sk
             where t.change_time > v_change_start_time
               and t.change_time < v_change_end_time
               and t.channel_settle_status =
                   pkg_dk_channel_settle_status.doing
               and t.change_type in (pkg_up_fund_change_type.debit_amount,
                    pkg_up_fund_change_type.refund_amount)
             group by trunc(t.order_time),
                      t.channel_settle_batch_id,
                      t.up_channel_no) tab;

  l_up_change_count := sql%rowcount;

  ---2.添加渠道下游结算记录
  insert into dk_reprot_channel_settle
    (id,
     channel_no,
     channel_type,
     settle_data_time,
     settle_batch_id,
     settle_amount,
     settle_status)
    select seq_dk_chennel_settle_id.nextval,
           tab.down_channel_no,
           pkg_channel_type.down_channel,
           tab.order_time,
           tab.channel_settle_batch_id,
           tab.settle_amount,
           decode(tab.payment_type,
                  pkg_dk_channel_payment_type.prepay,
                  pkg_dk_report_settle_status.noneed,
                  pkg_dk_report_settle_status.wait)
      from (select trunc(t.order_time) order_time,
                   t.channel_settle_batch_id,
                   t.down_channel_no,
                   max(c.payment_type) payment_type,
                   sum(decode(t.change_type,
                              pkg_up_fund_change_type.debit_amount,
                              1,
                              -1) * t.down_draw_amount) settle_amount
              from dk_trade_up_fund t
             inner join dk_base_down_channel c on t.down_channel_no =
                                                  c.channel_no
                                              and c.classification =
                                                  pkg_dk_channel_classification.sk
             where t.change_time > v_change_start_time
               and t.change_time < v_change_end_time
               and t.channel_settle_status =
                   pkg_dk_channel_settle_status.doing
               and t.change_type in (pkg_up_fund_change_type.debit_amount,
                    pkg_up_fund_change_type.refund_amount)
             group by trunc(t.order_time),
                      t.channel_settle_batch_id,
                      t.down_channel_no) tab;

  l_down_change_count := sql%rowcount;

  if l_down_change_count = 0 and l_up_change_count = 0 then
    return pkg_error_code.data_error;
  end if;

  ---3.循环获取等待计算批次号
  for item in (select f.channel_settle_batch_id
                 from dk_trade_up_fund f
                where f.change_time > v_change_start_time
                  and f.change_time < v_change_end_time
                  and f.channel_settle_status =
                      pkg_dk_channel_settle_status.doing
                group by f.channel_settle_batch_id) loop
    begin
      ---4.添加下游资金变动结算信息
      update dk_trade_down_fund t
         set t.channel_settle_status   = pkg_dk_channel_settle_status.complete,
             t.channel_settle_batch_id = item.channel_settle_batch_id,
             t.channel_settle_time     = sysdate
       where t.create_time > v_change_start_time - 2
         and t.create_time < v_change_end_time + 2
         and exists (select 1
                from dk_trade_up_fund f
               where f.change_time > v_change_start_time
                 and f.change_time < v_change_end_time
                 and f.trade_order_no = t.trade_order_no
                 and f.channel_settle_batch_id =
                     item.channel_settle_batch_id
                 and f.channel_settle_status =
                     pkg_dk_channel_settle_status.doing);
    end;
  end loop;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  ---5.完成渠道结算记录创建
  update dk_trade_up_fund t
     set t.channel_settle_status = pkg_dk_channel_settle_status.complete,
         t.channel_settle_time   = sysdate
   where t.change_time > v_change_start_time
     and t.change_time < v_change_end_time
     and t.channel_settle_status = pkg_dk_channel_settle_status.doing;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_MANUAL_DOWN_COMMI_ADD
prompt ============================================
prompt
create or replace function fd_account.dk_f_manual_down_commi_add(v_down_channel_no in varchar2,
                                                      v_down_account_id in number,
                                                      v_amount          in number,
                                                      v_commi_month     in varchar2,
                                                      v_create_user     in varchar2,
                                                      v_memo            in varchar2)
  return varchar2 is
  ------------------代扣下游佣金转渠道余额-----------------
  l_inner_balance       number;
  l_fund_record_main_id number;
  l_cap_account_name    varchar2(100);
  l_bank_batch_id       number;
  l_commi_balance       number;
  ------------下游手工加款----------
begin
  select seq_bank_service_id.nextval, seq_trade_down_fund_id.nextval
    into l_bank_batch_id, l_fund_record_main_id
    from dual;

  --===============3.修改渠道佣金=============================================
  ---1.锁下游渠道
  select t.commi_balance
    into l_commi_balance
    from dk_base_down_channel t
   where t.channel_no = v_down_channel_no
     for update;

  ---2.检查佣金余额
  if v_amount > l_commi_balance then
    return pkg_error_code.balance_low;
  end if;

  ---3.修改佣金余额
  update dk_base_down_channel t
     set t.commi_balance  = (l_commi_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.channel_no = v_down_channel_no;

  ---4.添加佣金结算记录
  insert into dk_trade_commission_settle
    (report_id,
     channel_no,
     channel_type,
     commission,
     settle_month,
     settle_status,
     settle_user,
     settle_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     settle_type,
     commi_balance,
     memo)
  values
    (seq_trade_commission_settle_id.nextval,
     v_down_channel_no,
     pkg_channel_type.down_channel,
     v_amount,
     to_date(v_commi_month, 'yyyymmddhh24miss'),
     pkg_sys_boolean.istrue,
     v_create_user,
     sysdate,
     pkg_sys_boolean.isfalse,
     0,
     l_bank_batch_id,
     pkg_commi_settle_type.to_channel,
     (l_commi_balance - v_amount),
     v_memo);

  --==============4.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加下游手工加款记录、添加下游资金变动]=====
  ---1.锁下游渠道账户
  select t.inner_balance
    into l_inner_balance
    from dk_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.更新渠道账户余额
  update dk_base_down_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---3.添加下游人工加款记录
  insert into dk_trade_down_settle
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_fund_record_main_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_create_user,
     l_bank_batch_id,
     l_cap_account_name,
     v_memo);

  ---4.添加下游资金变动
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_main_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.add_amount,
     v_amount,
     (l_inner_balance + v_amount),
     v_memo);
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_MANUAL_DOWN_COMMI_ADD_CK
prompt ===============================================
prompt
create or replace function fd_account.dk_f_manual_down_commi_add_ck(v_down_channel_no varchar2,
                                                         v_down_account_id number,
                                                         v_amount          number)
  return varchar2 is
  ------------------下游佣金转渠道余额检查-----------------
  l_company_id    number;
  l_commi_balance number;
begin
  ---1.检查加款金额
  if v_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户
  select c.company_id, c.commi_balance
    into l_company_id, l_commi_balance
    from dk_base_down_account_map t
   inner join dk_base_down_account a on t.account_id = a.account_id
   inner join dk_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
     and rownum <= 1;

  if v_amount > l_commi_balance then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_MANUAL_DOWN_DRAW
prompt =======================================
prompt
create or replace function fd_account.dk_f_manual_down_draw(v_down_channel_no varchar2,
                                                 v_down_account_id number,
                                                 v_bank_account_id number,
                                                 v_amount          number, ---渠道到账金额
                                                 v_service_fee     number, ---公司承担手续费
                                                 v_create_user     varchar2,
                                                 v_partner_account varchar2,
                                                 v_memo            varchar2,
                                                 v_remark_name     in varchar2,--收付款账户名称
                                                 v_account_name    varchar2,
                                                 v_channel_name    varchar2)
  return varchar2 is
  l_inner_balance  number;
  l_credit_money   number;
  l_bank_balance   number;
  l_fund_record_id number;
  l_bank_company   number;
  l_bank_batch_id  number;
  ----------------------------------------------
  --功能：下游提款
  --创建人：周荣省
  --创建时间：2019-05-24
  ----------------------------------------------
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

  -----银行卡手续费（资金变动(i)6）
  -----银行卡（账户表 (f)2，账户(u)5,加款资金变动(i)7）
  -----公司手续费（账户表(f)1，账户(u)3,资金变动(i)4）
  -----下游渠道（账户(f)8，账户(u)9,下游加款记录表(i)10,资金变动(i)11）
begin
  --================1.锁账户获取参数======================
  --=========[锁公司手续费账户、锁实体卡账户、检查实体卡余额、获取seq]=======

  --1.锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  /*if (v_amount + v_service_fee) > l_bank_balance then
    return pkg_error_code.balance_low;
  end if;*/

  ---2.获取部分添加参数

  select seq_trade_down_fund_id.nextval into l_fund_record_id from dual;

  ---获取银行卡资金变动统一流水号
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================3.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡手续费的资金变动、添加实体卡加款的资金变动]===
  ---1.更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + v_amount - v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  if (v_service_fee > 0) then
    ---2.添加手续费
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       l_bank_company,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.add_amount,
       pkg_bank_use_type.service_fee,
       v_channel_name,
       v_account_name,
       v_memo,
       l_bank_batch_id,v_remark_name);

  end if;

  ---3.添加实体卡资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company,
     v_amount,
     (l_bank_balance + v_amount - v_service_fee),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.add_amount,
     pkg_bank_use_type.down_draw,
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id,v_remark_name);

  --==============4.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加下游手工加款记录、添加下游资金变动]=====
  ---1.锁下游渠道账户
  select t.inner_balance
    into l_inner_balance
    from dk_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.更新渠道账户余额
  update dk_base_down_account t
     set t.inner_balance  = (l_inner_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---3.添加下游人工加款记录
  insert into dk_trade_down_settle
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_fund_record_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.draw_amount,
     v_amount,
     sysdate,
     (l_inner_balance - v_amount),
     v_create_user,
     l_bank_batch_id,
     v_partner_account,
     v_memo);

  ---4.添加下游资金变动
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.draw_amount,
     v_amount,
     (l_inner_balance - v_amount),
     v_memo);

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function DK_F_MANUAL_DOWN_DRAW_CHECK
prompt =============================================
prompt
create or replace function fd_account.dk_f_manual_down_draw_check(v_down_channel_no varchar2,
                                                       v_down_account_id number,
                                                       v_bank_account_id number,
                                                       v_amount          number,
                                                       v_service_fee     number,
                                                       v_account_name    out varchar2,
                                                       v_channel_name    out varchar2)
  return varchar2 is
  ----------------------------------------
  --功能：手工操作获取下游支付账户
  --创建人：周荣省
  --创建时间：2019-05-24
  ----------------------------------------
  l_bank_count   number;
  l_company_id   number;
  l_bank_balance number;
begin
  ---1. 判断金额是否大于0
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2. 检查下游渠道
  select c.company_id, a.account_name, c.channel_name
    into l_company_id, v_account_name, v_channel_name
    from dk_base_down_account_map t
   inner join dk_base_down_account a on t.account_id = a.account_id
   inner join dk_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
        --and a.status = 0
        --and c.status = 0
     and rownum <= 1;

  ---3.检查实体卡账户是否存在
  select count(1), max(t.balance)
    into l_bank_count, l_bank_balance
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id;

  if (l_bank_count = 0) then
    return pkg_error_code.bank_account_id_error;
  end if;

  if (v_amount > l_bank_balance) then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function DK_F_MANUAL_DOWN_RV_CHANNEL
prompt =============================================
prompt
create or replace function fd_account.dk_f_manual_down_rv_channel(v_down_channel_no varchar2,
                                                       v_down_account_id number,
                                                       v_revise_type     number,
                                                       v_revise_amount   number,
                                                       v_create_user     varchar2,
                                                       v_memo            varchar2)
  return varchar2 is
  -------------------渠道账户余额平账------------------
  l_inner_balance         number;
  l_trade_fund_id         number;
  l_down_manual_type      number;
  l_up_fund_type          number;
  l_down_fund_type        number;
  l_balance_change_amount number;
begin
  ---1.获取变动记录参数
  select seq_trade_down_fund_id.nextval into l_trade_fund_id from dual;

  if (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.balance) then
    l_down_manual_type      := pkg_down_manual_change_type.balance_revise_add;
    l_up_fund_type          := 0;
    l_down_fund_type        := pkg_down_fund_change_type.add_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount < 0 and
        v_revise_type = pkg_sys_revise_type.balance) then
    l_down_manual_type      := pkg_down_manual_change_type.balance_revise_minus;
    l_up_fund_type          := 0;
    l_down_fund_type        := pkg_down_fund_change_type.add_amount;
    l_balance_change_amount := v_revise_amount;
  else
    return pkg_error_code.data_error;
  end if;

  ---2.锁渠道账户
  select t.inner_balance
    into l_inner_balance
    from dk_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---4修改账户余额添加资金变动
  update dk_base_down_account t
     set t.inner_balance  = (l_inner_balance + l_balance_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---5下游手工记录添加
  insert into dk_trade_down_settle
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo)
  values
    (l_trade_fund_id,
     v_down_channel_no,
     v_down_account_id,
     0,
     0,
     l_down_manual_type,
     v_revise_amount,
     sysdate,
     (l_inner_balance + l_balance_change_amount),
     v_create_user,
     nvl2(v_memo, v_memo || ',下游平账', '下游平账'));

  ---6.下游资金变动添加
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_trade_fund_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     l_down_fund_type,
     v_revise_amount,
     (l_inner_balance + l_balance_change_amount),
     v_memo);

  ---7.上游资金变动（不存下游公司以免结算)
  if l_up_fund_type != 0 then
    insert into dk_trade_up_fund
      (record_id,
       down_channel_no,
       down_account_id,
       down_company_id,
       up_channel_no,
       up_account_id,
       up_company_id,
       down_draw_unit,
       down_draw_face,
       down_draw_amount,
       down_real_amount,
       up_draw_amount,
       up_real_amount,
       change_time,
       change_type,
       balance,
       memo)
    values
      (seq_trade_up_fund_id.nextval,
       v_down_channel_no,
       v_down_account_id,
       0,
       0,
       0,
       0,
       0,
       0,
       v_revise_amount,
       v_revise_amount,
       0,
       0,
       sysdate,
       l_up_fund_type,
       0,
       v_memo);
  end if;

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function DK_F_MANUAL_DOWN_RV_CHANNEL_CK
prompt ================================================
prompt
create or replace function fd_account.dk_f_manual_down_rv_channel_ck(v_down_channel_no varchar2,
                                                          v_down_account_id number,
                                                          v_revise_amount   number)
  return varchar2 is
  -------------------检查下游渠道账户手工平账渠道账户、金额是否正确--------------------
  l_down_account_id number;
begin
  ---1.检查调整金额是否正确
  if (v_revise_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户是否正确
  select t.account_id
    into l_down_account_id
    from dk_base_down_account_map t
   inner join dk_base_down_account a on t.account_id = a.account_id
   inner join dk_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
     and rownum <= 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_or_account_error;
  
end;
/

prompt
prompt Creating function DK_F_MANUAL_DOWN_RV_TRADE
prompt ===========================================
prompt
create or replace function fd_account.dk_f_manual_down_rv_trade(v_down_channel_no  varchar2,
                                                     v_down_account_id  number,
                                                     v_down_draw_amount number,
                                                     v_down_real_amount number,
                                                     v_business_type    number,
                                                     v_bill_type        number,
                                                     v_create_user      varchar2,
                                                     v_memo             varchar2)
  return varchar2 is
  l_trade_fund_id    number;
  l_inner_balance    number;
  l_trade_up_fund_id number;
  l_down_company     number;

  --------------------下游渠道交易平账-----------------------
begin
  ---1.获取变动记录参数
  select seq_trade_down_fund_id.nextval, seq_trade_up_fund_id.nextval
    into l_trade_fund_id, l_trade_up_fund_id
    from dual;

  select t.company_id
    into l_down_company
    from dk_base_down_channel t
   where t.channel_no = v_down_channel_no;

  if v_down_draw_amount != 0 then
  
    select t.inner_balance
      into l_inner_balance
      from dk_base_down_account t
     where t.account_id = v_down_account_id
       for update;
  
    ---2.修改账户余额添加资金变动
    update dk_base_down_account t
       set t.inner_balance  = (l_inner_balance - v_down_draw_amount),
           t.last_edit_user = v_create_user,
           t.last_edit_time = sysdate
     where t.account_id = v_down_account_id;
  else
    select t.inner_balance
      into l_inner_balance
      from dk_base_down_account t
     where t.account_id = v_down_account_id;
  
  end if;

  ---3.下游手工记录添加
  insert into dk_trade_down_settle
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo,
     real_amount)
  values
    (l_trade_fund_id,
     v_down_channel_no,
     v_down_account_id,
     0,
     0,
     pkg_down_manual_change_type.trade_revise,
     v_down_draw_amount,
     sysdate,
     (l_inner_balance - v_down_draw_amount),
     v_create_user,
     nvl2(v_memo, v_memo || ',下游交易平账', '下游交易平账'),
     v_down_real_amount);

  ---4.下游资金变动添加(通过trade_order_no关联上游资金变动)
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_trade_fund_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     'SARV' || l_trade_up_fund_id,
     pkg_down_fund_change_type.debit_amount,
     v_down_draw_amount,
     (l_inner_balance - v_down_draw_amount),
     v_memo);

  ---5.上游资金变动（上游下游公司相同避免结算)
  insert into dk_trade_up_fund
    (record_id,
     trade_order_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     balance,
     memo)
  values
    (l_trade_up_fund_id,
     'SARV' || l_trade_up_fund_id,
     v_down_channel_no,
     v_down_account_id,
     l_down_company,
     0,
     0,
     l_down_company,
     0,
     0,
     v_down_draw_amount,
     v_down_real_amount,
     0,
     0,
     sysdate,
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     v_business_type,
     0,
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_MANUAL_DOWN_RV_TRADE_CK
prompt ==============================================
prompt
create or replace function fd_account.dk_f_manual_down_rv_trade_ck(v_down_channel_no  varchar2,
                                                        v_down_account_id  number,
                                                        v_down_draw_amount number,
                                                        v_down_real_amount number)

 return varchar2 is
  l_down_account_id number;
begin
  ---1.检查调整金额是否正确
  if (v_down_draw_amount = 0 and v_down_real_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户是否正确
  select t.account_id
    into l_down_account_id
    from dk_base_down_account_map t
   inner join dk_base_down_account a on t.account_id = a.account_id
   inner join dk_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
     and rownum <= 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function DK_F_MANUAL_DOWN_SETTLE
prompt =========================================
prompt
create or replace function fd_account.dk_f_manual_down_settle(v_down_channel_no varchar2,
                                                   v_down_account_id number,
                                                   v_bank_account_id number,
                                                   v_settle_amount   number, ---渠道到账金额
                                                   v_service_fee     number, ---暂不考虑手续费
                                                   v_create_user     varchar2,
                                                   v_partner_account varchar2,
                                                   v_memo            varchar2,
                                                   v_remark_name     in varchar2,--收付款账户名称
                                                   v_account_name    varchar2,
                                                   v_channel_name    varchar2,
                                                   v_bank_batch_id   out number)
  return varchar2 is
  l_inner_balance          number;
  l_bank_balance           number;
  l_fund_record_main_id    number;
  l_fund_record_service_id number;
  l_bank_company           number;
  ------------下游手工加款----------
  ---->>>>>>>>>>>>>>>>>>>>>>>>>>>>
  ---- 手续费不明确，暂时去掉该段逻辑
  ---- yangdejian 20161019
  ----<<<<<<<<<<<<<<<<<<<<<<<<<<<<

  -----银行卡手续费（资金变动(i)6）
  -----银行卡（账户表 (f)2，账户(u)5,加款资金变动(i)7）
  -----公司手续费（账户表(f)1，账户(u)3,资金变动(i)4）
  -----下游渠道（账户(f)8，账户(u)9,下游加款记录表(i)10,资金变动(i)11）
begin
  --================1.锁账户获取参数======================
  --=========[锁公司手续费账户、锁实体卡账户、检查实体卡余额、获取seq]=======

  --1.锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---2.获取部分添加参数

  select seq_trade_down_fund_id.nextval
    into l_fund_record_main_id
    from dual;
  select seq_trade_down_fund_id.nextval
    into l_fund_record_service_id
    from dual;

  ---获取银行卡资金变动统一流水号
  select seq_bank_service_id.nextval into v_bank_batch_id from dual;

  -->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  -- 这里和以前不同，结算是对实体卡 进行减款
  -- yangdj 20161019
  --<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  --====================3.实体卡账户==================
  --==[更新实体卡账户余额、添加实体卡手续费的资金变动、添加实体卡 减款 的资金变动]===
  ---1.更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_settle_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---3.添加实体卡资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company,
     v_settle_amount,
     (l_bank_balance - v_settle_amount),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.minus_amount, --- 这里由add_amount 改为了 minus_amount, yangdj 20161019
     pkg_bank_use_type.dk_down_settle, --->>>>>>>> 新增user_type.dk_down_settle
     v_channel_name,
     v_account_name,
     v_memo,
     v_bank_batch_id,v_remark_name);

  --==============4.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加下游手工加款记录、添加下游资金变动]=====
  ---1.锁下游渠道账户
  select t.inner_balance
    into l_inner_balance
    from dk_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.更新渠道账户余额
  update dk_base_down_account t
     set t.inner_balance  = (l_inner_balance + v_settle_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---3.添加下游人工加款记录
  insert into dk_trade_down_settle
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_fund_record_main_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.add_amount,
     v_settle_amount,
     sysdate,
     (l_inner_balance + v_settle_amount),
     v_create_user,
     v_bank_batch_id,
     v_partner_account,
     v_memo);

  ---4.添加下游资金变动
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_main_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.add_amount,
     v_settle_amount,
     (l_inner_balance + v_settle_amount),
     v_memo);

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function DK_F_MANUAL_DOWN_SETTLE_CHECK
prompt ===============================================
prompt
create or replace function fd_account.dk_f_manual_down_settle_check(v_down_channel_no varchar2,
                                                         v_down_account_id number,
                                                         v_bank_account_id number,
                                                         v_settle_amount   number,
                                                         v_service_fee     number,
                                                         v_account_name    out varchar2,
                                                         v_channel_name    out varchar2)
  return varchar2 is
  ----------------手工操作获取下游支付账户-----------------
  l_bank_count number;
  l_company_id number;
begin
  ---1. 判断金额是否大于0
  if (v_settle_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2. 检查下游渠道
  select c.company_id, a.account_name, c.channel_name
    into l_company_id, v_account_name, v_channel_name
    from dk_base_down_account_map t
   inner join dk_base_down_account a on t.account_id = a.account_id
   inner join dk_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
        -- and a.status = 0
        --  and c.status = 0
     and rownum <= 1;

  ---3.检查实体卡账户是否存在
  select count(1)
    into l_bank_count
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id;

  if (l_bank_count = 0) then
    return pkg_error_code.bank_account_id_error;
  end if;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function DK_F_MANUAL_UP_COMMI_ADD
prompt ==========================================
prompt
create or replace function fd_account.dk_f_manual_up_commi_add(v_up_channel_no in varchar2,
                                                    v_up_account_id in number,
                                                    v_amount        in number,
                                                    v_commi_month   in varchar2,
                                                    v_create_user   in varchar2,
                                                    v_memo          in varchar2)
  return varchar2 is
  ------------------上游佣金转渠道余额-----------------
  l_inner_balance number;
  l_fund_id       number;
  l_bank_batch_id number;
  l_commi_balance number;
  l_channel_name  varchar2(100);
  l_company_id    number;
begin

  --===============1.修改渠道佣金=============================================
  select seq_bank_service_id.nextval, seq_trade_up_fund_id.nextval
    into l_bank_batch_id, l_fund_id
    from dual;

  ---1.锁下游渠道
  select t.commi_balance, t.channel_name, t.company_id
    into l_commi_balance, l_channel_name, l_company_id
    from dk_base_up_channel t
   where t.channel_no = v_up_channel_no
     for update;

  ---2.检查佣金余额
  if v_amount > l_commi_balance then
    return pkg_error_code.balance_low;
  end if;

  ---3.修改佣金余额
  update dk_base_up_channel t
     set t.commi_balance  = (l_commi_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.channel_no = v_up_channel_no;

  ---4.添加佣金结算记录
  insert into dk_trade_commission_settle
    (report_id,
     channel_no,
     channel_type,
     commission,
     settle_month,
     settle_status,
     settle_user,
     settle_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     settle_type,
     commi_balance,
     memo)
  values
    (seq_trade_commission_settle_id.nextval,
     v_up_channel_no,
     pkg_channel_type.up_channel,
     v_amount,
     to_date(v_commi_month, 'yyyymmddhh24miss'),
     pkg_sys_boolean.istrue,
     v_create_user,
     sysdate,
     pkg_sys_boolean.isfalse,
     0,
     l_bank_batch_id,
     pkg_commi_settle_type.to_channel,
     (l_commi_balance - v_amount),
     v_memo);

  --==============2.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加下游手工加款记录、添加下游资金变动]=====
  ---1.锁下游渠道账户
  select t.inner_balance
    into l_inner_balance
    from dk_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.更新渠道账户余额
  update dk_base_up_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  ---3.添加手工加款记录
  insert into dk_trade_up_settle
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.cap_add,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_memo,
     v_create_user,
     l_channel_name,
     l_bank_batch_id);

  ---4.添加资金变动
  insert into dk_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     l_company_id,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance + v_amount),
     v_memo);
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_MANUAL_UP_COMMI_ADD_CK
prompt =============================================
prompt
create or replace function fd_account.dk_f_manual_up_commi_add_ck(v_up_channel_no varchar2,
                                                       v_up_account_id number,
                                                       v_amount        number)
  return varchar2 is
  ------------------上游佣金转渠道余额检查-----------------
  l_company_id    number;
  l_commi_balance number;
begin
  ---1.检查加款金额
  if v_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户
  select c.company_id, c.commi_balance
    into l_company_id, l_commi_balance
    from dk_base_up_account_map t
   inner join dk_base_up_account a on t.account_id = a.account_id
   inner join dk_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and rownum <= 1;

  if v_amount > l_commi_balance then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_MANUAL_UP_DRAW
prompt =====================================
prompt
create or replace function fd_account.dk_f_manual_up_draw(v_up_channel_no   varchar2,
                                               v_up_company_id   number,
                                               v_up_account_id   number,
                                               v_bank_account_id number,
                                               v_amount          number,
                                               v_service_fee     number,
                                               v_create_user     varchar2,
                                               v_partner_account varchar2,
                                               v_memo            varchar2,
                                               v_remark_name     in varchar2,--收付款账户名称
                                               v_account_name    varchar2,
                                               v_channel_name    varchar2)
  return varchar2 is
  l_inner_balance   number;
  l_bank_balance    number;
  l_fund_id         number;
  l_bank_company_id number;
  l_bank_batch_id   number; ---银行卡加款变动统一流水号
  -----------------------------------------------
  --功能：账户手工加款,上游退款银行卡余额减少
  --创建人：周荣省
  --创建时间：2019-05-24
  -----------------------------------------------
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

  -----银行卡手续费（资金变动(i)6）
  -----银行卡（账户表 (f)2，账户(u)5,加款资金变动(i)7）
  -----公司手续费（账户表(f)1，账户(u)3,资金变动(i)4）
  -----上游渠道（账户(f)8，账户(u)9,上游加款记录表(i)10,资金变动(i)11）

begin
  --===============1.锁账户获取参数==========================================
  --=========[锁实体卡账户、检查实体卡余额、获取seq]=======
  ---1.锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---3.获取资金变动主键
  ---手续费手费资金变动编号，小于人工加款的资金变动编号
  select seq_trade_up_fund_id.nextval into l_fund_id from dual;
  ---获取银行卡加款变动统一流水号
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================2.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡手续费的资金变动、添加实体卡加款的资金变动]===
  ---1更新实体卡账户
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_amount - v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  if (v_service_fee > 0) then
    ---2.添加实体卡手续费资金变动
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       l_bank_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       v_channel_name,
       v_account_name,
       v_memo,
       l_bank_batch_id,v_remark_name);
  end if;

  ---3.添加实体卡加款资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company_id,
     v_amount,
     (l_bank_balance - v_amount - v_service_fee),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.up_draw,
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id,v_remark_name);

  --==============4.更新渠道账户==================================================
  ---1.锁上游渠道账户
  select t.inner_balance
    into l_inner_balance
    from dk_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.更新上游渠道账户余额
  update dk_base_up_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  ---3.添加手工加款的提款记录
  insert into dk_trade_up_settle
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.draw_amount,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_memo,
     v_create_user,
     v_partner_account,
     l_bank_batch_id);

  ---4.添加资金变动
  insert into dk_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.draw_amount,
     (l_inner_balance + v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_MANUAL_UP_DRAW_CHECK
prompt ===========================================
prompt
create or replace function fd_account.dk_f_manual_up_draw_check(v_up_channel_no   varchar2,
                                                     v_up_account_id   number,
                                                     v_bank_account_id number,
                                                     v_amount          number,
                                                     v_service_fee     number,
                                                     v_up_company_id   out number,
                                                     v_account_name    out varchar2,
                                                     v_channel_name    out varchar2)
  return varchar2 is
  -----------------------------------------
  --功能：上游提款检查
  --创建人：周荣省
  --创建时间：2019-05-24
  -----------------------------------------
  l_bank_count number;
begin
  ---1.检查金额是否正确
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查上游资金账户
  select c.company_id, a.account_name, c.channel_name
    into v_up_company_id, v_account_name, v_channel_name
    from dk_base_up_account_map t
   inner join dk_base_up_account a on t.account_id = a.account_id
   inner join dk_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
        --and a.status = pkg_sys_boolean.istrue
        -- and c.status = pkg_sys_boolean.istrue
     and rownum <= 1;

  ---3.检查实体卡账户是否存在
  select count(1)
    into l_bank_count
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id;

  if (l_bank_count = 0) then
    return pkg_error_code.bank_account_id_error;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function DK_F_MANUAL_UP_RV_CHANNEL
prompt ===========================================
prompt
create or replace function fd_account.dk_f_manual_up_rv_channel(v_up_channel_no varchar2,
                                                     v_up_account_id number,
                                                     v_revise_type   number,
                                                     v_revise_amount number,
                                                     v_create_user   varchar2,
                                                     v_memo          varchar2)
  return varchar2 is
  -------------------上游渠道账户平账------------------
  l_inner_balance         number;
  l_trade_fund_id         number;
  l_up_manual_type        number;
  l_fund_type             number;
  l_balance_change_amount number;
begin
  ---1.获取渠道资金变动参数
  select seq_trade_up_fund_id.nextval into l_trade_fund_id from dual;

  if (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.balance) then
    l_up_manual_type        := pkg_up_manual_change_type.balance_revise_add;
    l_fund_type             := pkg_up_fund_change_type.add_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount < 0 and
        v_revise_type = pkg_sys_revise_type.balance) then
    l_up_manual_type        := pkg_up_manual_change_type.balance_revise_minus;
    l_fund_type             := pkg_up_fund_change_type.add_amount;
    l_balance_change_amount := v_revise_amount;
  else
    return pkg_error_code.data_error;
  end if;

  ---2.锁渠道账户
  select t.inner_balance
    into l_inner_balance
    from dk_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---3.修改账户余额添加资金变动
  update dk_base_up_account t
     set t.inner_balance  = (l_inner_balance + l_balance_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  insert into dk_trade_up_settle
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     has_adjust)
  values
    (l_trade_fund_id,
     v_up_channel_no,
     v_up_account_id,
     0,
     l_up_manual_type,
     v_revise_amount,
     sysdate,
     (l_inner_balance + l_balance_change_amount),
     nvl2(v_memo, v_memo || ',上游平账', '上游平账'),
     v_create_user,
     0);

  insert into dk_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_trade_fund_id,
     v_up_channel_no,
     v_up_account_id,
     0,
     v_revise_amount,
     v_revise_amount,
     sysdate,
     l_fund_type,
     (l_inner_balance + l_balance_change_amount),
     v_memo);

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function DK_F_MANUAL_UP_RV_CHANNEL_CK
prompt ==============================================
prompt
create or replace function fd_account.dk_f_manual_up_rv_channel_ck(v_up_channel_no  varchar2,
                                                        v_up_account_id  number,
                                                        v_account_amount number)
  return varchar2 is
  -------------------检查手工平账渠道账户、金额是否正确--------------------
  l_company_id number;
begin

  ---1.检查金额是否正确
  if (v_account_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户是否正确
  select c.company_id
    into l_company_id
    from dk_base_up_account_map t
   inner join dk_base_up_account a on t.account_id = a.account_id
   inner join dk_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and rownum <= 2;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function DK_F_MANUAL_UP_RV_TRADE
prompt =========================================
prompt
create or replace function fd_account.dk_f_manual_up_rv_trade(v_up_channel_no  varchar2,
                                                   v_up_account_id  number,
                                                   v_up_draw_amount number,
                                                   v_up_real_amount number,
                                                   v_business_type  number,
                                                   v_bill_type      number,
                                                   v_create_user    varchar2,
                                                   v_memo           varchar2)
  return varchar2 is
  l_inner_balance    number;
  l_trade_up_fund_id number;
  l_up_company       number;

  --------------------下游渠道交易平账-----------------------
begin
  ---1.获取变动记录参数
  select t.company_id
    into l_up_company
    from dk_base_up_channel t
   where t.channel_no = v_up_channel_no;

  if v_up_draw_amount != 0 then
    select t.inner_balance
      into l_inner_balance
      from dk_base_up_account t
     where t.account_id = v_up_account_id
       for update;
  
    ---2.修改账户余额添加资金变动
    update dk_base_up_account t
       set t.inner_balance  = (l_inner_balance - v_up_draw_amount),
           t.last_edit_user = v_create_user,
           t.last_edit_time = sysdate
     where t.account_id = v_up_account_id;
  else
    select t.inner_balance
      into l_inner_balance
      from dk_base_up_account t
     where t.account_id = v_up_account_id;
  end if;

  ---3.添加上游加款记录
  select seq_trade_up_fund_id.nextval into l_trade_up_fund_id from dual;

  insert into dk_trade_up_settle
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     has_adjust,
     real_amount)
  values
    (l_trade_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     0,
     pkg_up_manual_change_type.trade_revise,
     v_up_draw_amount,
     sysdate,
     (l_inner_balance - v_up_draw_amount),
     v_memo,
     v_create_user,
     0,
     v_up_real_amount);

  ---4.上游资金变动（上游下游公司相同避免结算)
  insert into dk_trade_up_fund
    (record_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     balance,
     memo)
  values
    (l_trade_up_fund_id,
     0,
     0,
     l_up_company,
     v_up_channel_no,
     v_up_account_id,
     l_up_company,
     0,
     0,
     0,
     0,
     v_up_draw_amount,
     v_up_real_amount,
     sysdate,
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     v_business_type,
     (l_inner_balance - v_up_draw_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_MANUAL_UP_RV_TRADE_CK
prompt ============================================
prompt
create or replace function fd_account.dk_f_manual_up_rv_trade_ck(v_up_channel_no  varchar2,
                                                      v_up_account_id  number,
                                                      v_up_draw_amount number,
                                                      v_up_real_amount number)

 return varchar2 is
  l_up_account_id number;
begin
  ---1.检查调整金额是否正确
  if (v_up_draw_amount = 0 and v_up_real_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户是否正确
  select t.account_id
    into l_up_account_id
    from dk_base_up_account_map t
   inner join dk_base_up_account a on t.account_id = a.account_id
   inner join dk_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and rownum <= 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function DK_F_MANUAL_UP_SETTLE
prompt =======================================
prompt
create or replace function fd_account.dk_f_manual_up_settle(v_up_channel_no   varchar2,
                                                 v_up_company_id   number,
                                                 v_up_account_id   number,
                                                 v_bank_account_id number, -- 上游给我们打款的收款账户
                                                 v_settle_amount   number,
                                                 v_service_fee     number, -- 手续费暂不考虑
                                                 v_create_user     varchar2,
                                                 v_partner_account varchar2, -- 上游(合作方)的打款账户
                                                 v_memo            varchar2,
                                                 v_remark_name     in varchar2,--收付款账户名称
                                                 v_account_name    varchar2,
                                                 v_channel_name    varchar2)
  return varchar2 is
  l_inner_balance   number;
  l_bank_balance    number;
  l_fund_id         number;
  l_bank_company_id number;
  l_bank_batch_id   number; ---银行卡加款变动统一流水号
  ------------上游手工加款----------
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

  -----银行卡手续费（资金变动(i)6）
  -----银行卡（账户表 (f)2，账户(u)5,加款资金变动(i)7）
  -----公司手续费（账户表(f)1，账户(u)3,资金变动(i)4）
  -----上游渠道（账户(f)8，账户(u)9,上游加款记录表(i)10,资金变动(i)11）

begin
  --===============1.锁账户获取参数==========================================
  --=========[锁实体卡账户、检查实体卡余额、获取seq]=======
  ---1.锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---3.获取资金变动主键
  ---手续费手费资金变动编号，小于人工加款的资金变动编号
  select seq_trade_up_fund_id.nextval into l_fund_id from dual;
  ---获取银行卡加款变动统一流水号
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  -->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  -- 这里和以前不同，结算是对实体卡 进行加款
  -- yangdj 20161019
  --<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  --====================2.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡手续费的资金变动、添加实体卡加款的资金变动]===
  ---1更新实体卡账户
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + v_settle_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---3.添加实体卡加款资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company_id,
     v_settle_amount,
     (l_bank_balance + v_settle_amount),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.add_amount, --- 这里由 minus_amount 改为了 add_amount, yangdj 20161019
     pkg_bank_use_type.dk_up_settle, -->>>>>>>>>> 新增user_type.dk_up_settle
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id,v_remark_name);

  --==============4.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加上游手工加款记录、添加上游资金变动]=====
  ---1.锁上游渠道账户
  select t.inner_balance
    into l_inner_balance
    from dk_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.更新上游渠道账户余额
  update dk_base_up_account t
     set t.inner_balance  = (l_inner_balance + v_settle_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  ---3.添加手工加款记录
  insert into dk_trade_up_settle
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.add_amount,
     v_settle_amount,
     sysdate,
     (l_inner_balance + v_settle_amount),
     v_memo,
     v_create_user,
     v_partner_account,
     l_bank_batch_id);

  ---4.添加资金变动
  insert into dk_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_settle_amount,
     v_settle_amount,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance + v_settle_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_MANUAL_UP_SETTLE_CHECK
prompt =============================================
prompt
create or replace function fd_account.dk_f_manual_up_settle_check(v_up_channel_no   varchar2,
                                                       v_up_account_id   number,
                                                       v_bank_account_id number,
                                                       v_amount          number,
                                                       v_service_fee     number,
                                                       v_up_company_id   out number,
                                                       v_account_name    out varchar2,
                                                       v_channel_name    out varchar2)
  return varchar2 is
  ----------------获取上游支付账户-----------------
  l_bank_count number;
begin
  ---1.检查金额是否正确
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查上游资金账户
  select c.company_id, a.account_name, c.channel_name
    into v_up_company_id, v_account_name, v_channel_name
    from dk_base_up_account_map t
   inner join dk_base_up_account a on t.account_id = a.account_id
   inner join dk_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
        --  and a.status = pkg_sys_boolean.istrue
        --   and c.status = pkg_sys_boolean.istrue
     and rownum <= 1;

  ---3.检查实体卡账户是否存在
  select count(1)
    into l_bank_count
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id;

  if (l_bank_count = 0) then
    return pkg_error_code.bank_account_id_error;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function DK_F_SUP_ADJUST_BIND_UP
prompt =========================================
prompt
create or replace function fd_account.dk_f_sup_adjust_bind_up(v_sup_record_id      number,
                                                   v_jz_record_id       number,
                                                   v_settle_change_type number,
                                                   v_adjust_user        varchar2,
                                                   v_adjust_memo        varchar2)
  return varchar2 is
  -----------------收卡结算关联的收卡上游、18上游红冲---------------
  l_sup_account_id    number;
  l_sup_inner_balance number;
  l_up_adjust_id      number;
  l_fund_amount       number;
  l_jz_account_id     number;
  l_jz_inner_balance  number;
begin
  ---======================收卡的上游红冲==================
  ---1.获取收卡的上游结算信息
  select t.account_id,
         seq_trade_up_fund_id.nextval,
         decode(v_settle_change_type,
                pkg_up_manual_change_type.red_recharge,
                -1,
                1) * t.change_amount
    into l_sup_account_id, l_up_adjust_id, l_fund_amount
    from dk_trade_up_settle t
   where t.record_id = v_sup_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse
     and v_settle_change_type in (pkg_up_manual_change_type.red_recharge,
          pkg_up_manual_change_type.red_draw);

  ---2.锁收卡的上游账户
  select t.inner_balance
    into l_sup_inner_balance
    from dk_base_up_account t
   where t.account_id = l_sup_account_id
     for update;

  ---3.修改账户余额
  update dk_base_up_account t
     set t.inner_balance  = (l_sup_inner_balance + l_fund_amount),
         t.last_edit_user = v_adjust_user,
         t.last_edit_time = sysdate
   where t.account_id = l_sup_account_id;

  ---4.添加结算红冲记录
  insert into dk_trade_up_settle
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     has_adjust,
     bank_fund_id,
     service_id,
     ext_record_no)
    select l_up_adjust_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           v_settle_change_type,
           (0 - t.change_amount),
           sysdate,
           (l_sup_inner_balance + l_fund_amount),
           v_adjust_memo,
           v_adjust_user,
           t.partner_account,
           pkg_sys_boolean.istrue,
           t.bank_fund_id,
           t.service_id,
           t.ext_record_no
      from dk_trade_up_settle t
     where t.record_id = v_sup_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.添加资金变动红冲记录
  insert into dk_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
    select l_up_adjust_id,
           t.up_channel_no,
           t.up_account_id,
           t.up_company_id,
           t.down_draw_unit,
           (0 - t.up_draw_amount),
           (0 - t.up_real_amount),
           sysdate,
           t.change_type,
           (l_sup_inner_balance + l_fund_amount),
           t.memo
      from dk_trade_up_fund t
     where t.record_id = v_sup_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---6.修改原纪录红冲状态
  update dk_trade_up_settle t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_sup_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --=======================18的上游红冲====================
  ---1.获取18的上游结算信息
  select t.account_id
    into l_jz_account_id
    from fd_trade_up_manual t
   where t.record_id = v_sup_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  ---2.锁18的上游账户
  select t.inner_balance
    into l_jz_inner_balance
    from fd_base_up_account t
   where t.account_id = l_jz_account_id
     for update;

  ---3.修改账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_jz_inner_balance + l_fund_amount),
         t.last_edit_user = v_adjust_user,
         t.last_edit_time = sysdate
   where t.account_id = l_jz_account_id;

  ---4.添加结算红冲记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     has_adjust,
     bank_fund_id,
     service_id,
     ext_record_no)
    select l_up_adjust_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           v_settle_change_type,
           (0 - t.change_amount),
           sysdate,
           (l_jz_inner_balance + l_fund_amount),
           v_adjust_memo,
           v_adjust_user,
           t.partner_account,
           pkg_sys_boolean.istrue,
           t.bank_fund_id,
           t.service_id,
           t.ext_record_no
      from fd_trade_up_manual t
     where t.record_id = v_sup_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.添加资金变动红冲记录
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
    select l_up_adjust_id,
           t.up_channel_no,
           t.up_account_id,
           t.up_company_id,
           t.down_draw_unit,
           (0 - t.up_draw_amount),
           (0 - t.up_real_amount),
           sysdate,
           t.change_type,
           (l_jz_inner_balance + l_fund_amount),
           t.memo
      from fd_trade_up_fund t
     where t.record_id = v_jz_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---6.修改原纪录红冲状态
  update fd_trade_up_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_jz_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_SUP_ADJUST_BIND_UP_CHECK
prompt ===============================================
prompt
create or replace function fd_account.dk_f_sup_adjust_bind_up_check(v_fund_batch_id    number,
                                                         v_change_amount    number,
                                                         v_fund_change_time date,
                                                         v_change_type      number,
                                                         v_sup_record_id    out number,
                                                         v_jz_record_id     out number)
  return varchar2 is
  --------------检查绑定的上游相关下游结算记录是否正确--------------

begin
  ---1.检查收卡系统的上游渠道相关结算记录
  select t.record_id
    into v_sup_record_id
    from dk_trade_up_settle t
   inner join dk_base_up_account a on t.account_id = a.account_id
   where t.change_time > (v_fund_change_time - 1 / 24 / 60)
     and t.change_time < (v_fund_change_time + 1 / 24 / 60)
     and t.bank_fund_id = v_fund_batch_id
     and t.change_amount = v_change_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.manual_change_type = v_change_type
     and rownum <= 2;

  ---2.检查记账系统的收卡上游渠道相关结算记录
  select t.record_id
    into v_jz_record_id
    from fd_trade_up_manual t
   inner join fd_base_up_account a on t.account_id = a.account_id
   where t.change_time > (v_fund_change_time - 1 / 24 / 60)
     and t.change_time < (v_fund_change_time + 1 / 24 / 60)
     and t.bank_fund_id = v_fund_batch_id
     and t.change_amount = v_change_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.manual_change_type = v_change_type
     and rownum <= 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
  
end;
/

prompt
prompt Creating function DK_F_SUP_ADJUST_DOWN_SETTLE
prompt =============================================
prompt
create or replace function fd_account.dk_f_sup_adjust_down_settle(v_record_id   number,
                                                       v_create_user varchar2,
                                                       v_memo        varchar2)
  return varchar2 is
  -------------下游结算红冲--------------

  l_pay_account_id        number;
  l_bank_fund_id          number;
  l_bank_account_id       number;
  l_change_amount         number;
  l_inner_balance         number;
  l_bank_balance          number;
  l_fund_main_id          number;
  l_fund_service_id       number;
  l_bank_batch_id         number; ---加款记录的统一流水编号---查询需要红冲的银行卡变动记录
  l_handle_batch_id       number; ---红冲加款的统一流水号
  l_change_time           date;
  l_service_count         number;
  l_service_change_amount number;
  l_bank_service_id       number;
begin
  --================获取相关记录数据================
  ---1. 获取实体卡资金变动编号
  select t.bank_fund_id, t.account_id, t.change_amount, t.change_time
    into l_bank_batch_id, l_pay_account_id, l_change_amount, l_change_time
    from dk_trade_down_settle t
   where t.record_id = v_record_id;

  ---2. 获取结算银行流水
  select t.account_id, t.record_id
    into l_bank_account_id, l_bank_fund_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.change_type = pkg_bank_fund_change_type.minus_amount -->>>>>>>>>>> 由原来的 add 改成了 minus
     and t.use_type = pkg_bank_use_type.dk_down_settle --<<<<<<<<<<<<<< 这里要和原来扣款的枚举一致 yangdj 20161019
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  ---3. 获取结算手续费记录数据
  select count(1), nvl(max(t.change_amount), 0), max(t.record_id)
    into l_service_count, l_service_change_amount, l_bank_service_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.use_type = pkg_bank_use_type.service_fee
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  --===================手续费记录红冲====================
  ---1. 锁实体卡账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;

  ---2.修改实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + l_change_amount +
                            l_service_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_bank_account_id;

  ---3获取红冲加款的统一流水号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  --=====================银行卡记录红冲=============================
  if (l_service_count > 0) then
    ---1.红冲实体卡手续费记录
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
      select seq_bank_cash_fund_id.nextval,
             t.account_id,
             t.record_id,
             t.company_id,
             (0 - t.change_amount),
             (l_bank_balance + l_service_change_amount),
             sysdate,
             v_create_user,
             t.change_type,
             t.use_type,
             pkg_sys_boolean.istrue,
             t.link_channel_name,
             t.link_account_name,
             v_memo,
             l_handle_batch_id
        from fd_bank_cash_fund t
       where t.record_id = l_bank_service_id
         and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  
    ---2.修改原手续费记录状态
    update fd_bank_cash_fund t
       set t.has_adjust = pkg_sys_boolean.istrue
     where t.record_id = l_bank_service_id
       and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  end if;

  ---3.红冲实体卡下游加款记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0-l_change_amount),
           (l_bank_balance + l_change_amount+l_service_change_amount), 
           sysdate,
           v_create_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id
      from fd_bank_cash_fund t
     where t.record_id = l_bank_fund_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---4.修改原记录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_bank_fund_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --=================渠道账户红冲===================
  ---1. 锁下游支付账户
  select t.inner_balance
    into l_inner_balance
    from dk_base_down_account t
   where t.account_id = l_pay_account_id
     for update;

  ---2.更新账户余额
  update dk_base_down_account t
     set t.inner_balance  = l_inner_balance - l_change_amount, --->>>>>>>>>>>>>> 这里没有变化,负：欠商户的结算款 增多
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_pay_account_id;

  ---3.红冲手工加款记录
  select seq_trade_down_fund_id.nextval into l_fund_main_id from dual;
  select seq_trade_down_fund_id.nextval into l_fund_service_id from dual;

  insert into dk_trade_down_settle
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
    select l_fund_main_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           0,
           pkg_down_manual_change_type.red_recharge,
           (0 - l_change_amount),
           sysdate,
           (l_inner_balance - l_change_amount),
           v_create_user,
           t.partner_account,
           v_memo
      from dk_trade_down_settle t
     where t.record_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---4.修改原加款记录状态
  update dk_trade_down_settle t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.红冲资金变动中手工加款记录
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
    select l_fund_main_id,
           t.dk_order_id,
           t.channel_no,
           t.account_id,
           t.trade_order_no,
           t.ext_order_no,
           t.order_source,
           sysdate,
           t.order_time,
           t.change_type,
           (0 - l_change_amount),
           (l_inner_balance - l_change_amount),
           v_memo
      from dk_trade_down_fund t
     where t.record_id = v_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_SUP_ADJUST_DOWN_AFTER
prompt ============================================
prompt
create or replace function fd_account.dk_f_sup_adjust_down_after(v_down_report_id number,
                                                      v_record_id      number,
                                                      v_fund_batch_id  number,
                                                      v_sup_record_id  number,
                                                      v_jz_record_id   number,
                                                      v_adjust_user    varchar2,
                                                      v_adjust_memo    varchar2)
  return varchar2 is
  ---------------收卡下游预付结算红冲---------------
  l_result varchar2(32);
begin
  ---1.还原后付结算记录
  l_result := dk_f_adjust_settle_report(v_down_report_id, v_fund_batch_id);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---2.红冲下游结算及银行记录
  l_result := dk_f_sup_adjust_down_settle(v_record_id,
                                          v_adjust_user,
                                          v_adjust_memo);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---3.红冲下游计算管理的收卡和18的上游渠道
  l_result := dk_f_sup_adjust_bind_up(v_sup_record_id,
                                      v_jz_record_id,
                                      pkg_up_manual_change_type.red_recharge,
                                      v_adjust_user,
                                      v_adjust_memo);

  return l_result;
end;
/

prompt
prompt Creating function DK_F_SUP_ADJUST_DOWN_AFTER_CK
prompt ===============================================
prompt
create or replace function fd_account.dk_f_sup_adjust_down_after_ck(v_down_report_id number,
                                                         v_adjust_days    number,
                                                         v_fund_batch_id  out number,
                                                         v_down_settle_id out number,
                                                         v_change_amount  out number,
                                                         v_change_time    out date)
  return varchar2 is
  --------------下游后付结算红冲检查---------
  l_settle_time date;
  l_result      varchar2(32);
begin
  ---1.获取下游后付结算信息
  select t.settle_deal_id, t.settle_time, t.settle_amount
    into v_fund_batch_id, l_settle_time, v_change_amount
    from dk_reprot_channel_settle t
   where t.id = v_down_report_id
     and t.channel_type = pkg_channel_type.down_channel
     and t.settle_status = pkg_dk_report_settle_status.complete;

  ---2.获取预付结算信息
  select t.record_id, t.change_time
    into v_down_settle_id, v_change_time
    from dk_trade_down_settle t
   where t.change_time > l_settle_time - 1 / 24 / 60
     and t.change_time < l_settle_time + 1 / 24 / 60
     and t.bank_fund_id = v_fund_batch_id
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_amount = v_change_amount
     and t.add_type = pkg_down_manual_change_type.add_amount;

  ---3.检查相关下游结算及银行记录
  l_result := dk_f_adjust_down_settle_check(v_down_settle_id, v_adjust_days);

  return l_result;
exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function DK_F_SUP_ADJUST_DOWN_PRE
prompt ==========================================
prompt
create or replace function fd_account.dk_f_sup_adjust_down_pre(v_record_id     number,
                                                    v_sup_record_id number,
                                                    v_jz_record_id  number,
                                                    v_adjust_user   varchar2,
                                                    v_adjust_memo   varchar2)
  return varchar2 is
  ---------------收卡下游预付结算红冲---------------
  l_result varchar2(32);
begin
  ---1.红冲下游结算及银行记录
  l_result := dk_f_sup_adjust_down_settle(v_record_id,
                                          v_adjust_user,
                                          v_adjust_memo);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---2.红冲下游计算管理的收卡和18的上游渠道
  l_result := dk_f_sup_adjust_bind_up(v_sup_record_id,
                                      v_jz_record_id,
                                      pkg_up_manual_change_type.red_recharge,
                                      v_adjust_user,
                                      v_adjust_memo);

  return l_result;
end;
/

prompt
prompt Creating function DK_F_SUP_ADJUST_DOWN_PRE_CHECK
prompt ================================================
prompt
create or replace function fd_account.dk_f_sup_adjust_down_pre_check(v_down_settle_id number,
                                                          v_adjust_days    number,
                                                          v_fund_batch_id  out number,
                                                          v_change_amount  out number,
                                                          v_change_time    out date)
  return varchar2 is
  ---------------检查下游预付结算相关记录---------------
  l_result varchar2(32);
begin
  ---1.获取预付结算信息
  select t.bank_fund_id, t.change_amount, t.change_time
    into v_fund_batch_id, v_change_amount, v_change_time
    from dk_trade_down_settle t
   where t.record_id = v_down_settle_id;

  ---2.检查相关下游结算及银行记录
  l_result := dk_f_adjust_down_settle_check(v_down_settle_id, v_adjust_days);

  return l_result;
end;
/

prompt
prompt Creating function DK_F_SUP_ADJUST_UP_AFTER
prompt ==========================================
prompt
create or replace function fd_account.dk_f_sup_adjust_up_after(v_up_report_id  number,
                                                    v_up_settle_id  number,
                                                    v_fund_batch_id number,
                                                    v_sup_record_id number,
                                                    v_jz_record_id  number,
                                                    v_adjust_user   varchar2,
                                                    v_adjust_memo   varchar2)
  return varchar2 is
  ----------------收卡上游后付红冲--------------
  l_result varchar2(32);
begin
  ---1.还原后付结算记录
  l_result := dk_f_adjust_settle_report(v_up_report_id, v_fund_batch_id);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---2.红冲下游结算及银行记录
  l_result := dk_f_adjust_up_settle_handle(v_up_settle_id,
                                           v_adjust_user,
                                           v_adjust_memo);

  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---3.红冲下游计算管理的收卡和18的上游渠道
  l_result := dk_f_sup_adjust_bind_up(v_sup_record_id,
                                      v_jz_record_id,
                                      pkg_up_manual_change_type.red_draw,
                                      v_adjust_user,
                                      v_adjust_memo);

  return l_result;

end;
/

prompt
prompt Creating function DK_F_SUP_ADJUST_UP_AFTER_CK
prompt =============================================
prompt
create or replace function fd_account.dk_f_sup_adjust_up_after_ck(v_up_report_id  number,
                                                       v_adjust_days   number,
                                                       v_fund_batch_id out number,
                                                       v_up_settle_id  out number,
                                                       v_change_amount out number,
                                                       v_change_time   out date)
  return varchar2 is

  ---------------上游后付结算红冲检查---------------
  l_settle_time date;
  l_result      varchar2(32);
begin
  ---1.获取下游后付结算信息
  select t.settle_deal_id, t.settle_time, t.settle_amount
    into v_fund_batch_id, l_settle_time, v_change_amount
    from dk_reprot_channel_settle t
   where t.id = v_up_report_id
     and t.channel_type = pkg_channel_type.up_channel
     and t.settle_status = pkg_dk_report_settle_status.complete;

  ---2.获取预付结算信息
  select t.record_id, t.change_time
    into v_up_settle_id, v_change_time
    from dk_trade_up_settle t
   where t.change_time > l_settle_time - 1 / 24 / 60
     and t.change_time < l_settle_time + 1 / 24 / 60
     and t.bank_fund_id = v_fund_batch_id
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_amount = v_change_amount
     and t.manual_change_type = pkg_up_manual_change_type.add_amount;

  ---3.检查预付上游渠道、账户及银行信息
  l_result := dk_f_adjust_up_settle_check(v_up_settle_id, v_adjust_days);

  return l_result;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function DK_F_SUP_ADJUST_UP_PRE
prompt ========================================
prompt
create or replace function fd_account.dk_f_sup_adjust_up_pre(v_up_settle_id  number,
                                                  v_sup_record_id number,
                                                  v_jz_record_id  number,
                                                  v_adjust_user   varchar2,
                                                  v_adjust_memo   varchar2)
  return varchar2 is
  -------------收卡系统上游预付红冲--------------
  l_result varchar2(32);
begin
  ---1.红冲下游结算及银行记录
  l_result := dk_f_adjust_up_settle_handle(v_up_settle_id,
                                           v_adjust_user,
                                           v_adjust_memo);

  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---2.红冲下游计算管理的收卡和18的上游渠道
  l_result := dk_f_sup_adjust_bind_up(v_sup_record_id,
                                      v_jz_record_id,
                                      pkg_up_manual_change_type.red_draw,
                                      v_adjust_user,
                                      v_adjust_memo);

  return l_result;

end;
/

prompt
prompt Creating function DK_F_SUP_ADJUST_UP_PRE_CHECK
prompt ==============================================
prompt
create or replace function fd_account.dk_f_sup_adjust_up_pre_check(v_up_settle_id  number,
                                                        v_adjust_days   number,
                                                        v_fund_batch_id out number,
                                                        v_change_amount out number,
                                                        v_change_time   out date)
  return varchar2 is
  -----------------上游预付红冲检查-------------
  l_result varchar2(32);
begin
  ---1.获取预付结算信息
  select t.bank_fund_id, t.change_amount, t.change_time
    into v_fund_batch_id, v_change_amount, v_change_time
    from dk_trade_up_settle t
   where t.record_id = v_up_settle_id;

  ---2.检查预付上游渠道、账户及银行信息
  l_result := dk_f_adjust_up_settle_check(v_up_settle_id, v_adjust_days);

  return l_result;
end;
/

prompt
prompt Creating function DK_F_SUP_BANK_SETTLE
prompt ======================================
prompt
create or replace function fd_account.dk_f_sup_bank_settle(v_bank_account_id number,
                                                v_channel_name    varchar2,
                                                v_account_name    varchar2,
                                                v_change_type     number,
                                                v_bank_use_type   number,
                                                v_settle_amount   number,
                                                v_service_fee     number,
                                                v_create_user     varchar2,
                                                v_memo            varchar2,
                                                v_remark_name     varchar2,
                                                v_bank_batch_id   out number)
  return varchar2 is
  --------------------------------
  --功能：银行结算
  --修改人：周荣省
  --修改时间：2019-08-26
  --修改内容：
  --------------------------------
  l_bank_balance    number;
  l_bank_company_id number;
  l_change_amount   number;
begin
  ---1.锁银行卡账户
  select t.balance,
         t.company_id,
         seq_bank_service_id.nextval,
         decode(v_change_type, pkg_bank_fund_change_type.add_amount, 1, -1) *
         v_settle_amount
    into l_bank_balance,
         l_bank_company_id,
         v_bank_batch_id,
         l_change_amount
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     and v_change_type in (pkg_bank_fund_change_type.add_amount,
          pkg_bank_fund_change_type.minus_amount)
     for update;

  ---2.修改银行卡余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + l_change_amount -
                            v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  if (v_service_fee > 0) then
    ---3.添加银行卡手续费资金变动
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       l_bank_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       v_channel_name,
       v_account_name,
       v_memo,
       v_bank_batch_id,v_remark_name);
  end if;

  ---4.添加银行卡资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company_id,
     v_settle_amount,
     (l_bank_balance + l_change_amount - v_service_fee),
     sysdate,
     v_create_user,
     v_change_type,
     v_bank_use_type,
     v_channel_name,
     v_account_name,
     v_memo,
     v_bank_batch_id,v_remark_name);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_SUP_BIND_UP_CHECK
prompt ========================================
prompt
create or replace function fd_account.dk_f_sup_bind_up_check(v_sup_up_channel_no varchar2,
                                                  v_jz_up_channel_no  varchar2,
                                                  v_sup_up_account_id out number,
                                                  v_jz_up_account_id  out number,
                                                  v_sup_up_company_id out number,
                                                  v_jz_up_company_id  out number)
  return varchar2 is
  ----------------绑定的收卡系统的18上游与记账系统的收卡上游检查---------------
begin

  ---1.检查收卡中关联18的上游渠道信息是否正确
  select a.account_id, c.company_id
    into v_sup_up_account_id, v_sup_up_company_id
    from dk_base_up_account_map t
   inner join dk_base_up_account a on t.account_id = a.account_id
   inner join dk_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_sup_up_channel_no
     and c.classification = pkg_dk_channel_classification.sk
     and c.payment_type = pkg_dk_channel_payment_type.prepay
     and rownum <= 2;

  ---2.检查直充系统中18关联收卡的上游渠道信息是否正确
  select a.account_id, c.company_id
    into v_jz_up_account_id, v_jz_up_company_id
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_jz_up_channel_no
     and rownum <= 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function DK_F_SUP_BIND_UP_SETTLE
prompt =========================================
prompt
create or replace function fd_account.dk_f_sup_bind_up_settle(v_sup_up_channel_no varchar2,
                                                   v_sup_up_account_id number,
                                                   v_sup_up_company_id number,
                                                   v_jz_up_channel_no  varchar2,
                                                   v_jz_up_account_id  number,
                                                   v_jz_up_company_id  number,
                                                   v_up_fund_type      number,
                                                   v_bank_batch_id     number,
                                                   v_settle_amount     number,
                                                   v_partner_account   varchar2,
                                                   v_create_user       varchar2,
                                                   v_memo              varchar2)
  return varchar2 is
  --------------收卡系统与18系统上游同步结算------------
  l_sup_inner_balance  number;
  l_jz_inner_balance   number;
  l_fund_amount        number;
  l_up_fund_id         number;
  l_manual_change_type number;
begin
  ---====================收卡系统中对应18的上游渠道操作========================
  ---1.锁收卡系统对应18的上游渠道
  select t.inner_balance,
         seq_trade_up_fund_id.nextval,
         decode(v_up_fund_type, pkg_up_fund_change_type.add_amount, 1, -1) *
         v_settle_amount,
         decode(v_up_fund_type,
                pkg_up_fund_change_type.add_amount,
                pkg_up_manual_change_type.add_amount,
                pkg_up_manual_change_type.draw_amount)
    into l_sup_inner_balance,
         l_up_fund_id,
         l_fund_amount,
         l_manual_change_type
    from dk_base_up_account t
   where t.account_id = v_sup_up_account_id
     and v_up_fund_type in (pkg_up_fund_change_type.add_amount,
          pkg_up_fund_change_type.draw_amount)
     for update;

  ---2.修改渠道账户的余额
  update dk_base_up_account t
     set t.inner_balance  = (l_sup_inner_balance + l_fund_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_sup_up_account_id;

  ---3.添加渠道的人工操作记录
  insert into dk_trade_up_settle
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_up_fund_id,
     v_sup_up_channel_no,
     v_sup_up_account_id,
     l_manual_change_type,
     v_settle_amount,
     sysdate,
     (l_sup_inner_balance + l_fund_amount),
     v_memo,
     v_create_user,
     v_partner_account,
     v_bank_batch_id);

  ---4.添加渠道资金变动记录
  insert into dk_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_up_fund_id,
     v_sup_up_channel_no,
     v_sup_up_account_id,
     v_sup_up_company_id,
     v_settle_amount,
     v_settle_amount,
     sysdate,
     v_up_fund_type,
     (l_sup_inner_balance + l_fund_amount),
     v_memo);

  ---==================记账系统中对应收卡的上游渠道操作======================
  ---1.锁记账系统对应收卡的上游渠道
  select t.inner_balance
    into l_jz_inner_balance
    from fd_base_up_account t
   where t.account_id = v_jz_up_account_id
     for update;

  ---2.修改渠道账户的余额
  update fd_base_up_account t
     set t.inner_balance  = (l_jz_inner_balance + l_fund_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_jz_up_account_id;

  ---3.添加渠道的人工操作记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_up_fund_id,
     v_jz_up_channel_no,
     v_jz_up_account_id,
     l_manual_change_type,
     v_settle_amount,
     sysdate,
     (l_jz_inner_balance + l_fund_amount),
     v_memo,
     v_create_user,
     v_partner_account,
     v_bank_batch_id);

  ---4.添加渠道资金变动记录
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_up_fund_id,
     v_jz_up_channel_no,
     v_jz_up_account_id,
     v_jz_up_company_id,
     v_settle_amount,
     v_settle_amount,
     sysdate,
     v_up_fund_type,
     (l_jz_inner_balance + l_fund_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_SUP_BIND_UP_SETTLE_T
prompt ===========================================
prompt
create or replace function fd_account.dk_f_sup_bind_up_settle_t(v_sup_up_channel_no varchar2,
                                                     v_sup_up_account_id number,
                                                     v_sup_up_company_id number,
                                                     v_jz_up_channel_no  varchar2,
                                                     v_jz_up_account_id  number,
                                                     v_jz_up_company_id  number,
                                                     v_up_fund_type      number,
                                                     v_bank_batch_id     number,
                                                     v_settle_amount     number,
                                                     v_partner_account   varchar2,
                                                     v_create_user       varchar2,
                                                     v_memo              varchar2)
  return varchar2 is
  --------------收卡系统与18系统上游同步结算------------
  l_sup_inner_balance  number;
  l_jz_inner_balance   number;
  l_fund_amount        number;
  l_up_fund_id         number;
  l_manual_change_type number;
begin
  ---====================收卡系统中对应18的上游渠道操作========================
  ---1.锁收卡系统对应18的上游渠道
  select t.inner_balance,
         seq_trade_up_fund_id.nextval,
         decode(v_up_fund_type, pkg_up_fund_change_type.add_amount, 1, -1) *
         v_settle_amount,
         decode(v_up_fund_type,
                pkg_up_fund_change_type.add_amount,
                pkg_up_manual_change_type.add_amount,
                pkg_up_manual_change_type.draw_amount)
    into l_sup_inner_balance,
         l_up_fund_id,
         l_fund_amount,
         l_manual_change_type
    from dk_base_up_account t
   where t.account_id = v_sup_up_account_id
     and v_up_fund_type in (pkg_up_fund_change_type.add_amount,
          pkg_up_fund_change_type.draw_amount)
     for update;

  ---2.修改渠道账户的余额
  update dk_base_up_account t
     set t.inner_balance  = (l_sup_inner_balance + l_fund_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_sup_up_account_id;

  ---3.添加渠道的人工操作记录
  insert into dk_trade_up_settle
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_up_fund_id,
     v_sup_up_channel_no,
     v_sup_up_account_id,
     l_manual_change_type,
     v_settle_amount,
     sysdate,
     (l_sup_inner_balance + l_fund_amount),
     v_memo,
     v_create_user,
     v_partner_account,
     v_bank_batch_id);

  ---4.添加渠道资金变动记录
  insert into dk_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_up_fund_id,
     v_sup_up_channel_no,
     v_sup_up_account_id,
     v_sup_up_company_id,
     v_settle_amount,
     v_settle_amount,
     sysdate,
     v_up_fund_type,
     (l_sup_inner_balance + l_fund_amount),
     v_memo);

  ---==================记账系统中对应收卡的上游渠道操作======================
  ---1.锁记账系统对应收卡的上游渠道
  select t.inner_balance
    into l_jz_inner_balance
    from fd_base_up_account t
   where t.account_id = v_jz_up_account_id
     for update;

  ---2.修改渠道账户的余额
  update fd_base_up_account t
     set t.inner_balance  = (l_jz_inner_balance + l_fund_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_jz_up_account_id;

  ---3.添加渠道的人工操作记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_up_fund_id,
     v_jz_up_channel_no,
     v_jz_up_account_id,
     l_manual_change_type,
     v_settle_amount,
     sysdate,
     (l_jz_inner_balance + l_fund_amount),
     v_memo,
     v_create_user,
     v_partner_account,
     v_bank_batch_id);

  ---4.添加渠道资金变动记录
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_up_fund_id,
     v_jz_up_channel_no,
     v_jz_up_account_id,
     v_jz_up_company_id,
     v_settle_amount,
     v_settle_amount,
     sysdate,
     v_up_fund_type,
     (l_jz_inner_balance + l_fund_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_TRADE_FUND_DIFFER_ADD
prompt ============================================
prompt
create or replace function fd_account.dk_f_trade_fund_differ_add(v_dk_order_id   number, --订单编号
                                                      v_trade_type    number, --交易类型（1.下游扣款2.上游扣款3.上游退款4.下游退款5.转账退款）
                                                      v_channel_no    varchar2, --渠道编号
                                                      v_account_id    number, --账户编号
                                                      v_business_type number, --业务类型
                                                      v_bill_type     number, --利润类型                         
                                                      v_order_face    number, --订单面值
                                                      v_order_amount  number, --订单扣款金额
                                                      v_down_face     number, --下游扣款或上游中的下游扣款面值
                                                      v_down_amount   number, --下游扣款或上游中的下游扣款金额
                                                      v_up_face       number --上游扣款面值
                                                      ) return varchar2 is
  -----------------------记录资金变动相关统计差异数据----------------------
  l_today_date         date := trunc(sysdate);
  l_differ_count       number;
  l_down_adjust_face   number := 0; ---资金变动差异表中，下游退款造成多冲时，需要用来抵消上游资金变动中的下游扣款面值
  l_down_adjust_unit   number := 0; ---同上的规格
  l_down_adjust_amount number := 0; ---同上的金额
  l_down_adjust_real   number := 0; ---同上的真实金额
  l_up_many_face       number := 0; ---资金变动差异表中记录的上游多冲的面值
  l_up_many_amount     number := 0; ---同上的金额
  l_to_front_face      number := 0; ---资金变动差异表中记录的需要由前向转为后向的面值
  l_to_front_unit      number := 0; ---同上的规格
  l_to_front_amount    number := 0; ---同上的金额
  l_to_front_real      number := 0; ---同上的真实金额
  l_down_first_face    number := 0; ---订单差异表中下有扣款比上游资金变动中下游扣款多的面值
  l_down_first_amount  number := 0; ---同上金额
  l_use_bill_type      number := v_bill_type;

  l_total_many_face   number; ---当天单笔订单总多冲面值
  l_total_many_amount number; ---同上金额
  l_bill_many_face    number; ---当天单笔订单退款bill_type的多冲面值
  l_bill_many_amount  number; ---同上金额
  l_refund_many_face  number;
  l_down_draw_unit    number;
  l_down_draw_face    number;
  l_down_draw_amount  number;
  l_down_real_amount  number;
  l_down_refund_face  number;
  l_real_order_face   number;
  l_all_up_face       number;
  l_down_up_differ    number;
  l_main_differ_count number;
  l_many_face_now     number; ---退款红冲后多冲值
  l_many_face_red     number; ---退款红冲前多冲值

begin
 

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_SUP_DOWN_FEE_REFUND
prompt ==========================================
prompt
create or replace function fd_account.dk_f_sup_down_fee_refund(v_order_source    in number,
                                                    v_down_channel_no in varchar2,
                                                    v_trade_order_no  in varchar2,
                                                    v_trade_refund_no varchar2,
                                                    v_refund_unit     number,
                                                    v_refund_face     number,
                                                    v_refund_amount   number,
                                                    v_real_refund     number,
                                                    v_order_date      varchar2,
                                                    v_trade_time      varchar2,
                                                    v_service_fee     number,
                                                    v_memo            varchar2)
  return varchar2 is
  l_dk_order_id       number;
  l_down_account_id   number;
  l_order_source      number;
  l_trade_order_no    varchar2(32);
  l_ext_order_no      varchar2(32);
  l_down_channel_no   varchar2(32);
  l_refund_count      number;
  l_total_refund      number;
  l_inner_balance     number;
  l_down_fund_id      number;
  l_down_order_face   number;
  l_down_order_amount number;
  l_result            varchar2(32);

  l_debit_count       number;
  l_total_refund_face number;
  l_business_type     number;
  l_order_total_face  number;
  ------------下游订单退款------------
begin
  --===========================检查订单重复退款、金额错误==========================
  ---1.锁下游订单
  select t.dk_order_id,
         t.order_source,
         t.down_channel_no,
         t.down_account_id,
         t.ext_order_no,
         t.trade_order_no,
         t.total_face,
         t.down_order_amount * t.recharge_times,
         t.business_type,
         t.total_face * t.recharge_times
    into l_dk_order_id,
         l_order_source,
         l_down_channel_no,
         l_down_account_id,
         l_ext_order_no,
         l_trade_order_no,
         l_down_order_face,
         l_down_order_amount,
         l_business_type,
         l_order_total_face
    from dk_trade_order_main t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1
     for update;

  ---2.检测订单重复退款
  select count(1)
    into l_refund_count
    from dk_trade_down_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = l_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  ---2.1检查退款时是否有扣款
  select count(1)
    into l_debit_count
    from dk_trade_down_fund t
   where t.dk_order_id = l_dk_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and t.order_source = l_order_source
     and t.is_sk_adjust = pkg_sys_boolean.isfalse
     and rownum <= 1;

  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---3.获取订单扣款、已退款金额
  select nvl(sum(t.refund_amount), 0), nvl(sum(t.refund_face), 0)
    into l_total_refund, l_total_refund_face
    from dk_trade_down_refund t
   where t.dk_order_id = l_dk_order_id;

  ---4.检查退款金额是否超过订单总面值
  --- 总面值 yangdejian
  --if (v_refund_amount > (l_order_total_face - l_total_refund)) then
  if (v_refund_amount > (l_down_order_amount - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;

  --==================================修改账户余额===============================
  ---5.获取并修改账户余额
  select t.inner_balance
    into l_inner_balance
    from dk_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  ----（退款金额已扣除手续费）
  update dk_base_down_account t
     set t.inner_balance = (l_inner_balance + v_refund_amount)
   where t.account_id = l_down_account_id;

  --===================添加数据变动记录=============
  ---6.添加退款记录
  select seq_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into dk_trade_down_refund
    (record_id,
     channel_no,
     account_id,
     dk_order_id,
     trade_order_no,
     trade_refund_no,
     order_source,
     refund_time,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund, ---删掉了退款类型
     memo)
    select l_down_fund_id,
           t.down_channel_no,
           t.down_account_id,
           t.dk_order_id,
           t.trade_order_no,
           v_trade_refund_no,
           t.order_source,
           sysdate,
           t.business_type,
           t.carrier_no,
           t.province_no,
           v_refund_unit,
           v_refund_face,
           v_refund_amount,
           v_real_refund,
           v_memo
      from dk_trade_order_main t
     where t.dk_order_id = l_dk_order_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---7.添加下游资金变动
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee,
     trade_time)
  values
    (l_down_fund_id,
     l_dk_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     l_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_date, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_down_fund_change_type.refund_amount,
     v_refund_amount,
     (l_inner_balance + v_refund_amount),
     v_memo,
     v_service_fee,
     to_date(v_trade_time, 'yyyy-mm-dd hh24:mi:ss'));

  --===========================订单差异信息记录=================================

  ---8.调用差异调整函数
  l_result := dk_f_trade_fund_differ_add(l_dk_order_id,
                                         pkg_trade_type.down_refund,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         pkg_bill_type.front,
                                         l_down_order_face,
                                         l_down_order_amount,
                                         v_refund_face,
                                         v_refund_amount,
                                         0);

  return l_result;
end;
/

prompt
prompt Creating function DK_F_SUP_DOWN_ORDER_FEE_MUS
prompt =============================================
prompt
create or replace function fd_account.dk_f_sup_down_order_fee_mus(v_order_source    number,
                                                       v_down_channel_no varchar2,
                                                       v_trade_order_no  varchar2,
                                                       v_trade_fund_no   varchar2,
                                                       v_is_adjust       varchar2,
                                                       v_ext_order_no    varchar2,
                                                       v_order_time      varchar2,
                                                       v_trade_time      varchar2,
                                                       v_settle_amount   number,
                                                       v_service_fee     number,
                                                       v_memo            varchar2)
  return varchar2 is
  -------------------下游扣款----------------------
  l_dk_order_id         number;
  l_pay_count           number;
  l_inner_balance       number;
  l_down_account_id     number;
  l_order_settle_amount number;
  l_total_face          number;
  l_business_type       number;
  l_result              varchar2(32) := pkg_error_code.success;
  l_recharge_times      number;
  l_fund_count          number;
  l_down_company_id     number;
begin

  ----===============================锁订单，检查是否重复扣款================================
  ---1.锁订单，检查扣款是否存在
  select t.dk_order_id,
         t.down_account_id,
         t.down_order_amount,
         t.total_face,
         t.business_type,
         t.recharge_times,
         t.down_company_id
    into l_dk_order_id,
         l_down_account_id,
         l_order_settle_amount,
         l_total_face,
         l_business_type,
         l_recharge_times,
         l_down_company_id
    from dk_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查是否存在扣款记录
  select sum(decode(t.is_sk_adjust, pkg_sys_boolean.istrue, 0, 1)), ---非二次结算的数据条数
         sum(decode(t.trade_fund_no, v_trade_fund_no, 1, 0)) ---相同资金变动记录条数
    into l_pay_count, l_fund_count
    from dk_trade_down_fund t
   where t.dk_order_id = l_dk_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount;

  if (l_fund_count > 0) or (l_pay_count >= l_recharge_times and
     v_is_adjust = pkg_sys_boolean.isfalse) then
  
    return pkg_error_code.success;
  end if;

  ---3.检查从订单查询的扣款与本次扣款是否一致

  if l_order_settle_amount != v_settle_amount and
     v_is_adjust = pkg_sys_boolean.isfalse then
    return pkg_error_code.amount_error;
  end if;

  --=========================锁账户，检查余额并扣款=====================================
  ---3.获取下游账户信息
  select t.inner_balance
    into l_inner_balance
    from dk_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  ---5.下游扣款（扣款金额已除去手续费）
  update dk_base_down_account t
     set t.inner_balance = (l_inner_balance - v_settle_amount)
   where t.account_id = l_down_account_id;

  ---6.添加下游资金变动
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee,
     trade_time,
     trade_fund_no,
     is_sk_adjust)
  values
    (seq_trade_down_fund_id.nextval,
     l_dk_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     v_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_down_fund_change_type.debit_amount,
     v_settle_amount,
     (l_inner_balance - v_settle_amount),
     v_memo,
     v_service_fee,
     to_date(v_trade_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_trade_fund_no,
     v_is_adjust);

  ---7.补二次结算上游资金变动记录
  if v_is_adjust = pkg_sys_boolean.istrue then
    insert into dk_trade_up_fund
      (record_id,
       dk_order_id,
       trade_order_no,
       order_source,
       down_channel_no,
       down_account_id,
       down_company_id,
       up_channel_no,
       up_account_id,
       up_company_id,
       down_draw_amount,
       down_real_amount,
       up_draw_amount,
       up_real_amount,
       change_time,
       order_time,
       change_type,
       business_type,
       balance,
       memo,
       trade_time,
       channel_settle_status)
    values
      (seq_trade_up_fund_id.nextval,
       l_dk_order_id,
       v_trade_order_no,
       v_order_source,
       v_down_channel_no,
       l_down_account_id,
       l_down_company_id,
       '-',
       0,
       l_down_company_id,
       v_settle_amount,
       v_settle_amount,
       0,
       0,
       sysdate,
       to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
       pkg_up_fund_change_type.debit_amount,
       pkg_business_type.DK_Recharge_Card,
       0,
       v_memo,
       to_date(v_trade_time, 'yyyy-mm-dd hh24:mi:ss'),
       pkg_dk_channel_settle_status.wait);
  end if;

  ---8.扣款成功记录订单差异表
  l_result := dk_f_trade_fund_differ_add(l_dk_order_id,
                                         pkg_trade_type.down_debit,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         pkg_bill_type.front,
                                         l_total_face,
                                         l_order_settle_amount,
                                         l_total_face,
                                         v_settle_amount,
                                         0);

  return l_result;
end;
/

prompt
prompt Creating function DK_F_SUP_DOWN_SETTLE
prompt ======================================
prompt
create or replace function fd_account.dk_f_sup_down_settle(v_down_channel_no varchar2,
                                                v_down_account_id number,
                                                v_down_fund_type  number,
                                                v_settle_amount   number,
                                                v_bank_batch_id   number,
                                                v_partner_account varchar2,
                                                v_create_user     varchar2,
                                                v_memo            varchar2)
  return varchar2 is
  ----------------下游渠道结算---------------
  l_inner_balance      number;
  l_fund_record_id     number;
  l_fund_amount        number;
  l_manual_change_type number;
begin
  ---1.锁下游渠道账户
  select t.inner_balance,
         seq_trade_down_fund_id.nextval,
         decode(v_down_fund_type,
                pkg_down_fund_change_type.add_amount,
                1,
                -1) * v_settle_amount, --账户余额变动的金额
         decode(v_down_fund_type,
                pkg_down_fund_change_type.add_amount,
                pkg_down_manual_change_type.add_amount,
                pkg_down_manual_change_type.draw_amount) --人工操作表操作类型获取
    into l_inner_balance,
         l_fund_record_id,
         l_fund_amount,
         l_manual_change_type
    from dk_base_down_account t
   where t.account_id = v_down_account_id
     and v_down_fund_type in (pkg_down_fund_change_type.add_amount,
          pkg_down_fund_change_type.draw_amount)
     for update;

  ---2.更新渠道账户余额
  update dk_base_down_account t
     set t.inner_balance  = (l_inner_balance + l_fund_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---3.添加下游人工加款记录
  insert into dk_trade_down_settle
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_fund_record_id,
     v_down_channel_no,
     v_down_account_id,
     pkg_sys_boolean.isfalse,
     l_manual_change_type,
     v_settle_amount,
     sysdate,
     (l_inner_balance + l_fund_amount),
     v_create_user,
     v_bank_batch_id,
     v_partner_account,
     v_memo);

  ---4.添加下游资金变动
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     v_down_fund_type,
     v_settle_amount,
     (l_inner_balance + l_fund_amount),
     v_memo);

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function DK_F_SUP_REPORT_AFTER_SETTLE
prompt ==============================================
prompt
create or replace function fd_account.dk_f_sup_report_after_settle(v_settle_record_id number,
                                                        v_bank_batch_id    number,
                                                        v_settle_user      varchar2,
                                                        v_settle_memo      varchar2)
  return varchar2 is
  ----------------完成下游后付结算-----------------
begin
  update dk_reprot_channel_settle t
     set t.settle_status  = pkg_dk_report_settle_status.complete,
         t.settle_deal_id = v_bank_batch_id,
         t.settle_user    = v_settle_user,
         t.settle_time    = sysdate,
         t.settle_memo    = v_settle_memo
   where t.id = v_settle_record_id
     and t.settle_status = pkg_dk_report_settle_status.doing;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_SUP_DOWN_SETTLE_AFTER
prompt ============================================
prompt
create or replace function fd_account.dk_f_sup_down_settle_after(v_down_channel_no   varchar2,
                                                      v_down_account_id   number,
                                                      v_bank_account_id   number,
                                                      v_settle_record_id  number,
                                                      v_channel_name      varchar2,
                                                      v_account_name      varchar2,
                                                      v_sup_up_channel_no varchar2,
                                                      v_sup_up_account_id number,
                                                      v_sup_up_company_id number,
                                                      v_jz_up_channel_no  varchar2,
                                                      v_jz_up_account_id  number,
                                                      v_jz_up_company_id  number,
                                                      v_settle_amount     number,
                                                      v_service_fee       number,
                                                      v_partner_account   varchar2,
                                                      v_settle_user       varchar2,
                                                      v_remark_name      varchar2,--添加收付款账户名称
                                                      v_settle_memo       varchar2)
  return varchar2 is
  ---------------------------------
  --功能：下游后付结算
  --修改人：周荣省
  --修改时间：2019-08-27
  --修改内容：添加收付款账户名称
  ---------------------------------
  l_result        varchar2(32);
  l_bank_batch_id number;
begin
  ---1.银行卡出账、并收取手续费(银行扣款)
  l_result := dk_f_sup_bank_settle(v_bank_account_id,
                                   v_channel_name,
                                   v_account_name,
                                   pkg_bank_fund_change_type.minus_amount,
                                   pkg_bank_use_type.dk_down_settle,
                                   v_settle_amount,
                                   v_service_fee,
                                   v_settle_user,
                                   v_settle_memo,
                                   v_remark_name,
                                   l_bank_batch_id);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---2.下游渠道结算(下游加款)
  l_result := dk_f_sup_down_settle(v_down_channel_no,
                                   v_down_account_id,
                                   pkg_down_fund_change_type.add_amount,
                                   v_settle_amount,
                                   l_bank_batch_id,
                                   v_partner_account,
                                   v_settle_user,
                                   v_settle_memo);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---3.收卡上游与18上游关联结算
  l_result := dk_f_sup_bind_up_settle(v_sup_up_channel_no,
                                      v_sup_up_account_id,
                                      v_sup_up_company_id,
                                      v_jz_up_channel_no,
                                      v_jz_up_account_id,
                                      v_jz_up_company_id,
                                      pkg_up_fund_change_type.add_amount,
                                      l_bank_batch_id,
                                      v_settle_amount,
                                      v_partner_account,
                                      v_settle_user,
                                      v_settle_memo);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---4.修改收卡结算记录，完成结算
  l_result := dk_f_sup_report_after_settle(v_settle_record_id,
                                           l_bank_batch_id,
                                           v_settle_user,
                                           v_settle_memo);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_SUP_DOWN_SETTLE_PRE_CHECK
prompt ================================================
prompt
create or replace function fd_account.dk_f_sup_down_settle_pre_check(v_down_channel_no varchar2,
                                                          v_down_account_id number,
                                                          v_bank_account_id number,
                                                          v_settle_amount   number,
                                                          v_service_fee     number,
                                                          v_channel_name    out varchar2,
                                                          v_account_name    out varchar2)
  return varchar2 is
  ---------------收卡下游预付结算检查---------------
  l_result varchar2(32);
begin
  ---1.检查渠道是否为sup渠道
  select t.channel_name
    into v_channel_name
    from dk_base_down_channel t
   where t.channel_no = v_down_channel_no
     and t.classification = pkg_dk_channel_classification.sk;

  ---2.检查金额、下游渠道、及银行信息
  ---********************************************************
  ---@预付为渠道列表中结算，不做强制限制，预付、后付都可使用
  ---********************************************************
  l_result := dk_f_manual_down_settle_check(v_down_channel_no,
                                            v_down_account_id,
                                            v_bank_account_id,
                                            v_settle_amount,
                                            v_service_fee,
                                            v_account_name,
                                            v_channel_name);
  return l_result;
exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function DK_F_SUP_DOWN_SETTLE_AFTER_CK
prompt ===============================================
prompt
create or replace function fd_account.dk_f_sup_down_settle_after_ck(v_settle_record_id number,
                                                         v_down_channel_no  varchar2,
                                                         v_down_account_id  number,
                                                         v_bank_account_id  number,
                                                         v_service_fee      number,
                                                         v_channel_name     out varchar2,
                                                         v_account_name     out varchar2,
                                                         v_settle_amount    out number)
  return varchar2 is
  -----------------收卡系统后付信息检查-----------------
  l_down_channel_no varchar2(32);
  l_result          varchar2(32);

begin
  ---1.检查结算记录是否可以结算
  select t.channel_no, t.settle_amount
    into l_down_channel_no, v_settle_amount
    from dk_reprot_channel_settle t
   inner join dk_base_down_channel c on t.channel_no = c.channel_no
   where t.id = v_settle_record_id
     and t.channel_no = v_down_channel_no
     and t.channel_type = pkg_channel_type.down_channel
     and t.settle_status = pkg_dk_report_settle_status.wait
     and c.classification = pkg_dk_channel_classification.sk
     and c.payment_type = pkg_dk_channel_payment_type.after_pay;

  ---2.检查收卡下游、收卡中关联18的上游、直充系统中18关联收卡的上游相关数据是否正确
  l_result := dk_f_sup_down_settle_pre_check(v_down_channel_no,
                                             v_down_account_id,
                                             v_bank_account_id,
                                             v_settle_amount,
                                             v_service_fee,
                                             v_channel_name,
                                             v_account_name);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---3.修改结算记录为正在结算
  update dk_reprot_channel_settle t
     set t.settle_status = pkg_dk_report_settle_status.doing
   where t.id = v_settle_record_id
     and t.settle_status = pkg_dk_report_settle_status.wait;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function DK_F_SUP_DOWN_SETTLE_PRE
prompt ==========================================
prompt
create or replace function fd_account.dk_f_sup_down_settle_pre(v_down_channel_no   varchar2,
                                                    v_down_account_id   number,
                                                    v_bank_account_id   number,
                                                    v_channel_name      varchar2,
                                                    v_account_name      varchar2,
                                                    v_sup_up_channel_no varchar2,
                                                    v_sup_up_account_id number,
                                                    v_sup_up_company_id number,
                                                    v_jz_up_channel_no  varchar2,
                                                    v_jz_up_account_id  number,
                                                    v_jz_up_company_id  number,
                                                    v_settle_amount     number,
                                                    v_service_fee       number,
                                                    v_partner_account   varchar2,
                                                    v_settle_user       varchar2,
                                                    v_remark_name       varchar2,--添加收付款账户名称
                                                    v_settle_memo       varchar2)
  return varchar2 is
  ------------------------------
  --功能：下游预付结算
  --修改人：周荣省
  --修改时间：2019-08-26
  --修改内容：添加收付款账户名称
  ------------------------------
  l_result        varchar2(32);
  l_bank_batch_id number;
begin
  ---1.银行卡出账、并收取手续费(银行扣款)
  l_result := dk_f_sup_bank_settle(v_bank_account_id,
                                   v_channel_name,
                                   v_account_name,
                                   pkg_bank_fund_change_type.minus_amount,
                                   pkg_bank_use_type.dk_down_settle,
                                   v_settle_amount,
                                   v_service_fee,
                                   v_settle_user,
                                   v_settle_memo,
                                   v_remark_name,
                                   l_bank_batch_id);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---2.下游渠道结算(下游加款)
  l_result := dk_f_sup_down_settle(v_down_channel_no,
                                   v_down_account_id,
                                   pkg_down_fund_change_type.add_amount,
                                   v_settle_amount,
                                   l_bank_batch_id,
                                   v_partner_account,
                                   v_settle_user,
                                   v_settle_memo);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---3.收卡上游与18上游关联结算(上游加款)
  l_result := dk_f_sup_bind_up_settle(v_sup_up_channel_no,
                                      v_sup_up_account_id,
                                      v_sup_up_company_id,
                                      v_jz_up_channel_no,
                                      v_jz_up_account_id,
                                      v_jz_up_company_id,
                                      pkg_up_fund_change_type.add_amount,
                                      l_bank_batch_id,
                                      v_settle_amount,
                                      v_partner_account,
                                      v_settle_user,
                                      v_settle_memo);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_SUP_DOWN_SETTLE_PRE_CK_T
prompt ===============================================
prompt
create or replace function fd_account.dk_f_sup_down_settle_pre_ck_t(v_down_channel_no varchar2,
                                                         v_down_account_id number,
                                                         v_record_no       varchar2,
                                                         v_settle_amount   number,
                                                         v_service_fee     number,
                                                         v_channel_name    out varchar2,
                                                         v_account_name    out varchar2)
  return varchar2 is
  ---------------收卡下游预付结算检查---------------
  l_settle_count number;
begin

  ---1.检查结算是否存在
  select count(1)
    into l_settle_count
    from dk_trade_down_settle t
   where t.ext_record_no = v_record_no;

  if l_settle_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  ---2. 检查下游渠道
  select a.account_name, c.channel_name
    into v_account_name, v_channel_name
    from dk_base_down_account_map t
   inner join dk_base_down_account a on t.account_id = a.account_id
   inner join dk_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
     and c.classification = pkg_dk_channel_classification.sk
     and rownum <= 1;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function DK_F_SUP_DOWN_SETTLE_T
prompt ========================================
prompt
create or replace function fd_account.dk_f_sup_down_settle_t(v_down_channel_no varchar2,
                                                  v_down_account_id number,
                                                  v_record_no       varchar2,
                                                  v_down_fund_type  number,
                                                  v_settle_amount   number,
                                                  v_bank_batch_id   number,
                                                  v_partner_account varchar2,
                                                  v_create_user     varchar2,
                                                  v_memo            varchar2)
  return varchar2 is
  ----------------下游渠道结算---------------
  l_inner_balance      number;
  l_fund_record_id     number;
  l_fund_amount        number;
  l_manual_change_type number;
  l_settle_count       number;
begin
  ---1.锁下游渠道账户
  select t.inner_balance,
         seq_trade_down_fund_id.nextval,
         decode(v_down_fund_type,
                pkg_down_fund_change_type.add_amount,
                1,
                -1) * v_settle_amount, --账户余额变动的金额
         decode(v_down_fund_type,
                pkg_down_fund_change_type.add_amount,
                pkg_down_manual_change_type.add_amount,
                pkg_down_manual_change_type.draw_amount) --人工操作表操作类型获取
    into l_inner_balance,
         l_fund_record_id,
         l_fund_amount,
         l_manual_change_type
    from dk_base_down_account t
   where t.account_id = v_down_account_id
     and v_down_fund_type in (pkg_down_fund_change_type.add_amount,
          pkg_down_fund_change_type.draw_amount)
     for update;

  ---2.检查结算记录是否存在
  select count(1)
    into l_settle_count
    from dk_trade_down_settle t
   where t.ext_record_no = v_record_no;

  if l_settle_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  ---3.更新渠道账户余额
  update dk_base_down_account t
     set t.inner_balance  = (l_inner_balance + l_fund_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---4.添加下游人工加款记录
  insert into dk_trade_down_settle
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo,
     ext_record_no)
  values
    (l_fund_record_id,
     v_down_channel_no,
     v_down_account_id,
     pkg_sys_boolean.istrue,
     l_manual_change_type,
     v_settle_amount,
     sysdate,
     (l_inner_balance + l_fund_amount),
     v_create_user,
     v_bank_batch_id,
     v_partner_account,
     v_memo,
     v_record_no);

  ---5.添加下游资金变动
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     v_down_fund_type,
     v_settle_amount,
     (l_inner_balance + l_fund_amount),
     v_memo);

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function DK_F_SUP_UP_ORDER_MINUS
prompt =========================================
prompt
create or replace function fd_account.dk_f_sup_up_order_minus(v_order_source      number,
                                                   v_trade_order_no    varchar2,
                                                   v_trade_delivery_no varchar2,
                                                   v_up_channel_no     varchar2,
                                                   v_up_account_id     number,
                                                   v_up_draw_unit      number,
                                                   v_up_draw_face      number,
                                                   v_up_draw_amount    number,
                                                   v_up_real_amount    number,
                                                   v_down_draw_unit    number,
                                                   v_down_draw_face    number,
                                                   v_down_draw_amount  number,
                                                   v_down_real_amount  number,
                                                   v_bill_type         number,
                                                   v_order_time        varchar2,
                                                   v_trade_time        varchar2,
                                                   v_up_service_fee    number,
                                                   v_memo              varchar2)
  return varchar2 is
  l_down_order_all_unit number;
  l_down_order_all_face number;
  l_down_debit_now_unit number;
  l_down_debit_now_face number;
  l_down_draw_unit      number;
  l_down_draw_face      number;
  l_down_draw_amount    number;
  l_down_real_amount    number;

  l_up_company_id   number;
  l_down_channel_no varchar2(32);
  l_down_company_id number;
  l_inner_balance   number;
  l_query_balance   number;
  l_dk_order_id     number;
  l_pay_count       number;
  l_settle_status   number;
  l_down_account_id number;
  l_business_type   number;
  l_carrier_no      varchar2(32);
  l_province_no     varchar2(32);
  l_city_no         varchar2(32);

  l_profits          number;
  l_down_commission  number;
  l_up_commission    number;
  l_refund_face      number;
  l_refund_unit      number;
  l_order_all_amount number;
  l_order_all_unit   number;
  l_order_all_face   number;
  l_result           varchar2(32);
  l_recharge_times   number;

  l_up_draw_unit number;
  l_up_draw_face number;
  -------------------上游减款----------------------
begin

  --===============================检查订单支付情况==================================
  ---1.锁支付订单
  select t.dk_order_id,
         t.down_channel_no,
         t.down_account_id,
         t.down_company_id,
         t.recharge_unit,
         t.total_face,
         t.business_type,
         t.carrier_no,
         t.province_no,
         t.city_no,
         t.down_order_amount
    into l_dk_order_id,
         l_down_channel_no,
         l_down_account_id,
         l_down_company_id,
         l_order_all_unit,
         l_order_all_face,
         l_business_type,
         l_carrier_no,
         l_province_no,
         l_city_no,
         l_order_all_amount
    from dk_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查订单是否已支付
  select count(1)
    into l_pay_count
    from dk_trade_up_fund t
   where t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount;

  if (l_pay_count > 0) then
    return pkg_error_code.success;
  end if;

  ---3.计算下游规格、订单金额
  select nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_unit),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_face),
             0)
    into l_down_debit_now_unit, l_down_debit_now_face
    from dk_trade_up_fund t
   where t.dk_order_id = l_dk_order_id
     and t.change_type in (pkg_up_fund_change_type.debit_amount,
          pkg_up_fund_change_type.refund_amount);

  ---4.计算出下游退款金额
  select nvl(sum(t.refund_face), 0), nvl(sum(t.refund_unit), 0)
    into l_refund_face, l_refund_unit
    from dk_trade_down_refund t
   where t.dk_order_id = l_dk_order_id;

  ---5.计算扣款金额
  l_down_draw_unit   := v_down_draw_unit;
  l_down_draw_face   := v_down_draw_face;
  l_down_draw_amount := v_down_draw_amount;
  l_down_real_amount := v_down_real_amount;

  l_up_draw_unit := v_up_draw_unit;
  l_up_draw_face := v_up_draw_face;
  if v_up_draw_face != l_down_draw_face then
    l_up_draw_unit := l_down_draw_unit;
    l_up_draw_face := l_down_draw_face;
  end if;

  --===================================获取公司结算信息=================================

  ---4. 是否需要结算给公司
  select t.company_id
    into l_up_company_id
    from dk_base_up_channel t
   where t.channel_no = v_up_channel_no;

  l_settle_status := pkg_settle_status.no_need;
  if (l_up_company_id != l_down_company_id) then
    l_settle_status := pkg_settle_status.wait_settle;
  end if;

  --======================================上游减款=====================================

  ---5.1获取并修改账户余额
  select t.query_balance, t.inner_balance
    into l_query_balance, l_inner_balance
    from dk_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  update dk_base_up_account t
     set t.inner_balance = (l_inner_balance - v_up_draw_amount)
   where t.account_id = v_up_account_id;

  l_profits         := v_up_real_amount - l_down_real_amount; --->>>>>>>>>>>>>>>>>> 利润需要反过来减
  l_down_commission := l_down_draw_amount - l_down_real_amount; --->>>>>>>>>>> 下游佣金
  l_up_commission   := v_up_draw_amount - v_up_real_amount; --->>>>>>>>>>> 上游佣金

  ---6.添加上游资金变动
  insert into dk_trade_up_fund
    (record_id,
     dk_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     order_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     memo,
     trade_time,
     channel_settle_status)
  values
    (seq_trade_up_fund_id.nextval,
     l_dk_order_id,
     v_trade_order_no,
     v_order_source,
     v_trade_delivery_no,
     l_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_up_channel_no,
     v_up_account_id,
     l_up_company_id,
     l_down_draw_unit,
     l_down_draw_face,
     l_down_draw_amount,
     l_down_real_amount,
     l_up_draw_unit,
     l_up_draw_face,
     v_up_draw_amount,
     v_up_real_amount,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     l_business_type,
     l_carrier_no,
     l_province_no,
     (l_inner_balance - v_up_draw_amount),
     l_profits,
     l_down_commission,
     l_up_commission,
     0,
     l_settle_status,
     v_memo,
     to_date(v_trade_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_dk_channel_settle_status.wait);

  ---7.添加订单差异表数据
  l_result := dk_f_trade_fund_differ_add(l_dk_order_id,
                                         pkg_trade_type.up_debit,
                                         l_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         v_bill_type,
                                         l_order_all_face,
                                         l_order_all_amount,
                                         l_down_draw_face,
                                         l_down_draw_amount,
                                         l_up_draw_face);

  return l_result;
end;
/

prompt
prompt Creating function DK_F_SUP_UP_ORDER_REFUND
prompt ==========================================
prompt
create or replace function fd_account.dk_f_sup_up_order_refund(v_order_source            number,
                                                    v_down_channel_no         varchar2,
                                                    v_up_channel_no           varchar2,
                                                    v_trade_order_no          varchar2,
                                                    v_trade_delivery_no       varchar2,
                                                    v_trade_refund_no         varchar2,
                                                    v_bill_type               number,
                                                    v_business_type           number,
                                                    v_carrier_no              varchar2,
                                                    v_province_no             varchar2,
                                                    v_up_refund_unit          number,
                                                    v_up_refund_face          number,
                                                    v_up_refund_amount        number,
                                                    v_up_refund_real_amount   number,
                                                    v_order_time              varchar2,
                                                    v_trade_time              varchar2,
                                                    v_service_fee             number,
                                                    v_memo                    varchar2,
                                                    v_down_refund_unit        in number, -- 下游退款总规格
                                                    v_down_refund_face        in number, -- 下游退款总面值
                                                    v_down_refund_amount      in number, -- 下游退款金额
                                                    v_down_refund_real_amount in number -- 下游实际退款金额
                                                    ) return varchar2 is

  ------------上游订单退款------------
  l_dk_order_id      number;
  l_refund_count     number;
  l_up_company_id    number;
  l_settle_amount    number;
  l_settle_status    number;
  l_query_balance    number;
  l_inner_balance    number;
  l_down_account_id  number;
  l_down_company_id  number;
  l_total_pay        number;
  l_total_refund     number;
  l_up_account_id    number;
  l_up_fund_id       number;
  l_down_refund_face number;
  l_up_refund_face   number;
  l_up_draw_face     number;
  l_order_face       number;
  l_face_differ      number;
  l_up_down_face     number;
  l_up_down_unit     number;
  l_up_down_amount   number;
  l_up_down_real     number;

  l_up_all_down_face   number;
  l_up_all_down_unit   number;
  l_up_all_down_amount number;
  l_up_all_down_real   number;

  l_order_amount  number;
  l_up_all_face   number;
  l_debit_count   number;
  l_business_type number;
  l_result        varchar2(32);

  l_cg_up_draw_unit number;
  l_cg_up_draw_face number;
begin
  --=============================检查订单重复退款、金额错误==============================
  ---1.锁下游订单
  select t.dk_order_id,
         t.down_account_id,
         t.down_company_id,
         t.total_face,
         t.down_order_amount,
         t.business_type
    into l_dk_order_id,
         l_down_account_id,
         l_down_company_id,
         l_order_face,
         l_order_amount,
         l_business_type
    from dk_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查重复退款
  select count(1)
    into l_refund_count
    from dk_trade_up_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = v_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  ---2.1检查退款时是否有扣款
  select count(1)
    into l_debit_count
    from dk_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---3.获取上游支付扣款、已退款金额
  select t.up_draw_amount,
         t.up_account_id,
         t.settle_amount,
         t.up_company_id,
         t.up_draw_face
    into l_total_pay,
         l_up_account_id,
         l_settle_amount,
         l_up_company_id,
         l_up_draw_face
    from dk_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  select nvl(sum(t.up_draw_amount), 0), nvl(sum(t.up_draw_face), 0)
    into l_total_refund, l_up_refund_face
    from dk_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.refund_amount;

  ---4.检查退款金额是否超过上游总代扣面值
  ---- 是总面值：yangdejian 20161019
  --if (v_up_refund_amount > (l_up_draw_face - l_total_refund)) then
  if (v_up_refund_amount > (l_total_pay - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;
  if (v_down_refund_amount > v_down_refund_face) then
    return pkg_error_code.amount_error;
  end if;

  ---5.计算上游资金变动的下游信息
  select nvl(sum(t.refund_face), 0)
    into l_down_refund_face
    from dk_trade_down_refund t
   where t.dk_order_id = l_dk_order_id;

  l_up_down_face   := v_down_refund_face;
  l_up_down_unit   := v_down_refund_unit;
  l_up_down_amount := v_down_refund_amount;
  l_up_down_real   := v_down_refund_real_amount;

  l_cg_up_draw_unit := v_up_refund_unit;
  l_cg_up_draw_face := v_up_refund_face;
  if v_up_refund_face != l_up_down_face then
    l_cg_up_draw_unit := l_up_down_unit;
    l_cg_up_draw_face := l_up_down_face;
  end if;

  --=============================获取退款结算信息=================================
  ---5.获取公司结算状态
  l_settle_status := pkg_settle_status.no_need;
  if (l_up_company_id != l_down_company_id) then
    l_settle_status := pkg_settle_status.wait_settle;
  end if;

  --==================================上游退款===================================
  ---6.获取并修改账户余额
  select t.query_balance, t.inner_balance
    into l_query_balance, l_inner_balance
    from dk_base_up_account t
   where t.account_id = l_up_account_id
     for update;

  update dk_base_up_account t
     set t.inner_balance = (l_inner_balance + v_up_refund_amount)
   where t.account_id = l_up_account_id;

  ---7.添加上游退款记录
  select seq_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into dk_trade_up_refund
    (record_id,
     channel_no,
     account_id,
     dk_order_id,
     trade_order_no,
     trade_delivery_no,
     trade_refund_no,
     order_source,
     refund_time,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund,
     memo)
  values
    (l_up_fund_id,
     v_up_channel_no,
     l_up_account_id,
     l_dk_order_id,
     v_trade_order_no,
     v_trade_delivery_no,
     v_trade_refund_no,
     v_order_source,
     sysdate,
     v_bill_type,
     v_business_type,
     v_carrier_no,
     v_province_no,
     l_cg_up_draw_unit,
     l_cg_up_draw_face,
     v_up_refund_amount,
     v_up_refund_real_amount,
     v_memo);

  ---8.添加上游资金变动
  insert into dk_trade_up_fund
    (record_id,
     dk_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount, ---- 14
     down_real_amount, --- 15
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     order_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     memo,
     trade_time,
     channel_settle_status)
    select l_up_fund_id,
           l_dk_order_id,
           v_trade_order_no,
           v_order_source,
           v_trade_delivery_no,
           v_down_channel_no,
           l_down_account_id,
           l_down_company_id,
           v_up_channel_no,
           l_up_account_id,
           l_up_company_id,
           l_up_down_unit,
           l_up_down_face,
           l_up_down_amount, -- 14
           l_up_down_real, -- 15
           l_cg_up_draw_unit,
           l_cg_up_draw_face,
           v_up_refund_amount,
           v_up_refund_real_amount,
           sysdate,
           to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
           pkg_up_fund_change_type.refund_amount,
           v_bill_type,
           v_business_type,
           v_carrier_no,
           v_province_no,
           (l_inner_balance + v_up_refund_amount),
           t.profits,
           t.down_commission,
           (v_up_refund_amount - v_up_refund_real_amount),
           l_settle_amount,
           l_settle_status,
           v_memo,
           to_date(v_trade_time, 'yyyy-mm-dd hh24:mi:ss'),
           pkg_dk_channel_settle_status.wait
      from dk_trade_up_fund t
     where t.dk_order_id = l_dk_order_id
       and t.trade_delivery_no = v_trade_delivery_no
       and t.change_type = pkg_up_fund_change_type.debit_amount
       and rownum <= 1;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---9.记录差异信息
  l_result := dk_f_trade_fund_differ_add(l_dk_order_id,
                                         pkg_trade_type.up_refund,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         v_bill_type,
                                         l_order_face,
                                         l_order_amount,
                                         l_up_down_face,
                                         l_up_down_amount,
                                         l_cg_up_draw_face);

  return l_result;
end;
/

prompt
prompt Creating function DK_F_SUP_UP_SETTLE
prompt ====================================
prompt
create or replace function fd_account.dk_f_sup_up_settle(v_up_channel_no   varchar2,
                                              v_up_account_id   number,
                                              v_up_company_id   number,
                                              v_bank_batch_id   number,
                                              v_up_fund_type    number,
                                              v_settle_amount   number,
                                              v_partner_account varchar2,
                                              v_settle_user     varchar2,
                                              v_settle_memo     varchar2)
  return varchar2 is
  -----------------收卡上游渠道结算--------------
  l_inner_balance      number;
  l_up_fund_id         number;
  l_fund_amount        number;
  l_manual_change_type number;
begin
  ---1.锁收卡系统上游渠道
  select t.inner_balance,
         seq_trade_up_fund_id.nextval,
         decode(v_up_fund_type, pkg_up_fund_change_type.add_amount, 1, -1) *
         v_settle_amount, ---通过变动类型决定是加款还是减款
         decode(v_up_fund_type,
                pkg_up_fund_change_type.add_amount,
                pkg_up_manual_change_type.add_amount,
                pkg_up_manual_change_type.draw_amount)
    into l_inner_balance, l_up_fund_id, l_fund_amount, l_manual_change_type
    from dk_base_up_account t
   where t.account_id = v_up_account_id
     and v_up_fund_type in (pkg_up_fund_change_type.add_amount,
          pkg_up_fund_change_type.draw_amount)
     for update;

  ---2.修改渠道账户的余额
  update dk_base_up_account t
     set t.inner_balance  = (l_inner_balance + l_fund_amount),
         t.last_edit_user = v_settle_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  ---3.添加渠道的人工操作记录
  insert into dk_trade_up_settle
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     l_manual_change_type,
     v_settle_amount,
     sysdate,
     (l_inner_balance + l_fund_amount),
     v_settle_memo,
     v_settle_user,
     v_partner_account,
     v_bank_batch_id);

  ---4.添加渠道资金变动记录
  insert into dk_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_settle_amount,
     v_settle_amount,
     sysdate,
     v_up_fund_type,
     (l_inner_balance + l_fund_amount),
     v_settle_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_SUP_UP_SETTLE_AFTER
prompt ==========================================
prompt
create or replace function fd_account.dk_f_sup_up_settle_after(v_up_channel_no     varchar2,
                                                    v_up_account_id     number,
                                                    v_up_company_id     number,
                                                    v_bank_account_id   number,
                                                    v_settle_record_id  number,
                                                    v_channel_name      varchar2,
                                                    v_account_name      varchar2,
                                                    v_sup_up_channel_no varchar2,
                                                    v_sup_up_account_id number,
                                                    v_sup_up_company_id number,
                                                    v_jz_up_channel_no  varchar2,
                                                    v_jz_up_account_id  number,
                                                    v_jz_up_company_id  number,
                                                    v_settle_amount     number,
                                                    v_partner_account   varchar2,
                                                    v_settle_user       varchar2,
                                                    v_remark_name       varchar2,
                                                    v_settle_memo       varchar2)
  return varchar2 is
  --------------收卡系统上游后付结算---------------
  l_bank_batch_id number;
  l_result        varchar2(32);
begin
  ---1.银行卡入账(银行加款)
  l_result := dk_f_sup_bank_settle(v_bank_account_id,

                                   v_channel_name,
                                   v_account_name,
                                   pkg_bank_fund_change_type.add_amount,
                                   pkg_bank_use_type.dk_up_settle,
                                   v_settle_amount,
                                   0,
                                   v_settle_user,
                                   v_settle_memo,
                                   v_remark_name,
                                   l_bank_batch_id);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---2.上游渠道结算(上游加款)
  l_result := dk_f_sup_up_settle(v_up_channel_no,
                                 v_up_account_id,
                                 v_up_company_id,
                                 l_bank_batch_id,
                                 pkg_up_fund_change_type.add_amount,
                                 v_settle_amount,
                                 v_partner_account,
                                 v_settle_user,
                                 v_settle_memo);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---3.收卡上游与18上游关联退款(上游减款)
  l_result := dk_f_sup_bind_up_settle(v_sup_up_channel_no,
                                      v_sup_up_account_id,
                                      v_sup_up_company_id,
                                      v_jz_up_channel_no,
                                      v_jz_up_account_id,
                                      v_jz_up_company_id,
                                      pkg_up_fund_change_type.draw_amount,
                                      l_bank_batch_id,
                                      v_settle_amount,
                                      v_partner_account,
                                      v_settle_user,
                                      v_settle_memo);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---4.修改收卡结算记录，完成结算
  l_result := dk_f_sup_report_after_settle(v_settle_record_id,
                                           l_bank_batch_id,
                                           v_settle_user,
                                           v_settle_memo);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_SUP_UP_SETTLE_PRE_CHECK
prompt ==============================================
prompt
create or replace function fd_account.dk_f_sup_up_settle_pre_check(v_up_channel_no     varchar2,
                                                        v_up_account_id     number,
                                                        v_bank_account_id   number,
                                                        v_sup_up_channel_no varchar2,
                                                        v_settle_amount     number,
                                                        v_up_company_id     out number,
                                                        v_channel_name      out varchar2,
                                                        v_account_name      out varchar2)
  return varchar2 is
  ---------------收卡系统上游预付结算---------------
  l_result varchar2(32);
begin
  ---1.检查上游渠道是否为收卡渠道、是否为非18对应上游
  select t.channel_name
    into v_channel_name
    from dk_base_up_channel t
   where t.channel_no = v_up_channel_no
     and t.classification = pkg_dk_channel_classification.sk
     and t.channel_no != v_sup_up_channel_no;

  ---2.检查结算的金额、上游渠道、账户及银行账户是否正确
  ---********************************************************
  ---@预付为渠道列表中结算，不做强制限制，预付、后付都可使用
  ---********************************************************
  l_result := dk_f_manual_up_settle_check(v_up_channel_no,
                                          v_up_account_id,
                                          v_bank_account_id,
                                          v_settle_amount,
                                          0,
                                          v_up_company_id,
                                          v_account_name,
                                          v_channel_name);

  return l_result;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function DK_F_SUP_UP_SETTLE_AFTER_CK
prompt =============================================
prompt
create or replace function fd_account.dk_f_sup_up_settle_after_ck(v_up_channel_no     varchar2,
                                                       v_up_account_id     number,
                                                       v_bank_account_id   number,
                                                       v_settle_record_id  number,
                                                       v_sup_up_channel_no varchar2,
                                                       v_up_company_id     out number,
                                                       v_channel_name      out varchar2,
                                                       v_account_name      out varchar2,
                                                       v_settle_amount     out number)
  return varchar2 is
  ------------------检查上游后付信息-----------------
  l_up_channel_no varchar2(32);
  l_result        varchar2(32);
begin
  ---1.检查结算记录是否可以结算
  select t.channel_no, t.settle_amount
    into l_up_channel_no, v_settle_amount
    from dk_reprot_channel_settle t
   inner join dk_base_up_channel c on t.channel_no = c.channel_no
   where t.id = v_settle_record_id
     and t.channel_no = v_up_channel_no
     and t.channel_type = pkg_channel_type.up_channel
     and t.settle_status = pkg_dk_report_settle_status.wait
     and c.classification = pkg_dk_channel_classification.sk
     and c.payment_type = pkg_dk_channel_payment_type.after_pay;

  ---2.检查收卡上游相关数据是否正确
  l_result := dk_f_sup_up_settle_pre_check(v_up_channel_no,
                                           v_up_account_id,
                                           v_bank_account_id,
                                           v_sup_up_channel_no,
                                           v_settle_amount,
                                           v_up_company_id,
                                           v_channel_name,
                                           v_account_name);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---3.修改结算记录为正在结算
  update dk_reprot_channel_settle t
     set t.settle_status = pkg_dk_report_settle_status.doing
   where t.id = v_settle_record_id
     and t.settle_status = pkg_dk_report_settle_status.wait;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function DK_F_SUP_UP_SETTLE_PRE
prompt ========================================
prompt
create or replace function fd_account.dk_f_sup_up_settle_pre(v_up_channel_no     varchar2,
                                                  v_up_account_id     number,
                                                  v_up_company_id     number,
                                                  v_bank_account_id   number,
                                                  v_channel_name      varchar2,
                                                  v_account_name      varchar2,
                                                  v_sup_up_channel_no varchar2,
                                                  v_sup_up_account_id number,
                                                  v_sup_up_company_id number,
                                                  v_jz_up_channel_no  varchar2,
                                                  v_jz_up_account_id  number,
                                                  v_jz_up_company_id  number,
                                                  v_settle_amount     number,
                                                  v_partner_account   varchar2,
                                                  v_settle_user       varchar2,
                                                  v_remark_name       varchar2,
                                                  v_settle_memo       varchar2)
  return varchar2 is
  --------------------------------
  --功能：上游预付结算
  --修改人：周荣省
  --修改时间：2019-08-26
  --修改内容：添加收付款账户名称
  --------------------------------
  l_bank_batch_id number;
  l_result        varchar2(32);
begin
  ---1.银行卡入账(银行加款)
  l_result := dk_f_sup_bank_settle(v_bank_account_id,
                                   v_channel_name,
                                   v_account_name,
                                   pkg_bank_fund_change_type.add_amount,
                                   pkg_bank_use_type.dk_up_settle,
                                   v_settle_amount,
                                   0,
                                   v_settle_user,
                                   v_settle_memo,
                                   v_remark_name,
                                   l_bank_batch_id);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---2.上游渠道结算(上游加款)
  l_result := dk_f_sup_up_settle(v_up_channel_no,
                                 v_up_account_id,
                                 v_up_company_id,
                                 l_bank_batch_id,
                                 pkg_up_fund_change_type.add_amount,
                                 v_settle_amount,
                                 v_partner_account,
                                 v_settle_user,
                                 v_settle_memo);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---3.收卡上游与18上游关联退款(上游减款)
  l_result := dk_f_sup_bind_up_settle(v_sup_up_channel_no,
                                      v_sup_up_account_id,
                                      v_sup_up_company_id,
                                      v_jz_up_channel_no,
                                      v_jz_up_account_id,
                                      v_jz_up_company_id,
                                      pkg_up_fund_change_type.draw_amount,
                                      l_bank_batch_id,
                                      v_settle_amount,
                                      v_partner_account,
                                      v_settle_user,
                                      v_settle_memo);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_SUP_UP_SETTLE_PRE_CK_T
prompt =============================================
prompt
create or replace function fd_account.dk_f_sup_up_settle_pre_ck_t(v_up_channel_no varchar2,
                                                       v_up_account_id number,
                                                       v_record_no     number,
                                                       v_settle_amount number,
                                                       v_up_company_id out number,
                                                       v_channel_name  out varchar2,
                                                       v_account_name  out varchar2)
  return varchar2 is
  ---------------收卡系统上游预付结算---------------
  l_settle_count number;
begin
  ---1.检查结算记录是否已同步
  select count(1)
    into l_settle_count
    from dk_trade_up_settle t
   where t.ext_record_no = v_record_no;

  if l_settle_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  ---2.检查上游资金账户
  select c.company_id, a.account_name, c.channel_name
    into v_up_company_id, v_account_name, v_channel_name
    from dk_base_up_account_map t
   inner join dk_base_up_account a on t.account_id = a.account_id
   inner join dk_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and c.classification = pkg_dk_channel_classification.sk
     and rownum <= 1;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function DK_F_SUP_UP_SETTLE_T
prompt ======================================
prompt
create or replace function fd_account.dk_f_sup_up_settle_t(v_up_channel_no   varchar2,
                                                v_up_account_id   number,
                                                v_up_company_id   number,
                                                v_record_no       varchar2,
                                                v_bank_batch_id   number,
                                                v_up_fund_type    number,
                                                v_settle_amount   number,
                                                v_partner_account varchar2,
                                                v_settle_user     varchar2,
                                                v_settle_memo     varchar2)
  return varchar2 is
  -----------------收卡上游渠道结算--------------
  l_inner_balance      number;
  l_up_fund_id         number;
  l_fund_amount        number;
  l_manual_change_type number;
  l_settle_count       number;
begin
  ---1.锁收卡系统上游渠道
  select t.inner_balance,
         seq_trade_up_fund_id.nextval,
         decode(v_up_fund_type, pkg_up_fund_change_type.add_amount, 1, -1) *
         v_settle_amount, ---通过变动类型决定是加款还是减款
         decode(v_up_fund_type,
                pkg_up_fund_change_type.add_amount,
                pkg_up_manual_change_type.add_amount,
                pkg_up_manual_change_type.draw_amount)
    into l_inner_balance, l_up_fund_id, l_fund_amount, l_manual_change_type
    from dk_base_up_account t
   where t.account_id = v_up_account_id
     and v_up_fund_type in (pkg_up_fund_change_type.add_amount,
          pkg_up_fund_change_type.draw_amount)
     for update;

  ---2.检查结算记录是否存在
  select count(1)
    into l_settle_count
    from dk_trade_up_settle t
   where t.ext_record_no = v_record_no;

  if l_settle_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  ---3.修改渠道账户的余额
  update dk_base_up_account t
     set t.inner_balance  = (l_inner_balance + l_fund_amount),
         t.last_edit_user = v_settle_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  ---4.添加渠道的人工操作记录
  insert into dk_trade_up_settle
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     has_adjust,
     bank_fund_id,
     ext_record_no)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     l_manual_change_type,
     v_settle_amount,
     sysdate,
     (l_inner_balance + l_fund_amount),
     v_settle_memo,
     v_settle_user,
     v_partner_account,
     pkg_sys_boolean.istrue,
     v_bank_batch_id,
     v_record_no);

  ---5.添加渠道资金变动记录
  insert into dk_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_settle_amount,
     v_settle_amount,
     sysdate,
     v_up_fund_type,
     (l_inner_balance + l_fund_amount),
     v_settle_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_SYSTEM_ID_GET
prompt ====================================
prompt
create or replace function fd_account.dk_f_system_id_get(v_source_name varchar2,
                                              v_source_id   out number)
  return varchar2 is
  ---------------------通过名称获取系统编号------------------
begin

  select t.source_system_id
    into v_source_id
    from fd_base_source_system t
   where t.source_system_name = v_source_name
     and rownum <= 2;

  return pkg_error_code.success;
exception
  when others then
    fd_p_write_log('dk_f_system_id_get', '系统名称有重复项！请检查！');
    return pkg_error_code.failure;
end;
/

prompt
prompt Creating function DK_F_TRADE_AC_PAY_ACCOUNT_GET
prompt ===============================================
prompt
create or replace function fd_account.dk_f_trade_ac_pay_account_get(v_order_source  number,
                                                         v_up_channel_no varchar2,
                                                         v_up_account_id number)
  return varchar2 is

  -----------------获取上游支付账户编号------------------
  l_up_account_id number;
begin

  ---1.获取上游渠道唯一账户，当有多个账户时，请使用其它方式获取
  select t.account_id
    into l_up_account_id
    from dk_base_up_account_map t
   inner join dk_base_up_account a on t.account_id = a.account_id
   inner join dk_base_up_channel c on t.channel_no = c.channel_no
   inner join dk_base_up_system_map s on t.channel_no = s.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and s.source_system_id = v_order_source
     and a.status = 0
     and c.status = 0
     and rownum <= 1;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function DK_F_TRADE_DOWN_FEE_REFUND
prompt ============================================
prompt
create or replace function fd_account.dk_f_trade_down_fee_refund(v_order_source    in number,
                                                      v_down_channel_no in varchar2,
                                                      v_trade_order_no  in varchar2,
                                                      v_trade_refund_no varchar2,
                                                      v_refund_unit     number,
                                                      v_refund_face     number,
                                                      v_refund_amount   number,
                                                      v_real_refund     number,
                                                      v_order_date      varchar2,
                                                      v_service_fee     number,
                                                      v_memo            varchar2,
                                                      v_sys_paid_amount number)
  return varchar2 is
  l_dk_order_id       number;
  l_down_account_id   number;
  l_order_source      number;
  l_trade_order_no    varchar2(32);
  l_ext_order_no      varchar2(32);
  l_down_channel_no   varchar2(32);
  l_refund_count      number;
  l_total_refund      number;
  l_inner_balance     number;
  l_down_fund_id      number;
  l_down_order_face   number;
  l_down_order_amount number;
  l_result            varchar2(32);

  l_debit_count       number;
  l_total_refund_face number;
  l_business_type     number;
  l_order_total_face  number;
  ------------下游订单退款------------
begin
  --===========================检查订单重复退款、金额错误==========================
  ---1.锁下游订单
  select t.dk_order_id,
         t.order_source,
         t.down_channel_no,
         t.down_account_id,
         t.ext_order_no,
         t.trade_order_no,
         t.total_face,
         t.down_order_amount,
         t.business_type,
         t.total_face * t.recharge_times
    into l_dk_order_id,
         l_order_source,
         l_down_channel_no,
         l_down_account_id,
         l_ext_order_no,
         l_trade_order_no,
         l_down_order_face,
         l_down_order_amount,
         l_business_type,
         l_order_total_face
    from dk_trade_order_main t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1
     for update;

  ---2.检测订单重复退款
  select count(1)
    into l_refund_count
    from dk_trade_down_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = l_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  ---2.1检查退款时是否有扣款
  select count(1)
    into l_debit_count
    from dk_trade_down_fund t
   where t.dk_order_id = l_dk_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and t.order_source = l_order_source
     and rownum <= 1;

  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---3.获取订单扣款、已退款金额
  select nvl(sum(t.refund_amount), 0), nvl(sum(t.refund_face), 0)
    into l_total_refund, l_total_refund_face
    from dk_trade_down_refund t
   where t.dk_order_id = l_dk_order_id;

  ---4.检查退款金额是否超过订单总面值
  --- 总面值 yangdejian
  if (v_refund_amount > (l_order_total_face - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;

  --==================================修改账户余额===============================
  ---5.获取并修改账户余额
  select t.inner_balance
    into l_inner_balance
    from dk_base_down_account t
   where t.account_id = l_down_account_id
     for update;
  ----（退款金额已扣除手续费）
  update dk_base_down_account t
     set t.inner_balance = (l_inner_balance + v_refund_amount)
   where t.account_id = l_down_account_id;

  --===================添加数据变动记录=============
  ---6.添加退款记录
  select seq_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into dk_trade_down_refund
    (record_id,
     channel_no,
     account_id,
     dk_order_id,
     trade_order_no,
     trade_refund_no,
     order_source,
     refund_time,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund, ---删掉了退款类型
     memo)
    select l_down_fund_id,
           t.down_channel_no,
           t.down_account_id,
           t.dk_order_id,
           t.trade_order_no,
           v_trade_refund_no,
           t.order_source,
           sysdate,
           t.business_type,
           t.carrier_no,
           t.province_no,
           v_refund_unit,
           v_refund_face,
           v_refund_amount,
           v_real_refund,
           v_memo
      from dk_trade_order_main t
     where t.dk_order_id = l_dk_order_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---7.添加下游资金变动
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee)
  values
    (l_down_fund_id,
     l_dk_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     l_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_date, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_down_fund_change_type.refund_amount,
     v_refund_amount,
     (l_inner_balance + v_refund_amount),
     v_memo,
     v_service_fee); ---退手续费

  --===========================订单差异信息记录=================================
  --- 垫付金额不能大于面值
  if (v_sys_paid_amount > v_refund_face) then
    return pkg_error_code.amount_error;
  end if;

  if (v_sys_paid_amount != 0) then
    insert into dk_trade_refund_sys_cost
      (id,
       record_date,
       dk_order_id,
       channel_no,
       account_id,
       business_type,
       sys_cost,
       trade_order_no,
       trade_refund_no)
    values
      (seq_dktraderefundsyscost_id.nextval,
       sysdate,
       l_dk_order_id,
       v_down_channel_no,
       l_down_account_id,
       l_business_type,
       v_sys_paid_amount,
       v_trade_order_no,
       v_trade_refund_no);
  end if;

  ---10调用差异调整函数
  l_result := dk_f_trade_fund_differ_add(l_dk_order_id,
                                         pkg_trade_type.down_refund,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         pkg_bill_type.front,
                                         l_down_order_face,
                                         l_down_order_amount,
                                         v_refund_face,
                                         v_refund_amount,
                                         0);

  return l_result;
end;
/

prompt
prompt Creating function DK_F_TRADE_DOWN_LOSS_REFUND
prompt =============================================
prompt
create or replace function fd_account.dk_f_trade_down_loss_refund(v_order_source    in number,
                                                       v_down_channel_no in varchar2,
                                                       v_trade_order_no  in varchar2,
                                                       v_trade_refund_no varchar2,
                                                       v_refund_unit     number,
                                                       v_refund_face     number,
                                                       v_refund_amount   number,
                                                       v_real_refund     number,
                                                       v_order_date      varchar2,
                                                       v_service_fee     number,
                                                       v_memo            varchar2,
                                                       v_sys_paid_amount number,
                                                       v_calc_profit     number)
  return varchar2 is
  l_dk_order_id       number;
  l_down_account_id   number;
  l_order_source      number;
  l_trade_order_no    varchar2(32);
  l_ext_order_no      varchar2(32);
  l_down_channel_no   varchar2(32);
  l_refund_count      number;
  l_total_refund      number;
  l_inner_balance     number;
  l_down_fund_id      number;
  l_down_order_face   number;
  l_down_order_amount number;
  l_result            varchar2(32);

  l_debit_count       number;
  l_total_refund_face number;
  l_business_type     number;
  l_order_total_face  number;
  l_down_company_id   number;
  l_province_no       varchar2(32);
  l_carrier_no        varchar2(32);
  ------------下游订单退款------------
begin
  --===========================检查订单重复退款、金额错误==========================
  ---1.锁下游订单
  select t.dk_order_id,
         t.order_source,
         t.down_channel_no,
         t.down_account_id,
         t.ext_order_no,
         t.trade_order_no,
         t.total_face,
         t.down_order_amount,
         t.business_type,
         t.total_face * t.recharge_times,
         t.down_company_id,
         t.province_no,
         t.carrier_no
    into l_dk_order_id,
         l_order_source,
         l_down_channel_no,
         l_down_account_id,
         l_ext_order_no,
         l_trade_order_no,
         l_down_order_face,
         l_down_order_amount,
         l_business_type,
         l_order_total_face,
         l_down_company_id,
         l_province_no,
         l_carrier_no
    from dk_trade_order_main t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1
     for update;

  ---2.检测订单重复退款
  select count(1)
    into l_refund_count
    from dk_trade_down_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = l_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  ---2.1检查退款时是否有扣款
  select count(1)
    into l_debit_count
    from dk_trade_down_fund t
   where t.dk_order_id = l_dk_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and t.order_source = l_order_source
     and rownum <= 1;

  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---3.获取订单扣款、已退款金额
  select nvl(sum(t.refund_amount), 0), nvl(sum(t.refund_face), 0)
    into l_total_refund, l_total_refund_face
    from dk_trade_down_refund t
   where t.dk_order_id = l_dk_order_id;

  ---4.检查退款金额是否超过订单总面值
  --- 总面值 yangdejian
  if (v_refund_amount > (l_order_total_face - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;

  --==================================修改账户余额===============================
  ---5.获取并修改账户余额
  select t.inner_balance
    into l_inner_balance
    from dk_base_down_account t
   where t.account_id = l_down_account_id
     for update;
  ----（退款金额已扣除手续费）
  update dk_base_down_account t
     set t.inner_balance = (l_inner_balance + v_refund_amount)
   where t.account_id = l_down_account_id;

  --===================添加数据变动记录=============
  ---6.添加退款记录
  select seq_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into dk_trade_down_refund
    (record_id,
     channel_no,
     account_id,
     dk_order_id,
     trade_order_no,
     trade_refund_no,
     order_source,
     refund_time,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund, ---删掉了退款类型
     memo)
    select l_down_fund_id,
           t.down_channel_no,
           t.down_account_id,
           t.dk_order_id,
           t.trade_order_no,
           v_trade_refund_no,
           t.order_source,
           sysdate,
           t.business_type,
           t.carrier_no,
           t.province_no,
           v_refund_unit,
           v_refund_face,
           v_refund_amount,
           v_real_refund,
           v_memo
      from dk_trade_order_main t
     where t.dk_order_id = l_dk_order_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---7.添加下游资金变动
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee)
  values
    (l_down_fund_id,
     l_dk_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     l_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_date, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_down_fund_change_type.refund_amount,
     v_refund_amount,
     (l_inner_balance + v_refund_amount),
     v_memo,
     v_service_fee); ---退手续费

  --===========================下游退款金额需要计算利润=========================
  if v_calc_profit = pkg_sys_boolean.istrue then
    insert into dk_trade_up_fund
      (record_id,
       dk_order_id,
       trade_order_no,
       order_source,
       trade_delivery_no,
       down_channel_no,
       down_account_id,
       down_company_id,
       up_channel_no,
       up_account_id,
       up_company_id,
       down_draw_unit,
       down_draw_face,
       down_draw_amount,
       down_real_amount,
       up_draw_unit,
       up_draw_face,
       up_draw_amount,
       up_real_amount,
       change_time,
       order_time,
       change_type,
       bill_type,
       business_type,
       carrier_no,
       province_no,
       balance,
       memo)
    values
      (seq_trade_up_fund_id.nextval,
       l_dk_order_id,
       v_trade_order_no,
       v_order_source,
       'DREF' || v_trade_refund_no,
       l_down_channel_no,
       l_down_account_id,
       l_down_company_id,
       0,
       0,
       l_down_company_id,
       0,
       0,
       v_refund_amount,
       v_real_refund,
       0,
       0,
       0,
       0,
       sysdate,
       to_date(v_order_date, 'yyyy-mm-dd hh24:mi:ss'),
       pkg_up_fund_change_type.debit_amount,
       pkg_bill_type.front,
       l_business_type,
       l_carrier_no,
       l_province_no,
       0,
       v_memo);
  end if;
  --===========================订单差异信息记录=================================
  --- 垫付金额不能大于面值
  if (v_sys_paid_amount > v_refund_face) then
    return pkg_error_code.amount_error;
  end if;

  if (v_sys_paid_amount != 0) then
    insert into dk_trade_refund_sys_cost
      (id,
       record_date,
       dk_order_id,
       channel_no,
       account_id,
       business_type,
       sys_cost,
       trade_order_no,
       trade_refund_no)
    values
      (seq_dktraderefundsyscost_id.nextval,
       sysdate,
       l_dk_order_id,
       v_down_channel_no,
       l_down_account_id,
       l_business_type,
       v_sys_paid_amount,
       v_trade_order_no,
       v_trade_refund_no);
  end if;

  ---10调用差异调整函数
  l_result := dk_f_trade_fund_differ_add(l_dk_order_id,
                                         pkg_trade_type.down_refund,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         pkg_bill_type.front,
                                         l_down_order_face,
                                         l_down_order_amount,
                                         v_refund_face,
                                         v_refund_amount,
                                         0);

  return l_result;
end;
/

prompt
prompt Creating function DK_F_TRADE_DOWN_ORDER_FEE_MUS
prompt ===============================================
prompt
create or replace function fd_account.dk_f_trade_down_order_fee_mus(v_order_source    number,
                                                         v_down_channel_no varchar2,
                                                         v_trade_order_no  varchar2,
                                                         v_ext_order_no    varchar2,
                                                         v_order_time      varchar2,
                                                         v_settle_amount   number,
                                                         v_service_fee     number,
                                                         v_memo            varchar2)
  return varchar2 is
  -------------------下游扣款----------------------
  l_dk_order_id         number;
  l_pay_count           number;
  l_inner_balance       number;
  l_down_account_id     number;
  l_order_settle_amount number;
  l_total_face          number;
  l_business_type       number;
  l_result              varchar2(32) := pkg_error_code.success;
  l_recharge_times number;
begin

  ----===============================锁订单，检查是否重复扣款================================
  ---1.锁订单，检查扣款是否存在
  select t.dk_order_id,
         t.down_account_id,
         t.down_order_amount,
         t.total_face,
         t.business_type,
         t.recharge_times
    into l_dk_order_id,
         l_down_account_id,
         l_order_settle_amount,
         l_total_face,
         l_business_type,
         l_recharge_times
    from dk_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查是否存在扣款记录
  select count(1)
    into l_pay_count
    from dk_trade_down_fund t
   where t.dk_order_id = l_dk_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount;

  if (l_pay_count >= l_recharge_times) then
    return pkg_error_code.success;
  end if;

  ---3.检查从订单查询的扣款与本次扣款是否一致
  if l_order_settle_amount != v_settle_amount then
    return pkg_error_code.amount_error;
  end if;

  --=========================锁账户，检查余额并扣款=====================================
  ---3.获取下游账户信息
  select t.inner_balance
    into l_inner_balance
    from dk_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  ---5.下游扣款（扣款金额已除去手续费）
  update dk_base_down_account t
     set t.inner_balance = (l_inner_balance - v_settle_amount)
   where t.account_id = l_down_account_id;

  ---6.添加下游资金变动
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee)
  values
    (seq_trade_down_fund_id.nextval,
     l_dk_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     v_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_down_fund_change_type.debit_amount,
     v_settle_amount,
     (l_inner_balance - v_settle_amount),
     v_memo,
     v_service_fee); ---加上手续费

  ---7.扣款成功记录订单差异表
  l_result := dk_f_trade_fund_differ_add(l_dk_order_id,
                                         pkg_trade_type.down_debit,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         pkg_bill_type.front,
                                         l_total_face,
                                         l_order_settle_amount,
                                         l_total_face,
                                         v_settle_amount,
                                         0);

  return l_result;
end;
/

prompt
prompt Creating function DK_F_TRADE_HS_MOVE
prompt ====================================
prompt
create or replace function fd_account.dk_f_trade_hs_move(v_order_source    number,
                                              v_down_channel_no varchar2,
                                              v_trade_order_no  varchar2)
  return varchar2 is
  -------------------历史库中的数据转移到当前库--------------------
  l_order_count         number;
  l_order_hs_count      number;
  l_dk_order_id         number;
  l_order_add_count     number;
  l_down_fund_add_count number;
  l_up_fund_add_count   number;
  l_order_del_count     number;
  l_down_fund_del_count number;
  l_up_fund_del_count   number;
begin
  ---1.检查当前库订单是否存在
  select count(1)
    into l_order_count
    from dk_trade_order_main t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1;

  if l_order_count > 0 then
    return pkg_error_code.success;
  end if;

  ---2.当前库订单不存在，检查历史库订单是否存在
  select count(1), max(t.dk_order_id)
    into l_order_hs_count, l_dk_order_id
    from dk_trade_order_main_hs t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1;

  if l_order_hs_count = 0 then
    return pkg_error_code.order_not_exists;
  end if;

  ---3.历史库订单存在，获取历史库订单及其变动数据存入当前库
  ---3.1订单主表数据
  insert into dk_trade_order_main
    (dk_order_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     business_type,
     carrier_no,
     province_no,
     city_no,
     total_face,
     recharge_unit,
     recharge_account_no,
     down_order_amount,
     recharge_times)
    select dk_order_id,
           down_channel_no,
           down_account_id,
           down_company_id,
           trade_order_no,
           ext_order_no,
           order_source,
           create_time,
           order_time,
           business_type,
           carrier_no,
           province_no,
           city_no,
           total_face,
           recharge_unit,
           recharge_account_no,
           t.down_order_amount,
           t.recharge_times
      from dk_trade_order_main_hs t
     where t.dk_order_id = l_dk_order_id;
  l_order_add_count := sql%rowcount;

  if l_order_add_count = 0 then
    return pkg_error_code.data_error;
  end if;

  ---3.2删除历史库订单主表数据
  delete from dk_trade_order_main_hs t where t.dk_order_id = l_dk_order_id;
  l_order_del_count := sql%rowcount;

  if l_order_del_count != l_order_add_count then
    return pkg_error_code.data_error;
  end if;

  ---3.3下游资金变动数据
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee) ----添加手续费
    select record_id,
           dk_order_id,
           channel_no,
           account_id,
           trade_order_no,
           ext_order_no,
           order_source,
           create_time,
           order_time,
           change_type,
           change_amount,
           balance,
           memo,
           service_fee
      from dk_trade_down_fund_hs t
     where t.dk_order_id = l_dk_order_id;
  l_down_fund_add_count := sql%rowcount;

  ---3.4删除历史库下游资金变动数据
  delete from dk_trade_down_fund_hs t where t.dk_order_id = l_dk_order_id;
  l_down_fund_del_count := sql%rowcount;

  if l_down_fund_del_count != l_down_fund_add_count then
    return pkg_error_code.data_error;
  end if;

  ---3.5上游资金变动数据
  insert into dk_trade_up_fund
    (record_id,
     dk_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_batch_id,
     settle_status,
     settle_time,
     memo,
     order_time)
    select record_id,
           dk_order_id,
           trade_order_no,
           order_source,
           trade_delivery_no,
           down_channel_no,
           down_account_id,
           down_company_id,
           up_channel_no,
           up_account_id,
           up_company_id,
           down_draw_unit,
           down_draw_face,
           down_draw_amount,
           down_real_amount,
           up_draw_unit,
           up_draw_face,
           up_draw_amount,
           up_real_amount,
           change_time,
           change_type,
           bill_type,
           business_type,
           carrier_no,
           province_no,
           balance,
           profits,
           down_commission,
           up_commission,
           settle_amount,
           settle_batch_id,
           settle_status,
           settle_time,
           memo,
           order_time
      from dk_trade_up_fund_hs t
     where t.dk_order_id = l_dk_order_id;
  l_up_fund_add_count := sql%rowcount;

  ---3.6删除历史库上游资金变动数据
  delete from dk_trade_up_fund_hs t where t.dk_order_id = l_dk_order_id;
  l_up_fund_del_count := sql%rowcount;

  if l_up_fund_del_count != l_up_fund_add_count then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_TRADE_ORDER_EXIST_CHECK
prompt ==============================================
prompt
create or replace function fd_account.dk_f_trade_order_exist_check(v_order_source    number,
                                                        v_down_channel_no varchar2,
                                                        v_trade_order_no  varchar2,
                                                        v_fd_order_id     out number)
  return varchar2 is

  ----------------------------检查订单是否存在-----------------------------

begin
  ---1.检查订单是否存在
  select t.dk_order_id
    into v_fd_order_id
    from dk_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and rownum <= 1;

  return pkg_error_code.success;
exception
  when others then
    ---2.返回订单不存在
    return pkg_error_code.order_or_account_not_exists;
end;
/

prompt
prompt Creating function DK_F_TRADE_ORDER_CREATE
prompt =========================================
prompt
create or replace function fd_account.dk_f_trade_order_create(v_order_source        number,
                                                   v_down_channel_no     varchar2,
                                                   v_trade_order_no      varchar2,
                                                   v_ext_order_no        varchar2,
                                                   v_recharge_account_no varchar2,
                                                   v_business_type       number,
                                                   v_carrier_no          varchar2,
                                                   v_province_no         varchar2,
                                                   v_city_no             varchar2,
                                                   v_total_face          number,
                                                   v_deduct_unit         number,
                                                   v_settle_amount       number,
                                                   v_order_time          varchar2,
                                                   v_recharge_times      number)
  return varchar2 is

  l_result          varchar2(32);
  l_dk_order_id     number;
  l_down_account_id number;
  l_down_company_id number;
  ----------------------------检查并创建订单-----------------------------

begin
  ---1.检查订单是否存在
  l_result := dk_f_trade_order_exist_check(v_order_source,
                                           v_down_channel_no,
                                           v_trade_order_no,
                                           l_dk_order_id);

  if (l_result = pkg_error_code.success) then
    return pkg_error_code.success;
  end if;

  ---2.获取下游账户和公司
  select t.account_id, c.company_id
    into l_down_account_id, l_down_company_id
    from dk_base_down_account_map t
   inner join dk_base_down_account a on t.account_id = a.account_id
   inner join dk_base_down_channel c on t.channel_no = c.channel_no
   inner join dk_base_down_system_map s on t.channel_no = s.channel_no
   where t.channel_no = v_down_channel_no
     and s.source_system_id = v_order_source
        --  and a.status = 0
        --  and c.status = 0
     and rownum <= 2;

  ---3.添加订单
  select seq_trade_order_main_id.nextval into l_dk_order_id from dual;

  insert into dk_trade_order_main
    (dk_order_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     business_type,
     carrier_no,
     province_no,
     city_no,
     total_face,
     recharge_unit,
     recharge_account_no,
     down_order_amount,
     recharge_times)
  values
    (l_dk_order_id,
     v_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_trade_order_no,
     v_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_business_type,
     v_carrier_no,
     v_province_no,
     v_city_no,
     v_total_face,
     v_deduct_unit,
     v_recharge_account_no,
     v_settle_amount,
     v_recharge_times);

  return pkg_error_code.success;

EXCEPTION
  WHEN others THEN
    ---4.订单添加失败，检查是否并发添加
    l_result := dk_f_trade_order_exist_check(v_order_source,
                                             v_down_channel_no,
                                             v_trade_order_no,
                                             l_dk_order_id);
  
    if l_result != pkg_error_code.success then
      fd_p_write_log('dk_f_trade_order_create', sqlerrm);
      return pkg_error_code.order_insert_fail;
    end if;
  
    return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_TRADE_PAY_ACCOUNT_GET
prompt ============================================
prompt
create or replace function fd_account.dk_f_trade_pay_account_get(v_order_source  number,
                                                      v_up_channel_no varchar2,
                                                      v_up_account_id out number)
  return varchar2 is

  -----------------获取上游支付账户编号------------------
begin

  ---1.获取上游渠道唯一账户，当有多个账户时，请使用其它方式获取
  select t.account_id
    into v_up_account_id
    from dk_base_up_account_map t
   inner join dk_base_up_account a on t.account_id = a.account_id
   inner join dk_base_up_channel c on t.channel_no = c.channel_no
   inner join dk_base_up_system_map s on t.channel_no = s.channel_no
   where t.channel_no = v_up_channel_no
     and s.source_system_id = v_order_source
   --  and a.status = 0
   --  and c.status = 0
     and rownum <= 2;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function DK_F_TRADE_PAY_HS_MOVE
prompt ========================================
prompt
create or replace function fd_account.dk_f_trade_pay_hs_move(v_order_source    number,
                                                  v_down_channel_no varchar2,
                                                  v_trade_order_no  varchar2,
                                                  v_order_time      varchar2,
                                                  v_recharge_times  number,
                                                  v_settle_amount   number)
  return varchar2 is
  ---------------------支付扣款从历史库获取一个月前订单数据------------------
  l_end_time date := add_months(trunc(sysdate + 3, 'dd'), -1);
  l_result   varchar2(32) := pkg_error_code.success;
begin
  if to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss') < l_end_time then
    l_result := dk_f_trade_hs_move(v_order_source,
                                   v_down_channel_no,
                                   v_trade_order_no);
  
    if (l_result = pkg_error_code.order_not_exists) then
      return pkg_error_code.success;
    end if;
  end if;

  ---->>>>>>>>>>>>> 更新充值次数
  ---->>>>>>>>>>>>> yangdj 20161023
  if (l_result = pkg_error_code.success) then
    update dk_trade_order_main t
       set t.recharge_times    = v_recharge_times,
           t.down_order_amount = v_settle_amount
     where t.order_source = v_order_source
       and t.down_channel_no = v_down_channel_no
       and t.trade_order_no = v_trade_order_no
       and rownum <= 1;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function DK_F_TRADE_UP_ORDER_MINUS
prompt ===========================================
prompt
create or replace function fd_account.dk_f_trade_up_order_minus(v_order_source      number,
                                                     v_trade_order_no    varchar2,
                                                     v_trade_delivery_no varchar2,
                                                     v_up_channel_no     varchar2,
                                                     v_up_account_id     number,
                                                     v_up_draw_unit      number,
                                                     v_up_draw_face      number,
                                                     v_up_draw_amount    number,
                                                     v_up_real_amount    number,
                                                     v_down_draw_unit    number,
                                                     v_down_draw_face    number,
                                                     v_down_draw_amount  number,
                                                     v_down_real_amount  number,
                                                     v_bill_type         number,
                                                     v_order_time        varchar2,
                                                     v_up_service_fee    number,
                                                     v_memo              varchar2)
  return varchar2 is
  l_down_order_all_unit number;
  l_down_order_all_face number;
  l_down_debit_now_unit number;
  l_down_debit_now_face number;
  l_down_draw_unit      number;
  l_down_draw_face      number;
  l_down_draw_amount    number;
  l_down_real_amount    number;

  l_up_company_id   number;
  l_down_channel_no varchar2(32);
  l_down_company_id number;
  l_inner_balance   number;
  l_query_balance   number;
  l_dk_order_id     number;
  l_pay_count       number;
  l_settle_status   number;
  l_down_account_id number;
  l_business_type   number;
  l_carrier_no      varchar2(32);
  l_province_no     varchar2(32);
  l_city_no         varchar2(32);

  l_profits          number;
  l_down_commission  number;
  l_up_commission    number;
  l_refund_face      number;
  l_refund_unit      number;
  l_order_all_amount number;
  l_order_all_unit   number;
  l_order_all_face   number;
  l_result           varchar2(32);
  l_recharge_times   number;
  -------------------上游减款----------------------
begin

  --===============================检查订单支付情况==================================
  ---1.锁支付订单
  select t.dk_order_id,
         t.down_channel_no,
         t.down_account_id,
         t.down_company_id,
         t.recharge_unit,
         t.total_face,
         t.business_type,
         t.carrier_no,
         t.province_no,
         t.city_no,
         t.down_order_amount
    into l_dk_order_id,
         l_down_channel_no,
         l_down_account_id,
         l_down_company_id,
         l_order_all_unit,
         l_order_all_face,
         l_business_type,
         l_carrier_no,
         l_province_no,
         l_city_no,
         l_order_all_amount
    from dk_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查订单是否已支付
  select count(1)
    into l_pay_count
    from dk_trade_up_fund t
   where t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount;

  if (l_pay_count > 0) then
    return pkg_error_code.success;
  end if;

  ---3.计算下游规格、订单金额
  select nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_unit),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_face),
             0)
    into l_down_debit_now_unit, l_down_debit_now_face
    from dk_trade_up_fund t
   where t.dk_order_id = l_dk_order_id
     and t.change_type in (pkg_up_fund_change_type.debit_amount,
          pkg_up_fund_change_type.refund_amount);

  ---4.计算出下游退款金额
  select nvl(sum(t.refund_face), 0), nvl(sum(t.refund_unit), 0)
    into l_refund_face, l_refund_unit
    from dk_trade_down_refund t
   where t.dk_order_id = l_dk_order_id;

  ---5.计算扣款金额
  l_down_draw_unit   := v_down_draw_unit;
  l_down_draw_face   := v_down_draw_face;
  l_down_draw_amount := v_down_draw_amount;
  l_down_real_amount := v_down_real_amount;

  --===================================获取公司结算信息=================================

  ---4. 是否需要结算给公司
  select t.company_id
    into l_up_company_id
    from dk_base_up_channel t
   where t.channel_no = v_up_channel_no;

  l_settle_status := pkg_settle_status.no_need;
  if (l_up_company_id != l_down_company_id) then
    l_settle_status := pkg_settle_status.wait_settle;
  end if;

  --======================================上游减款=====================================

  ---5.1获取并修改账户余额
  select t.query_balance, t.inner_balance
    into l_query_balance, l_inner_balance
    from dk_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  update dk_base_up_account t
     set t.inner_balance = (l_inner_balance - v_up_draw_amount)
   where t.account_id = v_up_account_id;

  l_profits         := v_up_real_amount - l_down_real_amount; --->>>>>>>>>>>>>>>>>> 利润需要反过来减
  l_down_commission := 0; --->>>>>>>>>>> 暂不考虑佣金
  l_up_commission   := 0; --->>>>>>>>>>> 暂不考虑佣金

  ---6.添加上游资金变动
  insert into dk_trade_up_fund
    (record_id,
     dk_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     order_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     memo)
  values
    (seq_trade_up_fund_id.nextval,
     l_dk_order_id,
     v_trade_order_no,
     v_order_source,
     v_trade_delivery_no,
     l_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_up_channel_no,
     v_up_account_id,
     l_up_company_id,
     l_down_draw_unit,
     l_down_draw_face,
     l_down_draw_amount,
     l_down_real_amount,
     v_up_draw_unit,
     v_up_draw_face,
     v_up_draw_amount,
     v_up_real_amount,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     l_business_type,
     l_carrier_no,
     l_province_no,
     (l_inner_balance - v_up_draw_amount),
     l_profits,
     l_down_commission,
     l_up_commission,
     0,
     l_settle_status,
     v_memo);

  ---7.添加订单差异表数据
  l_result := dk_f_trade_fund_differ_add(l_dk_order_id,
                                         pkg_trade_type.up_debit,
                                         l_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         v_bill_type,
                                         l_order_all_face,
                                         l_order_all_amount,
                                         l_down_draw_face,
                                         l_down_draw_amount,
                                         v_up_draw_face);

  return l_result;
end;
/

prompt
prompt Creating function DK_F_TRADE_UP_ORDER_REFUND
prompt ============================================
prompt
create or replace function fd_account.dk_f_trade_up_order_refund(v_order_source            number,
                                                      v_down_channel_no         varchar2,
                                                      v_up_channel_no           varchar2,
                                                      v_trade_order_no          varchar2,
                                                      v_trade_delivery_no       varchar2,
                                                      v_trade_refund_no         varchar2,
                                                      v_bill_type               number,
                                                      v_business_type           number,
                                                      v_carrier_no              varchar2,
                                                      v_province_no             varchar2,
                                                      v_up_refund_unit          number,
                                                      v_up_refund_face          number,
                                                      v_up_refund_amount        number,
                                                      v_up_refund_real_amount   number,
                                                      v_order_time              varchar2,
                                                      v_service_fee             number,
                                                      v_memo                    varchar2,
                                                      v_down_refund_unit        in number, -- 下游退款总规格
                                                      v_down_refund_face        in number, -- 下游退款总面值
                                                      v_down_refund_amount      in number, -- 下游退款金额
                                                      v_down_refund_real_amount in number -- 下游实际退款金额
                                                      ) return varchar2 is

  ------------上游订单退款------------
  l_dk_order_id      number;
  l_refund_count     number;
  l_up_company_id    number;
  l_settle_amount    number;
  l_settle_status    number;
  l_query_balance    number;
  l_inner_balance    number;
  l_down_account_id  number;
  l_down_company_id  number;
  l_total_pay        number;
  l_total_refund     number;
  l_up_account_id    number;
  l_up_fund_id       number;
  l_down_refund_face number;
  l_up_refund_face   number;
  l_up_draw_face     number;
  l_order_face       number;
  l_face_differ      number;
  l_up_down_face     number;
  l_up_down_unit     number;
  l_up_down_amount   number;
  l_up_down_real     number;

  l_up_all_down_face   number;
  l_up_all_down_unit   number;
  l_up_all_down_amount number;
  l_up_all_down_real   number;

  l_order_amount  number;
  l_up_all_face   number;
  l_debit_count   number;
  l_business_type number;
  l_result        varchar2(32);
begin
  --=============================检查订单重复退款、金额错误==============================
  ---1.锁下游订单
  select t.dk_order_id,
         t.down_account_id,
         t.down_company_id,
         t.total_face,
         t.down_order_amount,
         t.business_type
    into l_dk_order_id,
         l_down_account_id,
         l_down_company_id,
         l_order_face,
         l_order_amount,
         l_business_type
    from dk_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查重复退款
  select count(1)
    into l_refund_count
    from dk_trade_up_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = v_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  ---2.1检查退款时是否有扣款
  select count(1)
    into l_debit_count
    from dk_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---3.获取上游支付扣款、已退款金额
  select t.up_draw_amount,
         t.up_account_id,
         t.settle_amount,
         t.up_company_id,
         t.up_draw_face
    into l_total_pay,
         l_up_account_id,
         l_settle_amount,
         l_up_company_id,
         l_up_draw_face
    from dk_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  select nvl(sum(t.up_draw_amount), 0), nvl(sum(t.up_draw_face), 0)
    into l_total_refund, l_up_refund_face
    from dk_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.refund_amount;

  ---4.检查退款金额是否超过上游总代扣面值
  ---- 是总面值：yangdejian 20161019
  if (v_up_refund_amount > (l_up_draw_face - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;
  if (v_down_refund_amount > v_down_refund_face) then
    return pkg_error_code.amount_error;
  end if;

  ---5.计算上游资金变动的下游信息
  select nvl(sum(t.refund_face), 0)
    into l_down_refund_face
    from dk_trade_down_refund t
   where t.dk_order_id = l_dk_order_id;

  l_up_down_face   := v_down_refund_face;
  l_up_down_unit   := v_down_refund_unit;
  l_up_down_amount := v_down_refund_amount;
  l_up_down_real   := v_down_refund_real_amount;

  --=============================获取退款结算信息=================================
  ---5.获取公司结算状态
  l_settle_status := pkg_settle_status.no_need;
  if (l_up_company_id != l_down_company_id) then
    l_settle_status := pkg_settle_status.wait_settle;
  end if;

  --==================================上游退款===================================
  ---6.获取并修改账户余额
  select t.query_balance, t.inner_balance
    into l_query_balance, l_inner_balance
    from dk_base_up_account t
   where t.account_id = l_up_account_id
     for update;

  update dk_base_up_account t
     set t.inner_balance = (l_inner_balance + v_up_refund_amount)
   where t.account_id = l_up_account_id;

  ---7.添加上游退款记录
  select seq_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into dk_trade_up_refund
    (record_id,
     channel_no,
     account_id,
     dk_order_id,
     trade_order_no,
     trade_delivery_no,
     trade_refund_no,
     order_source,
     refund_time,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund,
     memo)
  values
    (l_up_fund_id,
     v_up_channel_no,
     l_up_account_id,
     l_dk_order_id,
     v_trade_order_no,
     v_trade_delivery_no,
     v_trade_refund_no,
     v_order_source,
     sysdate,
     v_bill_type,
     v_business_type,
     v_carrier_no,
     v_province_no,
     v_up_refund_unit,
     v_up_refund_face,
     v_up_refund_amount,
     v_up_refund_real_amount,
     v_memo);

  ---8.添加上游资金变动
  insert into dk_trade_up_fund
    (record_id,
     dk_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount, ---- 14
     down_real_amount, --- 15
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     order_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     memo)
    select l_up_fund_id,
           l_dk_order_id,
           v_trade_order_no,
           v_order_source,
           v_trade_delivery_no,
           v_down_channel_no,
           l_down_account_id,
           l_down_company_id,
           v_up_channel_no,
           l_up_account_id,
           l_up_company_id,
           l_up_down_unit,
           l_up_down_face,
           l_up_down_amount, -- 14
           l_up_down_real, -- 15
           v_up_refund_unit,
           v_up_refund_face,
           v_up_refund_amount,
           v_up_refund_real_amount,
           sysdate,
           to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
           pkg_up_fund_change_type.refund_amount,
           v_bill_type,
           v_business_type,
           v_carrier_no,
           v_province_no,
           (l_inner_balance + v_up_refund_amount),
           t.profits,
           t.down_commission,
           (v_up_refund_amount - v_up_refund_real_amount),
           l_settle_amount,
           l_settle_status,
           v_memo
      from dk_trade_up_fund t
     where t.dk_order_id = l_dk_order_id
       and t.trade_delivery_no = v_trade_delivery_no
       and t.change_type = pkg_up_fund_change_type.debit_amount
       and rownum <= 1;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---9.记录差异信息
  l_result := dk_f_trade_fund_differ_add(l_dk_order_id,
                                         pkg_trade_type.up_refund,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         v_bill_type,
                                         l_order_face,
                                         l_order_amount,
                                         l_up_down_face,
                                         l_up_down_amount,
                                         v_up_refund_face);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_ACTIVITY_DETAILS_ADD
prompt ===========================================
prompt
create or replace function fd_account.fd_f_activity_details_add(v_activity_id          number,
                                                     v_trade_record_no      varchar2,
                                                     v_activity_change_type number,
                                                     v_fd_business_type     number,
                                                     v_bill_type            number,
                                                     v_details_amount       number,
                                                     v_handle_user          varchar2,
                                                     v_memo                 varchar2)
  return varchar2 is
  ----------------添加活动明细记录----------------
  l_activity_name varchar2(64);
  l_details_count number;
begin

  ---1.锁活动主信息记录
  select t.activity_name
    into l_activity_name
    from fd_trade_activity_main t
   where t.id = v_activity_id
     for update;

  ---2.检查活动详情记录是否已添加
  select count(1)
    into l_details_count
    from fd_trade_activity_details t
   where t.trade_record_no = v_trade_record_no
     and t.activity_id = v_activity_id
     and rownum <= 1;

  if l_details_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  ---3.修改主记录会龙资金信息
  update fd_trade_activity_main t
     set t.activity_return_amount = (t.activity_return_amount +
                                    decode(v_activity_change_type,
                                            pkg_activity_change_type.prepay,
                                            0,
                                            pkg_activity_change_type.minus_profit,
                                            v_details_amount,
                                            -1 * v_details_amount))
   where t.id = v_activity_id;

  ---4.添加活动详情记录
  insert into fd_trade_activity_details
    (id,
     activity_id,
     trade_record_no,
     business_type,
     bill_type,
     change_type,
     change_amount,
     change_time,
     change_user,
     memo)
  values
    (seq_trade_activity_details_id.nextval,
     v_activity_id,
     v_trade_record_no,
     v_fd_business_type,
     v_bill_type,
     v_activity_change_type,
     v_details_amount,
     sysdate,
     v_handle_user,
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ACTIVITY_DOWN_RV_TRADE
prompt =============================================
prompt
create or replace function fd_account.fd_f_activity_down_rv_trade(v_order_source     number,
                                                       v_down_channel_no  varchar2,
                                                       v_down_account_id  number,
                                                       v_down_company_id  number,
                                                       v_trade_record_no  varchar2,
                                                       v_down_draw_amount number,
                                                       v_down_real_amount number,
                                                       v_fd_business_type number,
                                                       v_bill_type        number,
                                                       v_create_user      varchar2,
                                                       v_memo             varchar2)
  return varchar2 is
  l_trade_fund_id    number;
  l_inner_balance    number;
  l_trade_up_fund_id number;

  --------------------下游渠道交易平账-----------------------
begin
  ---1.锁下游支付账户
  select t.inner_balance,
         seq_trade_down_fund_id.nextval,
         seq_trade_up_fund_id.nextval
    into l_inner_balance, l_trade_fund_id, l_trade_up_fund_id
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.修改账户余额
  update fd_base_down_account t
     set t.inner_balance = (l_inner_balance - v_down_draw_amount)
   where t.account_id = v_down_account_id;

  ---3.添加平账对应的下游手工记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo,
     ext_record_no,
     real_amount)
  values
    (l_trade_fund_id,
     v_down_channel_no,
     v_down_account_id,
     0,
     0,
     pkg_down_manual_change_type.trade_revise,
     v_down_draw_amount,
     sysdate,
     (l_inner_balance - v_down_draw_amount),
     v_create_user,
     nvl2(v_memo, v_memo || ',下游交易平账', '下游交易平账'),
     v_trade_record_no,
     v_down_real_amount);

  ---4.添加平账对应的下游资金变动添加(通过trade_order_no关联上游资金变动)
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_trade_fund_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     v_trade_record_no,
     v_order_source,
     sysdate,
     sysdate,
     pkg_down_fund_change_type.debit_amount,
     v_down_draw_amount,
     (l_inner_balance - v_down_draw_amount),
     v_memo);

  ---5.为了计算佣金利润，添加下游对应的上游资金变动（上游下游公司相同避免结算)
  insert into fd_trade_up_fund
    (record_id,
     trade_order_no,
     order_source,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     balance,
     memo)
  values
    (l_trade_up_fund_id,
     v_trade_record_no,
     v_order_source,
     v_down_channel_no,
     v_down_account_id,
     v_down_company_id,
     0,
     0,
     v_down_company_id,
     0,
     0,
     v_down_draw_amount,
     v_down_real_amount,
     0,
     0,
     sysdate,
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     v_fd_business_type,
     0,
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ACTIVITY_INFO_CHECK
prompt ==========================================
prompt
create or replace function fd_account.fd_f_activity_info_check(v_activity_id     number,
                                                    v_trade_record_no varchar2,
                                                    v_prepay_amount   number,
                                                    v_down_channel_no out varchar2,
                                                    v_down_account_id out number,
                                                    v_down_company_id out number)
  return varchar2 is
  ---------------检查活动信息--------------
  l_count         number;
  l_activity_name varchar2(32);
begin
  ---1.检查活动预付金额
  if v_prepay_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查预付是否存在
  select count(1)
    into l_count
    from fd_trade_activity_details t
   where t.trade_record_no = v_trade_record_no
     and t.activity_id = v_activity_id
     and rownum <= 1;

  if l_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  ---3.检查预付对应的活动是否存在，活动配置的渠道账户是否可用
  select t.activity_name, t.channel_no, t.channel_account_id, c.company_id
    into l_activity_name,
         v_down_channel_no,
         v_down_account_id,
         v_down_company_id
    from fd_trade_activity_main t
   inner join fd_base_down_account_map m on t.channel_no = m.channel_no
                                        and t.channel_account_id =
                                            m.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   inner join fd_base_down_account a on t.channel_account_id = a.account_id
   where t.id = v_activity_id
     and t.has_closed = pkg_sys_boolean.isfalse;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_not_exists;
end;
/

prompt
prompt Creating function FD_F_ADJUST_CAPITAL_CHECK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_adjust_capital_check(v_record_id      number,
                                                     v_adjust_days    number,
                                                     v_bank_record_id out number)
  return varchar2 is
  ------------------检查记录数据及实体卡余额-------------------
  l_capital_account_id number;
  l_bank_account_id    number;
  l_bank_balance       number;
  l_change_time        date;
  l_bank_batch_id      number;
  l_cap_account_type   number;
  l_bank_use_type      number;
begin
  ---1.检查资产账户记录及数据
  select t.account_id, t.change_time, t.bank_batch_id, c.account_type
    into l_capital_account_id,
         l_change_time,
         l_bank_batch_id,
         l_cap_account_type
    from fd_trade_co_cap_fund t
   inner join fd_base_company_account_cap c on t.account_id = c.account_id
   where t.change_id = v_record_id
     and c.account_type in
         (pkg_co_cap_account_type.borrow, pkg_co_cap_account_type.deposit,
          pkg_co_cap_account_type.bond, pkg_co_cap_account_type.prepayment,
          pkg_co_cap_account_type.short_borrow,
          pkg_co_cap_account_type.personal_borrow,
          pkg_co_cap_account_type.transfer_refund,
          pkg_co_cap_account_type.manual_refund)
     and c.status = 0;

  ---2.检查变动时间
  if trunc(l_change_time, 'dd') < trunc((sysdate - v_adjust_days), 'dd') then
    return pkg_error_code.adjust_timeout;
  end if;

  ---3.获取实体卡使用类型
  if l_cap_account_type = pkg_co_cap_account_type.borrow then
    l_bank_use_type := pkg_bank_use_type.borrow;
  elsif l_cap_account_type = pkg_co_cap_account_type.deposit then
    l_bank_use_type := pkg_bank_use_type.deposit;
  elsif l_cap_account_type = pkg_co_cap_account_type.bond then
    l_bank_use_type := pkg_bank_use_type.bond;
  elsif l_cap_account_type = pkg_co_cap_account_type.prepayment then
    l_bank_use_type := pkg_bank_use_type.prepayment;
  elsif l_cap_account_type = pkg_co_cap_account_type.short_borrow then
    l_bank_use_type := pkg_bank_use_type.short_borrow;
  elsif l_cap_account_type = pkg_co_cap_account_type.personal_borrow then
    l_bank_use_type := pkg_bank_use_type.personal_borrow;
  elsif l_cap_account_type = pkg_co_cap_account_type.transfer_refund then
    l_bank_use_type := pkg_bank_use_type.transfer_refund;
  else
    l_bank_use_type := pkg_bank_use_type.manual_refund;
  end if;

  ---4.检查实体卡相关数据
  select t.account_id, t.record_id
    into l_bank_account_id, v_bank_record_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.use_type = l_bank_use_type
     and rownum <= 1;

  ---5.获取银行卡账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_ADJUST_CAPITAL_RECORD
prompt ============================================
prompt
create or replace function fd_account.fd_f_adjust_capital_record(v_record_id      number,
                                                      v_bank_record_id number,
                                                      v_hander_user    varchar2,
                                                      v_memo           varchar2)
  return varchar2 is
  ------------------红冲 借支、押金、保证金相关记录-----------------
  l_capital_account_id     number;
  l_bank_account_id        number;
  l_capital_balance        number;
  l_bank_balance           number;
  l_cap_change_type        number;
  l_adjust_cap_balance     number;
  l_adjust_bank_balance    number;
  l_change_amount          number;
  l_bank_amount            number;
  l_service_count          number;
  l_service_fee            number;
  l_adjust_service_balance number;
  l_bank_service_id        number;
  l_service_record         number;
begin
  ---1.获取资产账户变动信息
  select t.account_id, t.change_type, t.change_amount
    into l_capital_account_id, l_cap_change_type, l_change_amount
    from fd_trade_co_cap_fund t
   where t.change_id = v_record_id;

  ---2.获取银行卡变动信息
  select t.account_id, t.service_id, t.change_amount
    into l_bank_account_id, l_bank_service_id, l_bank_amount
    from fd_bank_cash_fund t
   where t.record_id = v_bank_record_id;

  if l_change_amount != l_bank_amount then
    return pkg_error_code.change_amount_error;
  end if;

  ---3.获取银行卡手续费记录信息
  select count(1), nvl(max(t.change_amount), 0), max(t.record_id)
    into l_service_count, l_service_fee, l_service_record
    from fd_bank_cash_fund t
   where t.service_id = l_bank_service_id
     and t.use_type = pkg_bank_use_type.service_fee;

  ---4.锁资产账户
  select t.balance
    into l_capital_balance
    from fd_base_company_account_cap t
   where t.account_id = l_capital_account_id
     for update;

  ---5.锁银行卡账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;

  ---6.计算红冲相关参数
  if l_cap_change_type = pkg_co_cap_fund_type.add_amount then
    l_adjust_cap_balance     := l_capital_balance - l_change_amount;
    l_adjust_service_balance := l_bank_balance + l_service_fee;
    l_adjust_bank_balance    := l_adjust_service_balance + l_change_amount;
  else
    l_adjust_cap_balance     := l_capital_balance + l_change_amount;
    l_adjust_service_balance := l_bank_balance + l_service_fee;
    l_adjust_bank_balance    := l_adjust_service_balance - l_change_amount;
  end if;

  ---7.更新资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = l_adjust_cap_balance,
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = l_capital_account_id;

  ---8.添加资产账户红冲变动记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     memo)
    select seq_trade_co_cap_fund_id.nextval,
           t.account_id,
           (0 - t.change_amount),
           t.change_type,
           l_adjust_cap_balance,
           sysdate,
           t.change_id,
           pkg_sys_boolean.istrue,
           v_memo
      from fd_trade_co_cap_fund t
     where t.change_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  update fd_trade_co_cap_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.change_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---9.更新银行卡账户余额
  update fd_bank_account_info t
     set t.balance        = l_adjust_bank_balance,
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = l_bank_account_id;

  ---10.添加红冲银行卡手续费的记录
  if l_service_count > 0 then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,remark_name)
      select seq_bank_cash_fund_id.nextval,
             l_bank_account_id,
             t.record_id,
             t.company_id,
             (0 - t.change_amount),
             l_adjust_service_balance,
             sysdate,
             v_hander_user,
             t.change_type,
             t.use_type,
             pkg_sys_boolean.istrue,
             t.link_channel_name,
             t.link_account_name,
             v_memo,
             t.remark_name
        from fd_bank_cash_fund t
       where t.record_id = l_service_record;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  
    update fd_bank_cash_fund t
       set t.has_adjust = pkg_sys_boolean.istrue
     where t.record_id = l_service_record
       and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  end if;

  ---11.添加红冲银行卡变动记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,remark_name)
    select seq_bank_cash_fund_id.nextval,
           l_bank_account_id,
           t.record_id,
           t.company_id,
           (0 - t.change_amount),
           l_adjust_bank_balance,
           sysdate,
           v_hander_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           t.remark_name
      from fd_bank_cash_fund t
     where t.record_id = v_bank_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_bank_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_COMMISION_SETTLE
prompt ==============================================
prompt
create or replace function fd_account.fd_f_adjust_commision_settle(v_record_id   in number, ---红冲的结算编号
                                                        v_create_user in varchar2, ---操作人
                                                        v_memo        in varchar2 ---备注
                                                        ) return varchar2 is
  ---------------------------------
  --功能：佣金结算红冲
  --创建人：周荣省
  --创建时间：2019-08-21
  ---------------------------------
  l_bank_account_id number; --银行卡号
  l_channel_type    number; --渠道类型
  l_commission      number; --结算金额
  l_channel_no      varchar2(32); --渠道编号
  l_old_bank_batch_id number;

  l_bank_balance     number;
  l_bank_end_balance number;
  l_bank_change_type number;
  l_bank_use_type    number;
  l_bank_batch_id    number;
  l_company_id       number;
  l_channel_name     varchar2(100);
  l_commi_balance    number;
  l_remark_name      varchar2(100);
begin

  select b.account_id, t.channel_type, t.commission, t.channel_no,t.bank_batch_id,b.remark_name
    into l_bank_account_id, l_channel_type, l_commission, l_channel_no,l_old_bank_batch_id,l_remark_name
    from fd_trade_commission_settle t
   inner join fd_bank_cash_fund b on t.bank_batch_id = b.service_id
   where t.report_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse
     and b.has_adjust = pkg_sys_boolean.isfalse
     and t.commission = b.change_amount
     and t.settle_type = pkg_commi_settle_type.settle
     and (b.use_type = pkg_bank_use_type.down_commission or
         b.use_type = pkg_bank_use_type.up_commission);

  ---1.锁银行卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_company_id
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;

  ---2.修改银行卡余额
  if l_channel_type = pkg_channel_type.down_channel then
    l_bank_end_balance := l_bank_balance + l_commission;
    l_bank_change_type := pkg_bank_fund_change_type.add_amount;
    l_bank_use_type    := pkg_bank_use_type.down_commission;
  
    select t.channel_name
      into l_channel_name
      from fd_base_down_channel t
     where t.channel_no = l_channel_no;
  else
    l_bank_end_balance := l_bank_balance - l_commission;
    l_bank_change_type := pkg_bank_fund_change_type.minus_amount;
    l_bank_use_type    := pkg_bank_use_type.up_commission;
  
    select t.channel_name
      into l_channel_name
      from fd_base_up_channel t
     where t.channel_no = l_channel_no;
  end if;

  update fd_bank_account_info t
     set t.balance        = l_bank_end_balance,
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_bank_account_id;

  ---3.添加银行卡流水
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     l_bank_account_id,
     v_record_id,
     l_company_id,
     l_commission,
     l_bank_end_balance,
     sysdate,
     v_create_user,
     l_bank_change_type,
     l_bank_use_type,
     pkg_sys_boolean.istrue,
     l_channel_name,
     '-',
     v_memo,
     l_bank_batch_id,l_remark_name);

  if l_channel_type = pkg_channel_type.down_channel then
    ---4.下游渠道扣佣金
    select t.commi_balance
      into l_commi_balance
      from fd_base_down_channel t
     where t.channel_no = l_channel_no
       for update;
  
    update fd_base_down_channel t
       set t.commi_balance  = (l_commi_balance + l_commission),
           t.last_edit_user = v_create_user,
           t.last_edit_time = sysdate
     where t.channel_no = l_channel_no;
  else
    ---5.上游渠道扣佣金
    select t.commi_balance
      into l_commi_balance
      from fd_base_up_channel t
     where t.channel_no = l_channel_no
       for update;
  
    update fd_base_up_channel t
       set t.commi_balance  = (l_commi_balance + l_commission),
           t.last_edit_user = v_create_user,
           t.last_edit_time = sysdate
     where t.channel_no = l_channel_no;
  
  end if;

  ---6.添加佣金结算记录
  insert into fd_trade_commission_settle
    (report_id,
     channel_no,
     channel_type,
     commission,
     settle_month,
     settle_status,
     settle_user,
     settle_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     settle_type,
     commi_balance)
  values
    (seq_trade_commission_settle_id.nextval,
     l_channel_no,
     l_channel_type,
     l_commission,
     to_date(to_char(sysdate,'yyyymmdd'), 'yyyymmddhh24miss'),
     pkg_sys_boolean.istrue,
     v_create_user,
     sysdate,
     pkg_sys_boolean.istrue,
     v_record_id,
     l_bank_batch_id,
     pkg_commi_settle_type.settle,
     (l_commi_balance + l_commission));
  --7、修改状态
  update fd_trade_commission_settle t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.report_id = v_record_id;
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.service_id = l_old_bank_batch_id
     and (t.use_type = pkg_bank_use_type.down_commission or
         t.use_type = pkg_bank_use_type.up_commission);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_CO_SETTLE_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_adjust_co_settle_check(v_co_settle_fund_id number,
                                                       v_adjust_days       number)
  return varchar2 is
  --------------------检查记录及相关账户余额------------------
  l_change_time   date;
  l_bank_batch_id number;
  l_bank_count    number;
begin
  ---1.检查变动记录是否为公司间结算加款
  select t.change_time, t.bank_batch_id
    into l_change_time, l_bank_batch_id
    from fd_trade_co_recv_fund t
   where t.change_id = v_co_settle_fund_id
     and t.change_type = pkg_co_fund_recv_type.minus_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and rownum <= 1;

  if l_change_time < (sysdate - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  ---2.检查银行卡变动记录
  select count(1)
    into l_bank_count
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id;

  if l_bank_count != 2 and l_bank_count != 3 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_ADJUST_CO_SETTLE_RECORD
prompt ==============================================
prompt
create or replace function fd_account.fd_f_adjust_co_settle_record(v_co_settle_fund_id number,
                                                        v_adjust_user       varchar2,
                                                        v_memo              varchar2)
  return varchar2 is
  -------------------红冲公司间结算记录------------------
  l_co_account_id        number;
  l_bank_batch_id        number;
  l_change_amount        number;
  l_from_bank_account_id number;
  l_to_bank_account_id   number;
  l_co_balance           number;
  l_from_bank_balance    number;
  l_to_bank_balance      number;
  l_bank_from_amount     number;
  l_bank_to_amount       number;
  l_from_record_id       number;
  l_to_record_id         number;
  l_service_record_id    number;
  l_service_fee          number;
  l_handle_batch_id      number;
  l_change_time          date;
begin
  --===================获取原记录信息=====================
  ---1.获取公司结算信息
  select t.account_id, t.bank_batch_id, t.change_amount, t.change_time
    into l_co_account_id, l_bank_batch_id, l_change_amount, l_change_time
    from fd_trade_co_recv_fund t
   where t.change_id = v_co_settle_fund_id;

  ---2.获取银行卡手续费记录信息
  select max(t.record_id), nvl(max(t.change_amount), 0)
    into l_service_record_id, l_service_fee
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.use_type = pkg_bank_use_type.service_fee
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_time > l_change_time - 1 / 24 / 60
     and t.change_time < l_change_time + 1 / 24 / 60
     and rownum <= 1;

  ---3.获取银行卡出账记录信息
  select t.record_id, t.account_id, t.change_amount
    into l_from_record_id, l_from_bank_account_id, l_bank_from_amount
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.use_type = pkg_bank_use_type.up_add
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_time > l_change_time - 1 / 24 / 60
     and t.change_time < l_change_time + 1 / 24 / 60
     and rownum <= 1;

  ---4.获取银行卡入账记录信息
  select t.record_id, t.account_id, t.change_amount
    into l_to_record_id, l_to_bank_account_id, l_bank_to_amount
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.change_type = pkg_bank_fund_change_type.add_amount
     and t.use_type = pkg_bank_use_type.down_add
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_time > l_change_time - 1 / 24 / 60
     and t.change_time < l_change_time + 1 / 24 / 60
     and rownum <= 1;

  if (l_change_amount != l_bank_from_amount or
     l_bank_from_amount != l_bank_to_amount) then
  
    return pkg_error_code.change_amount_error;
  end if;

  --=====================锁相关账户账号=======================
  ---1.锁公司结算账户
  select t.balance
    into l_co_balance
    from fd_base_company_account_recv t
   where t.account_id = l_co_account_id
     for update;

  ---2.锁出账实体卡账号
  select t.balance
    into l_from_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_from_bank_account_id
     for update;

  ---3.锁入账实体卡账号
  select t.balance
    into l_to_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_to_bank_account_id
     for update;

  --===================添加相关红冲记录=======================
  ---1.获取红冲统一的批次流水号---标记同一操作的不同银行卡变动记录
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  ---2.修改公司间结算账户
  update fd_base_company_account_recv t
     set t.balance          = (l_co_balance + l_change_amount),
         t.last_update_time = sysdate,
         t.last_update_user = v_adjust_user
   where t.account_id = l_co_account_id;

  ---3.添加公司间结算记录红冲
  insert into fd_trade_co_recv_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     handle_user,
     remark)
    select seq_trade_co_recv_fund_id.nextval,
           t.account_id,
           (0 - t.change_amount),
           t.change_type,
           (l_co_balance + l_change_amount),
           sysdate,
           pkg_sys_boolean.istrue,
           t.change_id,
           l_handle_batch_id,
           v_adjust_user,
           v_memo
      from fd_trade_co_recv_fund t
     where t.change_id = v_co_settle_fund_id;

  update fd_trade_co_recv_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.change_id = v_co_settle_fund_id;

  ---4.修改实体卡出账账户
  update fd_bank_account_info t
     set t.balance        = (l_from_bank_balance + l_change_amount +
                            l_service_fee),
         t.last_edit_user = v_adjust_user,
         t.last_edit_time = sysdate
   where t.account_id = l_from_bank_account_id;

  ---5.添加手续费红冲记录
  if l_service_fee > 0 then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
      select seq_bank_cash_fund_id.nextval,
             t.account_id,
             t.record_id,
             t.company_id,
             (0 - t.change_amount),
             (l_from_bank_balance + l_service_fee),
             v_adjust_user,
             t.change_type,
             t.use_type,
             pkg_sys_boolean.istrue,
             t.link_channel_name,
             t.link_account_name,
             v_memo,
             l_handle_batch_id,
             t.remark_name
        from fd_bank_cash_fund t
       where t.record_id = l_service_record_id;
  
    update fd_bank_cash_fund t
       set t.has_adjust = pkg_sys_boolean.istrue
     where t.record_id = l_service_record_id;
  end if;

  ---6.添加银行卡出账红冲
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0 - t.change_amount),
           (l_from_bank_balance + l_change_amount + l_service_fee),
           v_adjust_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id
      from fd_bank_cash_fund t
     where t.record_id = l_from_record_id;

  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_from_record_id;

  ---7.修改实体卡入账账户
  update fd_bank_account_info t
     set t.balance        = (l_to_bank_balance - l_change_amount),
         t.last_edit_user = v_adjust_user,
         t.last_edit_time = sysdate
   where t.account_id = l_to_bank_account_id;

  ---8.添加银行卡入账红冲
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0 - t.change_amount),
           (l_to_bank_balance - l_change_amount),
           v_adjust_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id
      from fd_bank_cash_fund t
     where t.record_id = l_to_record_id;

  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_to_record_id;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_DOWN_ADD_CHECK
prompt ============================================
prompt
create or replace function fd_account.fd_f_adjust_down_add_check(v_record_id   number,
                                                      v_adjust_days number)
  return varchar2 is
  -------------检查加款记录、账户、余额、手续费--------------
  l_record_count number;
  l_change_time  date;
begin
  ---1. 检查加款记录、账户及余额
  select count(1), max(t.change_time)
    into l_record_count, l_change_time
    from fd_trade_down_manual t
   inner join fd_base_down_account f on t.account_id = f.account_id
   inner join fd_bank_cash_fund b on t.bank_fund_id = b.service_id
   inner join fd_bank_account_info a on b.account_id = a.account_id
   where t.record_id = v_record_id
     and t.add_type = pkg_down_manual_change_type.add_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and b.has_adjust = pkg_sys_boolean.isfalse
     and t.change_amount = b.change_amount;

  if (l_record_count != 1 and l_record_count != 2) then
    return pkg_error_code.data_error;
  end if;

  if l_change_time<(trunc(sysdate) - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_DOWN_ADD_HANDLE
prompt =============================================
prompt
create or replace function fd_account.fd_f_adjust_down_add_handle(v_record_id   number,
                                                       v_create_user varchar2,
                                                       v_memo        varchar2)
  return varchar2 is
  -------------下游手工加款红冲--------------
  l_down_channel_no varchar2(32);
  l_pay_account_id  number;
  l_bank_fund_id    number;
  l_bank_account_id number;
  l_change_amount   number;
  l_inner_balance   number;
  l_bank_balance    number;
  l_service_id      number;
  l_service_amount  number;
  l_service_count   number;
  l_fund_main_id    number;
  l_fund_service_id number;
  l_bank_batch_id   number; ---加款记录的统一流水编号---查询需要红冲的银行卡变动记录
  l_handle_batch_id number; ---红冲加款的统一流水号
  l_change_time     date;
begin
  --================获取相关记录数据================
  ---1. 获取实体卡资金变动编号
  select t.bank_fund_id,
         t.channel_no,
         t.account_id,
         t.change_amount,
         t.change_time
    into l_bank_batch_id,
         l_down_channel_no,
         l_pay_account_id,
         l_change_amount,
         l_change_time
    from fd_trade_down_manual t
   where t.record_id = v_record_id;

  ---1.1.获取手续费条数
  select count(1), nvl(max(t.change_amount), 0), max(t.record_id)
    into l_service_count, l_service_amount, l_service_id
    from fd_trade_down_manual t
   where t.bank_fund_id = l_bank_batch_id
     and t.add_type = pkg_down_manual_change_type.service_add
     and rownum <= 1;

  ---2. 获取手续费变动记录编号
  select t.account_id, t.record_id
    into l_bank_account_id, l_bank_fund_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.change_type = pkg_bank_fund_change_type.add_amount
     and t.use_type = pkg_bank_use_type.down_add
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  --===================手续费记录红冲====================
  ---1. 锁实体卡账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;

  ---2.修改实体卡账户余额

  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - l_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_bank_account_id;

  ---2.1获取红冲加款的统一流水号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  --=====================银行卡记录红冲=============================
  ---1.红冲实体卡下游加款记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0 - l_change_amount),
           (l_bank_balance - l_change_amount),
           sysdate,
           v_create_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id,
           t.remark_name
      from fd_bank_cash_fund t
     where t.record_id = l_bank_fund_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---2.修改原记录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_bank_fund_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --=================渠道账户红冲===================
  ---1. 锁下游支付账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_down_account t
   where t.account_id = l_pay_account_id
     for update;

  ---2.更新账户余额
  update fd_base_down_account t
     set t.inner_balance  = l_inner_balance - l_change_amount -
                            l_service_amount,
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_pay_account_id;

  ---3.红冲手工加款记录
  select seq_trade_down_fund_id.nextval into l_fund_main_id from dual;
  select seq_trade_down_fund_id.nextval into l_fund_service_id from dual;

  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
    select l_fund_main_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           0,
           pkg_down_manual_change_type.red_recharge,
           (0 - l_change_amount),
           sysdate,
           (l_inner_balance - l_change_amount),
           v_create_user,
           t.partner_account,
           v_memo
      from fd_trade_down_manual t
     where t.record_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---4.修改原加款记录状态
  update fd_trade_down_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.红冲手工加款表手续费记录
  if l_service_count > 0 then
    ---5.1添加红冲记录
    insert into fd_trade_down_manual
      (record_id,
       channel_no,
       account_id,
       adjust_id,
       has_adjust,
       add_type,
       change_amount,
       change_time,
       balance,
       create_user,
       partner_account,
       memo)
      select l_fund_service_id,
             t.channel_no,
             t.account_id,
             t.record_id,
             0,
             pkg_down_manual_change_type.service_red,
             (0 - l_service_amount),
             sysdate,
             (l_inner_balance - l_change_amount - l_service_amount),
             v_create_user,
             t.partner_account,
             v_memo
        from fd_trade_down_manual t
       where t.record_id = l_service_id
         and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  
    ---5.2.修改原加款记录状态
    update fd_trade_down_manual t
       set t.has_adjust = pkg_sys_boolean.istrue
     where t.record_id = l_service_id
       and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  end if;

  ---5.红冲资金变动中手工加款记录
  insert into fd_trade_down_fund
    (record_id,
     channel_no,
     account_id,
     create_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_main_id,
     l_down_channel_no,
     l_pay_account_id,
     sysdate,
     pkg_down_fund_change_type.add_amount,
     (0 - l_change_amount),
     (l_inner_balance - l_change_amount),
     v_memo);
  /*    select l_fund_main_id,
        t.fd_order_id,
        t.channel_no,
        t.account_id,
        t.trade_order_no,
        t.ext_order_no,
        t.order_source,
        sysdate,
        t.order_time,
        t.change_type,
        (0 - l_change_amount),
        (l_inner_balance - l_change_amount),
        v_memo
   from fd_trade_down_fund t
  where t.record_id = v_record_id;*/

  /*  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;*/

  if l_service_count > 0 then
    ---5.红冲资金变动中手工加款记录
    insert into fd_trade_down_fund
      (record_id,
       channel_no,
       account_id,
       create_time,
       change_type,
       change_amount,
       balance,
       memo)
    values
      (l_fund_service_id,
       l_down_channel_no,
       l_pay_account_id,
       sysdate,
       pkg_down_fund_change_type.service_amount,
       (0 - l_service_amount),
       (l_inner_balance - l_change_amount - l_service_amount),
       v_memo);
    /*      select l_fund_service_id,
          t.fd_order_id,
          t.channel_no,
          t.account_id,
          t.trade_order_no,
          t.ext_order_no,
          t.order_source,
          sysdate,
          t.order_time,
          t.change_type,
          (0 - l_service_amount),
          (l_inner_balance - l_change_amount - l_service_amount),
          v_memo
     from fd_trade_down_fund t
    where t.record_id = l_service_id;*/
  
    /*    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;*/
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_DOWN_BORROW_ADD
prompt =============================================
prompt
create or replace function fd_account.fd_f_adjust_down_borrow_add(v_record_id   number,
                                                       v_create_user varchar2,
                                                       v_memo        varchar2)
  return varchar2 is
  -------------下游手工加款红冲--------------
  l_pay_account_id  number;
  l_change_amount   number;
  l_inner_balance   number;
  l_service_id      number;
  l_service_amount  number;
  l_service_count   number;
  l_fund_main_id    number;
  l_fund_service_id number;
  l_bank_batch_id   number; ---加款记录的统一流水编号---查询需要红冲的银行卡变动记录
  l_handle_batch_id number; ---红冲加款的统一流水号
  l_change_time     date;
  l_cap_account_id  number;
  l_cap_balance     number;
  l_add_record_id   number;
begin
  --================获取相关记录数据================
  ---1.获取资产账户变动记录
  select t.account_id, t.bank_batch_id, t.change_amount, t.change_time
    into l_cap_account_id, l_bank_batch_id, l_change_amount, l_change_time
    from fd_trade_co_cap_fund t
   where t.change_id = v_record_id;

  ---2.获取下游加款记录 
  select t.bank_fund_id, t.account_id, t.record_id
    into l_bank_batch_id, l_pay_account_id, l_add_record_id
    from fd_trade_down_manual t
   where t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and t.bank_fund_id = l_bank_batch_id
     and t.add_type = pkg_down_manual_change_type.add_amount
     and rownum <= 2;

  ---3.获取下游手续记录信息
  select count(1), nvl(max(t.change_amount), 0), max(t.record_id)
    into l_service_count, l_service_amount, l_service_id
    from fd_trade_down_manual t
   where t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and t.bank_fund_id = l_bank_batch_id
     and t.add_type = pkg_down_manual_change_type.service_add
     and rownum <= 1;

  --===================修改借支账户余额====================
  ---1. 锁借支账户
  select t.balance
    into l_cap_balance
    from fd_base_company_account_cap t
   where t.account_id = l_cap_account_id
     for update;

  ---2.修改借支账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_cap_balance - l_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_cap_account_id;

  ---3.获取红冲加款的统一流水号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  --=====================借支账户加款红冲=============================
  ---1.红冲借支账户加款记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     create_user)
    select seq_trade_co_cap_fund_id.nextval,
           l_cap_account_id,
           (0 - l_change_amount),
           t.change_type,
           (l_cap_balance - l_change_amount),
           sysdate,
           t.change_id,
           pkg_sys_boolean.istrue,
           l_handle_batch_id,
           v_memo,
           v_create_user
      from fd_trade_co_cap_fund t
     where t.change_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---2.修改原纪录
  update fd_trade_co_cap_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.change_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --=================渠道账户红冲===================
  ---1. 锁下游支付账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_down_account t
   where t.account_id = l_pay_account_id
     for update;

  ---2.更新账户余额
  update fd_base_down_account t
     set t.inner_balance  = l_inner_balance - l_change_amount -
                            l_service_amount,
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_pay_account_id;

  ---3.红冲手工加款记录
  select seq_trade_down_fund_id.nextval into l_fund_main_id from dual;
  select seq_trade_down_fund_id.nextval into l_fund_service_id from dual;

  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
    select l_fund_main_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           0,
           pkg_down_manual_change_type.red_recharge,
           (0 - l_change_amount),
           sysdate,
           (l_inner_balance - l_change_amount),
           v_create_user,
           t.partner_account,
           v_memo
      from fd_trade_down_manual t
     where t.record_id = l_add_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---4.修改原加款记录状态
  update fd_trade_down_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_add_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.红冲手工加款表手续费记录
  if l_service_count > 0 then
    ---5.1添加红冲记录
    insert into fd_trade_down_manual
      (record_id,
       channel_no,
       account_id,
       adjust_id,
       has_adjust,
       add_type,
       change_amount,
       change_time,
       balance,
       create_user,
       partner_account,
       memo)
      select l_fund_service_id,
             t.channel_no,
             t.account_id,
             t.record_id,
             0,
             pkg_down_manual_change_type.service_red,
             (0 - l_service_amount),
             sysdate,
             (l_inner_balance - l_change_amount - l_service_amount),
             v_create_user,
             t.partner_account,
             v_memo
        from fd_trade_down_manual t
       where t.record_id = l_service_id
         and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  
    ---5.2.修改原加款记录状态
    update fd_trade_down_manual t
       set t.has_adjust = pkg_sys_boolean.istrue
     where t.record_id = l_service_id
       and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  end if;

  ---5.红冲资金变动中手工加款记录
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
    select l_fund_main_id,
           t.fd_order_id,
           t.channel_no,
           t.account_id,
           t.trade_order_no,
           t.ext_order_no,
           t.order_source,
           sysdate,
           t.order_time,
           t.change_type,
           (0 - l_change_amount),
           (l_inner_balance - l_change_amount),
           v_memo
      from fd_trade_down_fund t
     where t.record_id = l_add_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  if l_service_count > 0 then
    ---5.红冲资金变动中手工加款记录
    insert into fd_trade_down_fund
      (record_id,
       fd_order_id,
       channel_no,
       account_id,
       trade_order_no,
       ext_order_no,
       order_source,
       create_time,
       order_time,
       change_type,
       change_amount,
       balance,
       memo)
      select l_fund_service_id,
             t.fd_order_id,
             t.channel_no,
             t.account_id,
             t.trade_order_no,
             t.ext_order_no,
             t.order_source,
             sysdate,
             t.order_time,
             t.change_type,
             (0 - l_service_amount),
             (l_inner_balance - l_change_amount - l_service_amount),
             v_memo
        from fd_trade_down_fund t
       where t.record_id = l_service_id;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_DOWN_BORROW_CHECK
prompt ===============================================
prompt
create or replace function fd_account.fd_f_adjust_down_borrow_check(v_record_id   number,
                                                         v_adjust_days number)
  return varchar2 is
  -------------检查加款记录、账户、余额、手续费--------------
  l_change_time date;
begin
  ---1. 检查加款记录、账户及余额
  select t.change_time
    into l_change_time
    from fd_trade_co_cap_fund t
   inner join fd_base_company_account_cap c on t.account_id = c.account_id
   inner join fd_trade_down_manual m on t.bank_batch_id = m.bank_fund_id
   inner join fd_base_down_account a on m.account_id = a.account_id
   where t.change_id = v_record_id
     and t.change_type = pkg_co_cap_fund_type.down_borrow_add
     and m.add_type = pkg_down_manual_change_type.add_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and m.has_adjust = pkg_sys_boolean.isfalse
     and t.change_amount = m.change_amount;

  ---2.检查红冲是否超时
  if l_change_time < (trunc(sysdate) - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_DOWN_DEP_ADD
prompt ==========================================
prompt
create or replace function fd_account.fd_f_adjust_down_dep_add(v_record_id   number,
                                                    v_create_user varchar2,
                                                    v_memo        varchar2)
  return varchar2 is
  -------------下游手工加款红冲--------------
  l_pay_account_id  number;
  l_bank_fund_id    number;
  l_bank_account_id number;
  l_change_amount   number;
  l_inner_balance   number;
  l_bank_balance    number;
  l_fund_main_id    number;
  l_bank_batch_id   number; ---加款记录的统一流水编号---查询需要红冲的银行卡变动记录
  l_handle_batch_id number; ---红冲加款的统一流水号
  l_change_time     date;
  l_cap_account_id  number;
  l_change_id       number;
  l_cap_balance     number;
begin
  --================获取相关记录数据================
  ---1. 获取实体卡资金变动编号
  select t.bank_fund_id, t.account_id, t.change_amount, t.change_time
    into l_bank_batch_id, l_pay_account_id, l_change_amount, l_change_time
    from fd_trade_down_manual t
   where t.record_id = v_record_id;

  ---2. 获取银行卡变动记录
  select t.account_id, t.record_id
    into l_bank_account_id, l_bank_fund_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.change_type = pkg_bank_fund_change_type.add_amount
     and t.use_type = pkg_bank_use_type.down_add
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  ---3.获取押金、保证金账户变动记录
  select t.account_id, t.change_id
    into l_cap_account_id, l_change_id
    from fd_trade_co_cap_fund t
   where t.bank_batch_id = l_bank_batch_id
     and t.change_type = pkg_co_cap_fund_type.deposit_down_add
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;
  --===================押金、保证金记录红冲=================
  ---0.获取红冲加款的统一流水号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  ---1. 锁资产账户
  select t.balance
    into l_cap_balance
    from fd_base_company_account_cap t
   where t.account_id = l_cap_account_id
     for update;

  ---2. 修改资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_cap_balance + l_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_cap_account_id;

  ---3.红冲资产账户变动记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo)
    select seq_trade_co_cap_fund_id.nextval,
           t.account_id,
           (0 - t.change_amount),
           t.change_type,
           (l_cap_balance + l_change_amount),
           sysdate,
           t.change_id,
           pkg_sys_boolean.istrue,
           l_handle_batch_id,
           v_memo
      from fd_trade_co_cap_fund t
     where t.change_id = l_change_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---4.修改原记录编号
  update fd_trade_co_cap_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.change_id = l_change_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --=====================银行卡记录红冲=============================
  ---1. 锁实体卡账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;

  ---2.修改实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - l_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_bank_account_id;

  ---3.红冲实体卡下游加款记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0 - l_change_amount),
           (l_bank_balance - l_change_amount),
           sysdate,
           v_create_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id,
           t.remark_name
      from fd_bank_cash_fund t
     where t.record_id = l_bank_fund_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---2.修改原记录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_bank_fund_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --=================渠道账户红冲===================
  ---1. 锁下游支付账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_down_account t
   where t.account_id = l_pay_account_id
     for update;

  ---2.更新账户余额
  update fd_base_down_account t
     set t.inner_balance  = l_inner_balance - l_change_amount,
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_pay_account_id;

  ---3.红冲手工加款记录
  select seq_trade_down_fund_id.nextval into l_fund_main_id from dual;

  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
    select l_fund_main_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           0,
           pkg_down_manual_change_type.red_recharge,
           (0 - l_change_amount),
           sysdate,
           (l_inner_balance - l_change_amount),
           v_create_user,
           t.partner_account,
           v_memo
      from fd_trade_down_manual t
     where t.record_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---4.修改原加款记录状态
  update fd_trade_down_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.红冲资金变动中手工加款记录
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
    select l_fund_main_id,
           t.fd_order_id,
           t.channel_no,
           t.account_id,
           t.trade_order_no,
           t.ext_order_no,
           t.order_source,
           sysdate,
           t.order_time,
           t.change_type,
           (0 - l_change_amount),
           (l_inner_balance - l_change_amount),
           v_memo
      from fd_trade_down_fund t
     where t.record_id = v_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_DOWN_DEP_ADD_CK
prompt =============================================
prompt
create or replace function fd_account.fd_f_adjust_down_dep_add_ck(v_record_id   number,
                                                       v_adjust_days number)
  return varchar2 is
  -------------检查加款记录、账户、余额、手续费--------------
  l_record_count number;
  l_change_time  date;
begin
  ---1. 检查加款记录、账户及余额
  select count(1), max(t.change_time)
    into l_record_count, l_change_time
    from fd_trade_down_manual t
   inner join fd_base_down_account f on t.account_id = f.account_id
   inner join fd_bank_cash_fund b on t.bank_fund_id = b.service_id
   inner join fd_bank_account_info a on b.account_id = a.account_id
   inner join fd_trade_co_cap_fund c on t.bank_fund_id = c.bank_batch_id
   inner join fd_base_company_account_cap ac on c.account_id =
                                                ac.account_id
   where t.record_id = v_record_id
     and t.add_type = pkg_down_manual_change_type.add_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and b.has_adjust = pkg_sys_boolean.isfalse
     and t.change_amount = b.change_amount
     and t.change_amount = c.change_amount
     and ac.account_type in
         (pkg_co_cap_account_type.deposit, pkg_co_cap_account_type.bond);

  if (l_record_count != 1 and l_record_count != 2) then
    return pkg_error_code.data_error;
  end if;

  if l_change_time < (trunc(sysdate) - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_DOWN_DRAW_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_adjust_down_draw_check(v_record_id   number,
                                                       v_adjust_days number)
  return varchar2 is
  -------------检查提款记录、账户、余额、手续费--------------
  l_record_count number;
  l_change_time  date;
begin
  ---1. 检查加款记录、账户及余额
  select count(1), max(t.change_time)
    into l_record_count, l_change_time
    from fd_trade_down_manual t
   inner join fd_base_down_account f on t.account_id = f.account_id
   inner join fd_bank_cash_fund b on t.bank_fund_id = b.service_id
   inner join fd_bank_account_info a on b.account_id = a.account_id
   where t.record_id = v_record_id
     and t.add_type = pkg_down_manual_change_type.draw_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and b.has_adjust = pkg_sys_boolean.isfalse
     and t.change_amount = b.change_amount;

  if (l_record_count != 1 and l_record_count != 2) then
    return pkg_error_code.data_error;
  end if;

  if l_change_time < (trunc(sysdate) - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_DOWN_DRAW_HANDLE
prompt ==============================================
prompt
create or replace function fd_account.fd_f_adjust_down_draw_handle(v_record_id   number,
                                                        v_create_user varchar2,
                                                        v_memo        varchar2)
  return varchar2 is
  -------------下游手工提款红冲--------------
  l_down_channel_no varchar2(32);
  l_pay_account_id  number;
  l_bank_fund_id    number;
  l_bank_account_id number;
  l_change_amount   number;
  l_inner_balance   number;
  l_bank_balance    number;
  l_service_bank_id number;
  l_service_amount  number;
  l_service_count   number;
  l_fund_record_id  number;
  l_bank_batch_id   number; ---提款记录的统一流水编号---查询需要红冲的银行卡变动记录
  l_handle_batch_id number; ---红冲提款的统一流水号
  l_change_time     date;
begin
  --================获取相关记录数据================
  ---1. 获取实体卡资金变动编号
  select t.bank_fund_id,
         t.channel_no,
         t.account_id,
         t.change_amount,
         t.change_time
    into l_bank_batch_id,
         l_down_channel_no,
         l_pay_account_id,
         l_change_amount,
         l_change_time
    from fd_trade_down_manual t
   where t.record_id = v_record_id;

  ---2. 获取手续费变动记录编号
  select t.account_id, t.record_id
    into l_bank_account_id, l_bank_fund_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.use_type = pkg_bank_use_type.down_draw
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  ---3.获取手续费条数
  select count(1), nvl(max(t.change_amount), 0), max(t.record_id)
    into l_service_count, l_service_amount, l_service_bank_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.use_type = pkg_bank_use_type.service_fee
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  --===================手续费记录红冲====================
  ---1. 锁实体卡账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;

  ---2.修改实体卡账户余额

  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + l_service_amount +
                            l_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_bank_account_id;

  ---2.1获取红冲提款的统一流水号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  if (l_service_count > 0) then
    ---2.红冲实体卡手续费资金变动
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
      select seq_bank_cash_fund_id.nextval,
             t.account_id,
             t.record_id,
             t.company_id,
             (0 - t.change_amount),
             (l_bank_balance + l_service_amount),
             sysdate,
             v_create_user,
             t.change_type,
             t.use_type,
             pkg_sys_boolean.istrue,
             t.link_channel_name,
             t.link_account_name,
             v_memo,
             l_handle_batch_id,
             t.remark_name
        from fd_bank_cash_fund t
       where t.record_id = l_service_bank_id
         and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  
    ---3.修改原手续费记录状态
    update fd_bank_cash_fund t
       set t.has_adjust = pkg_sys_boolean.istrue
     where t.record_id = l_service_bank_id
       and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  end if;

  --=====================银行卡记录红冲=============================
  ---1.红冲实体卡下游提款记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0 - t.change_amount),
           (l_bank_balance + l_service_amount + l_change_amount),
           sysdate,
           v_create_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id,
           t.remark_name
      from fd_bank_cash_fund t
     where t.record_id = l_bank_fund_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---2.修改原记录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_bank_fund_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --=================渠道账户红冲===================
  ---1. 锁下游支付账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_down_account t
   where t.account_id = l_pay_account_id
     for update;

  ---2.更新账户余额
  update fd_base_down_account t
     set t.inner_balance  = l_inner_balance + l_change_amount,
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_pay_account_id;

  ---3.红冲手工提款记录
  select seq_trade_down_fund_id.nextval into l_fund_record_id from dual;

  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
    select l_fund_record_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           0,
           pkg_down_manual_change_type.draw_red,
           (0 - t.change_amount),
           sysdate,
           (l_inner_balance + l_change_amount),
           v_create_user,
           t.partner_account,
           v_memo
      from fd_trade_down_manual t
     where t.record_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---4.修改原提款记录状态
  update fd_trade_down_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.红冲资金变动中手工提款记录
  insert into fd_trade_down_fund
    (record_id,
     channel_no,
     account_id,
     create_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_id,
     l_down_channel_no,
     l_pay_account_id,
     sysdate,
     pkg_down_fund_change_type.draw_amount,
     (0 - l_change_amount),
     (l_inner_balance + l_change_amount),
     v_memo);
  /*    select l_fund_record_id,
        t.fd_order_id,
        t.channel_no,
        t.account_id,
        t.trade_order_no,
        t.ext_order_no,
        t.order_source,
        sysdate,
        t.order_time,
        t.change_type,
        (0 - t.change_amount),
        (l_inner_balance + l_change_amount),
        v_memo
   from fd_trade_down_fund t
  where t.record_id = v_record_id;*/

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_FUND_DIFFER_ADD
prompt ============================================
prompt
create or replace function fd_account.fd_f_trade_fund_differ_add(v_fd_order_id   number, --订单编号
                                                      v_trade_type    number, --交易类型（1.下游扣款2.上游扣款3.上游退款4.下游退款5.转账退款）
                                                      v_channel_no    varchar2, --渠道编号
                                                      v_account_id    number, --账户编号
                                                      v_business_type number, --业务类型
                                                      v_bill_type     number, --利润类型                         
                                                      v_order_face    number, --订单面值
                                                      v_order_amount  number, --订单扣款金额
                                                      v_down_face     number, --下游扣款或上游中的下游扣款面值
                                                      v_down_amount   number, --下游扣款或上游中的下游扣款金额
                                                      v_up_face       number --上游扣款面值
                                                      ) return varchar2 is
  -----------------------记录资金变动相关统计差异数据----------------------
  l_today_date         date := trunc(sysdate);
  l_differ_count       number;
  l_down_adjust_face   number := 0; ---资金变动差异表中，下游退款造成多冲时，需要用来抵消上游资金变动中的下游扣款面值
  l_down_adjust_unit   number := 0; ---同上的规格
  l_down_adjust_amount number := 0; ---同上的金额
  l_down_adjust_real   number := 0; ---同上的真实金额
  l_up_many_face       number := 0; ---资金变动差异表中记录的上游多冲的面值
  l_up_many_amount     number := 0; ---同上的金额
  l_to_front_face      number := 0; ---资金变动差异表中记录的需要由前向转为后向的面值
  l_to_front_unit      number := 0; ---同上的规格
  l_to_front_amount    number := 0; ---同上的金额
  l_to_front_real      number := 0; ---同上的真实金额
  l_down_first_face    number := 0; ---订单差异表中下有扣款比上游资金变动中下游扣款多的面值
  l_down_first_amount  number := 0; ---同上金额
  l_use_bill_type      number := v_bill_type;

  l_total_many_face   number; ---当天单笔订单总多冲面值
  l_total_many_amount number; ---同上金额
  l_bill_many_face    number; ---当天单笔订单退款bill_type的多冲面值
  l_bill_many_amount  number; ---同上金额
  l_refund_many_face  number;
  l_down_draw_unit    number;
  l_down_draw_face    number;
  l_down_draw_amount  number;
  l_down_real_amount  number;
  l_down_refund_face  number;
  l_real_order_face   number;
  l_all_up_face       number;
  l_down_up_differ    number;
  l_main_differ_count number;
  l_many_face_now     number; ---退款红冲后多冲值
  l_many_face_red     number; ---退款红冲前多冲值

begin
  --=======================数据计算========================
  ---1.计算差异报表需要的数据
  if v_trade_type = pkg_trade_type.down_debit then
  
    --1.1下游扣款
    l_down_first_face   := v_down_face;
    l_down_first_amount := v_down_amount;
  elsif v_trade_type = pkg_trade_type.up_debit then
  
    --1.2上游扣款
    l_down_first_face   := -1 * v_down_face;
    l_down_first_amount := -1 * v_down_amount;
    l_up_many_face      := v_up_face - v_down_face;
    l_up_many_amount    := v_order_amount * l_up_many_face / v_order_face;
  elsif v_trade_type = pkg_trade_type.up_refund then
  
    --1.3上游退款
    l_down_first_face   := v_down_face;
    l_down_first_amount := v_down_amount;
  
    ---1.3.1计算当前多冲的总面值
    select nvl(sum(t.up_many_face), 0), nvl(sum(t.up_many_amount), 0)
      into l_total_many_face, l_total_many_amount
      from fd_trade_up_fund_differ t
     where t.fd_order_id = v_fd_order_id;
  
    ---1.3.2计算当前多冲的当前bill_type的面值
    select nvl(sum(t.up_many_face), 0), nvl(sum(t.up_many_amount), 0)
      into l_bill_many_face, l_bill_many_amount
      from fd_trade_up_fund_differ t
     where t.fd_order_id = v_fd_order_id
       and t.bill_type = v_bill_type;
  
    ---1.3.3计算需要转移的数据
    l_refund_many_face := v_up_face - v_down_face;
    if l_refund_many_face > l_total_many_face then
      --多冲退款面值比多冲扣款面值多，数据不正确
      return pkg_error_code.debit_not_exists;
    elsif l_refund_many_face > l_bill_many_face then
      ---当l_bill_many_face < 0时退款多冲部分全部考虑进去
      if l_bill_many_face < 0 then
        l_bill_many_face := 0;
      end if;
    
      --当前bill_type的多冲扣款比本次的退款少，差异部分及为需要转移的面值
      --退款为前向，扣款后向，退款后下游需要 前向转后向
      if v_bill_type = pkg_bill_type.front then
        l_to_front_face := l_bill_many_face - l_refund_many_face;
      else
        l_to_front_face := l_refund_many_face - l_bill_many_face;
      end if;
    
      ---1.3.4取上游一条扣款记录按比例计算其他数据
      select t.down_draw_unit,
             t.down_draw_face,
             t.down_draw_amount,
             t.down_real_amount
        into l_down_draw_unit,
             l_down_draw_face,
             l_down_draw_amount,
             l_down_real_amount
        from fd_trade_up_fund t
       where t.fd_order_id = v_fd_order_id
         and t.change_type = pkg_up_fund_change_type.debit_amount
         and t.down_draw_face > 0
         and rownum <= 1;
    
      l_to_front_unit   := l_down_draw_unit * l_to_front_face /
                           l_down_draw_face;
      l_to_front_amount := l_down_draw_amount * l_to_front_face /
                           l_down_draw_face;
      l_to_front_real   := l_down_real_amount * l_to_front_face /
                           l_down_draw_face;
    end if;
    ---多冲退款面值比本bill_type的多冲扣款面值小，不会转移，所以没分if条件
  
    ---1.3.5多冲调整数据计算
    l_up_many_face   := -1 * l_refund_many_face;
    l_up_many_amount := v_order_amount * l_up_many_face / v_order_face;
  
  elsif v_trade_type = pkg_trade_type.down_refund or
        v_trade_type = pkg_trade_type.transfer_refund then
    --1.4下游退款、转账退款
    ---1.4.1计算扣除下游退款的实际订单面值
    select nvl(sum(t.refund_face), 0)
      into l_down_refund_face
      from fd_trade_down_refund t
     where t.fd_order_id = v_fd_order_id;
  
    l_real_order_face := v_order_face - l_down_refund_face;
  
    ---1.4.2计算当前总上游扣款
    select nvl(sum(decode(t.change_type,
                          pkg_up_fund_change_type.debit_amount,
                          1,
                          -1) * t.up_draw_face),
               0)
      into l_all_up_face
      from fd_trade_up_fund t
     where t.fd_order_id = v_fd_order_id
       and t.change_type in (pkg_up_fund_change_type.debit_amount,
            pkg_up_fund_change_type.refund_amount);
  
    ---1.4.3计算实际下游扣款比上游扣款多的值
    l_down_up_differ := l_all_up_face - l_real_order_face;
    --订单真实面值已包含本次退款
    --差>=退款   多冲 退款
    --退款>差>0  多冲 差
    --差<=0    无多冲
    if l_down_up_differ >= v_down_face then
      l_up_many_face   := v_down_face;
      l_up_many_amount := v_order_amount * l_up_many_face / v_order_face;
    
    elsif l_down_up_differ > 0 and v_down_face > l_down_up_differ then
      l_up_many_face   := l_down_up_differ;
      l_up_many_amount := v_order_amount * l_up_many_face / v_order_face;
    end if;
    ----差异小于等于退款部分无多冲，直接不计算
  
    ---1.4.4有多冲需要计算多冲造成的差异
    if l_up_many_face > 0 then
      select t.down_draw_unit,
             t.down_draw_face,
             t.down_draw_amount,
             t.down_real_amount,
             t.bill_type
        into l_down_draw_unit,
             l_down_draw_face,
             l_down_draw_amount,
             l_down_real_amount,
             l_use_bill_type
        from fd_trade_up_fund t
       where t.fd_order_id = v_fd_order_id
         and t.change_type = pkg_up_fund_change_type.debit_amount
         and t.down_draw_face > 0
         and rownum <= 1;
    
      l_down_adjust_face   := -1 * l_up_many_face;
      l_down_adjust_unit   := l_down_draw_unit * l_down_adjust_face /
                              l_down_draw_face;
      l_down_adjust_amount := l_down_draw_amount * l_down_adjust_face /
                              l_down_draw_face;
      l_down_adjust_real   := l_down_real_amount * l_down_adjust_face /
                              l_down_draw_face;
    
    end if;
  
    ---1.4.5上下游扣款时间差异
    l_down_first_face   := l_up_many_face - v_down_face;
    l_down_first_amount := l_up_many_amount - v_down_amount;
  elsif v_trade_type = pkg_trade_type.refund_red then
    ---1.5下游退款红冲
    ---1.5.1计算扣除下游退款的实际订单面值
    select nvl(sum(t.refund_face), 0)
      into l_down_refund_face
      from fd_trade_down_refund t
     where t.fd_order_id = v_fd_order_id;
  
    l_real_order_face := v_order_face - l_down_refund_face;
  
    ---1.5.2计算当前总上游扣款
    select nvl(sum(decode(t.change_type,
                          pkg_up_fund_change_type.debit_amount,
                          1,
                          -1) * t.up_draw_face),
               0)
      into l_all_up_face
      from fd_trade_up_fund t
     where t.fd_order_id = v_fd_order_id
       and t.change_type in (pkg_up_fund_change_type.debit_amount,
            pkg_up_fund_change_type.refund_amount);
  
    ---1.5.3计算当前多冲值与红冲前多冲值
    l_many_face_now := l_all_up_face - l_real_order_face;
    l_many_face_red := l_all_up_face - (l_real_order_face + v_down_face);
    if l_many_face_now >= 0 and l_many_face_red > 0 then
      ---红冲退款的值为多冲值(负值)，对订单的上下游时间差异无影响
      l_up_many_face   := v_down_face;
      l_up_many_amount := v_order_amount * l_up_many_face / v_order_face;
    elsif l_many_face_now < 0 and l_many_face_red > 0 then
      ---红冲前的多冲值的反值为多冲值(负值)，上下游时间差异为红冲后多冲值的反值
      l_up_many_face      := -1 * l_many_face_red;
      l_up_many_amount    := v_order_amount * l_up_many_face / v_order_face;
      l_down_first_face   := -1 * l_many_face_now;
      l_down_first_amount := v_order_amount * l_down_first_face /
                             v_order_face;
    else
      ---无多冲，红冲退款的值的反值为上下游时间差异的值
      l_down_first_face   := -1 * v_down_face;
      l_down_first_amount := v_order_amount * l_down_first_face /
                             v_order_face;
    end if;
  
    if l_up_many_face != 0 then
      select t.down_draw_unit,
             t.down_draw_face,
             t.down_draw_amount,
             t.down_real_amount,
             t.bill_type
        into l_down_draw_unit,
             l_down_draw_face,
             l_down_draw_amount,
             l_down_real_amount,
             l_use_bill_type
        from fd_trade_up_fund t
       where t.fd_order_id = v_fd_order_id
         and t.change_type = pkg_up_fund_change_type.debit_amount
         and t.down_draw_face > 0
         and rownum <= 1;
    
      l_down_adjust_face   := -1 * l_up_many_face;
      l_down_adjust_unit   := l_down_draw_unit * l_down_adjust_face /
                              l_down_draw_face;
      l_down_adjust_amount := l_down_draw_amount * l_down_adjust_face /
                              l_down_draw_face;
      l_down_adjust_real   := l_down_real_amount * l_down_adjust_face /
                              l_down_draw_face;
    
    end if;
  else
    --1.6错误数据
    return pkg_error_code.success;
  end if;

  --=======================数据收集=======================

  if l_up_many_face != 0 then
    ---2.检查差异表订单数据是否存在
    select count(1)
      into l_differ_count
      from fd_trade_up_fund_differ t
     where t.record_date = l_today_date
       and t.fd_order_id = v_fd_order_id
       and t.channel_no = v_channel_no
       and t.account_id = v_account_id
       and t.business_type = v_business_type
       and t.bill_type = l_use_bill_type;
  
    ---3.添加差异数据
    if l_differ_count = 0 then
      insert into fd_trade_up_fund_differ
        (differ_id,
         record_date,
         fd_order_id,
         channel_no,
         account_id,
         business_type,
         bill_type,
         down_adjust_face,
         down_adjust_unit,
         down_adjust_amount,
         down_adjust_real,
         up_many_face,
         up_many_amount,
         to_front_face,
         to_front_unit,
         to_front_amount,
         to_front_real)
      values
        (seq_trade_up_fund_differ_id.nextval,
         l_today_date,
         v_fd_order_id,
         v_channel_no,
         v_account_id,
         v_business_type,
         l_use_bill_type,
         l_down_adjust_face,
         l_down_adjust_unit,
         l_down_adjust_amount,
         l_down_adjust_real,
         l_up_many_face,
         l_up_many_amount,
         l_to_front_face,
         l_to_front_unit,
         l_to_front_amount,
         l_to_front_real);
    
    else
      update fd_trade_up_fund_differ t
         set t.down_adjust_face   = t.down_adjust_face + l_down_adjust_face,
             t.down_adjust_unit   = t.down_adjust_unit + l_down_adjust_unit,
             t.down_adjust_amount = t.down_adjust_amount +
                                    l_down_adjust_amount,
             t.down_adjust_real   = t.down_adjust_real + l_down_adjust_real,
             t.up_many_face       = t.up_many_face + l_up_many_face,
             t.up_many_amount     = t.up_many_amount + l_up_many_amount,
             t.to_front_face      = t.to_front_face + l_to_front_face,
             t.to_front_unit      = t.to_front_unit + l_to_front_unit,
             t.to_front_amount    = t.to_front_amount + l_to_front_amount,
             t.to_front_real      = t.to_front_real + l_to_front_real
       where t.record_date = l_today_date
         and t.fd_order_id = v_fd_order_id
         and t.channel_no = v_channel_no
         and t.account_id = v_account_id
         and t.business_type = v_business_type
         and t.bill_type = l_use_bill_type;
    
    end if;
    if sql%rowcount = 0 then
      return pkg_error_code.data_error;
    end if;
  end if;

  ---4.记录上下游扣款时间产生的差异
  select count(1)
    into l_main_differ_count
    from fd_trade_order_main_differ t
   where t.record_date = l_today_date
     and t.fd_order_id = v_fd_order_id
     and t.channel_no = v_channel_no
     and t.account_id = v_account_id
     and t.business_type = v_business_type;

  if l_main_differ_count = 0 then
    insert into fd_trade_order_main_differ
      (differ_id,
       record_date,
       fd_order_id,
       channel_no,
       account_id,
       business_type,
       down_first_face,
       down_first_amount)
    values
      (seq_trade_order_main_differ_id.nextval,
       l_today_date,
       v_fd_order_id,
       v_channel_no,
       v_account_id,
       v_business_type,
       l_down_first_face,
       l_down_first_amount);
  
  else
    update fd_trade_order_main_differ t
       set t.down_first_face   = (t.down_first_face + l_down_first_face),
           t.down_first_amount = (t.down_first_amount + l_down_first_amount)
     where t.record_date = l_today_date
       and fd_order_id = v_fd_order_id
       and t.channel_no = v_channel_no
       and t.account_id = v_account_id
       and t.business_type = business_type;
  
  end if;
  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_DOWN_REFUND_HANDER
prompt ================================================
prompt
create or replace function fd_account.fd_f_adjust_down_refund_hander(v_order_source    number,
                                                          v_down_channel_no varchar2,
                                                          v_trade_order_no  varchar2,
                                                          v_adjust_no       varchar2,
                                                          v_adjust_unit     number,
                                                          v_adjust_face     number,
                                                          v_adjust_amount   number,
                                                          v_adjust_refund   number,
                                                          v_adjust_time     varchar2,
                                                          v_memo            varchar2)
  return varchar2 is
  ------------------红冲下游退款------------------
  l_fd_order_id       number;
  l_down_account_id   number;
  l_inner_balance     number;
  l_fund_red_id       number;
  l_fund_service_id   number;
  l_adjust_time       date;
  l_refund_amount     number;
  l_credit_money      number;
  l_red_count         number;
  l_refund_face       number;
  l_business_type     number;
  l_total_face        number;
  l_order_main_amount number;
  l_result            varchar2(32);
begin
  ---1.锁支付订单
  select t.fd_order_id,
         t.down_account_id,
         t.business_type,
         t.total_face,
         t.down_order_amount
    into l_fd_order_id,
         l_down_account_id,
         l_business_type,
         l_total_face,
         l_order_main_amount
    from fd_trade_order_main t
   where t.down_channel_no = v_down_channel_no
     and t.order_source = v_order_source
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1
     for update;

  ---1.1检查重复红冲
  select count(1)
    into l_red_count
    from fd_trade_down_refund t
   where t.trade_refund_no = v_adjust_no
     and t.order_source = v_order_source
     and t.refund_amount < 0
     and t.real_refund < 0;

  if l_red_count > 0 then
    return pkg_error_code.success;
  end if;

  ---2.检查红冲金额是否大于退款减去已红冲金额的差
  select sum(t.refund_amount), sum(t.refund_face)
    into l_refund_amount, l_refund_face
    from fd_trade_down_refund t
   where t.fd_order_id = l_fd_order_id;

  if (v_adjust_amount > l_refund_amount) then
    return pkg_error_code.amount_error;
  end if;

  if (v_adjust_face > l_refund_face) then
    return pkg_error_code.face_error;
  end if;

  ---3.锁支付账户获取手续费率
  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  ---4.修改支付账户余额
  update fd_base_down_account t
     set t.inner_balance = (l_inner_balance - v_adjust_amount)
   where t.account_id = l_down_account_id;

  ---5.添加收取红冲手续费记录
  select seq_trade_down_fund_id.nextval into l_fund_red_id from dual;
  select seq_trade_down_fund_id.nextval,
         to_date(nvl(v_adjust_time,
                     to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss')),
                 'yyyy-mm-dd hh24:mi:ss')
    into l_fund_service_id, l_adjust_time
    from dual;

  ---6.添加红冲下游退款记录
  insert into fd_trade_down_refund
    (record_id,
     channel_no,
     account_id,
     fd_order_id,
     trade_order_no,
     trade_refund_no,
     order_source,
     refund_time,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund,
     memo)
    select l_fund_red_id,
           t.down_channel_no,
           t.down_account_id,
           t.fd_order_id,
           t.trade_order_no,
           v_adjust_no,
           t.order_source,
           l_adjust_time,
           t.business_type,
           t.carrier_no,
           t.province_no,
           0 - v_adjust_unit,
           0 - v_adjust_face,
           0 - v_adjust_amount,
           0 - v_adjust_refund,
           v_memo
      from fd_trade_order_main t
     where t.fd_order_id = l_fd_order_id;

  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
    select l_fund_red_id,
           t.fd_order_id,
           t.down_channel_no,
           t.down_account_id,
           t.trade_order_no,
           t.ext_order_no,
           t.order_source,
           l_adjust_time,
           t.order_time,
           pkg_down_fund_change_type.refund_amount,
           0 - v_adjust_amount,
           (l_inner_balance + v_adjust_amount),
           v_memo
      from fd_trade_order_main t
     where t.fd_order_id = l_fd_order_id;

  ---7.扣款成功记录订单差异表
  l_result := fd_f_trade_fund_differ_add(l_fd_order_id,
                                         pkg_trade_type.refund_red,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         pkg_bill_type.front,
                                         l_total_face,
                                         l_order_main_amount,
                                         -1 * v_adjust_face,
                                         -1 * v_adjust_amount,
                                         0);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_ADJUST_PROF_DRAW_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_adjust_prof_draw_check(v_draw_record_id number,
                                                       v_adjust_days    number)
  return varchar2 is
  -------------------检查红冲记录是否正确------------------
  l_change_amount number;
  l_change_time   date;
  l_bank_batch    number;
  l_bank_count    number;
begin
  ---1.检查毛利提取记录
  select t.change_amount, t.change_time, t.bank_batch_id
    into l_change_amount, l_change_time, l_bank_batch
    from fd_trade_co_cap_fund t
   inner join fd_base_company_account_cap c on t.account_id = c.account_id
   where t.change_id = v_draw_record_id
     and c.account_type = pkg_co_cap_account_type.profit
     and t.change_type = pkg_co_cap_fund_type.minus_amount
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if l_change_time < (sysdate - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  ---2.检查银行卡记录
  select count(1)
    into l_bank_count
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch;

  if l_bank_count != 1 and l_bank_count != 2 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_ADJUST_PROF_DRAW_RECORD
prompt ==============================================
prompt
create or replace function fd_account.fd_f_adjust_prof_draw_record(v_draw_record_id number,
                                                        v_adjust_user    varchar2,
                                                        v_memo           varchar2)
  return varchar2 is
  -------------------红冲毛利润提现--------------------
  l_bank_batch      number;
  l_change_amount   number;
  l_change_time     date;
  l_bank_record_id  number;
  l_bank_account_id number;
  l_bank_amount     number;
  l_service_fee     number;
  l_service_record  number;
  l_service_account number;
  l_cap_account_id  number;
  l_cap_balance     number;
begin
  --===================获取原数据====================
  ---1.获取毛利账户提款信息
  select t.bank_batch_id, t.change_amount, t.change_time, t.account_id
    into l_bank_batch, l_change_amount, l_change_time, l_cap_account_id
    from fd_trade_co_cap_fund t
   where t.change_id = v_draw_record_id;

  ---2.获取银行卡账户提款信息
  select t.record_id, t.account_id, t.change_amount
    into l_bank_record_id, l_bank_account_id, l_bank_amount
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch
     and t.change_amount = l_change_amount
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.use_type = pkg_bank_use_type.profits_withdraw
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60);

  if l_change_amount != l_bank_amount then
    return pkg_error_code.data_error;
  end if;

  ---3.获取银行卡手续费信息
  select nvl(max(t.change_amount), 0),
         nvl(max(t.record_id), 0),
         nvl(max(t.account_id), 0)
    into l_service_fee, l_service_record, l_service_account
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.use_type = pkg_bank_use_type.service_fee
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60);

  if l_bank_account_id != l_service_account then
    return pkg_error_code.data_error;
  end if;

  --===================红冲毛利提款==================
  ---1.锁毛利账户
  select t.balance
    into l_cap_balance
    from fd_base_company_account_cap t
   where t.account_id = l_cap_account_id
     for update;

  ---2.更新毛利账户余额
  ---3.添加毛利账户红冲记录
  --===================红冲银行卡记录===================
  ---1.锁银行卡账户
  ---2.更新银行卡账户余额
  ---3.添加手续费红冲记录
  ---4.添加银行卡红冲记录
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_SERVICE_CHECK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_adjust_service_check(v_record_id      number,
                                                     v_adjust_days    number,
                                                     v_bank_record_id out number)
  return varchar2 is
  ------------------检查记录数据及实体卡余额-------------------
  l_bank_account_id number;
  l_bank_balance    number;
  l_change_time     date;
  l_bank_batch_id   number;
begin
  ---1.检查资产账户记录及数据
  select t.change_time, t.bank_batch_id
    into l_change_time, l_bank_batch_id
    from fd_trade_co_self_fund t
   inner join fd_base_company_account_self c on t.account_id = c.account_id
   where t.change_id = v_record_id
     and c.account_type = pkg_co_self_account_type.service_fee;

  ---2.检查变动时间
  if trunc(l_change_time, 'dd') < trunc((sysdate - v_adjust_days), 'dd') then
    return pkg_error_code.adjust_timeout;
  end if;

  ---4.检查实体卡相关数据
  select t.account_id, t.record_id
    into l_bank_account_id, v_bank_record_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.use_type = pkg_bank_use_type.service_fee
     and rownum <= 1;

  ---5.获取银行卡账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_ADJUST_SERVICE_RECORD
prompt ============================================
prompt
create or replace function fd_account.fd_f_adjust_service_record(v_record_id      number,
                                                      v_bank_record_id number,
                                                      v_hander_user    varchar2,
                                                      v_memo           varchar2)
  return varchar2 is
  ------------------红冲 手续费-----------------
  l_self_account_id number;
  l_bank_account_id number;
  l_self_balance    number;
  l_bank_balance    number;
  l_change_amount   number;
  l_bank_amount     number;
begin
  ---1.获取资产账户变动信息
  select t.account_id, t.change_amount
    into l_self_account_id, l_change_amount
    from fd_trade_co_self_fund t
   where t.change_id = v_record_id;

  ---2.获取银行卡变动信息
  select t.account_id, t.change_amount
    into l_bank_account_id, l_bank_amount
    from fd_bank_cash_fund t
   where t.record_id = v_bank_record_id;

  if l_change_amount != l_bank_amount then
    return pkg_error_code.change_amount_error;
  end if;

  ---4.锁资产账户
  select t.balance
    into l_self_balance
    from fd_base_company_account_self t
   where t.account_id = l_self_account_id
     for update;

  ---5.锁银行卡账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;

  ---7.更新资产账户余额
  update fd_base_company_account_self t
     set t.balance        = l_self_balance - l_change_amount,
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = l_self_account_id;

  ---8.添加资产账户红冲变动记录
  insert into fd_trade_co_self_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     memo,
     create_user)
    select seq_trade_co_self_fund_id.nextval,
           t.account_id,
           (0 - t.change_amount),
           t.change_type,
           l_self_balance - l_change_amount,
           sysdate,
           t.change_id,
           pkg_sys_boolean.istrue,
           v_memo,
           v_hander_user
      from fd_trade_co_self_fund t
     where t.change_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  update fd_trade_co_self_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.change_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---9.更新银行卡账户余额
  update fd_bank_account_info t
     set t.balance        = l_bank_balance + l_change_amount,
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = l_bank_account_id;

  ---11.添加红冲银行卡变动记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,remark_name)
    select seq_bank_cash_fund_id.nextval,
           l_bank_account_id,
           t.record_id,
           t.company_id,
           (0 - t.change_amount),
           l_bank_balance + l_change_amount,
           sysdate,
           v_hander_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           t.remark_name
      from fd_bank_cash_fund t
     where t.record_id = v_bank_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_bank_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_TRANSFER_CHECK
prompt ============================================
prompt
create or replace function fd_account.fd_f_adjust_transfer_check(v_record_id   number,
                                                      v_adjust_days number)
  return varchar2 is
  ---------------检查转账相关数据是否正确--------------
  l_bank_account_id number;
  l_change_time     date;
  l_bank_batch_id   number;
  l_count           number;
begin

  ---1.检查记录是否正确
  select t.account_id, t.change_time, t.service_id
    into l_bank_account_id, l_change_time, l_bank_batch_id
    from fd_bank_cash_fund t
   where t.record_id = v_record_id
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.use_type = pkg_bank_use_type.transfer
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if l_change_time < (sysdate - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  ---2.检查账户与数据
  select count(1)
    into l_count
    from fd_bank_cash_fund t
   inner join fd_bank_account_info a on t.account_id = a.account_id
   where t.service_id = l_bank_batch_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if (l_count != 2 and l_count != 3) then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_ADJUST_TRANSFER_RECORD
prompt =============================================
prompt
create or replace function fd_account.fd_f_adjust_transfer_record(v_record_id   number,
                                                       v_hander_user varchar2,
                                                       v_memo        varchar2)
  return varchar2 is
  ----------------红冲实体卡转账记录-----------------
  l_out_bank_account_id number;
  l_in_bank_account_id  number;
  l_change_amount       number;
  l_change_type         number;
  l_out_bank_balance    number;
  l_in_bank_balance     number;
  l_bank_batch_id       number; ---转账记录的统一流水编号---查询需要红冲的银行卡变动记录
  l_service_count       number;
  l_service_fee         number;
  l_in_record_id        number;
  l_service_record_id   number;
  l_handle_batch_id     number; ---红冲转账的统一流水号
  l_change_time         date;
begin
  ---1.获取出账记录信息
  select t.account_id,
         t.change_amount,
         t.change_type,
         t.service_id,
         t.change_time
    into l_out_bank_account_id,
         l_change_amount,
         l_change_type,
         l_bank_batch_id,
         l_change_time
    from fd_bank_cash_fund t
   where t.record_id = v_record_id;

  ---2.获取入账记录信息
  select t.record_id, t.account_id
    into l_in_record_id, l_in_bank_account_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.change_type = pkg_bank_fund_change_type.add_amount
     and t.use_type = pkg_bank_use_type.transfer
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  ---3.获取转账银行收取手续费信息
  select count(1), nvl(max(t.change_amount), 0), max(t.record_id)
    into l_service_count, l_service_fee, l_service_record_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.use_type = pkg_bank_use_type.service_fee
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  ---4.锁出账银行卡账户
  select t.balance
    into l_out_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_out_bank_account_id
     for update;

  ---5.锁入账银行卡账户
  select t.balance
    into l_in_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_in_bank_account_id
     for update;

  ---4.修改出账银行卡余额
  update fd_bank_account_info t
     set t.balance        = (l_out_bank_balance + l_change_amount +
                            l_service_fee),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = l_out_bank_account_id;

  ---4.1红冲转账的统一流水号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  ---5.红冲银行卡手续费记录
  if l_service_count > 0 then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
      select seq_bank_cash_fund_id.nextval,
             l_out_bank_account_id,
             t.record_id,
             t.company_id,
             (0 - l_service_fee),
             (l_out_bank_balance + l_service_fee),
             sysdate,
             v_hander_user,
             t.change_type,
             t.use_type,
             pkg_sys_boolean.istrue,
             t.link_channel_name,
             t.link_account_name,
             v_memo,
             l_handle_batch_id,
             t.remark_name
        from fd_bank_cash_fund t
       where t.record_id = l_service_record_id
         and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  
    update fd_bank_cash_fund t
       set t.has_adjust = pkg_sys_boolean.istrue
     where t.record_id = l_service_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  end if;

  ---6.红冲银行卡转账出账记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
    select seq_bank_cash_fund_id.nextval,
           l_out_bank_account_id,
           t.record_id,
           t.company_id,
           (0 - l_change_amount),
           (l_out_bank_balance + l_change_amount + l_service_fee),
           sysdate,
           v_hander_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id
      from fd_bank_cash_fund t
     where t.record_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---7.修改入账账户余额
  update fd_bank_account_info t
     set t.balance        = (l_in_bank_balance - l_change_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = l_in_bank_account_id;

  ---8.红冲银行卡转账入账记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
    select seq_bank_cash_fund_id.nextval,
           l_in_bank_account_id,
           t.record_id,
           t.company_id,
           (0 - l_change_amount),
           (l_in_bank_balance - l_change_amount),
           sysdate,
           v_hander_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id
      from fd_bank_cash_fund t
     where t.record_id = l_in_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_in_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_UP_ADD_CHECK
prompt ==========================================
prompt
create or replace function fd_account.fd_f_adjust_up_add_check(v_record_id   number,
                                                    v_adjust_days number)
  return varchar2 is
  -------------检查加款记录、账户、余额、手续费--------------
  l_record_count number;
  l_change_time  date;
  l_kc_system    varchar2(32) := 'QXKC';
  l_kc_count     number;
begin
  ---0.检查渠道是否为空充渠道
  select count(1)
    into l_kc_count
    from fd_trade_up_manual t
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   inner join fd_base_up_system_map m on c.channel_no = m.channel_no
   inner join fd_base_source_system s on m.source_system_id =
                                         s.source_system_id
   where t.record_id = v_record_id
     and s.source_system_name = l_kc_system;

  if l_kc_count > 0 then
    return pkg_error_code.data_error;
  end if;

  ---1. 检查加款记录、账户及余额
  select count(1), max(t.change_time)
    into l_record_count, l_change_time
    from fd_trade_up_manual t
   inner join fd_base_up_account f on t.account_id = f.account_id
   inner join fd_bank_cash_fund b on t.bank_fund_id = b.service_id
   inner join fd_bank_account_info a on b.account_id = a.account_id
   where t.record_id = v_record_id
     and t.manual_change_type = pkg_up_manual_change_type.add_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and b.has_adjust = pkg_sys_boolean.isfalse
     and t.change_amount = b.change_amount;

  if (l_record_count != 1 and l_record_count != 2) then
    return pkg_error_code.data_error;
  end if;

  if l_change_time < (sysdate - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_UP_ADD_HANDLE
prompt ===========================================
prompt
create or replace function fd_account.fd_f_adjust_up_add_handle(v_record_id   number,
                                                     v_create_user varchar2,
                                                     v_memo        varchar2)
  return varchar2 is
  -------------上游手工加款红冲--------------
  l_up_channel_no         varchar2(32);
  l_pay_account_id        number;
  l_add_change_amount     number;
  l_bank_batch_id         number; ---加款记录的统一流水编号---查询需要红冲的银行卡变动记录
  l_service_change_amount number;
  l_bank_account_id       number;
  l_inner_balance         number;
  l_bank_balance          number;
  l_service_count         number;
  l_fund_record_id        number;
  l_bank_service_id       number;
  l_handle_batch_id       number; ---红冲加款的统一流水号
  l_bank_fund_id          number;
  l_change_time           date;
  l_up_company_id         number;
begin
  --===============获取相关记录数据=================

  ---1. 获取加款数据
  select t.channel_no,
         t.account_id,
         t.change_amount,
         t.bank_fund_id,
         t.change_time,
         c.company_id
    into l_up_channel_no,
         l_pay_account_id,
         l_add_change_amount,
         l_bank_batch_id,
         l_change_time,
         l_up_company_id
    from fd_trade_up_manual t
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.record_id = v_record_id;

  ---2. 获取实体卡加款记录数据
  select t.account_id, t.record_id
    into l_bank_account_id, l_bank_fund_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.use_type = pkg_bank_use_type.up_add
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  ---3. 获取手续费记录数据
  select count(1), nvl(max(t.change_amount), 0), max(t.record_id)
    into l_service_count, l_service_change_amount, l_bank_service_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.use_type = pkg_bank_use_type.service_fee
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  --=================实体卡手续费记录红冲====================
  ---1. 锁实体卡账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;

  ---2.更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + l_service_change_amount +
                            l_add_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_bank_account_id;

  ---2.1获取数据红冲对应的统一流水编号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  if (l_service_count > 0) then
    ---3.红冲实体卡手续费记录
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
      select seq_bank_cash_fund_id.nextval,
             t.account_id,
             t.record_id,
             t.company_id,
             (0 - t.change_amount),
             (l_bank_balance + l_service_change_amount),
             sysdate,
             v_create_user,
             t.change_type,
             t.use_type,
             pkg_sys_boolean.istrue,
             t.link_channel_name,
             t.link_account_name,
             v_memo,
             l_handle_batch_id,
             t.remark_name
        from fd_bank_cash_fund t
       where t.record_id = l_bank_service_id
         and t.has_adjust = pkg_sys_boolean.isfalse;

    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;

    ---4.修改原手续费记录状态
    update fd_bank_cash_fund t
       set t.has_adjust = pkg_sys_boolean.istrue
     where t.record_id = l_bank_service_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  end if;

  --========================实体卡加款记录红冲=============================
  ---1.红冲实体卡下游加款记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0 - t.change_amount),
           (l_bank_balance + l_service_change_amount + l_add_change_amount),
           sysdate,
           v_create_user,
           t.change_type,
           pkg_bank_use_type.up_add,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id,
           t.remark_name
      from fd_bank_cash_fund t
     where t.record_id = l_bank_fund_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---2.修改原实体卡加款纪录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_bank_fund_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --========================渠道账户记录红冲==============================
  ---1. 锁上游支付账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = l_pay_account_id
     for update;

  ---2.修改渠道账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance - l_add_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_pay_account_id;

  ---4.红冲手工加款记录
  select seq_trade_up_fund_id.nextval into l_fund_record_id from dual;

  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
    select l_fund_record_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           pkg_sys_boolean.istrue,
           pkg_up_manual_change_type.red_recharge,
           (0 - t.change_amount),
           sysdate,
           (l_inner_balance - l_add_change_amount),
           v_create_user,
           t.partner_account,
           v_memo
      from fd_trade_up_manual t
     where t.record_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.修改原加款记录状态
  update fd_trade_up_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---6.红冲资金变动中手工加款记录
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_record_id,
     l_up_channel_no,
     l_pay_account_id,
     l_up_company_id,
     (0 - l_add_change_amount),
     (0 - l_add_change_amount),
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance - l_add_change_amount),
     v_memo);
  /*    select l_fund_record_id,
        t.up_channel_no,
        t.up_account_id,
        t.up_company_id,
        (0 - t.up_draw_amount),
        (0 - t.up_real_amount),
        sysdate,
        pkg_up_fund_change_type.add_amount,
        (l_inner_balance - l_add_change_amount),
        v_memo
   from fd_trade_up_fund t
  where t.record_id = v_record_id;*/

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_UP_BORROW_ADD
prompt ===========================================
prompt
create or replace function fd_account.fd_f_adjust_up_borrow_add(v_change_id   number,
                                                     v_create_user varchar2,
                                                     v_memo        varchar2)
  return varchar2 is
  -------------借支类上游加款红冲--------------
  l_pay_account_id    number;
  l_add_change_amount number;
  l_bank_batch_id     number; ---加款记录的统一流水编号---查询需要红冲的银行卡变动记录
  l_inner_balance     number;
  l_fund_record_id    number;
  l_handle_batch_id   number; ---红冲加款的统一流水号
  l_change_time       date;
  l_cap_account_id    number;
  l_record_id         number;
  l_cap_balance       number;
begin
  --===============获取相关记录数据=================
  ---1.获取押金、保证金变动记录
  select t.account_id, t.bank_batch_id, t.change_time
    into l_cap_account_id, l_bank_batch_id, l_change_time
    from fd_trade_co_cap_fund t
   where t.change_id = v_change_id;

  ---2. 获取加款数据
  select t.account_id, t.record_id, t.change_amount
    into l_pay_account_id, l_record_id, l_add_change_amount
    from fd_trade_up_manual t
   where t.bank_fund_id = l_bank_batch_id
     and t.manual_change_type = pkg_up_manual_change_type.cap_add
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  --=================资产账户记录红冲========================
  ---0.获取数据红冲对应的统一流水编号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  ---1.锁资产账户
  select t.balance
    into l_cap_balance
    from fd_base_company_account_cap t
   where t.account_id = l_cap_account_id
     for update;

  ---2.修改资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_cap_balance + l_add_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_cap_account_id;

  ---3.添加资产账户的红冲记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo)
    select seq_trade_co_cap_fund_id.nextval,
           t.account_id,
           (0 - t.change_amount),
           t.change_type,
           (l_cap_balance + l_add_change_amount),
           sysdate,
           t.change_id,
           pkg_sys_boolean.istrue,
           l_handle_batch_id,
           v_memo
      from fd_trade_co_cap_fund t
     where t.change_id = v_change_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---4.修改原记录状态
  update fd_trade_co_cap_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.change_id = v_change_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --========================渠道账户记录红冲==============================
  ---1. 锁上游支付账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = l_pay_account_id
     for update;

  ---2.修改渠道账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance - l_add_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_pay_account_id;

  ---4.红冲手工加款记录
  select seq_trade_up_fund_id.nextval into l_fund_record_id from dual;

  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
    select l_fund_record_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           pkg_sys_boolean.istrue,
           pkg_up_manual_change_type.red_recharge,
           (0 - t.change_amount),
           sysdate,
           (l_inner_balance - l_add_change_amount),
           v_create_user,
           t.partner_account,
           v_memo
      from fd_trade_up_manual t
     where t.record_id = l_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.修改原加款记录状态
  update fd_trade_up_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---6.红冲资金变动中手工加款记录
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
    select l_fund_record_id,
           t.up_channel_no,
           t.up_account_id,
           t.up_company_id,
           (0 - t.up_draw_amount),
           (0 - t.up_real_amount),
           sysdate,
           pkg_up_fund_change_type.add_amount,
           (l_inner_balance - l_add_change_amount),
           v_memo
      from fd_trade_up_fund t
     where t.record_id = l_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_UP_BORROW_ADD_CK
prompt ==============================================
prompt
create or replace function fd_account.fd_f_adjust_up_borrow_add_ck(v_record_id   number,
                                                        v_adjust_days number)
  return varchar2 is
  -------------检查加款记录、账户、余额、手续费--------------
  l_record_count number;
  l_change_time  date;
begin
  ---1. 检查加款记录、账户及余额
  select count(1), max(t.change_time)
    into l_record_count, l_change_time
    from fd_trade_up_manual t
   inner join fd_base_up_account f on t.account_id = f.account_id
   inner join fd_trade_co_cap_fund c on t.bank_fund_id = c.bank_batch_id
   inner join fd_base_company_account_cap ac on c.account_id =
                                                ac.account_id
   where c.change_id = v_record_id
     and t.manual_change_type = pkg_up_manual_change_type.cap_add
     and t.has_adjust = pkg_sys_boolean.isfalse
     and c.has_adjust = pkg_sys_boolean.isfalse
     and t.change_amount = c.change_amount
     and ac.account_type in (pkg_co_cap_account_type.borrow,
          pkg_co_cap_account_type.short_borrow,
          pkg_co_cap_account_type.personal_borrow);

  if (l_record_count != 1) then
    return pkg_error_code.data_error;
  end if;

  if l_change_time < (sysdate - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_UP_DEP_ADD
prompt ========================================
prompt
create or replace function fd_account.fd_f_adjust_up_dep_add(v_record_id   number,
                                                  v_create_user varchar2,
                                                  v_memo        varchar2)
  return varchar2 is
  -------------押金类上游加款红冲--------------
  l_pay_account_id    number;
  l_add_change_amount number;
  l_bank_batch_id     number; ---加款记录的统一流水编号---查询需要红冲的银行卡变动记录
  l_inner_balance     number;
  l_fund_record_id    number;
  l_handle_batch_id   number; ---红冲加款的统一流水号
  l_change_time       date;
  l_cap_account_id    number;
  l_change_id         number;
  l_cap_balance       number;
begin
  --===============获取相关记录数据=================

  ---1. 获取加款数据
  select t.account_id, t.change_amount, t.bank_fund_id, t.change_time
    into l_pay_account_id,
         l_add_change_amount,
         l_bank_batch_id,
         l_change_time
    from fd_trade_up_manual t
   where t.record_id = v_record_id;

  ---2.获取押金、保证金变动记录
  select t.account_id, t.change_id
    into l_cap_account_id, l_change_id
    from fd_trade_co_cap_fund t
   where t.bank_batch_id = l_bank_batch_id
     and t.change_type = pkg_co_cap_fund_type.deposit_up_add
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  --=================资产账户记录红冲========================
  ---0.获取数据红冲对应的统一流水编号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  ---1.锁资产账户
  select t.balance
    into l_cap_balance
    from fd_base_company_account_cap t
   where t.account_id = l_cap_account_id
     for update;

  ---2.修改资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_cap_balance - l_add_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_cap_account_id;

  ---3.添加资产账户的红冲记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo)
    select seq_trade_co_cap_fund_id.nextval,
           t.account_id,
           (0 - t.change_amount),
           t.change_type,
           (l_cap_balance - l_add_change_amount),
           sysdate,
           t.change_id,
           pkg_sys_boolean.istrue,
           l_handle_batch_id,
           v_memo
      from fd_trade_co_cap_fund t
     where t.change_id = l_change_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---4.修改原记录状态
  update fd_trade_co_cap_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.change_id = l_change_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --========================渠道账户记录红冲==============================
  ---1. 锁上游支付账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = l_pay_account_id
     for update;

  ---2.修改渠道账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance - l_add_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_pay_account_id;

  ---4.红冲手工加款记录
  select seq_trade_up_fund_id.nextval into l_fund_record_id from dual;

  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
    select l_fund_record_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           pkg_sys_boolean.istrue,
           pkg_up_manual_change_type.red_recharge,
           (0 - t.change_amount),
           sysdate,
           (l_inner_balance - l_add_change_amount),
           v_create_user,
           t.partner_account,
           v_memo
      from fd_trade_up_manual t
     where t.record_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.修改原加款记录状态
  update fd_trade_up_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---6.红冲资金变动中手工加款记录
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
    select l_fund_record_id,
           t.up_channel_no,
           t.up_account_id,
           t.up_company_id,
           (0 - t.up_draw_amount),
           (0 - t.up_real_amount),
           sysdate,
           pkg_up_fund_change_type.add_amount,
           (l_inner_balance - l_add_change_amount),
           v_memo
      from fd_trade_up_fund t
     where t.record_id = v_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_UP_DEP_ADD_CK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_adjust_up_dep_add_ck(v_record_id   number,
                                                     v_adjust_days number)
  return varchar2 is
  -------------检查加款记录、账户、余额、手续费--------------
  l_record_count number;
  l_change_time  date;
begin
  ---1. 检查加款记录、账户及余额
  select count(1), max(t.change_time)
    into l_record_count, l_change_time
    from fd_trade_up_manual t
   inner join fd_base_up_account f on t.account_id = f.account_id
   inner join fd_trade_co_cap_fund c on t.bank_fund_id = c.bank_batch_id
   inner join fd_base_company_account_cap ac on c.account_id =
                                                ac.account_id
   where t.record_id = v_record_id
     and t.manual_change_type = pkg_up_manual_change_type.add_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and c.has_adjust = pkg_sys_boolean.isfalse
     and t.change_amount = c.change_amount
     and ac.account_type in
         (pkg_co_cap_account_type.deposit, pkg_co_cap_account_type.bond);

  if (l_record_count != 1) then
    return pkg_error_code.data_error;
  end if;

  if l_change_time < (sysdate - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_UP_DRAW_CHECK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_adjust_up_draw_check(v_record_id   number,
                                                     v_adjust_days number)
  return varchar2 is
  -------------检查加款记录、账户、余额、手续费--------------
  l_record_count number;
  l_change_time  date;
  l_kc_system    varchar2(32) := 'QXKC';
  l_kc_count     number;
begin
  ---0.检查渠道是否为空充渠道
  select count(1)
    into l_kc_count
    from fd_trade_up_manual t
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   inner join fd_base_up_system_map m on c.channel_no = m.channel_no
   inner join fd_base_source_system s on m.source_system_id =
                                         s.source_system_id
   where t.record_id = v_record_id
     and s.source_system_name = l_kc_system;

  if l_kc_count > 0 then
    return pkg_error_code.data_error;
  end if;

  ---1. 检查加款记录、账户及余额
  select count(1), max(t.change_time)
    into l_record_count, l_change_time
    from fd_trade_up_manual t
   inner join fd_base_up_account f on t.account_id = f.account_id
   inner join fd_bank_cash_fund b on t.bank_fund_id = b.service_id
   inner join fd_bank_account_info a on b.account_id = a.account_id
   where t.record_id = v_record_id
     and t.manual_change_type = pkg_up_manual_change_type.draw_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and b.has_adjust = pkg_sys_boolean.isfalse
     and t.change_amount = b.change_amount;

  if (l_record_count != 1 and l_record_count != 2) then
    return pkg_error_code.data_error;
  end if;

  if l_change_time < (sysdate - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ADJUST_UP_DRAW_HANDLE
prompt ============================================
prompt
create or replace function fd_account.fd_f_adjust_up_draw_handle(v_record_id   number,
                                                      v_create_user varchar2,
                                                      v_memo        varchar2)
  return varchar2 is
  -------------上游手工提款红冲--------------
  l_up_channel_no         varchar2(32);
  l_pay_account_id        number;
  l_add_change_amount     number;
  l_bank_batch_id         number; ---提款记录的统一流水编号---查询需要红冲的银行卡变动记录
  l_service_change_amount number;
  l_bank_account_id       number;
  l_inner_balance         number;
  l_bank_balance          number;
  l_service_count         number;
  l_fund_record_id        number;
  l_bank_service_id       number;
  l_handle_batch_id       number; ---红冲提款的统一流水号
  l_bank_fund_id          number;
  l_change_time           date;
  l_up_company_id         number;
begin
  --===============获取相关记录数据=================

  ---1. 获取提款数据
  select t.channel_no,
         t.account_id,
         t.change_amount,
         t.bank_fund_id,
         t.change_time,
         c.company_id
    into l_up_channel_no,
         l_pay_account_id,
         l_add_change_amount,
         l_bank_batch_id,
         l_change_time,
         l_up_company_id
    from fd_trade_up_manual t
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.record_id = v_record_id;

  ---2. 获取实体卡提款记录数据
  select t.account_id, t.record_id
    into l_bank_account_id, l_bank_fund_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.use_type = pkg_bank_use_type.up_draw
     and t.change_type = pkg_bank_fund_change_type.add_amount
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  ---3. 获取手续费记录数据
  select count(1), nvl(max(t.change_amount), 0), max(t.record_id)
    into l_service_count, l_service_change_amount, l_bank_service_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.use_type = pkg_bank_use_type.service_fee
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  --=================实体卡手续费记录红冲====================
  ---1. 锁实体卡账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;

  ---2.更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + l_service_change_amount -
                            l_add_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_bank_account_id;

  ---2.1获取数据红冲对应的统一流水编号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  if (l_service_count > 0) then
    ---3.红冲实体卡手续费记录
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
      select seq_bank_cash_fund_id.nextval,
             t.account_id,
             t.record_id,
             t.company_id,
             (0 - t.change_amount),
             (l_bank_balance + l_service_change_amount),
             sysdate,
             v_create_user,
             t.change_type,
             t.use_type,
             pkg_sys_boolean.istrue,
             t.link_channel_name,
             t.link_account_name,
             v_memo,
             l_handle_batch_id,
             t.remark_name
        from fd_bank_cash_fund t
       where t.record_id = l_bank_service_id
         and t.has_adjust = pkg_sys_boolean.isfalse;

    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;

    ---4.修改原手续费记录状态
    update fd_bank_cash_fund t
       set t.has_adjust = pkg_sys_boolean.istrue
     where t.record_id = l_bank_service_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  end if;

  --========================实体卡提款记录红冲=============================
  ---1.红冲实体卡下游提款记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0 - t.change_amount),
           (l_bank_balance + l_service_change_amount - l_add_change_amount),
           sysdate,
           v_create_user,
           t.change_type,
           pkg_bank_use_type.up_add,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id,
           t.remark_name
      from fd_bank_cash_fund t
     where t.record_id = l_bank_fund_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---2.修改原实体卡提款纪录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_bank_fund_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  --========================渠道账户记录红冲==============================
  ---1. 锁上游支付账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = l_pay_account_id
     for update;

  ---2.修改渠道账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance + l_add_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_pay_account_id;

  ---4.红冲手工提款记录
  select seq_trade_up_fund_id.nextval into l_fund_record_id from dual;

  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
    select l_fund_record_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           pkg_sys_boolean.istrue,
           pkg_up_manual_change_type.red_draw,
           (0 - t.change_amount),
           sysdate,
           (l_inner_balance + l_add_change_amount),
           v_create_user,
           t.partner_account,
           v_memo
      from fd_trade_up_manual t
     where t.record_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---5.修改原提款记录状态
  update fd_trade_up_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---6.红冲资金变动中手工提款记录
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_record_id,
     l_up_channel_no,
     l_pay_account_id,
     l_up_company_id,
     (0 - l_add_change_amount),
     (0 - l_add_change_amount),
     sysdate,
     pkg_up_fund_change_type.draw_amount,
     (l_inner_balance + l_add_change_amount),
     v_memo);
  /*    select l_fund_record_id,
        t.up_channel_no,
        t.up_account_id,
        t.up_company_id,
        (0 - t.up_draw_amount),
        (0 - t.up_real_amount),
        sysdate,
        pkg_up_fund_change_type.draw_amount,
        (l_inner_balance + l_add_change_amount),
        v_memo
   from fd_trade_up_fund t
  where t.record_id = v_record_id;*/

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ALL_UN_ORDER_CREATE
prompt ==========================================
prompt
create or replace function fd_account.fd_f_all_un_order_create(v_order_source   number,
                                                    v_trade_order_no varchar2,
                                                    v_up_amount      number,
                                                    v_bill_up_amount number,
                                                    v_user_id        varchar2, --用户id
                                                    v_phone_no       varchar2, ---合约机号码
                                                    v_user_name      varchar2, --用户姓名
                                                    v_id_card_no     varchar2, --身份账号
                                                    v_rec_address    varchar2, --收货地址
                                                    v_sale_user      varchar2, --销售客服
                                                    v_has_invoice    number)
  return varchar2 is
  ------------------------创建非冲订单表订单---------------------
  l_un_order_count number;
begin
  ---1.检查订单非冲订单主表是否有非冲订单
  select count(1)
    into l_un_order_count
    from fd_trade_order_main_un t
   where t.order_source = v_order_source
     and t.trade_order_no = v_trade_order_no;

  if l_un_order_count > 0 then
    return pkg_error_code.success;
  end if;

  ---2.创建非冲订单
  insert into fd_trade_order_main_un
    (fd_order_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     business_type,
     total_face,
     down_order_amount,
     up_phone_amount,
     up_bill_amount,
     user_id,
     phone_no,
     user_name,
     id_card_no,
     rec_address,
     sale_user,
     has_invoice)
    select t.fd_order_id,
           t.down_channel_no,
           t.down_account_id,
           t.down_company_id,
           t.trade_order_no,
           t.ext_order_no,
           t.order_source,
           t.create_time,
           t.order_time,
           t.business_type,
           t.total_face,
           t.down_order_amount,
           v_up_amount,
           v_bill_up_amount,
           v_user_id,
           v_phone_no,
           v_user_name,
           v_id_card_no,
           v_rec_address,
           v_sale_user,
           v_has_invoice
      from fd_trade_order_main t
     where t.order_source = v_order_source
       and t.trade_order_no = v_trade_order_no;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_ALL_UN_ORDER_REFUND
prompt ==========================================
prompt
create or replace function fd_account.fd_f_all_un_order_refund(v_order_source       number,
                                                    v_trade_order_no     varchar2,
                                                    v_down_refund_amount number,
                                                    v_up_refund_amount   number,
                                                    v_bill_refund_amount number)
  return varchar2 is
  -----------------非充订单退款信息记录----------------
begin
  update fd_trade_order_main_un t
     set t.down_order_refund = v_down_refund_amount,
         t.up_phone_refund   = v_up_refund_amount,
         t.up_bill_refund    = v_bill_refund_amount
   where t.order_source = v_order_source
     and t.trade_order_no = v_trade_order_no;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_APPLY_RV_COMPLETE
prompt ========================================
prompt
create or replace function fd_account.fd_f_apply_rv_complete(v_apply_id           number,
                                                  v_channel_no         varchar2,
                                                  v_account_id         number,
                                                  v_deal_rv_type       number,
                                                  v_deal_business_type number,
                                                  v_deal_bill_type     number,
                                                  v_deal_trade_amount  number,
                                                  v_deal_real_amount   number,
                                                  v_deal_user          varchar2,
                                                  v_deal_flow_id       number,
                                                  v_deal_memo          varchar2)
  return varchar2 is
  -------------完成平账申请------------
begin
  update fd_trade_rv_apply t
     set t.apply_status     = pkg_apply_rv_status.apply_complete,
         deal_rv_type       = v_deal_rv_type,
         deal_business_type = v_deal_business_type,
         deal_bill_type     = v_deal_bill_type,
         deal_trade_amount  = v_deal_trade_amount,
         deal_real_amount   = v_deal_real_amount,
         deal_time          = sysdate,
         deal_user          = v_deal_user,
         deal_flow_id       = v_deal_flow_id,
         deal_memo          = v_deal_memo
   where t.apply_id = v_apply_id
     and t.channel_no = v_channel_no
     and t.account_id = v_account_id
     and t.apply_status = pkg_apply_rv_status.apply_submit;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_AUTO_BANK_DAILY_COLLECT
prompt ==============================================
prompt
create or replace function fd_account.fd_f_auto_bank_daily_collect(v_collect_date date)
  return varchar2 is
  ----------------日报表数据收集-----------------
  l_rp_count    number;
  l_rp_amount   number;
  l_fund_date   date;
  l_rp_balance  number;
  l_account_id  number;
  l_change_type number;
begin
  ---1.检查创建日报表记录
  for item in (select a.account_id, a.balance from fd_bank_account_info a) loop
    select count(1)
      into l_rp_count
      from fd_report_bank_daily t
     where t.account_id = item.account_id
       and t.snap_time = trunc(v_collect_date, 'dd')
       and rownum <= 1;
  
    if l_rp_count = 0 then
      insert into fd_report_bank_daily
        (record_id,
         account_id,
         add_amount,
         minus_amount,
         balance,
         snap_time)
      values
        (seq_report_bank_daily_id.nextval,
         item.account_id,
         0,
         0,
         item.balance,
         trunc(v_collect_date, 'dd'));
    end if;
  end loop;

  ---2.收集日报表信息并更新记录
  for item in (select tb.account_id,
                      tb.change_type,
                      tb.l_rp_amount,
                      b.balance
                 into l_account_id, l_change_type, l_rp_amount, l_rp_balance
                 from (select a.account_id,
                              a.change_type,
                              max(trunc(a.change_time, 'dd')) l_fund_date,
                              sum(a.change_amount) l_rp_amount
                         from fd_bank_cash_fund a
                        where trunc(a.change_time, 'dd') =
                              trunc(v_collect_date, 'dd')
                        group by a.account_id, a.change_type) tb
                inner join fd_bank_cash_fund b on b.record_id =
                                                  (select max(l.record_id)
                                                     from fd_bank_cash_fund l
                                                    where trunc(l.change_time,
                                                                'dd') =
                                                          trunc(v_collect_date,
                                                                'dd'))) loop
    if item.change_type = pkg_bank_fund_change_type.add_amount then
      update fd_report_bank_daily t
         set t.add_amount = (t.add_amount + item.l_rp_amount),
             t.balance    = item.balance
       where t.account_id = item.account_id
         and t.snap_time = trunc(v_collect_date, 'dd');
    else
      update fd_report_bank_daily t
         set t.minus_amount = (t.minus_amount + item.l_rp_amount),
             t.balance      = item.balance
       where t.account_id = item.account_id
         and t.snap_time = trunc(v_collect_date, 'dd');
    end if;
  end loop;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_AUTO_CHANNEL_DRAW_GET
prompt ============================================
prompt
create or replace function fd_account.fd_f_auto_channel_draw_get(v_snap_time  date,
                                                      v_account_id number,
                                                      v_company_id number)
  return number is
  ---------------获取渠道交易量-------------
  l_channel_draw number;
begin
  select nvl(sum(t.draw_amount - t.refund_draw_amount), 0)
    into l_channel_draw
    from fd_report_commi_profit_daily t
   where t.snap_time = v_snap_time
     and t.account_id = v_account_id
     and t.company_id = v_company_id;

  return l_channel_draw;
end;
/

prompt
prompt Creating function FD_F_AUTO_DOWN_UP_ADD
prompt =======================================
prompt
create or replace function fd_account.fd_f_auto_down_up_add(v_add_date        in date,
                                                 v_down_channel_no in varchar2,
                                                 v_down_account_id in number,
                                                 v_up_channel_no   in varchar2,
                                                 v_up_account_id   in number)
  return varchar2 is
  ---------上下游更具上游前日交易量加款--------
  l_add_amount    number;
  l_down_balance  number;
  l_down_fund_id  number;
  l_up_balance    number;
  l_up_fund_id    number;
  l_up_company_id number;
begin
  ---1.获取上游交易量
  select sum(t.draw_amount - t.refund_draw_amount)
    into l_add_amount
    from fd_report_commi_profit_daily t
   where t.snap_time = v_add_date
     and t.channel_no = v_up_channel_no
     and t.channel_type = 1;

  ---2.锁下游渠道
  select t.inner_balance
    into l_down_balance
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---3.下游加款
  update fd_base_down_account t
     set t.inner_balance = (l_down_balance + l_add_amount)
   where t.account_id = v_down_account_id;

  ---4.添加下游资金变动
  select seq_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_down_fund_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.add_amount,
     l_add_amount,
     sysdate,
     (l_down_balance + l_add_amount),
     'sys',
     0,
     '-',
     '阿里云店铺-千行通信店自动关联加款');

  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_down_fund_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.add_amount,
     l_add_amount,
     (l_down_balance + l_add_amount),
     '阿里云店铺-千行通信店自动关联加款');

  ---5.锁上游渠道
  select t.inner_balance
    into l_up_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---6.上游渠道加款
  update fd_base_up_account t
     set t.inner_balance = (l_up_balance + l_add_amount)
   where t.account_id = v_up_account_id;

  ---7.添加下游资金变动
  select t.company_id, seq_trade_up_fund_id.nextval
    into l_up_company_id, l_up_fund_id
    from fd_base_up_channel t
   where t.channel_no = v_up_channel_no;

  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.add_amount,
     l_add_amount,
     sysdate,
     (l_up_balance + l_add_amount),
     '阿里云店铺-千行通信店自动关联加款',
     'sys',
     '-',
     0);

  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     l_up_company_id,
     l_add_amount,
     l_add_amount,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_up_balance + l_add_amount),
     '阿里云店铺-千行通信店自动关联加款');

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_DAY_ADD_GET
prompt =========================================
prompt
create or replace function fd_account.fd_f_b2e_up_day_add_get(v_up_account_id number)
  return varchar2 is
  ----------------检查每日加款金额---------------
  l_arrival_amount number;
begin

  --1.获取渠道今天总到账金额
  ---*************************************
  ---@生成自动加款时不存在未完成支付的订单
  ---@生成订单后不会出现其他到账金额
  ---*************************************
  select nvl(sum(t.arrival_success_amount), 0)
    into l_arrival_amount
    from fd_b2e_payment_record_main t
   where t.payment_audit_time >= trunc(sysdate)
     and t.payment_audit_time < trunc(sysdate) + 1
     and t.channel_account_id = v_up_account_id
     and t.arrival_success_amount > 0;

  return l_arrival_amount;

end;
/

prompt
prompt Creating function FD_F_B2E_ADJUST_ADD_AMOUNT
prompt ============================================
prompt
create or replace function fd_account.fd_f_b2e_adjust_add_amount(v_up_account_id       number,
                                                      v_up_add_amount       number,
                                                      v_account_balance     number,
                                                      v_max_account_balance number,
                                                      v_min_add_amount      number,
                                                      v_max_day_add_amount  number)
  return number is
  ------------------根据渠道账户的基础配置调整加款金额-----------------
  l_adjust_add_amount number := v_up_add_amount;
  l_len               number;
begin

  ---1.根据最大余额、最小金额调整加款
  ---***********************************************************
  ---@加款后余额大于最大加款余额，则取加款后刚好为最大余额的金额
  ---@加款金额小于最小加款配置，取最小加款为加款金额
  ---***********************************************************
  if (l_adjust_add_amount + v_account_balance) > v_max_account_balance then
    l_adjust_add_amount := (v_max_account_balance - v_account_balance);
  elsif l_adjust_add_amount < v_min_add_amount then
    l_adjust_add_amount := v_min_add_amount;
  end if;

  ---2.根据单日加款上限调整加款金额
  ---*******************************************************************
  ---@加款后已加款金额大于单日最大加款，取价款后刚好为单日最大加款的金额
  ---*******************************************************************
  if (l_adjust_add_amount + fd_f_b2e_up_day_add_get(v_up_account_id)) >
     v_max_day_add_amount then
    l_adjust_add_amount := v_max_day_add_amount -
                           fd_f_b2e_up_day_add_get(v_up_account_id);
  end if;

  ---3.对加款金额进行取整
  l_len := length(trunc(l_adjust_add_amount)) - 1; ---取整数位个数
  ---除首位后，剩余位数大于3位，后3位取0
  if l_len > 3 then
    l_len := 3;
  end if;
  l_adjust_add_amount := trunc(trunc(l_adjust_add_amount), -1 * l_len); --对非最高位取0

  return l_adjust_add_amount;
end;
/

prompt
prompt Creating procedure FD_P_B2E_WARN_INFO_SET
prompt =========================================
prompt
create or replace procedure fd_account.fd_p_b2e_warn_info_set(v_warn_uniq varchar2,
                                                   v_warn_type number,
                                                   v_title     varchar2,
                                                   v_content   varchar2,
                                                   v_key_word  varchar2) as
  -------------------设置报警信息---------------------
  pragma autonomous_transaction; --自治事务
  l_out_error varchar2(1000);

begin
  ---1.添加报警信息到报警表
  insert into fd_system_warn
    (warn_id,
     uniq_id,
     warn_level,
     warn_type,
     title,
     warn_date,
     content,
     sync_status,
     key_word)
  values
    (seq_system_warn_id.nextval,
     v_warn_uniq,
     5,
     v_warn_type,
     v_title,
     sysdate,
     v_content,
     pkg_balance_sync_status.wait,
     v_key_word);

  commit;
exception
  when others then
    rollback;
    l_out_error := to_char(sqlerrm);
    return;
end;
/

prompt
prompt Creating function FD_F_B2E_AUTO_PAYMENT_REMEDY
prompt ==============================================
prompt
create or replace function fd_account.fd_f_b2e_auto_payment_remedy(v_details_id    number,
                                                        v_submit_status number,
                                                        v_submit_time   date)
  return varchar2 is
  --------------卡单的子支付记录后补-------------
begin
  if v_submit_status = pkg_b2e_details_submit_status.Wait then
    ---1.子记录卡在支付等待状态，系统有问题，报警
    fd_p_b2e_warn_info_set('DS' || to_char(sysdate, 'yyyymmddhh24miss'),
                           pkg_warn_into_type.b2e_add_type,
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           '订单支付卡单.',
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           '银企直连支付卡单超过半小时.',
                           '订单支付卡单');
  else
    if nvl(v_submit_time, (sysdate - 1)) < (sysdate - 10 / 24 / 60) then
      ---2.子记录提交10钟未创建查询，将子记录查询状态设为等待查询状态
      update fd_b2e_payment_record_details t
         set t.submit_error_code = 'unknown',
             t.submit_deal_code  = pkg_deal_code.unknown,
             t.submit_error_msg  = '未知支付结果',
             t.bank_server_id    = 0,
             t.query_status      = Pkg_b2e_details_query_status.wait,
             t.next_query_time   = (sysdate + 1 / 24 / 60)
       where t.record_id = v_details_id
         and t.submit_status = pkg_b2e_details_submit_status.Dealing
         and t.query_status = pkg_b2e_details_query_status.not_start;
    
      if sql%rowcount = 0 then
        return pkg_error_code.data_error;
      end if;
    end if;
  end if;

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function FD_F_B2E_UP_ADD_BASE_CHECK
prompt ============================================
prompt
create or replace function fd_account.fd_f_b2e_up_add_base_check(v_account_id         number,
                                                      v_max_day_add_amount number)
  return varchar2 is
  ----------------检查上游转账白名单信息、及是否有转账信息----------------
  l_white_list_count number;
  l_payment_count    number;
begin

  --1.检查是否超过每日最大加款
  if fd_f_b2e_up_day_add_get(v_account_id) >= v_max_day_add_amount then
    return pkg_error_code.amount_exceed_limit;
  end if;

  --2.检查账户是否有对应的白名单配置
  select count(1)
    into l_white_list_count
    from fd_b2e_up_white_list t
   where t.channel_account_id = v_account_id
     and t.audit_status = pkg_audit_status.Complete;

  if l_white_list_count = 0 then
    return pkg_error_code.white_list_not_exists;
  end if;

  --3.检查账户是否有半小时内的正在执行的转账记录
  ---********************************************************
  ---@账户存在为上游渠道上游加款的记录
  ---@且记录支付未完成，或半小时内未完成加款不允许创建新纪录
  ---********************************************************
  select count(1)
    into l_payment_count
    from fd_b2e_payment_record_main t
   where t.channel_account_id = v_account_id
     and t.recv_type = pkg_recv_type.up_channel
     and t.payment_type = pkg_payment_type.up_add
     and ((t.payment_audit_status in (pkg_b2e_payment_audit_status.wait,
          pkg_b2e_payment_audit_status.dealing)) or
         (t.received_audit_status in (Pkg_b2e_received_status.not_start,
          Pkg_b2e_received_status.dealing) and
         t.payment_audit_time >= sysdate - 30 / 24 / 60))
     and t.expire_time > sysdate;

  if l_payment_count > 0 then
    return pkg_error_code.payment_record_repeat;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_ADD_RECORD_CREATE
prompt ===============================================
prompt
create or replace function fd_account.fd_f_b2e_up_add_record_create(v_up_channel_no    varchar2,
                                                         v_up_account_id    number,
                                                         v_bank_add_type_id number,
                                                         v_bank_account_id  number,
                                                         v_pay_card_no      varchar2,
                                                         v_pay_card_name    varchar2,
                                                         v_white_list_id    number,
                                                         v_up_card_no       varchar2,
                                                         v_up_add_amount    number,
                                                         v_sub_count        number,
                                                         v_sub_max_amount   number,
                                                         v_service_fee      number,
                                                         v_last_sub_amount  number,
                                                         v_last_sub_fee     number,
                                                         v_create_type      number,
                                                         v_expire_time      date,
                                                         v_add_memo         varchar2)
  return varchar2 is
  --------------------添加上游加款记录---------------------
begin

  ---1.添加加款主记录
  insert into fd_b2e_payment_record_main
    (record_id,
     bank_id,
     bank_add_type_id,
     payment_type,
     bank_card_no,
     bank_card_name,
     recv_type,
     channal_no,
     channel_account_id,
     create_time,
     total_amount,
     total_service_fee,
     white_list_id,
     client_receive_card_no,
     sub_record_count,
     int_sub_amount,
     last_sub_amount,
     int_sub_service_fee,
     last_sub_service_fee,
     expire_time,
     payment_audit_type,
     payment_audit_status,
     received_audit_status,
     create_type,
     add_memo)
  values
    (seq_fdb2eupaddmainrecord_id.nextval,
     v_bank_account_id,
     v_bank_add_type_id,
     pkg_payment_type.up_add,
     v_pay_card_no,
     v_pay_card_name,
     pkg_recv_type.up_channel,
     v_up_channel_no,
     v_up_account_id,
     sysdate,
     v_up_add_amount,
     v_service_fee,
     v_white_list_id,
     v_up_card_no,
     v_sub_count,
     v_sub_max_amount,
     v_last_sub_amount,
     decode(v_sub_count,
            1,
            v_service_fee,
            (v_service_fee - v_last_sub_fee) / (v_sub_count - 1)),
     v_last_sub_fee,
     v_expire_time,
     pkg_b2e_amount_audit_status.operate_audit,
     Pkg_b2e_payment_audit_status.wait,
     pkg_b2e_received_status.not_start,
     v_create_type,
     nvl(v_add_memo, '无'));

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_SERVICE_FEE_CALC
prompt ==============================================
prompt
create or replace function fd_account.fd_f_b2e_up_service_fee_calc(v_bank_type  number,
                                                        v_add_type   number,
                                                        v_max_amount number,
                                                        v_amount     number)
  return varchar2 is
  ----------------计算加款方式手续费----------------
  --*金额范围是包含下限，不包含上限
  --*不收取手续费的，不用配置到手续费配置当中
  l_type_count        number;
  l_int_fee           number;
  l_mod_amount        number;
  l_mod_fee           number;
  l_sub_max_amount    number;
  l_service_fee       number;
  l_int_service_count number;
  l_mod_service_count number;
begin
  ---0.没有找到加款方式对应的手续费计算方式，说明没有手续费
  select count(1)
    into l_type_count
    from fd_b2e_bank_payment_service t
   where t.bank_type = v_bank_type
     and t.payment_type = v_add_type;

  if l_type_count = 0 then
    l_service_fee := 0;
    return l_service_fee;
  end if;

  ---1.不拆单将转账金额作为拆单金额来计算，得到拆单只会一笔、没有余额
  select decode(v_max_amount, 0, v_amount, v_max_amount)
    into l_sub_max_amount
    from dual;

  ---2.拆单金额比转账金额还大，将订单金额作为拆单金额，得到拆单只会一笔、没有余额
  if v_max_amount > v_amount then
    l_sub_max_amount := v_amount;
  end if;

  ---3.拆单方式计算手续费（不拆单的变通为拆单）
  ---由于拆单的最大金额部分与余额部分的手续费计算比例等可能不同，所以分开计算
  ---3.1.计算整除部分
  ---防止出现没有整除部分出现手续费所以要*trunc(v_amount / l_sub_max_amount)

  --3.计算整除部分的手续费
  select count(1)
    into l_int_service_count
    from fd_b2e_bank_payment_service t
   where t.bank_type = v_bank_type
     and t.payment_type = v_add_type
     and ((t.min_amount = 0 and t.max_amount = 0) or
         (t.min_amount < l_sub_max_amount and
         t.max_amount >= l_sub_max_amount));

  l_int_fee := 0;
  ---3.1有手续费计算方式时计算手续费
  if l_int_service_count > 0 then
    select case
             when tab.max_service_fee = 0 then
              tab.int_fee --没有手续费限额取计算的手续费
             when tab.int_fee > tab.max_service_fee then
              tab.max_service_fee --计算的手续费比最大手续费大取最大手续费
             else
              tab.int_fee --比最大手续费小取计算的手续费
           end
      into l_int_fee
      from (select (l_sub_max_amount * t.discount + t.single_amount) *
                   trunc(v_amount / l_sub_max_amount) int_fee,
                   t.max_service_fee
              from fd_b2e_bank_payment_service t
             where t.bank_type = v_bank_type
               and t.payment_type = v_add_type
               and ((t.min_amount = 0 and t.max_amount = 0) or
                   (t.min_amount < l_sub_max_amount and
                   t.max_amount >= l_sub_max_amount))
             order by t.max_amount asc) tab
     where rownum <= 1;
  
  end if;

  --4.计算最后一笔的手续费
  l_mod_amount := mod(v_amount, l_sub_max_amount);
  select count(1)
    into l_mod_service_count
    from fd_b2e_bank_payment_service t
   where t.bank_type = v_bank_type
     and t.payment_type = v_add_type
     and ((t.min_amount = 0 and t.max_amount = 0) or
         (t.min_amount < l_mod_amount and t.max_amount >= l_mod_amount));

  l_mod_fee := 0;
  --4.1余数在收取手续费的范围内时计算
  if l_mod_service_count > 0 then
    select case
             when tab.max_service_fee = 0 then
              tab.mod_fee --没有手续费限额取计算的手续费
             when tab.mod_fee > tab.max_service_fee then
              tab.max_service_fee --计算的手续费比最大手续费大取最大手续费
             else
              tab.mod_fee --比最大手续费小取计算的手续费
           end
      into l_mod_fee
      from (select (l_mod_amount * t.discount + t.single_amount) *
                   decode(l_mod_amount, 0, 0, 1) mod_fee,
                   t.max_service_fee
              from fd_b2e_bank_payment_service t
             where t.bank_type = v_bank_type
               and t.payment_type = v_add_type
               and ((t.min_amount = 0 and t.max_amount = 0) or
                   (t.min_amount < l_mod_amount and
                   t.max_amount >= l_mod_amount))
             order by t.max_amount asc) tab
     where rownum <= 1;
  end if;

  l_service_fee := l_int_fee + l_mod_fee;

  return l_service_fee;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_SPLIT_ORDER_CALC
prompt ==============================================
prompt
create or replace function fd_account.fd_f_b2e_up_split_order_calc(v_bank_type       number,
                                                        v_add_type        number,
                                                        v_max_amount      number,
                                                        v_amount          number,
                                                        v_service_fee     out number,
                                                        v_sub_count       out number,
                                                        v_sub_max_amount  out number,
                                                        v_last_sub_amount out number,
                                                        v_last_sub_fee    out number)
  return varchar2 is
  ----------------计算加款方式手续费----------------
  --*金额范围是包含下限，不包含上限
  --*不收取手续费的，不用配置到手续费配置当中
  l_int_fee           number;
  l_mod_amount        number;
  l_mod_fee           number;
  l_int_service_count number;
  l_mod_service_count number;
begin
  ---1.不拆单方式变通为最大拆分金额为加款金额的拆单
  ---*********************************************************
  ---@将单笔没有限额、加款金额小于单笔限额的金额赋值给拆单金额
  ---*********************************************************
  select decode(v_max_amount, 0, v_amount, v_max_amount)
    into v_sub_max_amount
    from dual;

  if v_max_amount > v_amount then
    v_sub_max_amount := v_amount;
  end if;

  ---2.得到拆单条数与最后一笔的金额
  select ceil(v_amount / v_sub_max_amount),
         decode(mod(v_amount, v_sub_max_amount),
                0,
                v_sub_max_amount,
                mod(v_amount, v_sub_max_amount))
    into v_sub_count, v_last_sub_amount
    from dual;

  --3.计算整除部分的手续费
  select count(1)
    into l_int_service_count
    from fd_b2e_bank_payment_service t
   where t.bank_type = v_bank_type
     and t.payment_type = v_add_type
     and ((t.min_amount = 0 and t.max_amount = 0) or
         (t.min_amount < v_sub_max_amount and
         t.max_amount >= v_sub_max_amount));

  l_int_fee := 0;
  ---3.1有手续费计算方式时计算手续费
  if l_int_service_count > 0 then
    select case
             when tab.max_service_fee = 0 then
              tab.int_fee --没有手续费限额取计算的手续费
             when tab.int_fee > tab.max_service_fee then
              tab.max_service_fee --计算的手续费比最大手续费大取最大手续费
             else
              tab.int_fee --比最大手续费小取计算的手续费
           end
      into l_int_fee
      from (select (v_sub_max_amount * t.discount + t.single_amount) *
                   trunc(v_amount / v_sub_max_amount) int_fee,
                   t.max_service_fee
              from fd_b2e_bank_payment_service t
             where t.bank_type = v_bank_type
               and t.payment_type = v_add_type
               and ((t.min_amount = 0 and t.max_amount = 0) or
                   (t.min_amount < v_sub_max_amount and
                   t.max_amount >= v_sub_max_amount))
             order by t.max_amount asc) tab
     where rownum <= 1;
  end if;

  --4.计算最后一笔的手续费
  l_mod_amount := mod(v_amount, v_sub_max_amount);
  select count(1)
    into l_mod_service_count
    from fd_b2e_bank_payment_service t
   where t.bank_type = v_bank_type
     and t.payment_type = v_add_type
     and ((t.min_amount = 0 and t.max_amount = 0) or
         (t.min_amount < l_mod_amount and t.max_amount >= l_mod_amount));

  l_mod_fee := 0;
  --4.1余数在收取手续费的范围内时计算
  if l_mod_service_count > 0 then
    select case
             when tab.max_service_fee = 0 then
              tab.mod_fee --没有手续费限额取计算的手续费
             when tab.mod_fee > tab.max_service_fee then
              tab.max_service_fee --计算的手续费比最大手续费大取最大手续费
             else
              tab.mod_fee --比最大手续费小取计算的手续费
           end
      into l_mod_fee
      from (select (l_mod_amount * t.discount + t.single_amount) *
                   decode(l_mod_amount, 0, 0, 1) mod_fee,
                   t.max_service_fee
              from fd_b2e_bank_payment_service t
             where t.bank_type = v_bank_type
               and t.payment_type = v_add_type
               and ((t.min_amount = 0 and t.max_amount = 0) or
                   (t.min_amount < l_mod_amount and
                   t.max_amount >= l_mod_amount))
             order by t.max_amount asc) tab
     where rownum <= 1;
  end if;

  v_service_fee := l_int_fee + l_mod_fee;

  ---5.最后一笔的手续费
  select decode(l_mod_amount,
                0,
                l_int_fee / trunc(v_amount / v_sub_max_amount),
                l_mod_fee)
    into v_last_sub_fee
    from dual;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_SUB_COUNT_CALC
prompt ============================================
prompt
create or replace function fd_account.fd_f_b2e_up_sub_count_calc(v_max_amount number,
                                                      v_amount     number)
  return varchar2 is
  ----------------计算加款方式需要拆单笔数----------------

  l_sub_max_amount number;
begin
  ---1.不拆单将转账金额作为拆单金额来计算，得到拆单只会一笔、没有余额
  select decode(v_max_amount, 0, v_amount, v_max_amount)
    into l_sub_max_amount
    from dual;

  ---2.拆单金额比转账金额还大，将订单金额作为拆单金额，得到拆单只会一笔、没有余额
  if v_max_amount > v_amount then
    l_sub_max_amount := v_amount;
  end if;

  ---3.返回拆单笔数
  return ceil(v_amount / l_sub_max_amount);
end;
/

prompt
prompt Creating function FD_F_B2E_UP_ADD_TYPE_CHOICE
prompt =============================================
prompt
create or replace function fd_account.fd_f_b2e_up_add_type_choice(v_up_channel_no      varchar2,
                                                       v_up_account_id      number,
                                                       v_up_add_amount      number,
                                                       v_work_day_type      number,
                                                       v_channel_company_id number,
                                                       v_min_service_fee    out number,
                                                       v_bank_type          out number,
                                                       v_bank_add_type_id   out number,
                                                       v_bank_account_id    out number,
                                                       v_pay_card_no        out varchar2,
                                                       v_pay_card_name      out varchar2,
                                                       v_sub_count          out number,
                                                       v_sub_max_amount     out number,
                                                       v_last_sub_amount    out number,
                                                       v_last_sub_fee       out number,
                                                       v_expire_time        out date,
                                                       v_need_same_bank     out number)
  return varchar2 is
  ------------------上游加款方式选择-----------------
  l_result     varchar2(32);
  l_add_type   number;
  l_max_amount number;
begin
  ---1.按拆单次数最少、手续费最少的方式选出启用、在可用时间范围内的加款方式
  select tab.id,
         tab.bank_type,
         tab.bank_payment_type,
         tab.max_amount,
         tab.is_same_bank,
         tab.bank_account_id,
         tab.card_no,
         tab.account_name,
         tab.end_time
    into v_bank_add_type_id,
         v_bank_type,
         l_add_type,
         l_max_amount,
         v_need_same_bank,
         v_bank_account_id,
         v_pay_card_no,
         v_pay_card_name,
         v_expire_time
    from (select r.id,
                 r.bank_type,
                 r.bank_payment_type,
                 r.max_amount,
                 r.is_same_bank,
                 r.bank_account_id,
                 f.card_no,
                 f.account_name,
                 to_date(to_char(sysdate, 'yyyymmdd') || r.use_end_time,
                         'yyyymmddhh24miss') end_time
            from fd_b2e_bank_payment_account r
           inner join fd_bank_account_info f
              on r.bank_account_id = f.account_id
           inner join fd_b2e_up_white_list l
              on (r.rcv_card_type = l.rcv_card_type or
                 l.rcv_card_type = pkg_rcv_card_type.is_all)
             and l.channel_no = v_up_channel_no
             and l.channel_account_id = v_up_account_id
             and l.audit_status = pkg_audit_status.Complete
           where r.work_day_type in
                 (v_work_day_type, pkg_work_day_type.all_days)
             and to_date(to_char(sysdate, 'yyyymmdd') || r.use_start_time,
                         'yyyymmddhh24miss') <= sysdate
             and to_date(to_char(sysdate, 'yyyymmdd') || r.use_end_time,
                         'yyyymmddhh24miss') >= sysdate
             and r.status = pkg_sys_boolean.istrue
             and f.company_id = v_channel_company_id
             and r.is_same_bank in
                 (decode(r.bank_type, l.bank_type, 1, 2),
                  pkg_b2e_same_bank_type.is_all)
           order by l.sort_id desc,
                    r.sort_id desc,
                    fd_f_b2e_up_sub_count_calc(r.max_amount, v_up_add_amount),
                    fd_f_b2e_up_service_fee_calc(r.bank_type,
                                                 r.bank_payment_type,
                                                 r.max_amount,
                                                 v_up_add_amount) asc) tab
   where rownum <= 1;

  ---2.计算出选出加款方式的手续费、拆单、最后一笔订单信息
  l_result := fd_f_b2e_up_split_order_calc(v_bank_type,
                                           l_add_type,
                                           l_max_amount,
                                           v_up_add_amount,
                                           v_min_service_fee,
                                           v_sub_count,
                                           v_sub_max_amount,
                                           v_last_sub_amount,
                                           v_last_sub_fee);

  return l_result;

exception
  when others then
    ---3.没有可选的加款方式，报警
    fd_p_b2e_warn_info_set('AT' || to_char(sysdate, 'yyyymmddhh24miss'),
                           pkg_warn_into_type.b2e_add_type,
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           ' 自动生成加款失败.',
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           '没有可选加款方式.',
                           '银企直连没有可选加款方式');
  
    return pkg_error_code.bank_payment_type_error;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_HALFHOURS_GET
prompt ===========================================
prompt
create or replace function fd_account.fd_f_b2e_up_halfhours_get(v_up_account_id       number,
                                                     v_up_channel_no       varchar2,
                                                     v_account_balance     number,
                                                     v_max_day_add_amount  number,
                                                     v_max_account_balance number,
                                                     v_min_add_amount      number,
                                                     v_amount_calc_type    varchar2,
                                                     v_trade_duration      number,
                                                     v_up_add_amount       out number)
  return varchar2 is
  -----------------上游加款金额计算-----------------

  l_trade_amount         number;
  l_trade_start_time     date;
  l_morning_start_time   date := trunc(sysdate) + 8 / 24;
  l_morning_end_time     date := trunc(sysdate) + 9 / 24;
  l_afternoon_start_time date := trunc(sysdate) + 20 / 24;
  l_afternoon_end_time   date := trunc(sysdate) + 21 / 24;
begin
  ---1.获取渠道半小时交易金额的对应倍数的加款金额
  v_up_add_amount := 0;
  if v_amount_calc_type = 'default' then
    for item in (select s.source_system_id
                   from fd_base_up_system_map s
                  where s.channel_no = v_up_channel_no) loop
      begin
      
        select nvl(max(tab.trade_amount), 0) * v_trade_duration * 2,
               nvl(max(tab.collect_time), sysdate)
          into l_trade_amount, l_trade_start_time
          from (select t.trade_amount, t.collect_time
                  from fd_report_channel_halfhour t
                 where t.collect_time >= (sysdate - 2 / 24)
                   and t.collect_time < sysdate
                   and t.channel_type = pkg_channel_type.up_channel
                   and t.order_source = item.source_system_id
                   and t.channel_no = v_up_channel_no
                 order by t.collect_time desc) tab
         where rownum <= 1;
      
        ---2.早上八点到九点的交易量翻倍，晚上八点到九点的交易量减半
        if (l_trade_start_time >= l_morning_start_time and
           l_trade_start_time < l_morning_end_time) then
        
          l_trade_amount := l_trade_amount * 2;
        elsif (l_trade_start_time >= l_afternoon_start_time and
              l_trade_start_time < l_afternoon_end_time) then
        
          l_trade_amount := l_trade_amount * 0.5;
        end if;
      
        v_up_add_amount := v_up_add_amount + l_trade_amount;
      end;
    end loop;
  end if;

  ---3.检查加款金额是否在合理区间内
  v_up_add_amount := fd_f_b2e_adjust_add_amount(v_up_account_id,
                                                v_up_add_amount,
                                                v_account_balance,
                                                v_max_account_balance,
                                                v_min_add_amount,
                                                v_max_day_add_amount);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_RECEIVE_CARD_GET
prompt ==============================================
prompt
create or replace function fd_account.fd_f_b2e_up_receive_card_get(v_up_channel_no  varchar2,
                                                        v_up_account_id  number,
                                                        v_bank_type      number,
                                                        v_need_same_bank number,
                                                        v_white_list_id  out number,
                                                        v_up_card_no     out varchar2)
  return varchar2 is
  -----------------获取上游收款银行卡---------------
  l_up_card_name varchar2(32);
begin
  select tab.id, tab.holder_card_no, tab.bank_holder_name
    into v_white_list_id, v_up_card_no, l_up_card_name
    from (select t.id, t.holder_card_no, t.bank_holder_name, t.rcv_card_type
            from fd_b2e_up_white_list t
           where t.channel_no = v_up_channel_no
             and t.channel_account_id = v_up_account_id
             and t.audit_status = pkg_audit_status.Complete
             and v_need_same_bank in
                 (decode(t.bank_type, v_bank_type, 1, 2),
                  pkg_b2e_same_bank_type.is_all)
           order by t.rcv_card_type,
                    decode(t.bank_type, v_bank_type, 0, 1) asc) tab
   where rownum <= 1;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_AUTO_UP_CHANNEL_ADD
prompt ==============================================
prompt
create or replace function fd_account.fd_f_b2e_auto_up_channel_add(v_up_account_id       number,
                                                        v_up_channel_no       varchar2,
                                                        v_channel_company_id  number,
                                                        v_work_day_type       number,
                                                        v_amount_calc_type    varchar2,
                                                        v_trade_duration      number,
                                                        v_account_balance     number,
                                                        v_min_add_amount      number,
                                                        v_max_day_add_amount  number,
                                                        v_max_account_balance number)
  return varchar2 is
  ---------------渠道自动加款-------------
  l_result           varchar2(32);
  l_pay_card_no      varchar2(32);
  l_pay_card_name    varchar2(32);
  l_up_card_no       varchar2(32);
  l_up_add_amount    number;
  l_min_service_fee  number;
  l_bank_type        number;
  l_bank_add_type_id number;
  l_bank_account_id  number;
  l_sub_count        number;
  l_sub_max_amount   number;
  l_last_sub_amount  number;
  l_last_sub_fee     number;
  l_white_list_id    number;
  l_expire_time      date;
  l_need_same_bank   number;
begin
  ---1.对账户生成加款记录进行条件检查
  l_result := fd_f_b2e_up_add_base_check(v_up_account_id,
                                         v_max_day_add_amount);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---2.通过往期交易量预测本次加款金额
  --fd_f_b2e_up_add_amount_calc
  l_result := fd_f_b2e_up_halfhours_get(v_up_account_id,
                                        v_up_channel_no,
                                        v_account_balance,
                                        v_max_day_add_amount,
                                        v_max_account_balance,
                                        v_min_add_amount,
                                        v_amount_calc_type,
                                        v_trade_duration,
                                        l_up_add_amount);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---3.选择拆单次数最少、手续费最少的一条加款方式
  l_result := fd_f_b2e_up_add_type_choice(v_up_channel_no,
                                          v_up_account_id,
                                          l_up_add_amount,
                                          v_work_day_type,
                                          v_channel_company_id,
                                          l_min_service_fee,
                                          l_bank_type,
                                          l_bank_add_type_id,
                                          l_bank_account_id,
                                          l_pay_card_no,
                                          l_pay_card_name,
                                          l_sub_count,
                                          l_sub_max_amount,
                                          l_last_sub_amount,
                                          l_last_sub_fee,
                                          l_expire_time,
                                          l_need_same_bank);
  if l_result = pkg_error_code.bank_payment_type_error then
    commit;
  end if;
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---4.获取要加款的客户的收款银行，同行优先
  l_result := fd_f_b2e_up_receive_card_get(v_up_channel_no,
                                           v_up_account_id,
                                           l_bank_type,
                                           l_need_same_bank,
                                           l_white_list_id,
                                           l_up_card_no);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---5.添加加款的主记录
  l_result := fd_f_b2e_up_add_record_create(v_up_channel_no,
                                            v_up_account_id,
                                            l_bank_add_type_id,
                                            l_bank_account_id,
                                            l_pay_card_no,
                                            l_pay_card_name,
                                            l_white_list_id,
                                            l_up_card_no,
                                            l_up_add_amount,
                                            l_sub_count,
                                            l_sub_max_amount,
                                            l_min_service_fee,
                                            l_last_sub_amount,
                                            l_last_sub_fee,
                                            pkg_b2e_create_type.auto_create,
                                            l_expire_time,
                                            '无');

  return l_result;
end;
/

prompt
prompt Creating function FD_F_B2E_BANK_ACCOUNT_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_b2e_bank_account_check(v_bank_account_id number,
                                                       v_card_no         varchar2,
                                                       v_bank_acc_name   varchar2,
                                                       v_bank_type       number,
                                                       v_query_balance   number)
  return varchar2 is
  -----------------查询银行账户检查----------------
  l_account_id number;
begin
  ---1.检查查询余额
  if v_query_balance <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查银行账户
  select t.account_id
    into l_account_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     and t.card_no = v_card_no
     and t.account_name = v_bank_acc_name
     and t.bank_type = v_bank_type;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.bank_account_id_error;
end;
/

prompt
prompt Creating function FD_F_B2E_BANK_BALANCE_SAVE
prompt ============================================
prompt
create or replace function fd_account.fd_f_b2e_bank_balance_save(v_bank_account_id number,
                                                      v_card_no         varchar2,
                                                      v_bank_acc_name   varchar2,
                                                      v_bank_type       number,
                                                      v_query_balance   number)
  return varchar2 is
  ---------------银行查询余额保存--------------
begin

  ---1.修改银行查询余额
  update fd_bank_account_info t
     set t.query_balance = v_query_balance, t.query_time = sysdate
   where t.account_id = v_bank_account_id;

  ---2.添加银行余额查询记录
  insert into fd_b2e_bank_query_record
    (record_id,
     bank_account_id,
     card_no,
     bank_acc_name,
     bank_type,
     query_balance,
     query_time)
  values
    (seq_b2e_bank_query_id.nextval,
     v_bank_account_id,
     v_card_no,
     v_bank_acc_name,
     v_bank_type,
     v_query_balance,
     sysdate);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_CO_RECV_CHECK
prompt ========================================
prompt
create or replace function fd_account.fd_f_b2e_co_recv_check(v_recv_record_id  number,
                                                  v_bank_account_id out number,
                                                  v_service_fee     out number)
  return varchar2 is
  -----------------银企直连银行记录检查--------------------
  l_bank_balance number;
begin
  ---1.检查银行支出记录及银行信息是否正确
  select t.bank_account_id, t.receive_amount, b.balance
    into v_bank_account_id, v_service_fee, l_bank_balance
    from fd_b2e_bank_receive_record t
   inner join fd_bank_account_info b on t.bank_account_id = b.account_id
   where t.record_id = v_recv_record_id
     and t.trade_type = pkg_b2e_recv_trade_type.payment
     and t.deal_status = pkg_b2e_deal_status.wait
     and b.is_b2e = pkg_sys_boolean.istrue;

  ---2.检查银行卡余额是否足够
  if l_bank_balance < v_service_fee then
    return pkg_error_code.balance_low;
  end if;

  ---3.用状态锁记录，将支付记录设为正在处理，将基础信息存入记录
  update fd_b2e_bank_receive_record t
     set t.deal_status        = pkg_b2e_deal_status.dealing,
         t.match_type         = Pkg_b2e_recv_match_type.user_match,
         t.channel_no         = '-',
         t.channel_account_id = 0,
         t.channal_type       = pkg_channel_type.none,
         t.receive_type       = pkg_receive_type.service_fee
   where t.record_id = v_recv_record_id
     and t.trade_type = pkg_b2e_recv_trade_type.payment
     and t.deal_status = pkg_b2e_deal_status.wait;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_B2E_CO_SERVICE_ADJUST
prompt ============================================
prompt
create or replace function fd_account.fd_f_b2e_co_service_adjust(v_recv_record_id    number,
                                                      v_adjust_days       number,
                                                      v_service_record_id out number)
  return varchar2 is
  -------------银行手续费记录检查，并红冲该记录--------------
  l_service_fee number;
  l_deal_time   date;
begin
  ---1.检查记录是否为已完成的手续费记录
  select t.receive_amount, t.deal_time
    into l_service_fee, l_deal_time
    from fd_b2e_bank_receive_record t
   inner join fd_bank_account_info b on t.bank_account_id = b.account_id
   where t.record_id = v_recv_record_id
     and t.deal_status = pkg_b2e_deal_status.success
     and t.receive_type = pkg_receive_type.service_fee
     and t.trade_type = pkg_b2e_recv_trade_type.payment
     and t.deal_time >= (trunc(sysdate) - v_adjust_days);

  ---2.获取手续费账户资金变动记录
  select t.change_id
    into v_service_record_id
    from fd_trade_co_self_fund t
   where t.change_time > (l_deal_time - 1 / 24)
     and t.change_time < (l_deal_time + 1 / 24)
     and t.change_type = pkg_co_self_fund_type.add_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.memo like v_recv_record_id || '%'
     and rownum <= 2;

  ---3.还原银行记录到未记录手续费之前
  update fd_b2e_bank_receive_record t
     set t.deal_status        = pkg_b2e_deal_status.wait,
         t.match_type         = Pkg_b2e_recv_match_type.user_match,
         t.channel_no         = null,
         t.channel_account_id = null,
         t.channal_type       = null,
         t.receive_type       = null,
         t.deal_user          = null,
         t.deal_time          = null,
         t.deal_memo          = null
   where t.record_id = v_recv_record_id
     and t.trade_type = pkg_b2e_recv_trade_type.payment
     and t.deal_status = pkg_b2e_deal_status.success
     and t.trade_type = pkg_b2e_recv_trade_type.payment;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_B2E_CO_SERVICE_COMPLETE
prompt ==============================================
prompt
create or replace function fd_account.fd_f_b2e_co_service_complete(v_recv_record_id number,
                                                        v_hander_user    varchar2,
                                                        v_memo           varchar2)
  return varchar2 is
  -----------------完成银企直连手续费录入---------------
begin

  update fd_b2e_bank_receive_record t
     set t.deal_status = pkg_b2e_deal_status.success,
         t.deal_user   = v_hander_user,
         t.deal_time   = sysdate,
         t.deal_memo   = v_memo
   where t.record_id = v_recv_record_id
     and t.trade_type = pkg_b2e_recv_trade_type.payment
     and t.deal_status = pkg_b2e_deal_status.dealing;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_DETAILS_CREATE
prompt =========================================
prompt
create or replace function fd_account.fd_f_b2e_details_create(v_main_record_id         number,
                                                   v_bank_payment_type      number,
                                                   v_sub_amount             number,
                                                   v_service_fee            number,
                                                   v_expire_time            date,
                                                   v_up_add_mq              varchar2,
                                                   v_merchant_no            varchar2,
                                                   v_user_no                varchar2,
                                                   v_user_password          varchar2,
                                                   v_token_key              varchar2,
                                                   v_language               varchar2,
                                                   v_currency_code          varchar2,
                                                   v_app_id                 varchar2,
                                                   v_app_ver                varchar2,
                                                   v_up_receive_card_no     varchar2,
                                                   v_up_receive_card_name   varchar2,
                                                   v_up_receive_bank_code   varchar2,
                                                   v_up_receive_open_bank   varchar2,
                                                   v_up_receive_card_type   number,
                                                   v_up_receive_area_code   varchar2,
                                                   v_up_receive_province    varchar2,
                                                   v_up_receive_city        varchar2,
                                                   v_payment_bank_id        number,
                                                   v_payment_bank_card_no   varchar2,
                                                   v_payment_bank_card_name varchar2,
                                                   v_is_same_area           number,
                                                   v_is_same_bank           number,
                                                   v_payment_code           varchar2,
                                                   v_memo                   varchar2,
                                                   v_add_memo               varchar2)
  return varchar2 is
  -----------------创建支付子记录及任务----------------
  l_content          varchar2(1024);
  l_task_id          number;
  l_sub_record_id    number;
  l_task_create_time date;
begin
  ---1.获取任务记编号、子录编号、任务创建时间
  select seq_fdb2ebanktask_auto_id.nextval,
         seq_fdb2eupaddsubrecord_id.nextval,
         sysdate
    into l_task_id, l_sub_record_id, l_task_create_time
    from dual;

  ---2.拼接任务信息
  l_content := '{"task_id":"' || to_char(l_task_id) ||
               '","sub_record_id":"' || l_sub_record_id ||
               '","merchant_no":"' || v_merchant_no || '","user_no":"' ||
               v_user_no || '","user_password":"' || v_user_password ||
               '","language":"' || v_language || '","app_id":"' || v_app_id ||
               '","app_ver":"' || v_app_ver || '","record_id":"' ||
               l_sub_record_id || '","receive_card_no":"' ||
               v_up_receive_card_no || '","receive_card_name":"' ||
               v_up_receive_card_name || '","deal_time":"' ||
               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
               '","create_time":"' || to_char(sysdate, 'yyyymmddhh24miss') ||
               '","total_amount":"' ||
               to_char(v_sub_amount, 'fm999999990.99') || '","bank_name":"' ||
               v_up_receive_open_bank || '","province":"' ||
               v_up_receive_province || '","city":"' || v_up_receive_city ||
               '","rcv_card_type":"' || v_up_receive_card_type ||
               '","currency_code":"' || v_currency_code ||
               '","bank_account_id":"' || v_payment_bank_id ||
               '","bank_card_no":"' || v_payment_bank_card_no ||
               '","bank_card_name":"' || v_payment_bank_card_name ||
               '","bank_code":"' || v_up_receive_bank_code ||
               '","is_same_area":"' || v_is_same_area ||
               '","is_same_bank":"' || v_is_same_bank || '","add_type":"' ||
               v_bank_payment_type || '","payment_code":"' ||
               v_payment_code || '","token_key":"' || v_token_key ||
               '","memo":"' || v_memo || '","add_memo":"' || v_add_memo || '"}';

  ---3.添加子记录
  insert into fd_b2e_payment_record_details
    (record_id,
     main_record_id,
     create_time,
     client_card_no,
     client_holder_name,
     is_same_bank,
     client_card_type,
     client_bank_code,
     client_bank_name,
     client_bank_addr,
     client_area_code,
     total_amount,
     total_service_fee,
     submit_remark,
     submit_status,
     query_status)
  values
    (l_sub_record_id,
     v_main_record_id,
     sysdate,
     v_up_receive_card_no,
     v_up_receive_card_name,
     v_is_same_bank,
     v_up_receive_card_type,
     v_up_receive_bank_code,
     v_up_receive_open_bank,
     v_up_receive_open_bank,
     v_up_receive_area_code,
     v_sub_amount,
     v_service_fee,
     v_memo,
     pkg_b2e_details_submit_status.Wait,
     pkg_b2e_details_query_status.not_start);

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  ---4.添加对应支付任务记录
  insert into fd_b2e_bank_task
    (task_id,
     task_type,
     record_id,
     mq_name,
     task_status,
     create_time,
     content,
     timeout_time)
  values
    (l_task_id,
     pkg_task_type.payment,
     l_sub_record_id,
     v_up_add_mq,
     pkg_task_status.NotStart,
     l_task_create_time,
     l_content,
     v_expire_time);

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_DOWN_ADD_COMPLATE
prompt ============================================
prompt
create or replace function fd_account.fd_f_b2e_down_add_complate(v_recv_record_id  number,
                                                      v_down_channel_no varchar2,
                                                      v_down_account_id number,
                                                      v_bank_batch_id   number,
                                                      v_create_user     varchar2,
                                                      v_apply_id        number,
                                                      v_memo            varchar2)
  return varchar2 is
  -----------------修改下游收款记录状态为加款完成-----------------
begin
  update fd_b2e_bank_receive_record t
     set t.sys_fund_id        = v_bank_batch_id,
         t.channel_no         = v_down_channel_no,
         t.channel_account_id = v_down_account_id,
         t.channal_type       = pkg_channel_type.down_channel,
         t.receive_type       = pkg_receive_type.down_add,
         t.deal_status        = Pkg_b2e_deal_status.success,
         t.deal_user          = v_create_user,
         t.deal_time          = sysdate,
         t.deal_memo          = v_memo,
         t.apply_id           = v_apply_id
   where t.record_id = v_recv_record_id
     and t.deal_status = Pkg_b2e_deal_status.Dealing;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_DOWN_ADD_GET
prompt =======================================
prompt
create or replace function fd_account.fd_f_b2e_down_add_get(v_recv_record_id     number,
                                                 v_down_channel_no    varchar2,
                                                 v_channel_account_id number,
                                                 v_bank_account_id    out number,
                                                 v_receive_amount     out number,
                                                 v_down_card_no       out varchar2)
  return varchar2 is
  -----------------获取下游加款相关信息-------------------
  l_white_count        number;
  l_channel_account_id number;
  l_down_channel       varchar2(32);
begin
  ---1.检查下游收款记录状态
  select t.bank_account_id, t.receive_amount, t.client_card_no
    into v_bank_account_id, v_receive_amount, v_down_card_no
    from fd_b2e_bank_receive_record t
   where t.record_id = v_recv_record_id
     and t.deal_status = Pkg_b2e_deal_status.Wait
     for update;

  ---2.判断下游付款银行是否在白名单中，不在或匹配不正确返回错误
  select count(1), max(t.down_channel_no), max(t.channel_account_id)
    into l_white_count, l_down_channel, l_channel_account_id
    from fd_b2e_down_white_list t
   where t.down_holder_card_no = v_down_card_no
     and t.audit_status = pkg_audit_status.Complete
     and t.channel_account_id=v_channel_account_id;

  if l_white_count = 0 or l_down_channel != v_down_channel_no or
     l_channel_account_id != v_channel_account_id then
    return pkg_error_code.channel_match_error;
  end if;

  ---3.修改记录加款状态
  update fd_b2e_bank_receive_record t
     set t.deal_status = Pkg_b2e_deal_status.Dealing
   where t.record_id = v_recv_record_id
     and t.deal_status = Pkg_b2e_deal_status.Wait;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_B2E_DOWN_CHECK
prompt =====================================
prompt
create or replace function fd_account.fd_f_b2e_down_check(v_channel_no in varchar2, --渠道编号
                                               l_add_amount out number, --加款金额
                                               l_auto_add_on_time out date--自动加款开启时间
                                               ) return varchar2 is
  ---------------------------------
  --功能：判断渠道是否满足自动加款条件
  --创建人：周荣省
  --创建时间：2019-09-16
  ---------------------------------
  l_auto_add   number;
begin
  --1、判断渠道是否开启自动加款
  select t.auto_add, t.auto_amount,t.auto_add_on_time
    into l_auto_add, l_add_amount,l_auto_add_on_time
    from fd_base_down_channel t
   where t.channel_no = v_channel_no;
  --1.1判断开启状态
  if l_auto_add != 0 then
    return pkg_error_code.data_error;
  end if;
  return pkg_error_code.success;
exception
  when others then
    rollback;
    return pkg_error_code.not_exists;
end;
/

prompt
prompt Creating function FD_F_B2E_FORECAST_SAVE
prompt ========================================
prompt
create or replace function fd_account.fd_f_b2e_forecast_save(v_up_channel_no  varchar2,
                                                  v_time_now       date,
                                                  v_trade_duration number,
                                                  v_last_amount    number,
                                                  v_up_add_amount  number,
                                                  v_growth_rate0   number,
                                                  v_growth_rate1   number,
                                                  v_growth_rate2   number,
                                                  v_growth_rate3   number,
                                                  v_trade_rate0    number,
                                                  v_trade_rate1    number,
                                                  v_trade_rate2    number,
                                                  v_trade_rate3    number)
  return varchar2 is
  --------------保存预测计算信息-----------
  l_params varchar2(1024);
begin
  ---1.拼接预测参数信息
  l_params := '(' || round(v_growth_rate0, 5) || ',' ||
              round(v_growth_rate1, 5) || ',' || round(v_growth_rate2, 5) || ',' ||
              round(v_growth_rate3, 5) || ')' || '|' || v_last_amount || '|' || '(' ||
              round(v_trade_rate0, 5) || ',' || round(v_trade_rate1, 5) || ',' ||
              round(v_trade_rate2, 5) || ',' || round(v_trade_rate3, 5) || ')';

  ---2.将信息插入记录表
  insert into fd_b2e_up_forecast
    (start_time,
     end_time,
     up_channel_no,
     forecast_amount,
     real_amount,
     memo)
  values
    (v_time_now,
     v_time_now + v_trade_duration / 24,
     v_up_channel_no,
     v_up_add_amount,
     0,
     l_params);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_MONTH_DATE_CALC
prompt ==========================================
prompt
create or replace function fd_account.fd_f_b2e_month_date_calc(v_date_now date, ---当期日期
                                                    v_calc_num number ---计算往期的月份差
                                                    ) return date is
  -------------------往期对应日期计算------------------
  l_now_is_last     number;
  l_before_is_last  number;
  l_date_before     date;
  l_now_last_day    date;
  l_before_last_day date;
begin
  --1.计算当期、往期日期是否为对应月份的最后一天
  l_date_before     := add_months(v_date_now, v_calc_num); --往期的日期
  l_now_last_day    := last_day(v_date_now); --当期最后一天
  l_before_last_day := last_day(l_date_before); --往期最后一天

  select decode(v_date_now, l_now_last_day, 0, 1),
         decode(l_date_before, l_before_last_day, 0, 1)
    into l_now_is_last, l_before_is_last --当期与往期是否为最后一天的判断
    from dual;

  --2.计算往期日期
  ---***************************************************
  ---@不同时为最后一天时，当期是最后一天往期设为最后一天
  ---@当期不为最后一天，往期为最后一天的前一天
  ---***************************************************
  if l_now_is_last != l_before_is_last then
    if l_now_is_last = 0 then
      l_date_before := l_before_last_day;
    else
      l_date_before := l_before_last_day - 1;
    end if;
  end if;

  return l_date_before;
end;
/

prompt
prompt Creating function FD_F_B2E_GROWTH_RATE_CALC
prompt ===========================================
prompt
create or replace function fd_account.fd_f_b2e_growth_rate_calc(v_order_source       number,
                                                     v_current_start_time date,
                                                     v_current_end_time   date)
  return number is
  -------------------当前时间与往期对比计算交易增长率---------------------
  l_current_amount    number;
  l_before_amount     number;
  l_before_start_time date;
  l_before_end_time   date;
begin

  ---1.计算上期日期
  ---***********************************************************
  ---@避免当期与往期有无31号的差异，加上时间差的方式求结束时间
  ---***********************************************************
  l_before_start_time := fd_f_b2e_month_date_calc(v_current_start_time, -1);
  l_before_end_time   := l_before_start_time +
                         (v_current_end_time - v_current_start_time);

  ---2.计算当期系统交易量
  select sum(t.trade_amount)
    into l_current_amount
    from fd_report_channel_halfhour t
   where t.collect_time >= v_current_start_time
     and t.collect_time < v_current_end_time
     and t.channel_type = pkg_channel_type.up_channel
     and t.order_source = v_order_source;

  ---3.计算往期系统交易量
  select sum(t.trade_amount)
    into l_before_amount
    from fd_report_channel_halfhour t
   where t.collect_time >= l_before_start_time
     and t.collect_time < l_before_end_time
     and t.channel_type = pkg_channel_type.up_channel
     and t.order_source = v_order_source;

  ---4.计算交易增长率,为空不增长
  return nvl(l_current_amount / l_before_amount, 1);
end;
/

prompt
prompt Creating function FD_F_B2E_MAIN_STATUS_UPDATE
prompt =============================================
prompt
create or replace function fd_account.fd_f_b2e_main_status_update(v_main_record_id  number,
                                                       v_deal_code       varchar2, ---最近的子记录的成功失败处理码
                                                       v_sub_amount      number,
                                                       v_sub_service_fee number)
  return varchar2 is
  ---------------------主记录加款状态更新--------------------
  l_arrival_amount     number;
  l_sub_arrival_amount number;
  l_amount_is_same     number;
  l_count_is_same      number;
  l_is_all_fail        number;
begin
  ---1.锁支付主记录
  select t.arrival_success_amount
    into l_arrival_amount
    from fd_b2e_payment_record_main t
   where t.record_id = v_main_record_id
     and t.payment_audit_status = pkg_b2e_payment_audit_status.dealing
     and t.received_audit_status in
         (pkg_b2e_received_status.not_start, pkg_b2e_received_status.dealing)
     for update;

  ---2.获取子记录修改状态后的子记录的信息
  ---*********************************************************************
  ---@执行该方法是子记录已处理完成
  ---@获取子记录总到账
  ---@子记录完成总金额与主记录总金额、子记录完成条数与主记录总条数是否相等
  ---@完成的子记录是否全为失败
  ---*********************************************************************
  select sum(t.arrival_amount),
         decode(sum(t.total_amount), max(m.total_amount), 0, 1),
         decode(count(1), max(m.sub_record_count), 0, 1),
         decode(count(1),
                sum(decode(t.submit_status,
                           pkg_b2e_details_submit_status.failure,
                           1,
                           0)),
                0,
                1)
    into l_sub_arrival_amount,
         l_amount_is_same,
         l_count_is_same,
         l_is_all_fail
    from fd_b2e_payment_record_details t
   inner join fd_b2e_payment_record_main m on t.main_record_id =
                                              m.record_id
   where t.main_record_id = v_main_record_id
     and t.submit_status in (pkg_b2e_details_submit_status.failure,
          pkg_b2e_details_submit_status.complate);

  if l_amount_is_same = 0 and l_count_is_same = 0 then
    ---3.主子记录条数、金额都相等，子记录全部执行完成
    ---********************************************************************
    ---@子记录全部完成，且全部失败，支付状态为失败，有成功的则为成功
    ---@子记录全部完成，且全部失败，加款状态为失败，
    ---@    若有成功的且到账金额与加款金额相等则加款成功，否则正在加款
    ---@根据最近子记录的成功与失败判断是否累加提交金额、到账金额、到账手续费
    ---*********************************************************************
    update fd_b2e_payment_record_main t
       set t.payment_audit_status   = decode(l_is_all_fail,
                                             0,
                                             pkg_b2e_payment_audit_status.failure, ---全部执行失败，支付状态为失败
                                             pkg_b2e_payment_audit_status.success), ---有成功的，支付状态为成功
           t.received_audit_status  = decode(l_is_all_fail,
                                             0,
                                             pkg_b2e_received_status.failure, ---全部执行失败，加款状态为失败
                                             decode(t.received_success_amount,
                                                    l_sub_arrival_amount,
                                                    pkg_b2e_received_status.success, ---有成功，且到账与加款的相等，加款成功
                                                    pkg_b2e_received_status.dealing)), ---有成功，但到账与加款不相等，加款正在进行
           t.received_audit_time    = decode(l_is_all_fail, 0, sysdate, null),
           t.received_audit_user    = decode(l_is_all_fail, 0, 'sys', null),
           t.submit_success_amount  = t.submit_success_amount +
                                      decode(v_deal_code,
                                             pkg_deal_code.success,
                                             v_sub_amount, ---最近的一笔成功，累加提交金额
                                             0),
           t.arrival_success_amount = t.arrival_success_amount +
                                      decode(v_deal_code,
                                             pkg_deal_code.success,
                                             v_sub_amount, ---最近的一笔成功，累加到账金额
                                             0),
           t.arrival_service_fee    = t.arrival_service_fee +
                                      decode(v_deal_code,
                                             pkg_deal_code.success,
                                             v_sub_service_fee, ---最近的一笔成功，累加手续费
                                             0)
     where t.record_id = v_main_record_id
       and t.payment_audit_status = pkg_b2e_payment_audit_status.dealing
       and t.received_audit_status in (pkg_b2e_received_status.not_start,
            pkg_b2e_received_status.dealing);
  
  elsif l_amount_is_same = 1 and l_count_is_same = 1 then
    ---4.主子记录条数、金额都不相等，子记录未执行完成
    ---******************************************
    ---@若还有子记录未完成，支付状态依然为正在支付
    ---@最近的一笔成功，加款状态为正在加款，否则依然为原来的状态（未开始、正在）
    ---@根据最近子记录的成功与失败判断是否累加提交金额、到账金额、到账手续费
    ---******************************************
    update fd_b2e_payment_record_main t
       set t.received_audit_status  = decode(v_deal_code,
                                             pkg_deal_code.success,
                                             pkg_b2e_received_status.dealing,
                                             t.received_audit_status),
           t.submit_success_amount  = t.submit_success_amount +
                                      decode(v_deal_code,
                                             pkg_deal_code.success,
                                             v_sub_amount, ---最近的一笔成功，累加提交金额
                                             0),
           t.arrival_success_amount = t.arrival_success_amount +
                                      decode(v_deal_code,
                                             pkg_deal_code.success,
                                             v_sub_amount, ---最近的一笔成功，累加到账金额
                                             0),
           t.arrival_service_fee    = t.arrival_service_fee +
                                      decode(v_deal_code,
                                             pkg_deal_code.success,
                                             v_sub_service_fee, ---最近的一笔成功，累加手续费
                                             0)
     where t.record_id = v_main_record_id
       and t.payment_audit_status = pkg_b2e_payment_audit_status.dealing
       and t.received_audit_status in (pkg_b2e_received_status.not_start,
            pkg_b2e_received_status.dealing);
  else
    ---5.主子记录条数、金额都不完全相等，数据出现错误
    return pkg_error_code.data_error;
  end if;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_MANUAL_UP_MAIN_ADD_CK
prompt ================================================
prompt
create or replace function fd_account.fd_f_b2e_manual_up_main_add_ck(v_up_channel_no      varchar2,
                                                          v_up_account_id      number,
                                                          v_up_card_no         varchar2,
                                                          v_up_add_amount      number,
                                                          v_calc_range_type    number,
                                                          v_white_list_id      out number,
                                                          v_channel_company_id out number,
                                                          v_rcv_card_type      out number,
                                                          v_white_bank_type    out number)
  return varchar2 is
  --------------检查上游加款记录创建参数-------------
  l_channel_no         varchar2(32);
  l_max_day_add_amount number;
  l_max_balance        number;
  l_inner_balance      number;
  l_payment_count      number;
begin
  ---1.检查加款金额
  if v_up_add_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查上游渠道及加款配置
  ---****************************************************
  ---@配置关联的渠道与账户关联关系正确
  ---@账户余额小于报警余额，且账户是自动加款账户
  ---@白名单已配置且都已审核
  ---****************************************************
  select t.up_channel_no,
         b.id,
         t.max_day_add_amount,
         t.max_channel_balance,
         a.inner_balance,
         c.company_id,
         b.rcv_card_type,
         b.bank_type
    into l_channel_no,
         v_white_list_id,
         l_max_day_add_amount,
         l_max_balance,
         l_inner_balance,
         v_channel_company_id,
         v_rcv_card_type,
         v_white_bank_type
    from fd_b2e_up_channel_config t
   inner join fd_base_up_account_map m
      on t.up_channel_no = m.channel_no
     and t.channel_account_id = m.account_id
   inner join fd_base_up_channel c
      on t.up_channel_no = c.channel_no
   inner join fd_base_up_account a
      on t.channel_account_id = a.account_id
   inner join fd_b2e_up_white_list b
      on b.channel_no = t.up_channel_no
     and b.channel_account_id = t.channel_account_id
     and b.audit_status = pkg_audit_status.Complete
   where t.up_channel_no = v_up_channel_no
     and t.channel_account_id = v_up_account_id
     and t.date_range_type = v_calc_range_type
     and a.is_auto_add = pkg_sys_boolean.istrue
     and b.holder_card_no = v_up_card_no
     and rownum <= 2;

  --3.检查账户是否有半小时内的正在执行的转账记录
  ---********************************************************
  ---@账户存在为上游渠道上游加款的记录
  ---@且记录支付未完成，或半小时内未完成加款不允许创建新纪录
  ---********************************************************
  select count(1)
    into l_payment_count
    from fd_b2e_payment_record_main t
   where t.channel_account_id = v_up_account_id
     and t.channal_no = v_up_channel_no
     and t.recv_type = pkg_recv_type.up_channel
     and t.payment_type = pkg_payment_type.up_add
     and ((t.payment_audit_status = pkg_b2e_payment_audit_status.dealing) or
         (t.received_audit_status in
         (Pkg_b2e_received_status.not_start,
            Pkg_b2e_received_status.dealing) and
         t.payment_audit_time >= sysdate - 30 / 24 / 60))
     and t.expire_time > sysdate;

  if l_payment_count > 0 then
    return pkg_error_code.payment_record_repeat;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_repeat_or_error;
end;
/

prompt
prompt Creating function FD_F_B2E_MANUAL_UP_MAIN_EDT_CK
prompt ================================================
prompt
create or replace function fd_account.fd_f_b2e_manual_up_main_edt_ck(v_main_record_id  number,
                                                          v_up_channel_no   varchar2,
                                                          v_up_account_id   number,
                                                          v_up_card_no      varchar2,
                                                          v_add_type_id     number,
                                                          v_up_add_amount   number,
                                                          v_calc_range_type number,
                                                          v_work_day_type   number,
                                                          v_bank_account_id out number,
                                                          v_bank_card_no    out varchar2,
                                                          v_bank_card_name  out varchar2,
                                                          v_white_list_id   out number,
                                                          v_bank_type       out number,
                                                          v_add_type        out number,
                                                          v_max_amount      out number,
                                                          v_expire_time     out date)
  return varchar2 is
  --------------检查上游加款记录创建参数-------------
  l_channel_no         varchar2(32);
  l_bank_balance       number;
  l_max_day_add_amount number;
  l_inner_balance      number;
  l_max_balance        number;
  l_channel_company_id number;
  l_rcv_card_type      number;
  l_create_type        number;
  l_white_bank_type    number;
begin
  ---1.检查加款金额
  if v_up_add_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.获取记录的创建方式,并检查自动创建的记录修改的金额是否正确
  select t.create_type
    into l_create_type
    from fd_b2e_payment_record_main t
   where t.record_id = v_main_record_id;

  ---3.检查上游渠道及加款配置
  select t.channel_no,
         l.id,
         ct.max_day_add_amount,
         a.inner_balance,
         ct.max_channel_balance,
         c.company_id,
         l.rcv_card_type,
         l.bank_type
    into l_channel_no,
         v_white_list_id,
         l_max_day_add_amount,
         l_inner_balance,
         l_max_balance,
         l_channel_company_id,
         l_rcv_card_type,
         l_white_bank_type
    from fd_base_up_account_map t
   inner join fd_base_up_channel c
      on t.channel_no = c.channel_no
   inner join fd_base_up_account a
      on t.account_id = a.account_id
   inner join fd_b2e_up_channel_config ct
      on t.channel_no = ct.up_channel_no
     and ct.date_range_type = v_calc_range_type
     and ct.audit_status = pkg_audit_status.Complete
   inner join fd_b2e_up_white_list l
      on l.channel_no = t.channel_no
     and l.channel_account_id = t.account_id
     and l.audit_status = pkg_audit_status.Complete
   where (a.inner_balance <= ct.warn_balance or
         l_create_type = pkg_b2e_create_type.user_create)
     and t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and a.is_auto_add = pkg_sys_boolean.istrue
     and l.holder_card_no = v_up_card_no
     and rownum <= 2;

  if l_create_type = pkg_b2e_create_type.auto_create then
    ---3.1.检查加款金额是否超过最大每日加款限额
    if (v_up_add_amount + fd_f_b2e_up_day_add_get(v_up_account_id) >
       l_max_day_add_amount) then
      return pkg_error_code.amount_exceed_limit;
    end if;
  
    ---3.2.检查加款是否超过最大余额
    if l_inner_balance + v_up_add_amount > l_max_balance then
      return pkg_error_code.amount_exceed_limit;
    end if;
  end if;

  --4.检查加款方式是否可以使用
  begin
    select t.bank_account_id,
           t.bank_type,
           t.bank_payment_type,
           t.max_amount,
           to_date(to_char(sysdate, 'yyyymmdd') || t.use_end_time,
                   'yyyymmddhh24miss'),
           b.card_no,
           b.account_name,
           b.balance
      into v_bank_account_id,
           v_bank_type,
           v_add_type,
           v_max_amount,
           v_expire_time,
           v_bank_card_no,
           v_bank_card_name,
           l_bank_balance
      from fd_b2e_bank_payment_account t
     inner join fd_bank_account_info b
        on t.bank_account_id = b.account_id
     where t.id = v_add_type_id
       and t.work_day_type in (v_work_day_type, pkg_work_day_type.all_days)
       and b.company_id = l_channel_company_id
       and t.rcv_card_type in (l_rcv_card_type, pkg_rcv_card_type.is_all)
       and to_date(to_char(sysdate, 'yyyymmdd') || t.use_start_time,
                   'yyyymmddhh24miss') <= sysdate
       and to_date(to_char(sysdate, 'yyyymmdd') || t.use_end_time,
                   'yyyymmddhh24miss') >= sysdate
       and t.status = pkg_sys_boolean.istrue
       and t.is_same_bank in
           (decode(t.bank_type, l_white_bank_type, 1, 2),
            pkg_b2e_same_bank_type.is_all);
  exception
    when others then
      return pkg_error_code.bank_payment_type_error;
  end;

  ---5.检查银行账户余额
  if l_bank_balance < v_up_add_amount then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_B2E_PAYMENT_AUDIT_CHECK
prompt ==============================================
prompt
create or replace function fd_account.fd_f_b2e_payment_audit_check(v_main_record_id number)
  return varchar2 is
  --------------检测上游加款任务记录-------------
  l_record_id number;
begin
  ---1.检测进行支付因先满足的条件
  ---*************************************************
  ---@主记录未超时、支付审核未开始、金额审核为财务审核
  ---@加款选的银行卡余额大于加款金额
  ---@记录的金额和手续费数据正确
  ---*************************************************
  select t.record_id
    into l_record_id
    from fd_b2e_payment_record_main t
   inner join fd_bank_account_info b on t.bank_id = b.account_id
   where t.record_id = v_main_record_id
     and t.expire_time > sysdate
     and t.payment_audit_status = pkg_b2e_payment_audit_status.wait
     and t.payment_audit_type = pkg_b2e_amount_audit_status.finance_audit
     and b.balance >= t.total_amount
     and b.is_b2e = pkg_sys_boolean.istrue
     and t.total_amount =
         (t.int_sub_amount * (t.sub_record_count - 1) + t.last_sub_amount)
     and t.total_service_fee =
         (t.int_sub_service_fee * (t.sub_record_count - 1) +
         t.last_sub_service_fee);

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.expire_or_balance_low;
end;
/

prompt
prompt Creating function FD_F_B2E_PAYMENT_QUERY_CHECK
prompt ==============================================
prompt
create or replace function fd_account.fd_f_b2e_payment_query_check(v_sub_record_id  number,
                                                        v_bank_id        out number,
                                                        v_main_record_id out number)
  return varchar2 is
  ------------------检查任务及记录相关信息----------------
  l_up_channel_no varchar2(32);
begin

  ---1.检查主记录、子记录状态
  select t.main_record_id, m.channal_no, m.bank_id
    into v_main_record_id, l_up_channel_no, v_bank_id
    from fd_b2e_payment_record_details t
   inner join fd_b2e_payment_record_main m on t.main_record_id =
                                              m.record_id
   where t.record_id = v_sub_record_id
     and t.query_status = pkg_b2e_details_query_status.Dealing
     and t.submit_status = pkg_b2e_details_submit_status.Dealing
     and m.payment_audit_status = pkg_b2e_payment_audit_status.dealing
     and m.received_audit_status in
         (pkg_b2e_received_status.not_start, pkg_b2e_received_status.dealing);

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_B2E_PAYMENT_QUERY_CREATE
prompt ===============================================
prompt
create or replace function fd_account.fd_f_b2e_payment_query_create(v_main_record_id    number,
                                                         v_details_record_id number,
                                                         v_task_id           number,
                                                         v_task_create_time  date,
                                                         v_query_mq          varchar2,
                                                         v_merchant_no       varchar2,
                                                         v_user_no           varchar2,
                                                         v_user_password     varchar2,
                                                         v_rcv_card_type     varchar2,
                                                         v_language          varchar2,
                                                         v_app_id            varchar2,
                                                         v_app_ver           varchar2,
                                                         v_bank_id           number,
                                                         v_bank_server_id    varchar2,
                                                         v_payment_code      varchar2,
                                                         v_token_key         varchar2)
  return varchar2 is
  -------------------创建支付结果查询任务-----------------
  l_content varchar2(1024);
begin

  ---1.配置任务参数
  l_content := '{"main_record_id":"' || v_main_record_id ||
               '","sub_record_id":"' || v_details_record_id ||
               '","merchant_no":"' || v_merchant_no || '","user_no":"' ||
               v_user_no || '","user_password":"' || v_user_password ||
               '","rcv_card_type":"' || v_rcv_card_type || '","language":"' ||
               v_language || '","app_id":"' || v_app_id || '","app_ver":"' ||
               v_app_ver || '","bank_account_id":"' || v_bank_id ||
               '","payment_code":"' || v_payment_code || '","server_id":"' ||
               v_bank_server_id || '","token_key":"' || v_token_key ||
               '","create_time":"' || to_char(sysdate, 'yyyymmddhh24miss') ||
               '","task_id":"' || v_task_id || '"}';

  ---2.添加任务记录
  insert into fd_b2e_bank_task
    (task_id,
     task_type,
     record_id,
     mq_name,
     task_status,
     create_time,
     content,
     timeout_time)
  values
    (v_task_id,
     pkg_task_type.paymentQuery,
     v_details_record_id,
     v_query_mq,
     pkg_task_status.NotStart,
     v_task_create_time,
     l_content,
     (sysdate + 5 / 24 / 60));

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_PAYMENT_QUERY_SAVE
prompt =============================================
prompt
create or replace function fd_account.fd_f_b2e_payment_query_save(v_bank_id         number,
                                                       v_sub_record_id   number,
                                                       v_main_record_id  number,
                                                       v_error_code      varchar2,
                                                       v_query_error_msg varchar2,
                                                       v_manual_msg      varchar2)
  return varchar2 is
  -------------------完成上游查询任务-------------------
  l_deal_code       varchar2(32);
  l_sub_amount      number;
  l_sub_service_fee number;
  l_result          varchar2(32);
begin
  ---1.获取错误码对应处理码
  select nvl(max(t.deal_code), pkg_deal_code.unknown)
    into l_deal_code
    from fd_b2e_bank_error_code t
   inner join fd_bank_account_info a on t.bank_type = t.bank_type
                                    and a.account_id = v_bank_id
   where t.err_code = v_error_code
     and t.err_code_type = pkg_error_code_type.AddQuery
     and t.status = pkg_sys_boolean.istrue
     and t.deal_code in (pkg_deal_code.success, pkg_deal_code.failure,
          pkg_deal_code.unknown);

  ---2.获取子记录金额信息及锁子记录
  select t.total_amount, t.total_service_fee
    into l_sub_amount, l_sub_service_fee
    from fd_b2e_payment_record_details t
   where t.record_id = v_sub_record_id
     and t.query_status = Pkg_b2e_details_query_status.dealing
     and t.submit_status = pkg_b2e_details_submit_status.Dealing
     for update;

  ---3.处理结果为未知，将查询状态致为等待，进行再次查询
  if l_deal_code = pkg_deal_code.unknown then
    update fd_b2e_payment_record_details t
       set t.query_status     = pkg_b2e_details_query_status.Wait,
           t.query_time       = sysdate,
           t.next_query_time  = (sysdate + 2 / 24 / 60),
           t.query_error_code = v_error_code,
           t.query_deal_code  = l_deal_code,
           t.query_error_msg  = v_query_error_msg
     where t.record_id = v_sub_record_id;
  
    return pkg_error_code.success;
  end if;

  ---4.处理结果明确成功或失败，将子记录的支付状态设为成功或失败，并累加相关金额
  update fd_b2e_payment_record_details t
     set t.submit_status    = decode(l_deal_code,
                                     pkg_deal_code.success,
                                     pkg_b2e_details_submit_status.complate,
                                     pkg_b2e_details_submit_status.failure),
         t.submit_amount    = decode(l_deal_code,
                                     pkg_deal_code.success,
                                     t.total_amount,
                                     0),
         t.arrival_amount   = decode(l_deal_code,
                                     pkg_deal_code.success,
                                     t.total_amount,
                                     0),
         t.query_status     = pkg_b2e_details_query_status.complate,
         t.query_time       = sysdate,
         t.next_query_time  = to_date('20991231', 'yyyymmdd'),
         t.query_error_code = v_error_code,
         t.query_deal_code  = l_deal_code,
         t.query_error_msg  = nvl(v_query_error_msg, t.query_error_msg),
         t.manual_msg       = v_manual_msg
   where t.record_id = v_sub_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  ---5.修改主记录相关信息
  l_result := fd_f_b2e_main_status_update(v_main_record_id,
                                          l_deal_code,
                                          l_sub_amount,
                                          l_sub_service_fee);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_B2E_PAYMENT_TASK_CREATE
prompt ==============================================
prompt
create or replace function fd_account.fd_f_b2e_payment_task_create(v_main_record_id number,
                                                        v_audit_user     varchar2,
                                                        v_memo           varchar2)
  return varchar2 is
  ---------------上游加款任务创建--------------
  lr;
  l_bank_grade             number;
begin
  ---1.将任务状态改为正在审核
  update fd_b2e_payment_record_main t
     set t.payment_audit_type   _token_key              varchar2(64);
  l_merchant_no            varchar2(32);
  l_user_no                varchar2(32);
  l_user_password          varchar2(32);
  l_currency_code          varchar2(32);
  l_language               varchar2(32);
  l_app_id                 varchar2(32);
  l_app_ver                varchar2(32);
  l_sub_count              number;
  l_up_receive_card_no     varchar2(64);
  l_up_receive_card_name   varchar2(32);
  l_payment_bank_card_no   varchar2(64);
  l_payment_bank_card_name varchar2(32);
  l_is_same_bank           number;
  l_up_receive_card_type   varchar2(32);
  l_up_receive_open_bank   varchar2(128);
  l_up_receive_area_code   varchar2(12);
  l_up_receive_bank_code   varchar2(32);
  l_payment_bank_id        number;
  l_int_sub_amount         number;
  l_int_service_fee        number;
  l_last_sub_amount        number;
  l_last_sub_service_fee   number;
  l_expire_time            date;
  l_up_receive_province    varchar2(32);
  l_up_receive_city        varchar2(32);
  l_up_add_mq              varchar2(32);
  l_payment_code           varchar2(32);
  l_bank_payment_type      number;
  l_is_same_area           number;
  l_result                 varchar2(32);
  l_add_memo               varchar2(512);
  l_pay_bank_type          number;
  l_recv_bank_type         number;
  l_count                  numbe= pkg_b2e_amount_audit_status.complate,
         t.payment_audit_status = Pkg_b2e_payment_audit_status.Dealing,
         t.payment_audit_user   = v_audit_user,
         t.payment_audit_time   = sysdate
   where t.record_id = v_main_record_id
     and t.payment_audit_type = pkg_b2e_amount_audit_status.finance_audit
     and t.payment_audit_status = Pkg_b2e_payment_audit_status.wait;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---2.获取主记录信息及银行配置信息
  select e.bank_payment_type,
         t.int_sub_amount,
         t.int_sub_service_fee,
         t.last_sub_amount,
         t.last_sub_service_fee,
         t.sub_record_count,
         t.expire_time,
         t.add_memo,
         decode(e.bank_payment_type,
                Pkg_bank_payment_type.proxy_pay,
                a.add_mq,
                a.bank_add_mq),
         decode(e.bank_payment_type,
                Pkg_bank_payment_type.proxy_pay,
                decode(r.rcv_card_type,
                       pkg_rcv_card_type.is_private,
                       a.proxy_pri_merchant_no, --代付对私的商户号
                       a.proxy_merchant_no), --代付对公的商户号
                a.merchant_no), --网银支付的商户号
         a.user_no,
         a.user_password,
         a.token_key,
         a.language,
         a.currency_code,
         a.app_id,
         a.app_ver,
         t.client_receive_card_no,
         r.bank_holder_name,
         decode(e.bank_payment_type,
                Pkg_bank_payment_type.cyber_bank,
                r.main_bank_code,
                Pkg_bank_payment_type.js_super_bank,
                r.main_bank_code,
                Pkg_bank_payment_type.js_proxy_pay,
                r.main_bank_code,
                pkg_bank_payment_type.zx_big_pay,
                r.main_bank_code,
                pkg_bank_payment_type.zx_cyber_bank,
                r.main_bank_code,
                r.branch_bank_code),
         decode(e.bank_payment_type,
                Pkg_bank_payment_type.proxy_pay,
                d.description, ---代付传银行分类，在脚本中获取大银行名称
                r.account_bank_name), ---网银支付获取明确的开户行信息
         r.rcv_card_type,
         r.area_code,
         p.chinese_name,
         c.chinese_name,
         a.bank_account_id,
         b.card_no,
         b.account_name,
         decode(b.city_no, r.city_no, 0, 1),
         decode(b.bank_type, r.bank_type, 0, 1),
         b.bank_type,
         r.bank_type
    into l_bank_payment_type,
         l_int_sub_amount,
         l_int_service_fee,
         l_last_sub_amount,
         l_last_sub_service_fee,
         l_sub_count,
         l_expire_time,
         l_add_memo,
         l_up_add_mq,
         l_merchant_no,
         l_user_no,
         l_user_password,
         l_token_key,
         l_language,
         l_currency_code,
         l_app_id,
         l_app_ver,
         l_up_receive_card_no,
         l_up_receive_card_name,
         l_up_receive_bank_code,
         l_up_receive_open_bank,
         l_up_receive_card_type,
         l_up_receive_area_code,
         l_up_receive_province,
         l_up_receive_city,
         l_payment_bank_id,
         l_payment_bank_card_no,
         l_payment_bank_card_name,
         l_is_same_area,
         l_is_same_bank,
         l_pay_bank_type,
         l_recv_bank_type
    from fd_b2e_payment_record_main t
   inner join fd_b2e_up_white_list r
      on t.white_list_id = r.id
     and r.audit_status = pkg_audit_status.Complete
   inner join fd_system_dictionary d
      on r.bank_type = d.value
     and d.belong_enum = 'BankType' --B2BBankType
   inner join fd_bank_account_info b
      on t.bank_id = b.account_id
   inner join fd_b2e_bank_payment_account e
      on t.bank_add_type_id = e.id
     and e.status = pkg_sys_boolean.istrue
   inner join fd_system_canton_info p
      on r.province_no = p.canton_code
     and p.grade = 1
   inner join fd_system_canton_info c
      on r.city_no = c.canton_code
     and c.grade = 2
   inner join fd_b2e_bank_account_api_config a
      on t.bank_id = a.bank_account_id
   where t.record_id = v_main_record_id;

  ---3.获取银行接口对应的银行编号
  select nvl(max(t.code), '-')
    into l_payment_code
    from fd_b2e_bank_payment_code_map t
   where t.bank_payment_type = l_bank_payment_type
     and t.code_type = pkg_b2e_payment_code_type.pay;

  ---4.修改特殊支付方式的主行号
  if l_bank_payment_type = Pkg_bank_payment_type.js_proxy_pay then
    select count(1), nvl(max(t.recv_bank_code), 0)
      into l_count, l_up_receive_bank_code
      from fd_b2e_bank_main_code t
     where t.bank_type = l_pay_bank_type
       and t.interface_type = l_payment_code
       and t.recv_bank_type = l_recv_bank_type;
  
    if l_count != 1 then
      return pkg_error_code.bank_not_suport;
    end if;
  elsif l_bank_payment_type = Pkg_bank_payment_type.zx_night_pay then
    select count(1), nvl(min(t.bank_grade), 0)
      into l_count, l_bank_grade
      from fd_b2e_bank_zxyj_code t
     where t.bank_type = l_recv_bank_type
       and t.canton_code in ('0', l_up_receive_province, l_up_receive_city);
  
    if l_count = 0 then
      return pkg_error_code.bank_not_suport;
    end if;
  
    select t.bank_code, t.bank_name
      into l_up_receive_bank_code, l_up_receive_open_bank
      from fd_b2e_bank_zxyj_code t
     where t.bank_type = l_recv_bank_type
       and t.bank_grade = l_bank_grade
       and t.canton_code in ('0', l_up_receive_province, l_up_receive_city)
       and rownum <= 1;
  end if;

  ---5.添加除最后一笔的子记录和任务
  for item in 1 .. (l_sub_count - 1) loop
    l_result := fd_f_b2e_details_create(v_main_record_id,
                                        l_bank_payment_type,
                                        l_int_sub_amount,
                                        l_int_service_fee,
                                        l_expire_time,
                                        l_up_add_mq,
                                        l_merchant_no,
                                        l_user_no,
                                        l_user_password,
                                        l_token_key,
                                        l_language,
                                        l_currency_code,
                                        l_app_id,
                                        l_app_ver,
                                        l_up_receive_card_no,
                                        l_up_receive_card_name,
                                        l_up_receive_bank_code,
                                        l_up_receive_open_bank,
                                        l_up_receive_card_type,
                                        l_up_receive_area_code,
                                        l_up_receive_province,
                                        l_up_receive_city,
                                        l_payment_bank_id,
                                        l_payment_bank_card_no,
                                        l_payment_bank_card_name,
                                        l_is_same_area,
                                        l_is_same_bank,
                                        l_payment_code,
                                        v_memo,
                                        l_add_memo);
  
    if l_result != pkg_error_code.success then
      return l_result;
    end if;
  end loop;

  ---6.添加最后一笔的子记录和任务
  l_result := fd_f_b2e_details_create(v_main_record_id,
                                      l_bank_payment_type,
                                      l_last_sub_amount,
                                      l_last_sub_service_fee,
                                      l_expire_time,
                                      l_up_add_mq,
                                      l_merchant_no,
                                      l_user_no,
                                      l_user_password,
                                      l_token_key,
                                      l_language,
                                      l_currency_code,
                                      l_app_id,
                                      l_app_ver,
                                      l_up_receive_card_no,
                                      l_up_receive_card_name,
                                      l_up_receive_bank_code,
                                      l_up_receive_open_bank,
                                      l_up_receive_card_type,
                                      l_up_receive_area_code,
                                      l_up_receive_province,
                                      l_up_receive_city,
                                      l_payment_bank_id,
                                      l_payment_bank_card_no,
                                      l_payment_bank_card_name,
                                      l_is_same_area,
                                      l_is_same_bank,
                                      l_payment_code,
                                      v_memo,
                                      l_add_memo);

  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_PYMET_ADT_SAVE_CHECK
prompt ===============================================
prompt
create or replace function fd_account.fd_f_b2e_pymet_adt_save_check(v_sub_record_id  number,
                                                         v_bank_id        out number,
                                                         v_main_record_id out number)
  return varchar2 is
  -----------------检查完成加款提交检查-----------------
begin

  ---1.检查子记录相关信息
  select t.main_record_id, m.bank_id
    into v_main_record_id, v_bank_id
    from fd_b2e_payment_record_details t
   inner join fd_b2e_payment_record_main m on t.main_record_id =
                                              m.record_id
   where t.record_id = v_sub_record_id
     and t.submit_status = pkg_b2e_details_submit_status.Dealing
     and m.payment_audit_type = pkg_b2e_amount_audit_status.complate
     and m.payment_audit_status = pkg_b2e_payment_audit_status.dealing;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_B2E_RECV_DOWN_ADD_ADJUST
prompt ===============================================
prompt
create or replace function fd_account.fd_f_b2e_recv_down_add_adjust(v_sys_fund_id number,
                                                         v_adjust_days number,
                                                         v_create_user varchar2,
                                                         v_memo        varchar2)
  return varchar2 is
  ---------------下游收款记录下游加款红冲----------------
  l_result        varchar2(32);
  l_add_record_id number;
begin
  ---0.获取加款记录编号
  select t.record_id
    into l_add_record_id
    from fd_trade_down_manual t
   where t.bank_fund_id = v_sys_fund_id;

  ---1. 检查加款记录、账户、余额、手续费
  l_result := fd_f_adjust_down_add_check(l_add_record_id, v_adjust_days);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---2. 红冲下游手工加款记录
  l_result := fd_f_adjust_down_add_handle(l_add_record_id,
                                          v_create_user,
                                          v_memo);
  return l_result;
end;
/

prompt
prompt Creating function FD_F_B2E_RECV_QUERY_CHECK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_b2e_recv_query_check(v_bank_account_id     number,
                                                     v_start_time          varchar2,
                                                     v_end_time            varchar2,
                                                     v_main_card_no        out varchar2,
                                                     v_query_interval_time out number,
                                                     v_receive_query_mq    out varchar2,
                                                     v_merchant_no         out varchar2,
                                                     v_user_no             out varchar2,
                                                     v_user_password       out varchar2,
                                                     v_language            out varchar2,
                                                     v_app_id              out varchar2,
                                                     v_app_ver             out varchar2)
  return varchar2 is
  -----------------检查生成查询任务参数------------------

begin
  ---1.检查时间及查询参数
  if to_date(v_start_time, 'yyyy-mm-dd') >
     to_date(v_end_time, 'yyyy-mm-dd') then
  
    return pkg_error_code.data_error;
  end if;

  ---2.检查银行子账户及主账户
  select b.card_no,
         t.query_interval_time,
         c.receive_query_mq,
         c.merchant_no,
         c.user_no,
         c.user_password,
         c.language,
         c.app_id,
         c.app_ver
    into v_main_card_no,
         v_query_interval_time,
         v_receive_query_mq,
         v_merchant_no,
         v_user_no,
         v_user_password,
         v_language,
         v_app_id,
         v_app_ver
    from fd_b2e_bank_receive_account t
   inner join fd_b2e_bank_account_api_config c on c.bank_account_id = t.account_id
   inner join fd_bank_account_info b on t.account_id = b.account_id
   where t.account_id = v_bank_account_id
     and t.status = pkg_sys_boolean.istrue
     and b.is_b2e = pkg_sys_boolean.istrue;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_B2E_RECV_QUERY_TASK
prompt ==========================================
prompt
create or replace function fd_account.fd_f_b2e_recv_query_task(v_start_time          varchar2,
                                                    v_end_time            varchar2,
                                                    v_bank_account_id     number,
                                                    v_bank_card_no        varchar2,
                                                    v_query_interval_time number,
                                                    v_receive_query_mq    varchar2,
                                                    v_merchant_no         varchar2,
                                                    v_user_no             varchar2,
                                                    v_user_password       varchar2,
                                                    v_language            varchar2,
                                                    v_app_id              varchar2,
                                                    v_app_ver             varchar2)
  return varchar2 is
  ---------------创建查询下游收款记录任务------------------
  l_task_id   number;
  l_task_time date;
  l_content   varchar2(512);
begin

  ---1.获取任务记录编号及时间
  select seq_fdb2ebanktask_auto_id.nextval, sysdate
    into l_task_id, l_task_time
    from dual;

  ---2.根据银行分类生成对应任务信息
  l_content := '{"task_date":"' || to_char(l_task_time, 'yyyymmddhh24miss') ||
               '","merchant_no":"' || v_merchant_no || '","user_no":"' ||
               v_user_no || '","user_password":"' || v_user_password ||
               '","language":"' || v_language || '","app_id":"' || v_app_id ||
               '","app_ver":"' || v_app_ver || '","task_id":"' || l_task_id ||
               '","bank_card_no":"' || v_bank_card_no || '","start_time":"' ||
               v_start_time || '","end_time":"' || v_end_time ||
               '","bank_account_id":"' || v_bank_account_id ||
               '","batch_seq":"' || seq_b2e_batch_no.nextval ||
               '","batch_sub_seq":"' || seq_b2e_batch_no.nextval || '"}';

  ---3.添加对应查询任务记录
  insert into fd_b2e_bank_task
    (task_id,
     task_type,
     record_id,
     mq_name,
     task_status,
     create_time,
     content,
     timeout_time)
  values
    (l_task_id,
     pkg_task_type.ReceiveQuery,
     0,
     v_receive_query_mq,
     pkg_task_status.NotStart,
     l_task_time,
     l_content,
     (l_task_time + v_query_interval_time / 24 / 60 / 60));

  ---4.修改子账户最后查询时间
  update fd_b2e_bank_receive_account t
     set t.last_query_time = l_task_time
   where t.account_id = v_bank_account_id;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_RECV_STATUS_ADJUST
prompt =============================================
prompt
create or replace function fd_account.fd_f_b2e_recv_status_adjust(v_rec_record_id number,
                                                       v_sys_fund_id   out number,
                                                       v_receive_type  out number)
  return varchar2 is
  ---------------下游收款记录状态红冲---------------
begin
  ---1.获取并锁住加款记录
  select t.sys_fund_id, t.receive_type
    into v_sys_fund_id, v_receive_type
    from fd_b2e_bank_receive_record t
   where t.record_id = v_rec_record_id
     and t.deal_status = Pkg_b2e_deal_status.success
     for update;

  ---2.修改收款记录的状态
  update fd_b2e_bank_receive_record t
     set t.deal_status        = Pkg_b2e_deal_status.Wait,
         t.sys_fund_id        = null,
         t.channel_no         = null,
         t.channel_account_id = null,
         t.channal_type       = null,
         t.receive_type       = null,
         t.deal_user          = null,
         t.deal_memo          = null
   where t.record_id = v_rec_record_id
     and t.deal_status = Pkg_b2e_deal_status.success;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_B2E_TRADE_RATE_CALC
prompt ==========================================
prompt
create or replace function fd_account.fd_f_b2e_trade_rate_calc(v_order_source    number,
                                                    v_up_channel_no   varchar2,
                                                    v_calc_start_time date,
                                                    v_calc_end_time   date)
  return varchar2 is
  ----------------计算最近一天渠道交易量与对应系统交易的比，计算交易系数---------------
  l_trade_rate number;
begin
  ---1.计算渠道交易量占总交易量比例
  select sum(decode(t.channel_no, v_up_channel_no, 1, 0) * t.trade_amount) /
         sum(t.trade_amount)
    into l_trade_rate
    from fd_report_channel_halfhour t
   where t.collect_time >= v_calc_start_time
     and t.collect_time < v_calc_end_time
     and t.channel_type = pkg_channel_type.up_channel
     and t.order_source = v_order_source;

  ---2.为空算作没有交易量
  return nvl(l_trade_rate, 0);
end;
/

prompt
prompt Creating function FD_F_B2E_TRF_STATUS_ADJUST
prompt ============================================
prompt
create or replace function fd_account.fd_f_b2e_trf_status_adjust(v_main_record_id number,
                                                      v_payment_type   out number)
  return varchar2 is
  l_record_id number;
begin
  ---1.锁主记录
  select t.record_id, t.payment_type
    into l_record_id, v_payment_type
    from fd_b2e_payment_record_main t
   where t.record_id = v_main_record_id
     and t.received_audit_status in
         (pkg_b2e_received_status.Dealing, pkg_b2e_received_status.success)
     and t.received_success_amount > 0
     for update;

  ---2.还原主记录信息
  update fd_b2e_payment_record_main t
     set t.received_audit_status        = pkg_b2e_received_status.dealing,
         t.create_time                  = sysdate,
         t.received_success_amount      = 0,
         t.received_success_service_fee = 0,
         t.received_audit_user          = null,
         t.received_audit_time          = null,
         t.received_audit_memo          = null
   where t.record_id = v_main_record_id;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_ADD_AMOUNT_CALC
prompt =============================================
prompt
create or replace function fd_account.fd_f_b2e_up_add_amount_calc(v_up_account_id       number,
                                                       v_up_channel_no       varchar2,
                                                       v_account_balance     number,
                                                       v_max_day_add_amount  number,
                                                       v_max_account_balance number,
                                                       v_min_add_amount      number,
                                                       v_amount_calc_type    varchar2,
                                                       v_trade_duration      number,
                                                       v_up_add_amount       out number)
  return varchar2 is
  -----------------上游加款金额计算-----------------
  ---系统交易增长率*系统同期交易金额*上游渠道交易系数=加款金额
  ---系统交易增长率: 本月与上月同期对比，加权求平均值
  ---系统同期交易金额：  上月同期同时段交易金额
  ---渠道交易系数：  最近7天及24小时渠道的交易量占总交易量的比例，并加权求平均值

  l_time_now            date := sysdate;
  l_growth_rate0        number;
  l_growth_rate1        number;
  l_growth_rate2        number;
  l_growth_rate3        number;
  l_all_growth_rate     number;
  l_last_amount         number;
  l_trade_rate0         number;
  l_trade_rate1         number;
  l_trade_rate2         number;
  l_trade_rate3         number;
  l_all_trade_ratio     number;
  l_forecast_add_amount number;
  l_before_time         date;
  l_all_rate            number;
  l_result              varchar2(32);
begin

  --==============0.默认计算方式，按渠道的系统信息分别计算加款金额==================
  v_up_add_amount := 0;
  if v_amount_calc_type = 'default' then
    for item in (select s.source_system_id
                   from fd_base_up_system_map s
                  where s.channel_no = v_up_channel_no) loop
      begin
        --=======================1.计算系统增长率(同期与往期整体增长率)==============
        ---1.1.计算各期的交易增长率
        l_growth_rate0 := fd_f_b2e_growth_rate_calc(item.source_system_id,
                                                    trunc(l_time_now),
                                                    l_time_now);
        l_growth_rate1 := fd_f_b2e_growth_rate_calc(item.source_system_id,
                                                    trunc(l_time_now) - 1,
                                                    trunc(l_time_now));
      
        l_growth_rate2 := fd_f_b2e_growth_rate_calc(item.source_system_id,
                                                    trunc(l_time_now) - 2,
                                                    trunc(l_time_now) - 1);
      
        l_growth_rate3 := fd_f_b2e_growth_rate_calc(item.source_system_id,
                                                    trunc(l_time_now) - 3,
                                                    trunc(l_time_now) - 2);
      
        ---1.2.计算总交易增长率
        l_all_growth_rate := l_growth_rate0 * 0.5 + l_growth_rate1 * 0.3 +
                             l_growth_rate2 * 0.1 + l_growth_rate3 * 0.1;
      
        --========================2.计算同期交易金额===================================
        l_before_time := fd_f_b2e_month_date_calc(l_time_now, -1);
      
        select nvl(sum(t.trade_amount), 0)
          into l_last_amount
          from fd_report_channel_halfhour t
         where t.collect_time >= l_before_time
           and t.collect_time < l_before_time + v_trade_duration / 24
           and t.channel_type = pkg_channel_type.up_channel
           and t.order_source = item.source_system_id;
      
        --=======================3.计算渠道交易系数====================================
        --3.1计算各期渠道交易占比
        l_trade_rate0 := fd_f_b2e_trade_rate_calc(item.source_system_id,
                                                  v_up_channel_no,
                                                  trunc(l_time_now),
                                                  l_time_now);
      
        l_trade_rate1 := fd_f_b2e_trade_rate_calc(item.source_system_id,
                                                  v_up_channel_no,
                                                  l_time_now - 1,
                                                  l_time_now - 1 +
                                                  v_trade_duration / 24);
      
        l_trade_rate2 := fd_f_b2e_trade_rate_calc(item.source_system_id,
                                                  v_up_channel_no,
                                                  l_time_now - 2,
                                                  l_time_now - 2 +
                                                  v_trade_duration / 24);
      
        l_trade_rate3 := fd_f_b2e_trade_rate_calc(item.source_system_id,
                                                  v_up_channel_no,
                                                  l_time_now - 3,
                                                  l_time_now - 3 +
                                                  v_trade_duration / 24);
      
        --3.2计算去掉0占比数据后的权重总数
        select (decode(l_trade_rate0, 0, 0, 1) * 0.5 +
               decode(l_trade_rate1, 0, 0, 1) * 0.3 +
               decode(l_trade_rate2, 0, 0, 1) * 0.1 +
               decode(l_trade_rate3, 0, 0, 1) * 0.1)
          into l_all_rate
          from dual;
      
        --3.3权重总数为0不计算该次加款金额，不为零继续计算
        if l_all_rate != 0 then
          ---3.4根据各占比的实际权重计算渠道交易占比
          l_all_trade_ratio := l_trade_rate0 * 0.5 / l_all_rate +
                               l_trade_rate1 * 0.3 / l_all_rate +
                               l_trade_rate2 * 0.1 / l_all_rate +
                               l_trade_rate3 * 0.1 / l_all_rate;
        
          --==========================4.计算加款金额====================================
        
          ---4.1计算总加款金额
          l_forecast_add_amount := l_all_growth_rate * l_last_amount *
                                   l_all_trade_ratio;
          v_up_add_amount       := v_up_add_amount + l_forecast_add_amount;
        
          ---4.2保存预测各参数信息
          l_result := fd_f_b2e_forecast_save(v_up_channel_no,
                                             l_time_now,
                                             v_trade_duration,
                                             l_last_amount,
                                             l_forecast_add_amount,
                                             l_growth_rate0,
                                             l_growth_rate1,
                                             l_growth_rate2,
                                             l_growth_rate3,
                                             l_trade_rate0,
                                             l_trade_rate1,
                                             l_trade_rate2,
                                             l_trade_rate3);
        end if;
      end;
    end loop;
  end if;

  --====================================5.根据配置调整加款金额=========================

  ---5.1.检查加款金额是否在合理区间内
  v_up_add_amount := fd_f_b2e_adjust_add_amount(v_up_account_id,
                                                v_up_add_amount,
                                                v_account_balance,
                                                v_max_account_balance,
                                                v_min_add_amount,
                                                v_max_day_add_amount);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_ADD_COMPLATE
prompt ==========================================
prompt
create or replace function fd_account.fd_f_b2e_up_add_complate(v_main_record_id number,
                                                    v_submit_amount  number,
                                                    v_error_code     varchar2,
                                                    v_sub_record_id  number,
                                                    v_server_id      varchar2,
                                                    v_bank_id        number)
  return varchar2 is
  -----------------完成上游加款提交---------------
  l_count             number;
  l_deal_code         varchar2(32);
  l_up_channel        varchar2(32);
  l_sub_record_id     number;
  l_query_status      number;
  l_add_status        number;
  l_submit_amount     number;
  l_end_sub_count     number;
  l_total_amount      number;
  l_main_amount       number;
  l_main_record_count number;
  l_audit_status      number;
begin
  ---1.锁主记录信息
  select t.channal_no
    into l_up_channel
    from fd_b2e_payment_record_main t
   where t.record_id = v_main_record_id
     and t.payment_audit_status = pkg_audit_status.Auditing
     for update;

  ---2.锁子记录信息
  select t.record_id
    into l_sub_record_id
    from fd_b2e_payment_record_details t
   where t.record_id = v_sub_record_id
     and t.submit_status = pkg_b2e_details_submit_status.Dealing
     for update;

  ---3.获取错误码对应处理码
  select count(1), max(t.deal_code)
    into l_count, l_deal_code
    from fd_b2e_bank_error_code t
   inner join fd_bank_account_info b on t.bank_type = b.bank_type
                                    and b.account_id = v_bank_id
   where t.err_code = v_error_code
     and t.err_code_type = pkg_error_code_type.Addamount
     and t.status = pkg_sys_boolean.istrue;

  ---4.没有对应处理码,获取结果未知的处理码
  if l_count = 0 then
    l_deal_code := pkg_deal_code.unknown;
  end if;

  ---5.1根据处理码判断是否查询(提交结果未知的算作提交成功)
  l_query_status  := pkg_b2e_details_query_status.Wait;
  l_add_status    := pkg_b2e_payment_audit_status.success;
  l_submit_amount := v_submit_amount;
  if l_deal_code = pkg_deal_code.failure then
    l_query_status  := pkg_b2e_details_query_status.not_start;
    l_add_status    := pkg_b2e_payment_audit_status.failure;
    l_submit_amount := 0;
  end if;

  ---5.2修改子记录，完成子记录
  update fd_b2e_payment_record_details t
     set t.submit_status     = l_add_status,
         t.submit_error_code = v_error_code,
         t.submit_deal_code  = l_deal_code,
         t.bank_server_id    = v_server_id,
         t.query_status      = l_query_status,
         t.submit_amount     = l_submit_amount
   where t.record_id = v_sub_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  ---6.获取完成的子记录条数
  select count(1), sum(t.total_amount)
    into l_end_sub_count, l_total_amount
    from fd_b2e_payment_record_details t
   where t.main_record_id = v_main_record_id
     and t.submit_status in (pkg_b2e_details_submit_status.complate,
          pkg_b2e_details_submit_status.failure);

  ---7.获取主记录信息
  select t.total_amount, t.sub_record_count
    into l_main_amount, l_main_record_count
    from fd_b2e_payment_record_main t
   where t.record_id = v_main_record_id;

  l_audit_status := pkg_audit_status.Auditing;
  if l_end_sub_count = l_main_record_count and
     l_total_amount = l_main_amount then
  
    l_audit_status := pkg_audit_status.Complete;
  end if;

  ---8.修改主记录信息
  update fd_b2e_payment_record_main t
     set t.submit_success_amount = (t.submit_success_amount +
                                   decode(l_add_status,
                                           pkg_b2e_payment_audit_status.success,
                                           l_submit_amount,
                                           0)),
         t.payment_audit_status  = l_audit_status
   where t.record_id = v_main_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_ADD_FORECAST
prompt ==========================================
prompt
create or replace function fd_account.fd_f_b2e_up_add_forecast(v_up_channel_no  varchar2,
                                                    v_time_start     date,
                                                    v_trade_duration number,
                                                    v_up_add_amount  out number,
                                                    v_return_info    out varchar2)
  return varchar2 is
  -----------------上游加款金额计算-----------------
  ---系统交易增长率*系统同期交易金额*上游渠道交易系数=加款金额
  ---系统交易增长率: 本月与上月同期对比，加权求平均值
  ---系统同期交易金额：  上月同期同时段交易金额
  ---渠道交易系数：  最近7天及24小时渠道的交易量占总交易量的比例，并加权求平均值

  l_growth_rate0    number;
  l_growth_rate1    number;
  l_growth_rate2    number;
  l_growth_rate3    number;
  l_all_growth_rate number;
  l_last_amount     number;
  l_trade_rate0     number;
  l_trade_rate1     number;
  l_trade_rate2     number;
  l_trade_rate3     number;
  l_all_trade_ratio number;
  l_before_time     date;
  l_params1         varchar2(64) := '';
  l_params2         varchar2(64) := '';
  l_params3         varchar2(64) := '';
  l_all_rate        number;

begin

  ---2.获取渠道系统信息
  v_up_add_amount := 0;
  for item in (select s.source_system_id
                 from fd_base_up_system_map s
                where s.channel_no = v_up_channel_no) loop
    begin
      ---2.1计算系统增长率
      l_growth_rate0 := fd_f_b2e_growth_rate_calc(item.source_system_id,
                                                  trunc(v_time_start),
                                                  v_time_start);
      l_growth_rate1 := fd_f_b2e_growth_rate_calc(item.source_system_id,
                                                  trunc(v_time_start) - 1,
                                                  trunc(v_time_start));
    
      l_growth_rate2 := fd_f_b2e_growth_rate_calc(item.source_system_id,
                                                  trunc(v_time_start) - 2,
                                                  trunc(v_time_start) - 1);
    
      l_growth_rate3 := fd_f_b2e_growth_rate_calc(item.source_system_id,
                                                  trunc(v_time_start) - 3,
                                                  trunc(v_time_start) - 2);
    
      select (decode(l_growth_rate0, 0, 1, l_growth_rate0) * 0.5 +
             decode(l_growth_rate1, 0, 1, l_growth_rate1) * 0.3 +
             decode(l_growth_rate2, 0, 1, l_growth_rate2) * 0.1 +
             decode(l_growth_rate3, 0, 1, l_growth_rate3) * 0.1)
        into l_all_growth_rate
        from dual;
    
      ---2.2计算同期交易金额
      l_before_time := fd_f_b2e_month_date_calc(v_time_start, -1);
    
      select sum(t.trade_amount)
        into l_last_amount
        from fd_report_channel_halfhour t
       where t.collect_time >= l_before_time
         and t.collect_time < l_before_time + v_trade_duration / 24
         and t.order_source = item.source_system_id;
    
      ---2.3计算渠道交易系数
      l_trade_rate0 := fd_f_b2e_trade_rate_calc(item.source_system_id,
                                                v_up_channel_no,
                                                trunc(v_time_start),
                                                v_time_start);
    
      l_trade_rate1 := fd_f_b2e_trade_rate_calc(item.source_system_id,
                                                v_up_channel_no,
                                                v_time_start - 1,
                                                v_time_start - 1 +
                                                v_trade_duration / 24);
    
      l_trade_rate2 := fd_f_b2e_trade_rate_calc(item.source_system_id,
                                                v_up_channel_no,
                                                v_time_start - 2,
                                                v_time_start - 2 +
                                                v_trade_duration / 24);
    
      l_trade_rate3 := fd_f_b2e_trade_rate_calc(item.source_system_id,
                                                v_up_channel_no,
                                                v_time_start - 3,
                                                v_time_start - 3 +
                                                v_trade_duration / 24);
    
      select (decode(l_trade_rate0, 0, 0, 1) * 0.5 +
             decode(l_trade_rate1, 0, 0, 1) * 0.3 +
             decode(l_trade_rate2, 0, 0, 1) * 0.1 +
             decode(l_trade_rate3, 0, 0, 1) * 0.1)
        into l_all_rate
        from dual;
    
      if l_all_rate = 0 then
        return pkg_error_code.data_error;
      end if;
    
      l_all_trade_ratio := l_trade_rate0 * 0.5 / l_all_rate +
                           l_trade_rate1 * 0.3 / l_all_rate +
                           l_trade_rate2 * 0.1 / l_all_rate +
                           l_trade_rate3 * 0.1 / l_all_rate;
    
      ---2.4计算总加款金额
      l_params1 := l_params1 || '(' || round(l_growth_rate0, 5) || ',' ||
                   round(l_growth_rate1, 5) || ',' ||
                   round(l_growth_rate2, 5) || ',' ||
                   round(l_growth_rate3, 5) || ')' || ',';
      l_params2 := l_params2 || l_last_amount || ',';
      l_params3 := l_params3 || '(' || round(l_trade_rate0, 5) || ',' ||
                   round(l_trade_rate1, 5) || ',' ||
                   round(l_trade_rate2, 5) || ',' ||
                   round(l_trade_rate3, 5) || ')' || ',';
    
      v_up_add_amount := v_up_add_amount +
                         l_all_growth_rate * l_last_amount *
                         l_all_trade_ratio;
    
    end;
  end loop;

  v_return_info := l_params1 || '|' || l_params2 || '|' || l_params3;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_ADD_INFO_GET
prompt ==========================================
prompt
create or replace function fd_account.fd_f_b2e_up_add_info_get(v_main_record_id  in number,
                                                    v_bank_id         out number,
                                                    v_up_channal_no   out varchar2,
                                                    v_add_amount      out number,
                                                    v_add_service_fee out number,
                                                    v_partner_card    out varchar2,
                                                    v_account_id      out number)
  return varchar2 is
  --------------获取上游加款需要的信息-----------
begin
  ---1.获取上游总加款记录信息
  select t.bank_id,
         t.channal_no,
         t.channel_account_id,
         (t.arrival_success_amount - t.received_success_amount),
         (t.arrival_service_fee - t.received_success_service_fee),
         t.client_receive_card_no
    into v_bank_id,
         v_up_channal_no,
         v_account_id,
         v_add_amount,
         v_add_service_fee,
         v_partner_card
    from fd_b2e_payment_record_main t
   where t.record_id = v_main_record_id
     and t.payment_audit_status in (pkg_b2e_payment_audit_status.dealing,
          pkg_b2e_payment_audit_status.success)
     and t.received_audit_status = pkg_b2e_received_status.dealing
     and (t.arrival_success_amount - t.received_success_amount) > 0
     for update;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_ADD_RECORD_EDIT
prompt =============================================
prompt
create or replace function fd_account.fd_f_b2e_up_add_record_edit(v_main_record_id   number,
                                                       v_bank_add_type_id number,
                                                       v_bank_account_id  number,
                                                       v_bank_card_no     varchar2,
                                                       v_bank_card_name   varchar2,
                                                       v_up_card_no       varchar2,
                                                       v_white_list_id    number,
                                                       v_up_add_amount    number,
                                                       v_sub_count        number,
                                                       v_sub_max_amount   number,
                                                       v_service_fee      number,
                                                       v_last_sub_amount  number,
                                                       v_last_sub_fee     number,
                                                       v_expire_time      date)
  return varchar2 is
  --------------------添加上游加款记录---------------------
begin

  ---1.修改加款主记录
  update fd_b2e_payment_record_main t
     set t.bank_id                = v_bank_account_id,
         t.bank_add_type_id       = v_bank_add_type_id,
         t.bank_card_no           = v_bank_card_no,
         t.bank_card_name         = v_bank_card_name,
         t.total_amount           = v_up_add_amount,
         t.total_service_fee      = v_service_fee,
         t.white_list_id          = v_white_list_id,
         t.client_receive_card_no = v_up_card_no,
         t.sub_record_count       = v_sub_count,
         t.int_sub_amount         = v_sub_max_amount,
         t.last_sub_amount        = v_last_sub_amount,
         t.int_sub_service_fee    = decode(v_sub_count,
                                           1,
                                           v_service_fee,
                                           (v_service_fee - v_last_sub_fee) /
                                           (v_sub_count - 1)),
         t.last_sub_service_fee   = v_last_sub_fee,
         t.expire_time            = v_expire_time
   where t.record_id = v_main_record_id;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_ADD_STATUS_EDIT
prompt =============================================
prompt
create or replace function fd_account.fd_f_b2e_up_add_status_edit(v_main_record_id  number,
                                                       v_add_amount      number,
                                                       v_add_service_fee number,
                                                       v_create_user     varchar2,
                                                       v_memo            varchar2)
  return varchar2 is
  ---------------修改上游加款状态为完成-------------
  l_count           number;
begin
  ---1.主记录是否支付已全部成功、到账金额和收款记录加上本次加款相等
  select count(1)
    into l_count
    from fd_b2e_payment_record_main t
   where t.record_id = v_main_record_id
     and t.payment_audit_status = pkg_b2e_payment_audit_status.success
     and t.received_audit_status = pkg_b2e_received_status.dealing
     and (t.received_success_amount + v_add_amount) =
         t.arrival_success_amount;

  ---2.完成上游加款
  update fd_b2e_payment_record_main t
     set t.received_audit_status        = decode(l_count,
                                                 1,
                                                 pkg_b2e_received_status.success,
                                                 pkg_b2e_received_status.dealing),
         t.received_audit_user          = v_create_user,
         t.received_audit_time          = sysdate,
         t.received_audit_memo          = v_memo,
         t.received_success_amount      = (t.received_success_amount +
                                          v_add_amount),
         t.received_success_service_fee = (t.received_success_service_fee +
                                          v_add_service_fee)
   where t.record_id = v_main_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.failure;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_ADD_TYPE_INFO_GET
prompt ===============================================
prompt
create or replace function fd_account.fd_f_b2e_up_add_type_info_get(v_rcv_card_type      number,
                                                         v_up_add_amount      number,
                                                         v_work_day_type      number,
                                                         v_channel_company_id number,
                                                         v_white_bank_type    number,
                                                         v_min_service_fee    out number,
                                                         v_bank_type          out number,
                                                         v_bank_add_type_id   out number,
                                                         v_bank_account_id    out number,
                                                         v_pay_card_no        out varchar2,
                                                         v_pay_card_name      out varchar2,
                                                         v_sub_count          out number,
                                                         v_sub_max_amount     out number,
                                                         v_last_sub_amount    out number,
                                                         v_last_sub_fee       out number,
                                                         v_expire_time        out date)
  return varchar2 is
  ------------------上游加款方式选择-----------------
  l_result     varchar2(32);
  l_add_type   number;
  l_max_amount number;
begin
  ---1.按拆单次数最少、手续费最少的方式选出启用、在可用时间范围内的加款方式
  select tab.id,
         tab.bank_type,
         tab.bank_payment_type,
         tab.max_amount,
         tab.bank_account_id,
         tab.card_no,
         tab.account_name,
         tab.end_time
    into v_bank_add_type_id,
         v_bank_type,
         l_add_type,
         l_max_amount,
         v_bank_account_id,
         v_pay_card_no,
         v_pay_card_name,
         v_expire_time
    from (select r.id,
                 r.bank_type,
                 r.bank_payment_type,
                 r.max_amount,
                 r.bank_account_id,
                 f.card_no,
                 f.account_name,
                 to_date(to_char(sysdate, 'yyyymmdd') || r.use_end_time,
                         'yyyymmddhh24miss') end_time
            from fd_b2e_bank_payment_account r
           inner join fd_bank_account_info f
              on r.bank_account_id = f.account_id
           where r.work_day_type in
                 (v_work_day_type, pkg_work_day_type.all_days)
             and to_date(to_char(sysdate, 'yyyymmdd') || r.use_start_time,
                         'yyyymmddhh24miss') <= sysdate
             and to_date(to_char(sysdate, 'yyyymmdd') || r.use_end_time,
                         'yyyymmddhh24miss') >= sysdate
             and r.status = pkg_sys_boolean.istrue
             and r.rcv_card_type in
                 (v_rcv_card_type, pkg_rcv_card_type.is_all)
             and f.company_id = v_channel_company_id
             and r.is_same_bank in
                 (decode(r.bank_type, v_white_bank_type, 1, 2),
                  pkg_b2e_same_bank_type.is_all)
           order by r.sort_id desc,
                    fd_f_b2e_up_sub_count_calc(r.max_amount, v_up_add_amount),
                    fd_f_b2e_up_service_fee_calc(r.bank_type,
                                                 r.bank_payment_type,
                                                 r.max_amount,
                                                 v_up_add_amount) asc) tab
   where rownum <= 1;

  ---2.计算出选出加款方式的手续费、拆单、最后一笔订单信息
  l_result := fd_f_b2e_up_split_order_calc(v_bank_type,
                                           l_add_type,
                                           l_max_amount,
                                           v_up_add_amount,
                                           v_min_service_fee,
                                           v_sub_count,
                                           v_sub_max_amount,
                                           v_last_sub_amount,
                                           v_last_sub_fee);

  return l_result;

exception
  when others then
    ---3.没有可选的加款方式，报警
    fd_p_b2e_warn_info_set('AT' || to_char(sysdate, 'yyyymmddhh24miss'),
                           pkg_warn_into_type.b2e_add_type,
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           ' 自动生成加款失败.',
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           '没有可选加款方式.',
                           '银企直连没有可选加款方式');
  
    return pkg_error_code.bank_payment_type_error;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_DATE_INFO_GET
prompt ===========================================
prompt
create or replace function fd_account.fd_f_b2e_up_date_info_get(v_calc_range_type out number,
                                                     v_work_day_type   out number)
  return varchar2 is
  --------------获取参数信息-------------
  l_week_num  number := to_number(to_char(sysdate, 'd')) - 1; --星期几，0周日，1星期一，。。。。。
  l_date_now  number := to_number(to_char(sysdate, 'dd')); ---当前日期是几号
  l_date_last number := to_number(to_char(last_day(sysdate), 'dd')); ---本月最后一天是几号
begin
  --1.获取交易时段
  ---*************************************
  ---@日期为1号2号和每月最后一天的为高峰期
  ---@其余日期为正常交易日期
  ---*************************************
  if l_date_now > 2 and l_date_now < l_date_last then
    v_calc_range_type := pkg_date_range_type.NormalPeriod;
  else
    v_calc_range_type := pkg_date_range_type.PeakPeriod;
  end if;

  --2.获取工作日信息
  ---*************************************************
  ---@系统有当前日期的工作日信息配置，取系统配置
  ---@没有配置，周六周日默认非工作时间，其余为工作时间
  ---*************************************************
  select nvl(max(t.work_day_type),
             decode(l_week_num,
                    0, --周日
                    pkg_work_day_type.not_work_day,
                    6, --周六
                    pkg_work_day_type.not_work_day,
                    pkg_work_day_type.work_day))
    into v_work_day_type
    from fd_b2e_bank_work_date t
   where t.config_date = trunc(sysdate);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_B2E_UP_PAYMENT_AUDIT_SAVE
prompt ================================================
prompt
create or replace function fd_account.fd_f_b2e_up_payment_audit_save(v_main_record_id number,
                                                          v_error_code     varchar2,
                                                          v_error_msg      varchar2,
                                                          v_sub_record_id  number,
                                                          v_server_id      varchar2,
                                                          v_bank_id        number)
  return varchar2 is
  -----------------完成上游加款提交---------------
  l_deal_code       varchar2(32);
  l_sub_amount      number;
  l_sub_service_fee number;
  l_result          varchar2(32);
begin

  --==========================1.获取错误码对应处理码==============
  ---1.1获取处理吗信息
  select nvl(max(t.deal_code), pkg_deal_code.unknown)
    into l_deal_code
    from fd_b2e_bank_error_code t
   inner join fd_bank_account_info b on t.bank_type = b.bank_type
                                    and b.account_id = v_bank_id
   where t.err_code = v_error_code
     and t.err_code_type = pkg_error_code_type.Addamount
     and t.status = pkg_sys_boolean.istrue
     and t.deal_code in (pkg_deal_code.success, pkg_deal_code.failure,
          pkg_deal_code.unknown);

  ---1.2获取子记录金额信息及锁子记录
  select t.total_amount, t.total_service_fee
    into l_sub_amount, l_sub_service_fee
    from fd_b2e_payment_record_details t
   where t.record_id = v_sub_record_id
     and t.query_status = Pkg_b2e_details_query_status.not_start
     and t.submit_status = pkg_b2e_details_submit_status.Dealing
     for update;

  if l_deal_code = pkg_deal_code.failure then
    --=======================2.处理码为失败执行的流程==============
    --2.1将子记录修改为失败状态
    update fd_b2e_payment_record_details t
       set t.submit_status     = pkg_b2e_details_submit_status.failure,
           t.submit_amount     = 0,
           t.arrival_amount    = 0,
           t.submit_error_code = v_error_code,
           t.submit_deal_code  = l_deal_code,
           t.submit_error_msg  = v_error_msg,
           t.bank_server_id    = v_server_id,
           t.next_query_time   = to_date('20991231', 'yyyymmdd')
     where t.record_id = v_sub_record_id;
  
    if sql%rowcount = 0 then
      return pkg_error_code.data_error;
    end if;
  
    ---2.2修改主记录相关信息
    l_result := fd_f_b2e_main_status_update(v_main_record_id,
                                            l_deal_code,
                                            l_sub_amount,
                                            l_sub_service_fee);
  
    if l_result != pkg_error_code.success then
      return l_result;
    end if;
  else
    --=====================3.处理码为成功执行的流程===================
    ---1.将查询设为等待查询
    update fd_b2e_payment_record_details t
       set t.submit_error_code = v_error_code,
           t.submit_deal_code  = l_deal_code,
           t.submit_error_msg  = v_error_msg,
           t.bank_server_id    = v_server_id,
           t.query_status      = Pkg_b2e_details_query_status.wait,
           t.next_query_time   = (sysdate + 1 / 24 / 60)
     where t.record_id = v_sub_record_id
       and t.query_status = Pkg_b2e_details_query_status.not_start
       and t.submit_status = pkg_b2e_details_submit_status.Dealing;
  
    if sql%rowcount = 0 then
      return pkg_error_code.data_error;
    end if;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_ACT_ADD
prompt ===================================
prompt
create or replace function fd_account.fd_f_bank_act_add(v_act_account_id number,
                                             v_amount         number,
                                             v_hander_user    varchar2,
                                             v_memo           varchar2)
  return varchar2 is
  --------------活动专用账户添加收益-------------
  l_act_company_id    number;
  l_act_balance       number;
  l_profit_account_id number;
  l_batch_service_id  number;
  l_profit_balance    number;
begin
  ---1.锁相关活动专用账户和毛利账户
  select t.company_id, t.balance
    into l_act_company_id, l_act_balance
    from fd_base_company_account_cap t
   where t.account_id = v_act_account_id
     for update;

  select t.account_id, t.balance
    into l_profit_account_id, l_profit_balance
    from fd_base_company_account_cap t
   where t.company_id = l_act_company_id
     and t.account_type = pkg_co_cap_account_type.profit
     and t.status = pkg_sys_boolean.istrue
     for update;

  ---2.获取处理的批次编号
  select seq_bank_service_id.nextval into l_batch_service_id from dual;

  ---3.添加活动账户收益
  update fd_base_company_account_cap t
     set t.balance        = (l_act_balance + v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_act_account_id;

  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     create_user)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_act_account_id,
     v_amount,
     pkg_co_cap_fund_type.add_amount,
     (l_act_balance + v_amount),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     l_batch_service_id,
     v_memo,
     v_hander_user);

  ---4.增加利润账户利润
  update fd_base_company_account_cap t
     set t.balance        = (l_profit_balance + v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = l_profit_account_id;

  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     create_user)
  values
    (seq_trade_co_cap_fund_id.nextval,
     l_profit_account_id,
     v_amount,
     pkg_co_cap_fund_type.add_amount,
     (l_profit_balance + v_amount),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     l_batch_service_id,
     v_memo,
     v_hander_user);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_ACT_ADD_CHECK
prompt =========================================
prompt
create or replace function fd_account.fd_f_bank_act_add_check(v_act_account_id number,
                                                   v_amount         number)
  return varchar2 is
  -------------------检查相关活动账户、毛利账户及金额---------------------
  l_act_company_id number;
  l_profit_count   number;
begin
  ---1.检查加款金额是否正确
  if v_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查相关账户
  select t.company_id
    into l_act_company_id
    from fd_base_company_account_cap t
   where t.account_id = v_act_account_id
     and t.status = pkg_sys_boolean.istrue
     and t.account_type = pkg_co_cap_account_type.activity
     and rownum <= 2;

  ---3.检查相关毛利账户
  select count(1)
    into l_profit_count
    from fd_base_company_account_cap t
   where t.company_id = l_act_company_id
     and t.account_type = pkg_co_cap_account_type.profit
     and t.status = pkg_sys_boolean.istrue;

  if l_profit_count != 1 then
    return pkg_error_code.channel_or_account_error;
  end if;

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function FD_F_BANK_ACT_MINUS_CHECK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_bank_act_minus_check(v_bank_account_id number,
                                                     v_cap_account_id  number,
                                                     v_amount          number,
                                                     v_service_fee     number)
  return varchar2 is
  ---------------------检查活动账户相关信息---------------------
  l_bank_count  number;
  l_act_balance number;
begin
  ---1.检查对应金额是否正确
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查实体卡账户
  select count(1), max(c.balance)
    into l_bank_count, l_act_balance
    from fd_bank_account_info t
   inner join fd_base_company_account_cap c on t.company_id = c.company_id
   where t.account_id = v_bank_account_id
     and c.account_id = v_cap_account_id
     and c.account_type = pkg_co_cap_account_type.activity
     and c.status = 0
     and rownum <= 2;

  if l_bank_count = 0 then
    return pkg_error_code.data_error;
  end if;

  if l_act_balance < v_amount then
    return pkg_error_code.amount_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_CAPITAL_ADD
prompt =======================================
prompt
create or replace function fd_account.fd_f_bank_capital_add(v_bank_account_id    number,
                                                 v_cap_account_id     number,
                                                 v_fund_bank_use_type number,
                                                 v_amount             number,
                                                 v_service_fee        number,
                                                 v_hander_user        varchar2,
                                                 v_link_channel_name  varchar2,
                                                 v_link_account_name  varchar2,
                                                 v_memo               varchar2)
  return varchar2 is
  -----------------资产账户加款----------------
  l_capital_balance  number;
  l_bank_balance     number;
  l_company_id       number;
  l_batch_service_id number;
  l_cap_account_name varchar2(32);
begin
  ---1.锁资产账户
  select t.balance, t.account_name
    into l_capital_balance, l_cap_account_name
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     for update;

  ---2.锁银行卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---3.获取银行处理的批次编号
  select seq_bank_service_id.nextval into l_batch_service_id from dual;

  ---4.修改资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_capital_balance - v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_cap_account_id;

  ---5.添加资产账户变动记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_cap_account_id,
     v_amount,
     pkg_co_cap_fund_type.minus_amount,
     (l_capital_balance - v_amount),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     l_batch_service_id);

  ---6.修改银行卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_service_fee + v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---7.添加银行卡手续费变动记录
  if v_service_fee > 0 then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       0,
       l_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_hander_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       pkg_sys_boolean.isfalse,
       '',
       l_cap_account_name,
       v_memo,
       l_batch_service_id);
  end if;

  ---8.添加银行卡资金变动记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     0,
     l_company_id,
     v_amount,
     (l_bank_balance - v_service_fee + v_amount),
     sysdate,
     v_hander_user,
     pkg_bank_fund_change_type.add_amount,
     v_fund_bank_use_type,
     pkg_sys_boolean.isfalse,
     '',
     l_cap_account_name,
     v_memo,
     l_batch_service_id);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_CAPITAL_ADD_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_bank_capital_add_check(v_bank_account_id    number,
                                                       v_cap_account_id     number,
                                                       v_amount             number,
                                                       v_service_fee        number,
                                                       v_capital_type       out number,
                                                       v_fund_bank_use_type out number)
  return varchar2 is
  ---------------------检查借支、押金、保证金、短期借债的账户及金额---------------------
  l_bank_count number;
begin
  ---1.检查对应金额是否正确
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查实体卡账户
  select count(1), max(c.account_type)
    into l_bank_count, v_capital_type
    from fd_bank_account_info t
   inner join fd_base_company_account_cap c on t.company_id = c.company_id
   where t.account_id = v_bank_account_id
     and c.account_id = v_cap_account_id
     and c.account_type in
         (pkg_co_cap_account_type.borrow, pkg_co_cap_account_type.deposit,
          pkg_co_cap_account_type.bond, pkg_co_cap_account_type.short_borrow,
          pkg_co_cap_account_type.personal_borrow)
     and c.status = 0
     and rownum <= 1;

  if l_bank_count = 0 then
    return pkg_error_code.data_error;
  end if;

  ---3.获取银行卡使用类型
  if v_capital_type = pkg_co_cap_account_type.borrow then
    v_fund_bank_use_type := pkg_bank_use_type.borrow;
  elsif v_capital_type = pkg_co_cap_account_type.deposit then
    v_fund_bank_use_type := pkg_bank_use_type.deposit;
  elsif v_capital_type = pkg_co_cap_account_type.bond then
    v_fund_bank_use_type := pkg_bank_use_type.bond;
  elsif v_capital_type = pkg_co_cap_account_type.short_borrow then
    v_fund_bank_use_type := pkg_bank_use_type.short_borrow;
  else
    v_fund_bank_use_type := pkg_bank_use_type.personal_borrow;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_CAPITAL_MINUS
prompt =========================================
prompt
create or replace function fd_account.fd_f_bank_capital_minus(v_bank_account_id    number,
                                                   v_cap_account_id     number,
                                                   v_fund_bank_use_type number,
                                                   v_amount             number,
                                                   v_service_fee        number,
                                                   v_hander_user        varchar2,
                                                   v_link_channel_name  varchar2,
                                                   v_link_account_name  varchar2,
                                                   v_memo               varchar2)
  return varchar2 is
  -----------------资产账户减款----------------
  l_capital_balance  number;
  l_bank_balance     number;
  l_company_id       number;
  l_batch_service_id number;
  l_cap_account_name varchar2(32);
begin
  ---1.锁资产账户
  select t.balance, t.account_name
    into l_capital_balance, l_cap_account_name
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     for update;

  ---2.锁银行卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---3.获取银行处理的批次编号
  select seq_bank_service_id.nextval into l_batch_service_id from dual;

  ---4.修改资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_capital_balance + v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_cap_account_id;

  ---5.添加资产账户变动记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_cap_account_id,
     v_amount,
     pkg_co_cap_fund_type.add_amount,
     (l_capital_balance + v_amount),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     l_batch_service_id,
     v_memo);

  ---6.修改银行卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_service_fee - v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---7.添加银行卡手续费变动记录
  if v_service_fee > 0 then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       0,
       l_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_hander_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       pkg_sys_boolean.isfalse,
       '',
       l_cap_account_name,
       v_memo,
       l_batch_service_id);
  end if;

  ---8.添加银行卡资金变动记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     0,
     l_company_id,
     v_amount,
     (l_bank_balance - v_service_fee - v_amount),
     sysdate,
     v_hander_user,
     pkg_bank_fund_change_type.minus_amount,
     v_fund_bank_use_type,
     pkg_sys_boolean.isfalse,
     '',
     l_cap_account_name,
     v_memo,
     l_batch_service_id);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_CAPITAL_MINUS_CHECK
prompt ===============================================
prompt
create or replace function fd_account.fd_f_bank_capital_minus_check(v_bank_account_id    number,
                                                         v_cap_account_id     number,
                                                         v_amount             number,
                                                         v_service_fee        number,
                                                         v_capital_type       out number,
                                                         v_fund_bank_use_type out number)
  return varchar2 is
  ---------------------检查借支、押金、保证金、短期借债的账户及金额---------------------
  l_bank_count   number;
  l_bank_balance number;
begin
  ---1.检查对应金额是否正确
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查实体卡账户
  select count(1), max(t.balance), max(c.account_type)
    into l_bank_count, l_bank_balance, v_capital_type
    from fd_bank_account_info t
   inner join fd_base_company_account_cap c on t.company_id = c.company_id
   where t.account_id = v_bank_account_id
     and c.account_id = v_cap_account_id
     and c.account_type in
         (pkg_co_cap_account_type.borrow, pkg_co_cap_account_type.deposit,
          pkg_co_cap_account_type.bond, pkg_co_cap_account_type.prepayment,
          pkg_co_cap_account_type.short_borrow,
          pkg_co_cap_account_type.personal_borrow)
     and c.status = 0
     and rownum <= 1;

  if l_bank_count = 0 then
    return pkg_error_code.data_error;
  end if;

  ---3.检查银行卡余额
  if (v_amount + v_service_fee) > l_bank_balance then
    return pkg_error_code.balance_low;
  end if;

  ---4.获取银行卡使用类型
  if v_capital_type = pkg_co_cap_account_type.borrow then
    v_fund_bank_use_type := pkg_bank_use_type.borrow;
  elsif v_capital_type = pkg_co_cap_account_type.deposit then
    v_fund_bank_use_type := pkg_bank_use_type.deposit;
  elsif v_capital_type = pkg_co_cap_account_type.bond then
    v_fund_bank_use_type := pkg_bank_use_type.bond;
  elsif v_capital_type = pkg_co_cap_account_type.prepayment then
    v_fund_bank_use_type := pkg_bank_use_type.prepayment;
  elsif v_capital_type = pkg_co_cap_account_type.short_borrow then
    v_fund_bank_use_type := pkg_bank_use_type.short_borrow;
  else
    v_fund_bank_use_type := pkg_bank_use_type.personal_borrow;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_CAPITAL_PRE_MINUS
prompt =============================================
prompt
create or replace function fd_account.fd_f_bank_capital_pre_minus(v_cap_account_id number,
                                                       v_amount         number,
                                                       v_hander_user    varchar2,
                                                       v_record_no      varchar2,
                                                       v_memo           varchar2)
  return varchar2 is
  -----------------预付费账户减款----------------
  l_capital_balance number;
  l_record_count    number;
begin
  ---1.锁资产账户
  select t.balance
    into l_capital_balance
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     for update;

  ---1.1.检查并发同步
  select count(1)
    into l_record_count
    from fd_trade_co_cap_fund t
   inner join fd_base_company_account_cap c on t.account_id = c.account_id
   where t.record_no = v_record_no
     and c.account_id = v_cap_account_id
     and rownum <= 1;

  if l_record_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  ---2.修改资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_capital_balance - v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_cap_account_id;

  ---3.添加资产账户变动记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     record_no)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_cap_account_id,
     v_amount,
     pkg_co_cap_fund_type.minus_amount,
     (l_capital_balance - v_amount),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     0,
     v_memo,
     v_record_no);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_CAP_ADD
prompt ===================================
prompt
create or replace function fd_account.fd_f_bank_cap_add(v_bank_account_id    number,
                                             v_cap_account_id     number,
                                             v_fund_bank_use_type number,
                                             v_amount             number,
                                             v_service_fee        number,
                                             v_hander_user        varchar2,
                                             v_link_channel_name  varchar2,
                                             v_link_account_name  varchar2,
                                             v_remark_name       varchar2,--收付款账户名称
                                             v_memo               varchar2)
  return varchar2 is
  -----------------资产账户加款----------------
  l_capital_balance  number;
  l_bank_balance     number;
  l_company_id       number;
  l_batch_service_id number;
  l_cap_account_name varchar2(100);
begin
  ---1.锁资产账户
  select t.balance, t.account_name
    into l_capital_balance, l_cap_account_name
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     for update;

  ---2.锁银行卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---3.获取银行处理的批次编号
  select seq_bank_service_id.nextval into l_batch_service_id from dual;

  ---4.修改资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_capital_balance + v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_cap_account_id;

  ---5.添加资产账户变动记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_cap_account_id,
     v_amount,
     pkg_co_cap_fund_type.add_amount,
     (l_capital_balance + v_amount),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     l_batch_service_id,
     v_memo);

  ---6.修改银行卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_service_fee - v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---7.添加银行卡手续费变动记录
  if v_service_fee > 0 then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       0,
       l_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_hander_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       pkg_sys_boolean.isfalse,
       '',
       l_cap_account_name,
       v_memo,
       l_batch_service_id,v_remark_name);
  end if;

  ---8.添加银行卡资金变动记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     0,
     l_company_id,
     v_amount,
     (l_bank_balance - v_service_fee - v_amount),
     sysdate,
     v_hander_user,
     pkg_bank_fund_change_type.minus_amount,
     v_fund_bank_use_type,
     pkg_sys_boolean.isfalse,
     '',
     l_cap_account_name,
     v_memo,
     l_batch_service_id,v_remark_name);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_CAP_ADD_CHECK
prompt =========================================
prompt
create or replace function fd_account.fd_f_bank_cap_add_check(v_bank_account_id    number,
                                                   v_cap_account_id     number,
                                                   v_amount             number,
                                                   v_service_fee        number,
                                                   v_capital_type       out number,
                                                   v_fund_bank_use_type out number)
  return varchar2 is
  ---------------------检查借支、押金、保证金、短期借债的账户及金额---------------------
  l_bank_count   number;
  l_bank_balance number;
begin
  ---1.检查对应金额是否正确
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查实体卡账户
  select count(1), max(t.balance), max(c.account_type)
    into l_bank_count, l_bank_balance, v_capital_type
    from fd_bank_account_info t
   inner join fd_base_company_account_cap c on t.company_id = c.company_id
   where t.account_id = v_bank_account_id
     and c.account_id = v_cap_account_id
     and c.account_type in
         (pkg_co_cap_account_type.borrow, pkg_co_cap_account_type.deposit,
          pkg_co_cap_account_type.bond, pkg_co_cap_account_type.prepayment,
          pkg_co_cap_account_type.short_borrow,
          pkg_co_cap_account_type.personal_borrow,
          pkg_co_cap_account_type.transfer_refund,
          pkg_co_cap_account_type.manual_refund)
     and c.status = 0
     and rownum <= 1;

  if l_bank_count = 0 then
    return pkg_error_code.data_error;
  end if;

  ---3.检查银行卡余额
  if (v_amount + v_service_fee) > l_bank_balance then
    return pkg_error_code.balance_low;
  end if;

  ---4.获取银行卡使用类型
  if v_capital_type = pkg_co_cap_account_type.borrow then
    v_fund_bank_use_type := pkg_bank_use_type.borrow;
  elsif v_capital_type = pkg_co_cap_account_type.deposit then
    v_fund_bank_use_type := pkg_bank_use_type.deposit;
  elsif v_capital_type = pkg_co_cap_account_type.bond then
    v_fund_bank_use_type := pkg_bank_use_type.bond;
  elsif v_capital_type = pkg_co_cap_account_type.prepayment then
    v_fund_bank_use_type := pkg_bank_use_type.prepayment;
  elsif v_capital_type = pkg_co_cap_account_type.short_borrow then
    v_fund_bank_use_type := pkg_bank_use_type.short_borrow;
  elsif v_capital_type = pkg_co_cap_account_type.personal_borrow then
    v_fund_bank_use_type := pkg_bank_use_type.personal_borrow;
  elsif v_capital_type = pkg_co_cap_account_type.transfer_refund then
    v_fund_bank_use_type := pkg_bank_use_type.transfer_refund;
  else
    v_fund_bank_use_type := pkg_bank_use_type.manual_refund;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_CAP_MINUS
prompt =====================================
prompt
create or replace function fd_account.fd_f_bank_cap_minus(v_bank_account_id    number,
                                               v_cap_account_id     number,
                                               v_fund_bank_use_type number,
                                               v_amount             number,
                                               v_service_fee        number,
                                               v_hander_user        varchar2,
                                               v_link_channel_name  varchar2,
                                               v_link_account_name  varchar2,
                                               v_remark_name       varchar2,--收付款账户名称
                                               v_memo               varchar2)
  return varchar2 is
  -----------------资产账户减款----------------
  l_capital_balance  number;
  l_bank_balance     number;
  l_company_id       number;
  l_batch_service_id number;
  l_cap_account_name varchar2(100);
begin
  ---1.锁资产账户
  select t.balance, t.account_name
    into l_capital_balance, l_cap_account_name
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     for update;

  ---2.锁银行卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---3.获取银行处理的批次编号
  select seq_bank_service_id.nextval into l_batch_service_id from dual;

  ---4.修改资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_capital_balance - v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_cap_account_id;

  ---5.添加资产账户变动记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_cap_account_id,
     v_amount,
     pkg_co_cap_fund_type.minus_amount,
     (l_capital_balance - v_amount),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     l_batch_service_id,
     v_memo);

  ---6.修改银行卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_service_fee + v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---7.添加银行卡手续费变动记录
  if v_service_fee > 0 then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       0,
       l_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_hander_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       pkg_sys_boolean.isfalse,
       '',
       l_cap_account_name,
       v_memo,
       l_batch_service_id,v_remark_name);
  end if;

  ---8.添加银行卡资金变动记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     0,
     l_company_id,
     v_amount,
     (l_bank_balance - v_service_fee + v_amount),
     sysdate,
     v_hander_user,
     pkg_bank_fund_change_type.add_amount,
     v_fund_bank_use_type,
     pkg_sys_boolean.isfalse,
     '',
     l_cap_account_name,
     v_memo,
     l_batch_service_id,v_remark_name);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_CAP_MINUS_CHECK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_bank_cap_minus_check(v_bank_account_id    number,
                                                     v_cap_account_id     number,
                                                     v_amount             number,
                                                     v_service_fee        number,
                                                     v_capital_type       out number,
                                                     v_fund_bank_use_type out number)
  return varchar2 is
  ---------------------检查借支、押金、保证金、短期借债的账户及金额---------------------
  l_bank_count number;
begin
  ---1.检查对应金额是否正确
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查实体卡账户
  select count(1), max(c.account_type)
    into l_bank_count, v_capital_type
    from fd_bank_account_info t
   inner join fd_base_company_account_cap c on t.company_id = c.company_id
   where t.account_id = v_bank_account_id
     and c.account_id = v_cap_account_id
     and c.account_type in
         (pkg_co_cap_account_type.borrow, pkg_co_cap_account_type.deposit,
          pkg_co_cap_account_type.bond, pkg_co_cap_account_type.short_borrow,
          pkg_co_cap_account_type.personal_borrow)
     and c.status = 0
     and rownum <= 1;

  if l_bank_count = 0 then
    return pkg_error_code.data_error;
  end if;

  ---3.获取银行卡使用类型
  if v_capital_type = pkg_co_cap_account_type.borrow then
    v_fund_bank_use_type := pkg_bank_use_type.borrow;
  elsif v_capital_type = pkg_co_cap_account_type.deposit then
    v_fund_bank_use_type := pkg_bank_use_type.deposit;
  elsif v_capital_type = pkg_co_cap_account_type.bond then
    v_fund_bank_use_type := pkg_bank_use_type.bond;
  elsif v_capital_type = pkg_co_cap_account_type.short_borrow then
    v_fund_bank_use_type := pkg_bank_use_type.short_borrow;
  else
    v_fund_bank_use_type := pkg_bank_use_type.personal_borrow;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_CHECK_T
prompt ===================================
prompt
create or replace function fd_account.fd_f_bank_check_t(v_bank_account_id number,
                                             v_amount          number,
                                             v_change_type     number,
                                             v_use_type        number,
                                             v_record_no       varchar2)
  return varchar2 is
  --------------------导数据检查实体卡账户与金额--------------------
  l_account_id   number;
  l_record_count number;
begin
  ---1.检查账户是否存在
  select t.account_id
    into l_account_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id;

  ---1.1检查订单是否存在
  select count(1)
    into l_record_count
    from fd_bank_cash_fund t
   where t.record_no = v_record_no;

  if l_record_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  ---2.检查金额
  if (v_amount <= 0) then
    return pkg_error_code.amount_error;
  end if;

  ---3.检查类型
  if (v_change_type != 1 and v_change_type != 2) then
    return pkg_error_code.data_error;
  end if;

  if ((v_use_type <= 0 or v_use_type >= 9) and v_use_type != 99) then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.bank_account_id_error;
end;
/

prompt
prompt Creating function FD_F_BANK_COMMISION_CHECK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_bank_commision_check(v_channel_no      varchar2,
                                                     v_channel_type    number,
                                                     v_bank_account_id number,
                                                     v_commission      number,
                                                     v_service_fee     number)
  return varchar2 is
  ------------------获取并检查结算参数------------------
  l_bank_balance    number;
  l_commi_balance   number;
  l_bank_company_id number;
begin
  ---0.检查佣金
  if v_commission <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---1.检查银行卡
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id;

  ---2.检查渠道
  if v_channel_type = pkg_channel_type.up_channel then
  
    select t.commi_balance
      into l_commi_balance
      from fd_base_up_channel t
     where t.channel_no = v_channel_no
       and t.company_id = l_bank_company_id;
  elsif v_channel_type = pkg_channel_type.down_channel then
  
    select t.commi_balance
      into l_commi_balance
      from fd_base_down_channel t
     where t.channel_no = v_channel_no
       and t.company_id = l_bank_company_id;
  
    if (v_commission + v_service_fee) > l_bank_balance then
      return pkg_error_code.balance_low;
    end if;
  else
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_COMMISION_SETTLE
prompt ============================================
prompt
create or replace function fd_account.fd_f_bank_commision_settle(v_channel_no      varchar2,
                                                      v_channel_type    number,
                                                      v_bank_account_id number,
                                                      v_commission      number,
                                                      v_commi_month     varchar2,
                                                      v_service_fee     number,
                                                      v_settle_user     varchar2,
                                                      v_remark_name     varchar2,--添加收付款账户名称
                                                      v_memo            varchar2)
  return varchar2 is
  ---------------------------------
  --功能：佣金结算
  --修改人：周荣省
  --修改时间：2019-08-26
  --修改内容：添加收付款账户名称
  ---------------------------------
  l_bank_balance     number;
  l_bank_end_balance number;
  l_bank_change_type number;
  l_bank_use_type    number;
  l_bank_batch_id    number;
  l_company_id       number;
  l_channel_name     varchar2(100);
  l_commi_balance    number;
begin
  ---1.锁银行卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---2.修改银行卡余额
  if v_channel_type = pkg_channel_type.down_channel then
    l_bank_end_balance := l_bank_balance - v_commission - v_service_fee;
    l_bank_change_type := pkg_bank_fund_change_type.minus_amount;
    l_bank_use_type    := pkg_bank_use_type.down_commission;

    select t.channel_name
      into l_channel_name
      from fd_base_down_channel t
     where t.channel_no = v_channel_no;
  else
    l_bank_end_balance := l_bank_balance + v_commission - v_service_fee;
    l_bank_change_type := pkg_bank_fund_change_type.add_amount;
    l_bank_use_type    := pkg_bank_use_type.up_commission;

    select t.channel_name
      into l_channel_name
      from fd_base_up_channel t
     where t.channel_no = v_channel_no;
  end if;

  update fd_bank_account_info t
     set t.balance        = l_bank_end_balance,
         t.last_edit_user = v_settle_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---3.添加银行卡流水
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  if v_service_fee > 0 then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       0,
       l_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_settle_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       pkg_sys_boolean.isfalse,
       l_channel_name,
       '-',
       v_memo,
       l_bank_batch_id,v_remark_name);
  end if;

  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     0,
     l_company_id,
     v_commission,
     l_bank_end_balance,
     sysdate,
     v_settle_user,
     l_bank_change_type,
     l_bank_use_type,
     pkg_sys_boolean.isfalse,
     l_channel_name,
     '-',
     v_memo,
     l_bank_batch_id,v_remark_name);

  if v_channel_type = pkg_channel_type.down_channel then
    ---4.下游渠道扣佣金
    select t.commi_balance
      into l_commi_balance
      from fd_base_down_channel t
     where t.channel_no = v_channel_no
       for update;

    /*if v_commission > l_commi_balance then
      return pkg_error_code.balance_low;
    end if;*/

    update fd_base_down_channel t
       set t.commi_balance  = (l_commi_balance - v_commission),
           t.last_edit_user = v_settle_user,
           t.last_edit_time = sysdate
     where t.channel_no = v_channel_no;
  else
    ---5.上游渠道扣佣金
    select t.commi_balance
      into l_commi_balance
      from fd_base_up_channel t
     where t.channel_no = v_channel_no
       for update;

    if v_commission > l_commi_balance then
      return pkg_error_code.balance_low;
    end if;

    update fd_base_up_channel t
       set t.commi_balance  = (l_commi_balance - v_commission),
           t.last_edit_user = v_settle_user,
           t.last_edit_time = sysdate
     where t.channel_no = v_channel_no;

  end if;

  ---6.添加佣金结算记录
  insert into fd_trade_commission_settle
    (report_id,
     channel_no,
     channel_type,
     commission,
     settle_month,
     settle_status,
     settle_user,
     settle_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     settle_type,
     commi_balance)
  values
    (seq_trade_commission_settle_id.nextval,
     v_channel_no,
     v_channel_type,
     v_commission,
     to_date(v_commi_month, 'yyyymmddhh24miss'),
     pkg_sys_boolean.istrue,
     v_settle_user,
     sysdate,
     pkg_sys_boolean.isfalse,
     0,
     l_bank_batch_id,
     pkg_commi_settle_type.settle,
     (l_commi_balance - v_commission));

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_CO_SETTLE_ADD
prompt =========================================
prompt
create or replace function fd_account.fd_f_bank_co_settle_add(v_co_account_id       number,
                                                   v_out_bank_account_id number,
                                                   v_in_bank_account_id  number,
                                                   v_amount              number,
                                                   v_service_fee         number,
                                                   v_handle_user         varchar2,
                                                   v_remark_name         varchar2,--支出账户名称
                                                   v_remark_name_in      varchar2,--收入账户名
                                                   v_memo                varchar2)
  return varchar2 is
  -------------------------------------
  --功能：公司间结算加款
  --修改人：周荣省
  --修改时间：2019-08-27
  --修改内容：添加收付款账户名称
  -------------------------------------
  l_owe_company_id      number;
  l_recv_company_id     number;
  l_co_balance          number;
  l_out_bank_balance    number;
  l_in_bank_balance     number;
  l_batch_service_id    number;
  l_settle_account_name varchar2(100);
begin
  --========================锁结算涉及的账户======================================
  ---1.锁公司间结算账户
  select t.owe_company, t.recv_company, t.balance, t.account_name
    into l_owe_company_id,
         l_recv_company_id,
         l_co_balance,
         l_settle_account_name
    from fd_base_company_account_recv t
   where t.account_id = v_co_account_id
     for update;

  ---2.锁出实体卡账户
  select t.balance
    into l_out_bank_balance
    from fd_bank_account_info t
   where t.account_id = v_out_bank_account_id
     for update;

  ---3.锁入账实体卡账户
  select t.balance
    into l_in_bank_balance
    from fd_bank_account_info t
   where t.account_id = v_in_bank_account_id
     for update;

  ---4.检查实体卡账户余额
  if ((v_amount + v_service_fee) > l_out_bank_balance) then
    return pkg_error_code.balance_low;
  end if;

  --========================添加资金变动记录=============================
  ---1.获取银行卡变动记录批处理号---用于标记结算涉及的所有银行资金变动记录
  select seq_bank_service_id.nextval into l_batch_service_id from dual;

  ---2.公司结算账户扣款
  update fd_base_company_account_recv t
     set t.balance          = (l_co_balance - v_amount),
         t.last_update_time = sysdate,
         t.last_update_user = v_handle_user
   where t.account_id = v_co_account_id;

  ---3.公司间结算账户添加资金变动
  insert into fd_trade_co_recv_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     handle_user,
     remark)
  values
    (seq_trade_co_recv_fund_id.nextval,
     v_co_account_id,
     v_amount,
     pkg_co_fund_recv_type.minus_amount,
     (l_co_balance - v_amount),
     sysdate,
     pkg_sys_boolean.isfalse,
     0,
     l_batch_service_id,
     v_handle_user,
     v_memo);

  ---4.出账银行卡账户扣款
  update fd_bank_account_info t
     set t.balance        = (l_out_bank_balance - v_amount - v_service_fee),
         t.last_edit_user = v_handle_user,
         t.last_edit_time = sysdate
   where t.account_id = v_out_bank_account_id;

  ---5.出账实体卡扣除手续费资金变动
  if v_service_fee > 0 then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
    values
      (seq_bank_cash_fund_id.nextval,
       v_out_bank_account_id,
       0,
       l_owe_company_id,
       v_service_fee,
       (l_out_bank_balance - v_service_fee),
       sysdate,
       v_handle_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       pkg_sys_boolean.isfalse,
       '',
       l_settle_account_name,
       v_memo,
       l_batch_service_id,v_remark_name_in);
  end if;

  ---6.出账实体卡扣款资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_out_bank_account_id,
     0,
     l_owe_company_id,
     v_amount,
     (l_out_bank_balance - v_amount - v_service_fee),
     sysdate,
     v_handle_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.up_add,
     pkg_sys_boolean.isfalse,
     '',
     l_settle_account_name,
     v_memo,
     l_batch_service_id,v_remark_name_in);

  ---7.入账银行卡账户加款
  update fd_bank_account_info t
     set t.balance        = (l_in_bank_balance + v_amount),
         t.last_edit_user = v_handle_user,
         t.last_edit_time = sysdate
   where t.account_id = v_in_bank_account_id;

  ---8.入账公司加款资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_in_bank_account_id,
     0,
     l_recv_company_id,
     v_amount,
     (l_in_bank_balance + v_amount),
     sysdate,
     v_handle_user,
     pkg_bank_fund_change_type.add_amount,
     pkg_bank_use_type.down_add,
     pkg_sys_boolean.isfalse,
     '',
     l_settle_account_name,
     v_memo,
     l_batch_service_id,v_remark_name);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_CO_SETTLE_CHECK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_bank_co_settle_check(v_co_account_id       number,
                                                     v_out_bank_account_id number,
                                                     v_in_bank_account_id  number,
                                                     v_amount              number,
                                                     v_service_fee         number)
  return varchar2 is
  -------------------检查公司间结算账户及余额信息------------------

  l_out_balance    number;
  l_in_balance     number;
  l_co_out_company number;
  l_co_in_company  number;
begin
  ---1.检查公司间结算账户
  select t.owe_company, t.recv_company
    into l_co_out_company, l_co_in_company
    from fd_base_company_account_recv t
   where t.account_id = v_co_account_id;

  ---2.检查实体卡账户
  select t.balance
    into l_out_balance
    from fd_bank_account_info t
   where t.account_id = v_out_bank_account_id
     and t.company_id = l_co_out_company;

  select t.balance
    into l_in_balance
    from fd_bank_account_info t
   where t.account_id = v_in_bank_account_id
     and t.company_id = l_co_in_company;

  ---3.粗略检查出账实体卡余额
  if (v_amount + v_service_fee > l_out_balance) then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function FD_F_BANK_FUND_ADD_T
prompt ======================================
prompt
create or replace function fd_account.fd_f_bank_fund_add_t(v_bank_account_id number,
                                                v_amount          number,
                                                v_change_type     number,
                                                v_use_type        number,
                                                v_create_user     varchar2,
                                                v_create_time     varchar2,
                                                v_link_channel_no varchar2,
                                                v_link_account_id varchar2,
                                                v_memo            varchar2,
                                                v_record_no       varchar2)
  return varchar2 is
  --------------------添加实体卡资金变动--------------------
  l_balance      number;
  l_company_id   number;
  l_fund_balance number;
  l_fund_time    date;
  l_cash_fund_id number;
  l_fund_count   number;
begin
  ---1.锁实体卡账户
  select t.balance, t.company_id
    into l_balance, l_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---1.1检查记录是否存在
  select count(1)
    into l_fund_count
    from fd_bank_cash_fund t
   where t.record_no = v_record_no
     and rownum <= 1;

  if l_fund_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  select seq_bank_cash_fund_id.nextval,
         to_date(nvl(v_create_time, to_char(sysdate, 'yyyymmddhh24miss')),
                 'yyyymmddhh24miss')
    into l_cash_fund_id, l_fund_time
    from dual;

  ---2.构建资金变动参数
  if v_change_type = 1 then
    ---2.1.加款
    l_fund_balance := l_balance + v_amount;
  else
    ---2.2. 减款
    l_fund_balance := l_balance - v_amount;
  end if;

  ---3.实体卡资金变动
  update fd_bank_account_info t
     set t.balance        = l_fund_balance,
         t.last_edit_user = v_create_user,
         t.last_edit_time = l_fund_time
   where t.account_id = v_bank_account_id;

  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     record_no)
  values
    (l_cash_fund_id,
     v_bank_account_id,
     0,
     l_company_id,
     v_amount,
     l_fund_balance,
     l_fund_time,
     v_create_user,
     v_change_type,
     v_use_type,
     1,
     v_link_channel_no,
     v_link_account_id,
     v_memo,
     v_record_no);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_PRE_MINUS_CHECK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_bank_pre_minus_check(v_cap_account_id number,
                                                     v_amount         number,
                                                     v_record_no      varchar2)
  return varchar2 is
  ---------------------检查预付账户---------------------
  l_count        number;
  l_balance      number;
  l_record_count number;
begin
  ---1.检查对应金额是否正确
  /*  if (v_amount <= 0) then
    return pkg_error_code.amount_error;
  end if;*/

  ---2.检查实体卡账户
  select count(1), max(t.balance)
    into l_count, l_balance
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     and t.account_type = pkg_co_cap_account_type.prepayment
     and t.status = 0
     and rownum <= 1;

  if l_count = 0 then
    return pkg_error_code.data_error;
  end if;

  ---3.检查重复同步
  select count(1)
    into l_record_count
    from fd_trade_co_cap_fund t
   inner join fd_base_company_account_cap c on t.account_id = c.account_id
   where t.record_no = v_record_no
     and c.account_id = v_cap_account_id
     and rownum <= 1;

  if l_record_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  /*  if v_amount > l_balance then
    return pkg_error_code.balance_low;
  end if;*/

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_PROFIT_CHECK
prompt ========================================
prompt
create or replace function fd_account.fd_f_bank_profit_check(v_cap_account_id  number,
                                                  v_bank_account_id number,
                                                  v_profit          number,
                                                  v_service_fee     number)
  return varchar2 is
  ------------------检查利润相关信息---------------------
  l_profit_balance number;
  l_company_id     number;
  l_bank_balance   number;
begin
  ---1.检查利润数据
  if v_profit <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查毛利润
  select t.balance, t.company_id
    into l_profit_balance, l_company_id
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     and t.account_type = pkg_co_cap_account_type.profit;

  if v_profit > l_profit_balance then
    return pkg_error_code.balance_low;
  end if;

  ---3.检查银行账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     and t.company_id = l_company_id;

  if (v_profit + v_service_fee) > l_bank_balance then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_PROFIT_DRAW
prompt =======================================
prompt
create or replace function fd_account.fd_f_bank_profit_draw(v_cap_account_id  number,
                                                 v_bank_account_id number,
                                                 v_profit          number,
                                                 v_service_fee     number,
                                                 v_draw_user       varchar2,
                                                 v_memo            varchar2)
  return varchar2 is
  ------------------毛利润提现-----------------
  l_profit_balance      number;
  l_bank_balance        number;
  l_bank_batch_id       number;
  l_company_id          number;
  l_profit_account_name varchar2(32);
begin
  ---1.锁毛利润账户
  select t.balance, t.account_name
    into l_profit_balance, l_profit_account_name
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     for update;

  ---2.锁银行卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---3.检查余额
  if v_profit > l_profit_balance or
     (v_profit + v_service_fee) > l_bank_balance then
    return pkg_error_code.balance_low;
  end if;

  ---4.毛利润账户扣款
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  update fd_base_company_account_cap t
     set t.balance        = (l_profit_balance - v_profit),
         t.last_edit_user = v_draw_user,
         t.last_edit_time = sysdate
   where t.account_id = v_cap_account_id;

  ---5.添加毛利润账户资金变动
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     create_user)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_cap_account_id,
     v_profit,
     pkg_co_cap_fund_type.minus_amount,
     (l_profit_balance - v_profit),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     l_bank_batch_id,
     v_memo,
     v_draw_user);

  ---6.银行账户扣款
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_profit - v_service_fee),
         t.last_edit_user = v_draw_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---7.银行账户手续费变动记录
  if v_service_fee > 0 then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       0,
       l_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_draw_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       pkg_sys_boolean.isfalse,
       '-',
       l_profit_account_name,
       v_memo,
       l_bank_batch_id);
  end if;

  ---8.银行账户毛利润提现记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     0,
     l_company_id,
     v_profit,
     (l_bank_balance - v_profit - v_service_fee),
     sysdate,
     v_draw_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.profits_withdraw,
     pkg_sys_boolean.isfalse,
     '-',
     l_profit_account_name,
     v_memo,
     l_bank_batch_id);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_RCV_RECORD_UPDATE
prompt =============================================
prompt
create or replace function fd_account.fd_f_bank_rcv_record_update(v_apply_id         in number, --加款申请编号
                                                       v_pay_time         in date, --付款时间
                                                       v_apply_account_no in varchar2, --客户银行账号
                                                       v_add_amount       in number, --加款金额
                                                       v_tran_no          in varchar2, --柜员交易号
                                                       v_bank_id          in number,--收款银行账号
                                                       v_auto_add_on_time in date--自动加款开启时间
                                                       )
  return varchar2 is
  ---------------------------------
  --功能：修改银行流水状态
  --创建人：周荣省
  --创建时间：2019-09-12
  ---------------------------------
  l_record_id number;
begin
  --1、查找并锁银行流水
  select t.record_id
    into l_record_id
    from fd_b2e_bank_receive_record t
   where t.receive_time >= v_pay_time - 1
     and t.receive_time < v_pay_time + 1
     and t.client_card_no = v_apply_account_no
     and t.receive_amount = v_add_amount
     and t.bank_svr_seq = v_tran_no
     and t.trade_type = 2
     and t.deal_status = Pkg_b2e_deal_status.Wait
     and t.bank_account_id = v_bank_id
     and t.receive_time>v_auto_add_on_time
     and rownum <= 1
     for update;
  if l_record_id > 0 then
    --2、修改银行流水状态
    update fd_b2e_bank_receive_record t
       set t.match_type   = 2,
           t.deal_status  = 0,
           t.receive_type = 1,
           t.apply_id     = v_apply_id,
           t.deal_time    = sysdate,
           t.deal_memo    = '手工匹配'
     where t.record_id = l_record_id;
  end if;
  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.not_exists;
end;
/

prompt
prompt Creating function FD_F_BANK_SERVICE_ADD_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_bank_service_add_check(v_bank_account_id number,
                                                       v_amount          number,
                                                       v_cap_account_id  out number)
  return varchar2 is
  ---------------------检查借支、押金、保证金、短期借债的账户及金额---------------------
  l_bank_count   number;
  l_bank_balance number;
begin
  ---1.检查对应金额是否正确
  if (v_amount <= 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查实体卡账户
  select count(1), max(t.balance), max(c.account_id)
    into l_bank_count, l_bank_balance, v_cap_account_id
    from fd_bank_account_info t
   inner join fd_base_company_account_self c on t.company_id = c.company_id
   where t.account_id = v_bank_account_id
     and c.account_type = pkg_co_self_account_type.service_fee
     and rownum <= 1;

  if l_bank_count = 0 then
    return pkg_error_code.data_error;
  end if;

  ---3.检查银行卡余额
  if v_amount > l_bank_balance then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_SERVICE_FEE_ADD
prompt ===========================================
prompt
create or replace function fd_account.fd_f_bank_service_fee_add(v_bank_account_id number,
                                                     v_self_account_id number,
                                                     v_amount          number,
                                                     v_hander_user     varchar2,
                                                     v_remark_name       varchar2,--收付款账户名称
                                                     v_memo            varchar2)
  return varchar2 is
  --------------------------------------
  --功能;资产账户减款
  --修改人:周荣省
  --修改时间：2019-08-27
  --修改内容：添加收付款账户名称
  --------------------------------------
  l_self_balance      number;
  l_bank_balance      number;
  l_company_id        number;
  l_batch_service_id  number;
  l_self_account_name varchar2(100);
begin
  ---1.锁资产账户
  select t.balance, t.account_name
    into l_self_balance, l_self_account_name
    from fd_base_company_account_self t
   where t.account_id = v_self_account_id
     for update;

  ---2.锁银行卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---3.获取银行处理的批次编号
  select seq_bank_service_id.nextval into l_batch_service_id from dual;

  ---4.修改资产账户余额
  update fd_base_company_account_self t
     set t.balance        = (l_self_balance + v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_self_account_id;

  ---5.添加资产账户变动记录
  insert into fd_trade_co_self_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     create_user)
  values
    (seq_trade_co_self_fund_id.nextval,
     v_self_account_id,
     v_amount,
     pkg_co_self_fund_type.add_amount,
     (l_self_balance + v_amount),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     l_batch_service_id,
     v_memo,
     v_hander_user);

  ---6.修改银行卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---8.添加银行卡资金变动记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     0,
     l_company_id,
     v_amount,
     (l_bank_balance - v_amount),
     sysdate,
     v_hander_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.service_fee,
     pkg_sys_boolean.isfalse,
     '',
     l_self_account_name,
     v_memo,
     l_batch_service_id,v_remark_name);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_SERVICE_FEE_MINUS
prompt =============================================
prompt
create or replace function fd_account.fd_f_bank_service_fee_minus(v_bank_account_id number,
                                                       v_self_account_id number,
                                                       v_amount          number,
                                                       v_hander_user     varchar2,
                                                       v_remark_name     varchar2,--收付款账户名称
                                                       v_memo            varchar2)
  return varchar2 is
  -----------------手续费账户减款、银行计息----------------
  l_self_balance      number;
  l_bank_balance      number;
  l_company_id        number;
  l_batch_service_id  number;
  l_self_account_name varchar2(100);
begin
  ---1.锁资产账户
  select t.balance, t.account_name
    into l_self_balance, l_self_account_name
    from fd_base_company_account_self t
   where t.account_id = v_self_account_id
     for update;

  ---2.锁银行卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---3.获取银行处理的批次编号
  select seq_bank_service_id.nextval into l_batch_service_id from dual;

  ---4.修改资产账户余额
  update fd_base_company_account_self t
     set t.balance        = (l_self_balance - v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_self_account_id;

  ---5.添加资产账户变动记录
  insert into fd_trade_co_self_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     create_user)
  values
    (seq_trade_co_self_fund_id.nextval,
     v_self_account_id,
     v_amount,
     pkg_co_self_fund_type.minus_amount,
     (l_self_balance - v_amount),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     l_batch_service_id,
     v_memo,
     v_hander_user);

  ---6.修改银行卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---8.添加银行卡资金变动记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     0,
     l_company_id,
     v_amount,
     (l_bank_balance + v_amount),
     sysdate,
     v_hander_user,
     pkg_bank_fund_change_type.add_amount,
     pkg_bank_use_type.service_fee,
     pkg_sys_boolean.isfalse,
     '',
     l_self_account_name,
     v_memo,
     l_batch_service_id,v_remark_name);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_SERVICE_MINUS_CHECK
prompt ===============================================
prompt
create or replace function fd_account.fd_f_bank_service_minus_check(v_bank_account_id number,
                                                         v_amount          number,
                                                         v_cap_account_id  out number)
  return varchar2 is
  ---------------------银行计息检查---------------------
  l_bank_count number;
begin
  ---1.检查对应金额是否正确
  if (v_amount <= 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查实体卡账户
  select count(1), max(c.account_id)
    into l_bank_count, v_cap_account_id
    from fd_bank_account_info t
   inner join fd_base_company_account_self c on t.company_id = c.company_id
   where t.account_id = v_bank_account_id
     and c.account_type = pkg_co_self_account_type.service_fee
     and rownum <= 1;

  if l_bank_count = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_STREAM_ADD
prompt ======================================
prompt
create or replace function fd_account.fd_f_bank_stream_add(v_accountNo        in varchar2, --己方银行账户
                                                v_BankType         in number, --开户行类型 12：中信银行
                                                v_tranDate         in varchar2, --交易日期，格式YYYYMMDDhhmmss
                                                v_tranNo           in varchar2, --柜员交易号
                                                v_sumTranNo        in varchar2, --总交易流水号
                                                v_tranAmount       in number, --交易金额
                                                v_creditDebitFlag  in varchar2, --借贷标识 借：D，贷：C
                                                v_oppAccountNo     in varchar2, --对方账号
                                                v_oppAccountName   in varchar2, --对方账户名称
                                                v_oppOpenBankName  in varchar2, --对方开户行名
                                                v_abstract         in varchar2, --附言
                                                v_cashTransferFlag in number, --现转标识 0：现金；1：转帐
                                                v_balance          in number, --账户余额
                                                v_hostTranCode     in varchar2 --主机交易码
                                                ) return varchar2 is
  ---------------------------------
  --功能：插入银行流水
  --创建人：周荣省
  --创建时间：2019-09-12
  ---------------------------------
  l_bank_account_id number;
begin
  select t.account_id
    into l_bank_account_id
    from fd_bank_account_info t
   where t.card_no = v_accountNo
     and t.company_id = 1
     and t.bank_type = v_BankType;
  insert into fd_bank_stream_full
    (id,
     bank_account_id,
     card_no,
     bank_type,
     tran_date,
     tran_no,
     sum_tran_no,
     tran_amount,
     credit_debit_flag,
     opp_account_no,
     opp_account_name,
     opp_open_bank_name,
     abstract,
     balance,
     host_tran_code,
     cash_transfer_flag,
     create_time)
  values
    (seq_fdbankstreamfull_auto_id.nextval,
     l_bank_account_id,
     v_accountNo,
     v_BankType,
     to_date(v_tranDate, 'yyyymmddhh24miss'),
     v_tranNo,
     v_sumTranNo,
     v_tranAmount,
     v_creditDebitFlag,
     v_oppAccountNo,
     v_oppAccountName,
     v_oppOpenBankName,
     v_abstract,
     v_balance,
     v_hostTranCode,
     v_cashTransferFlag,
     sysdate);
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_STREAM_CHECK
prompt ========================================
prompt
create or replace function fd_account.fd_f_bank_stream_check(v_accountNo    in varchar2, --己方银行账户
                                                  v_BankType     in number, --开户行类型 12：中信银行
                                                  v_oppAccountNo in varchar2, --对方账号
                                                  v_sumTranNo    in varchar2 --总交易流水号
                                                  ) return varchar2 is
  ---------------------------------
  --功能：判断银行流水是否存在
  --创建人：周荣省
  --创建时间：2019-09-12
  ---------------------------------
  l_number number;
begin
  select count(0)
    into l_number
    from fd_bank_stream_full t
   where t.bank_type = v_BankType
     and t.card_no = v_accountNo
     and t.opp_account_no = v_oppAccountNo
     and t.sum_tran_no = v_sumTranNo;
  if l_number < 1 then
    return pkg_error_code.not_exists;
  end if;
  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.not_exists;
end;
/

prompt
prompt Creating function FD_F_BANK_TRANSFER
prompt ====================================
prompt
create or replace function fd_account.fd_f_bank_transfer(v_out_bank_account_id number,
                                              v_in_bank_account_id  number,
                                              v_transfer_amount     number,
                                              v_out_service_fee     number,
                                              v_hander_user         varchar2,
                                              v_link_channel_name   varchar2,
                                              v_link_account_name   varchar2,
                                              v_memo                varchar2)
  return varchar2 is
  ---------------实体卡转账-----------------
  l_out_balance      number;
  l_in_balance       number;
  l_in_company_id    number;
  l_out_company_id   number;
  l_bank_batch_id    number;
  l_out_account_name varchar2(64);
  l_in_account_name  varchar2(64);
  l_out_card_no      varchar2(64);
  l_in_card_no       varchar2(64);
begin

  ---1.锁转出银行卡账户
  select t.balance, t.company_id, t.account_name, t.card_no
    into l_out_balance, l_out_company_id, l_out_account_name, l_out_card_no
    from fd_bank_account_info t
   where t.account_id = v_out_bank_account_id
     for update;

  ---2.锁转入银行卡账户
  select t.balance, t.company_id, t.account_name, t.card_no
    into l_in_balance, l_in_company_id, l_in_account_name, l_in_card_no
    from fd_bank_account_info t
   where t.account_id = v_in_bank_account_id
     for update;

  ---3.检查转出银行卡余额
  if (v_transfer_amount + v_out_service_fee) > l_out_balance then
    return pkg_error_code.balance_low;
  end if;

  ---4.修改转出银行卡余额
  update fd_bank_account_info t
     set t.balance        = (l_out_balance - v_transfer_amount -
                            v_out_service_fee),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_out_bank_account_id;

  ---5.添加转出银行卡手续费资金变动
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  if v_out_service_fee > 0 then
  
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
    values
      (seq_bank_cash_fund_id.nextval,
       v_out_bank_account_id,
       0,
       l_out_company_id,
       v_out_service_fee,
       (l_out_balance - v_out_service_fee),
       sysdate,
       v_hander_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       pkg_sys_boolean.isfalse,
       '',
       l_in_account_name || '_' || substr(l_in_card_no, -4),
       v_memo,
       l_bank_batch_id);
  end if;

  ---6.添加转出银行卡转账资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_out_bank_account_id,
     0,
     l_out_company_id,
     v_transfer_amount,
     (l_out_balance - v_transfer_amount - v_out_service_fee),
     sysdate,
     v_hander_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.transfer,
     pkg_sys_boolean.isfalse,
     '',
     l_in_account_name || '_' || substr(l_in_card_no, -4),
     v_memo,
     l_bank_batch_id);

  ---7.修改入账银行卡余额
  update fd_bank_account_info t
     set t.balance        = (l_in_balance + v_transfer_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_in_bank_account_id;

  ---8.添加入账银行卡资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_in_bank_account_id,
     0,
     l_in_company_id,
     v_transfer_amount,
     (l_in_balance + v_transfer_amount),
     sysdate,
     v_hander_user,
     pkg_bank_fund_change_type.add_amount,
     pkg_bank_use_type.transfer,
     pkg_sys_boolean.isfalse,
     '',
     l_out_account_name || '_' || substr(l_out_card_no, -4),
     v_memo,
     l_bank_batch_id);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_BANK_TRANSFER_CHECK
prompt ==========================================
prompt
create or replace function fd_account.fd_f_bank_transfer_check(v_out_bank_account_id number,
                                                    v_in_bank_account_id  number,
                                                    v_transfer_amount     number,
                                                    v_out_service_fee     number)
  return varchar2 is
  -----------------实体卡转账账户及金额检查------------------
  l_out_count      number;
  l_out_balance    number;
  l_in_count       number;
  l_out_company_id number;
  l_in_company_id  number;
begin

  ---1.检查转账金额与手续费是否正确
  if (v_out_bank_account_id = v_in_bank_account_id or
     v_transfer_amount <= 0 or v_out_service_fee < 0) then
    return pkg_error_code.param_error;
  end if;

  ---2.检查实体卡是否存在
  select count(1), max(t.balance), max(t.company_id)
    into l_out_count, l_out_balance, l_out_company_id
    from fd_bank_account_info t
   where t.account_id = v_out_bank_account_id;

  select count(1), max(t.company_id)
    into l_in_count, l_in_company_id
    from fd_bank_account_info t
   where t.account_id = v_in_bank_account_id;

  if (l_out_count = 0 or l_in_count = 0 or
     l_out_company_id != l_in_company_id) then
    return pkg_error_code.bank_account_id_error;
  end if;

  if ((v_transfer_amount + v_out_service_fee) > l_out_balance) then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_CAPITAL_USE_RATE_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_capital_use_rate_check(v_record_id in number)
  return number is
  -------------检查资金利用率数据是否应该显示红色------------
  l_average_draw    number;
  l_account_balance number;
  l_no_draw_days    number;
  l_capital_class   number;
begin
  ---1.获取基础数据
  select rt.capital_class,
         rt.average_draw,
         rt.account_balance,
         rt.no_draw_days
    into l_capital_class, l_average_draw, l_account_balance, l_no_draw_days
    from fd_report_capital_use_rate rt
   where rt.record_id = v_record_id;

  ---2.无需判断的渠道排除(普通话费、普通流量、余额小于1000)
  if (l_capital_class != pkg_channel_capital_class.normal_huafei and
     l_capital_class != pkg_channel_capital_class.normal_flow) or
     l_account_balance < 1000 then
  
    return 0;
  end if;

  ---3.前三天平均交易额小于当前余额1/5
  if l_average_draw < 0.2 * l_account_balance then
    return 1;
  end if;

  ---4.累计无交易天数>=3
  if l_no_draw_days >= 3 then
    return 1;
  end if;

  ---5.日均交易量大于5万普通流量余额>=日均量的60%
  if (l_capital_class = pkg_channel_capital_class.normal_flow and
     l_average_draw >= 50000 and l_account_balance >= 0.6 * l_average_draw) then
    return 1;
  end if;

  return 0;

exception
  when others then
    fd_p_write_log('fd_f_capital_use_rate_check', sqlerrm, 1);
    return 0;
end;
/

prompt
prompt Creating function FD_F_CAP_JFB_ADD
prompt ==================================
prompt
create or replace function fd_account.fd_f_cap_jfb_add(v_down_channel_no  varchar2,
                                            v_down_account_id  number,
                                            v_down_jfb_month   varchar2,
                                            v_down_draw_amount number,
                                            v_business_type    number,
                                            v_create_user      varchar2,
                                            v_memo             varchar2)
  return varchar2 is
  -------------------集分宝账户加款------------------
  l_down_company_id number;
  l_jfb_account_id  number;
  l_jfb_balance     number;
  l_co_cap_fund_id  number;
begin
  ---1.获取下游渠道信息
  select t.company_id
    into l_down_company_id
    from fd_base_down_channel t
   where t.channel_no = v_down_channel_no;

  ---2.锁集分宝账户
  select t.account_id, t.balance
    into l_jfb_account_id, l_jfb_balance
    from fd_base_company_account_cap t
   where t.company_id = l_down_company_id
     and t.account_type = pkg_co_cap_account_type.jfb_account
     and rownum <= 2
     for update;

  ---3.集分宝账户加款
  update fd_base_company_account_cap t
     set t.balance       =
         (l_jfb_balance + v_down_draw_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_jfb_account_id;

  ---4.集分宝账户加款记录添加
  select seq_trade_co_cap_fund_id.nextval into l_co_cap_fund_id from dual;

  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     memo,
     create_user)
  values
    (l_co_cap_fund_id,
     l_jfb_account_id,
     v_down_draw_amount,
     pkg_co_cap_fund_type.add_amount,
     (l_jfb_balance + v_down_draw_amount),
     sysdate,
     v_memo,
     v_create_user);

  insert into fd_trade_co_cap_fund_jfb
    (change_id,
     trade_month,
     down_channel_no,
     down_account_id,
     business_type,
     settle_status)
  values
    (l_co_cap_fund_id,
     trunc(to_date(v_down_jfb_month, 'yyyymmddhh24miss'), 'mm'),
     v_down_channel_no,
     v_down_account_id,
     v_business_type,
     pkg_co_cap_jfb_settle_status.wait_settle);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_CAP_JFB_INFO_CHECK
prompt =========================================
prompt
create or replace function fd_account.fd_f_cap_jfb_info_check(v_co_cap_fund_id  number,
                                                   v_down_channel_no out varchar2,
                                                   v_down_account_id out number,
                                                   v_change_amount   out number)
  return varchar2 is
  -------------集分宝结算信息检查-------------
begin
  ---1.检查结算数据是否正确
  select j.down_channel_no, j.down_account_id, t.change_amount
    into v_down_channel_no, v_down_account_id, v_change_amount
    from fd_trade_co_cap_fund t
   inner join fd_trade_co_cap_fund_jfb j
      on t.change_id = j.change_id
   where t.change_id = v_co_cap_fund_id
     and t.change_type = pkg_co_cap_fund_type.add_amount
     and j.settle_status = pkg_co_cap_jfb_settle_status.wait_settle;

  ---2.检查渠道账户是否正确
  select t.account_id
    into v_down_account_id
    from fd_base_down_account_map t
   inner join fd_base_down_account a
      on t.account_id = a.account_id
   inner join fd_base_down_channel c
      on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
     and rownum <= 2;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_CAP_JFB_MINUS
prompt ====================================
prompt
create or replace function fd_account.fd_f_cap_jfb_minus(v_co_cap_fund_id number,
                                              v_settle_user    varchar2,
                                              v_memo           varchar2)
  return varchar2 is
  l_change_id       number;
  l_cap_account_id  number;
  l_change_amount   number;
  l_trade_month     date;
  l_down_channel_no varchar2(32);
  l_down_account_id number;
  l_business_type   number;
  l_jfb_balance     number;
  l_co_cap_fund_id  number;
begin
  ---1.获取并锁住待结算记录
  select t.change_id
    into l_change_id
    from fd_trade_co_cap_fund_jfb t
   where t.change_id = v_co_cap_fund_id
     and t.settle_status = pkg_co_cap_jfb_settle_status.wait_settle
     for update;

  select t.account_id,
         t.change_amount,
         j.trade_month,
         j.down_channel_no,
         j.down_account_id,
         j.business_type
    into l_cap_account_id,
         l_change_amount,
         l_trade_month,
         l_down_channel_no,
         l_down_account_id,
         l_business_type
    from fd_trade_co_cap_fund t
   inner join fd_trade_co_cap_fund_jfb j
      on t.change_id = j.change_id
   where t.change_id = v_co_cap_fund_id;

  ---2.锁集分宝账户
  select t.balance
    into l_jfb_balance
    from fd_base_company_account_cap t
   where t.account_id = l_cap_account_id
     and t.account_type = pkg_co_cap_account_type.jfb_account
     for update;

  ---3.集分宝账户减款
  update fd_base_company_account_cap t
     set t.balance       =
         (l_jfb_balance - l_change_amount),
         t.last_edit_user = v_settle_user,
         t.last_edit_time = sysdate
   where t.account_id = l_cap_account_id;

  ---4.集分宝账户加款记录添加
  select seq_trade_co_cap_fund_id.nextval into l_co_cap_fund_id from dual;

  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     memo,
     create_user)
  values
    (l_co_cap_fund_id,
     l_cap_account_id,
     l_change_amount,
     pkg_co_cap_fund_type.minus_amount,
     (l_jfb_balance - l_change_amount),
     sysdate,
     v_memo,
     v_settle_user);

  insert into fd_trade_co_cap_fund_jfb
    (change_id,
     trade_month,
     down_channel_no,
     down_account_id,
     business_type,
     settle_status)
  values
    (l_co_cap_fund_id,
     l_trade_month,
     l_down_channel_no,
     l_down_account_id,
     l_business_type,
     pkg_co_cap_jfb_settle_status.complete);

  ---5.修改原记录状态
  update fd_trade_co_cap_fund_jfb t
     set t.settle_status = pkg_co_cap_jfb_settle_status.complete
   where t.change_id = v_co_cap_fund_id
     and t.settle_status = pkg_co_cap_jfb_settle_status.wait_settle;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_COMMISION_SETTLE_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_commision_settle_check(v_record_id   number)
  return varchar2 is
  -------------------------------
  --功能：佣金结算红冲检查
  --创建人：周荣省
  --创建时间：2019-08-21
  -------------------------------
  l_record_count number;
  l_change_time  date;
begin
  ---1. 检查加款记录、账户及余额
  select count(1), max(t.settle_time)
    into l_record_count, l_change_time
    from fd_trade_commission_settle t
   inner join fd_bank_cash_fund b on t.bank_batch_id = b.service_id
   where t.report_id = v_record_id
     and t.settle_type = pkg_commi_settle_type.settle
     and t.has_adjust = pkg_sys_boolean.isfalse
     and b.has_adjust = pkg_sys_boolean.isfalse
     and t.commission = b.change_amount;

  if (l_record_count != 1 and l_record_count != 2) then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_CO_ACCOUNT_NAME_ADD
prompt ==========================================
prompt
create or replace function fd_account.fd_f_co_account_name_add(v_account_id      in number, ---账户编号
                                                    v_account_type    in number, ---账户类型：1：上游，2：下游
                                                    v_co_account_name in varchar2, ---收付款账户名称
                                                    v_create_user     in varchar2 ---创建人
                                                    ) return varchar2 is

  --------------------------------------
  --功能：添加收付款账户名称
  --创建人：周荣省
  --创建时间：2019-09-09
  --------------------------------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('添加收付款账户名称',
                        v_create_user,
                        ('v_account_id=' || v_account_id ||
                        'v_co_account_name=' || v_co_account_name));
  --2.添加收付款账户名称
  insert into fd_base_co_account_name
    (id,
     account_id,
     co_account_name,
     co_account_type,
     created_user,
     created_time)
  values
    (seq_coaccountname_auto_id.nextval,
     v_account_id,
     v_co_account_name,
     v_account_type,
     v_create_user,
     sysdate);
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_CO_ACCOUNT_NAME_EDIT
prompt ===========================================
prompt
create or replace function fd_account.fd_f_co_account_name_edit(v_account_id      in number, ---账户编号
                                                     v_account_type    in number, ---账户类型：1：上游，2：下游
                                                     v_co_account_name in varchar2, ---收付款账户名称
                                                     v_create_user     in varchar2 ---创建人
                                                     ) return varchar2 is

  --------------------------------------
  --功能：修改收付款账户名称
  --创建人：周荣省
  --创建时间：2019-09-09
  --------------------------------------
  l_number number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('添加收付款账户名称',
                        v_create_user,
                        ('v_account_id=' || v_account_id ||
                        'v_co_account_name=' || v_co_account_name));
  --2.锁定行
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_account_id
     and t.co_account_type = v_account_type;
  --3.修改账户名称
  if l_number >= 0 then
    update fd_base_co_account_name t
       set t.co_account_name = v_co_account_name,
           t.last_edit_user  = v_create_user,
           t.last_edit_time  = sysdate
     where t.account_id = v_account_id
       and t.co_account_type = v_account_type;
  end if;
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_CO_SETTLE_AMOUNT_GET
prompt ===========================================
prompt
create or replace function fd_account.fd_f_co_settle_amount_get(v_down_company_id   number,
                                                     v_up_company_id     number,
                                                     v_business_type     number,
                                                     v_up_draw_face      number,
                                                     v_down_real_amount  number,
                                                     v_up_real_amount    number,
                                                     v_settle_amount     out number,
                                                     v_settle_account_id out number)
  return varchar2 is
  ------------------ 获取单笔上游资金变动公司间结算金额------------------
  l_down_profit_count number;
  l_statistics_type   number;
  l_down_profit_cost  number;
  l_up_profit_count   number;
  l_up_profit_cost    number;
begin
  ---1.获取公司账户---账户编号
  select t.account_id
    into v_settle_account_id
    from fd_base_company_account_recv t
   where t.owe_company = v_down_company_id
     and t.recv_company = v_up_company_id
     and v_down_company_id != v_up_company_id
     and t.owe_company != t.recv_company
     and t.status = pkg_sys_boolean.istrue
     and rownum <= 1;

  ---2.获取订单统计类型
  select t.statistics_type
    into l_statistics_type
    from fd_system_business_statis_map t
   where t.local_business_type = v_business_type;

  ---3.获取下游固定留取利润的结算价格
  select count(*), max(t.profit_cost)
    into l_down_profit_count, l_down_profit_cost
    from fd_base_company_settle_new t
   where t.profit_company_id = v_down_company_id
     and t.related_company_id = v_up_company_id
     and t.statistics_type = l_statistics_type
     and t.status = pkg_sys_boolean.istrue
     and rownum <= 1;

  if l_down_profit_count > 0 then
    if v_down_real_amount > 0 then
      v_settle_amount := v_down_real_amount -
                         v_up_draw_face * l_down_profit_cost;
    else
      v_settle_amount := v_up_real_amount;
    end if;
  
    return pkg_error_code.success;
  end if;

  ---4.获取上游游固定留取利润的结算价格
  select count(*), max(t.profit_cost)
    into l_up_profit_count, l_up_profit_cost
    from fd_base_company_settle_new t
   where t.profit_company_id = v_up_company_id
     and t.related_company_id = v_down_company_id
     and t.statistics_type = l_statistics_type
     and t.status = pkg_sys_boolean.istrue
     and rownum <= 1;

  if l_up_profit_count > 0 then
    v_settle_amount := v_up_real_amount + v_up_draw_face * l_up_profit_cost;
  
    return pkg_error_code.success;
  end if;

  return pkg_error_code.failure;
end;
/

prompt
prompt Creating function FD_F_CO_SETTLE_COST_GET
prompt =========================================
prompt
create or replace function fd_account.fd_f_co_settle_cost_get(v_down_company_id   number,
                                                   v_up_company_id     number,
                                                   v_up_channel_no     varchar2,
                                                   v_down_channel_no   varchar2,
                                                   v_business_type     number,
                                                   v_carrier_no        varchar2,
                                                   v_province_no       varchar2,
                                                   v_settle_cost       out number,
                                                   v_settle_account_id out number)
  return varchar2 is
  -----------------------获取公司结算折扣----------------------
  l_config_count number;
begin

  ---1.获取公司账户---账户编号
  select t.account_id
    into v_settle_account_id
    from fd_base_company_account_recv t
   where t.owe_company = v_down_company_id
     and t.recv_company = v_up_company_id
     and v_down_company_id != v_up_company_id
     and t.owe_company != t.recv_company
     and t.status = 0
     and rownum <= 1;

  ---2.获取结算折扣
  select count(1)
    into l_config_count
    from fd_base_company_settle_config t
   where t.recv_company = v_up_company_id
     and rownum <= 1;

  if l_config_count > 0 then
    select tab.settle_cost
      into v_settle_cost
      from (select t.settle_cost
              from fd_base_company_settle_config t
             where t.recv_company = v_up_company_id
               and t.owe_company in (v_down_company_id, 0)
               and t.up_channel_no in (v_up_channel_no, '*')
               and t.down_channel_no in (v_down_channel_no, '*')
               and t.business_type in (v_business_type, 0)
               and t.carrier_no in (v_carrier_no, '*')
               and t.province_no in (v_province_no, '*')
             order by t.owe_company     desc,
                      t.up_channel_no   desc,
                      t.down_channel_no desc,
                      t.business_type   desc,
                      t.carrier_no      desc,
                      t.province_no     desc) tab
     where rownum <= 1;
  else
    return pkg_error_code.failure;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_CREATE_CAP_ACCOUNT
prompt =========================================
prompt
create or replace function fd_account.fd_f_create_cap_account(v_company_name     varchar2,
                                                   v_company_id       number,
                                                   v_cap_account_type number,
                                                   v_create_user      varchar2,
                                                   v_cap_use_type     number)
  return varchar2 is
  ------------------创建资产账户----------------
  l_count number;
begin
  ---1.检查账户是否创建
  select count(1)
    into l_count
    from fd_base_company_account_cap t
   where t.company_id = v_company_id
     and t.account_type = v_cap_account_type;

  if l_count > 0 then
    return pkg_error_code.success;
  end if;

  ---2.创建相关账户
  insert into fd_base_company_account_cap
    (account_id,
     account_name,
     company_id,
     account_type,
     balance,
     status,
     created_by,
     created_time,
     last_edit_user,
     last_edit_time,
     use_type)
  values
    (seq_base_co_account_cap_id.nextval,
     v_company_name,
     v_company_id,
     v_cap_account_type,
     0,
     0,
     v_create_user,
     sysdate,
     v_create_user,
     sysdate,
     v_cap_use_type);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_CREATE_IMP_ACCOUNT
prompt =========================================
prompt
create or replace function fd_account.fd_f_create_imp_account(v_account_name varchar2,
                                                   v_company_id   number,
                                                   v_create_user  varchar2)
  return varchar2 is
  --------------------创建公司倒款账户---------------------
  l_count number;
begin
  ---1.检查公司倒款账户是否存在
  select count(1)
    into l_count
    from fd_base_company_account_imp t
   where t.company_id = v_company_id
     and rownum <= 1;

  if l_count > 0 then
    return pkg_error_code.success;
  end if;

  ---2.创建对应的倒款账户
  insert into fd_base_company_account_imp
    (account_id,
     account_name,
     company_id,
     balance,
     status,
     created_by,
     created_time,
     last_edit_user,
     last_edit_time)
  values
    (seq_base_co_account_imp_id.nextval,
     v_account_name,
     v_company_id,
     0,
     pkg_sys_boolean.istrue,
     v_create_user,
     sysdate,
     v_create_user,
     sysdate);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_CREATE_SELF_ACCOUNT
prompt ==========================================
prompt
create or replace function fd_account.fd_f_create_self_account(v_company_name     varchar2,
                                                    v_company_id       number,
                                                    v_sel_account_type number,
                                                    v_create_user      varchar2)
  return varchar2 is
  ------------------创建非资产账户----------------
  l_count number;
begin
  ---1.检查账户是否存在
  select count(1)
    into l_count
    from fd_base_company_account_self t
   where t.company_id = v_company_id
     and t.account_type = v_sel_account_type;

  if l_count > 0 then
    return pkg_error_code.success;
  end if;

  ---2.创建相关账户
  insert into fd_base_company_account_self
    (account_id,
     account_name,
     company_id,
     account_type,
     balance,
     status,
     created_by,
     created_time,
     last_edit_user,
     last_edit_time)
  values
    (seq_base_co_account_self_id.nextval,
     v_company_name,
     v_company_id,
     v_sel_account_type,
     0,
     0,
     v_create_user,
     sysdate,
     v_create_user,
     sysdate);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_CREATE_COMPANY_ACCOUNT
prompt =============================================
prompt
create or replace function fd_account.fd_f_create_company_account(v_company_id  number,
                                                       v_create_user varchar2)
  return varchar2 is

  ---------------------创建公司及其相关的账户-------------------
  l_company_name varchar2(32);
  l_result       varchar2(32);
begin
  --==============================0.获取公司信息=========================
  select t.company_name
    into l_company_name
    from fd_base_company_info t
   where t.company_id = v_company_id;

  ---=============================1.创建资产账户==========================
  --1.借支账户
  l_result := fd_f_create_cap_account(l_company_name || '(借支)',
                                      v_company_id,
                                      pkg_co_cap_account_type.borrow,
                                      v_create_user,
                                      pkg_co_cap_use_type.input);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  --2.押金账户
  l_result := fd_f_create_cap_account(l_company_name || '(押金)',
                                      v_company_id,
                                      pkg_co_cap_account_type.deposit,
                                      v_create_user,
                                      pkg_co_cap_use_type.operate);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  --3.保证金账户
  l_result := fd_f_create_cap_account(l_company_name || '(保证金)',
                                      v_company_id,
                                      pkg_co_cap_account_type.bond,
                                      v_create_user,
                                      pkg_co_cap_use_type.operate);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  ---============================2.创建非资产账户========================
  --1.汇款手续费账户
  l_result := fd_f_create_self_account(l_company_name || '(手续费)',
                                       v_company_id,
                                       pkg_co_self_account_type.service_fee,
                                       v_create_user);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  --2.下游已付佣金账户
  l_result := fd_f_create_self_account(l_company_name || '(下游已付佣金)',
                                       v_company_id,
                                       pkg_co_self_account_type.down_commission,
                                       v_create_user);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  --3.上游已收佣金账户
  l_result := fd_f_create_self_account(l_company_name || '(上游已收佣金)',
                                       v_company_id,
                                       pkg_co_self_account_type.up_commission,
                                       v_create_user);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  --4.毛利提取
  l_result := fd_f_create_self_account(l_company_name || '(毛利已提取)',
                                       v_company_id,
                                       pkg_co_self_account_type.profit_draw,
                                       v_create_user);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  --==============================3.创建公司倒款账户============================
  --1.倒款账户
  l_result := fd_f_create_imp_account(l_company_name || '(倒款)',
                                      v_company_id,
                                      v_create_user);
  if l_result != pkg_error_code.success then
    return l_result;
  end if;

  --==============================4.创建公司间结算账户==========================
  --1.作为来源公司创建账户
  insert into fd_base_company_account_recv
    (account_id,
     account_name,
     owe_company,
     recv_company,
     balance,
     remark,
     status,
     last_update_time,
     last_update_user)
    select seq_base_company_account_id.nextval,
           (t.company_name || '应收(' || l_company_name || ')'),
           v_company_id,
           t.company_id,
           0,
           '创建账户添加',
           0,
           sysdate,
           v_create_user
      from fd_base_company_info t
     where t.company_id != v_company_id
       and t.company_id not in
           (select r.recv_company
              from fd_base_company_account_recv r
             where r.owe_company = v_company_id);

  --2.作为目标公司创建账户
  insert into fd_base_company_account_recv
    (account_id,
     account_name,
     owe_company,
     recv_company,
     balance,
     remark,
     status,
     last_update_time,
     last_update_user)
    select seq_base_company_account_id.nextval,
           (l_company_name || '应收(' || t.company_name || ')'),
           t.company_id,
           v_company_id,
           0,
           '创建账户添加',
           0,
           sysdate,
           v_create_user
      from fd_base_company_info t
     where t.company_id != v_company_id
       and t.company_id not in
           (select r.owe_company
              from fd_base_company_account_recv r
             where r.recv_company = v_company_id);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_DOWN_CHANNEL_MANNUL
prompt ==========================================
prompt
create or replace function fd_account.fd_f_down_channel_mannul(v_down_channel_no    varchar2,
                                                    v_manual_change_type number,
                                                    v_amount             number,
                                                    v_create_user        varchar2,
                                                    v_memo               varchar2)
  return varchar2 is
  ---------------------上游渠道操作（加款、提款）-------------------
  l_down_account_id       number;
  l_inner_balance         number;
  l_fund_id               number;
  l_fund_type             number;
  l_balance_change_amount number;
begin
  ---1.获取上游渠道关联账户
  select t.account_id
    into l_down_account_id
    from fd_base_down_account_map t
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   inner join fd_base_down_account a on t.account_id = a.account_id
   where t.channel_no = v_down_channel_no;

  ---2.获取参数
  if v_manual_change_type = pkg_down_manual_change_type.add_amount then
    l_fund_type             := pkg_down_fund_change_type.add_amount;
    l_balance_change_amount := v_amount;
  elsif v_manual_change_type = pkg_down_manual_change_type.draw_amount then
    l_fund_type             := pkg_down_fund_change_type.draw_amount;
    l_balance_change_amount := -1 * v_amount;
  else
    return pkg_error_code.param_error;
  end if;

  select seq_trade_down_fund_id.nextval into l_fund_id from dual;

  ---2.锁下游渠道账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  ---3.更新渠道账户余额
  update fd_base_down_account t
     set t.inner_balance  = (l_inner_balance + l_balance_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_down_account_id;

  ---4.添加下游人工加款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_fund_id,
     v_down_channel_no,
     l_down_account_id,
     1,
     v_manual_change_type,
     v_amount,
     sysdate,
     (l_inner_balance + l_balance_change_amount),
     v_create_user,
     '',
     '',
     v_memo);

  ---5.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_id,
     0,
     v_down_channel_no,
     l_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     l_fund_type,
     v_amount,
     (l_inner_balance + l_balance_change_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_IMP_ACCOUNT_MINUS
prompt ========================================
prompt
create or replace function fd_account.fd_f_imp_account_minus(v_down_channel_no varchar2,
                                                  v_imp_account_id  number,
                                                  v_bank_batch_id   number,
                                                  v_amount          number,
                                                  v_create_user     varchar2,
                                                  v_memo            varchar2)
  return varchar2 is
  ---------------------倒款账户减款-----------------
  l_balance number;
begin
  ---1.锁倒款账户
  select t.balance
    into l_balance
    from fd_base_company_account_imp t
   where t.account_id = v_imp_account_id
     for update;

  ---2.检查账户余额
  if v_amount > l_balance then
    return pkg_error_code.balance_low;
  end if;

  ---3.倒款账户减款
  update fd_base_company_account_imp t
     set t.balance        = (l_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_imp_account_id;

  ---4.添加倒款变动记录
  insert into fd_trade_co_imp_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     use_type,
     balance,
     change_time,
     bank_batch_id,
     partner_account,
     create_user,
     remark)
  values
    (seq_trade_co_imp_fund_id.nextval,
     v_imp_account_id,
     v_amount,
     pkg_co_imp_fund_type.minus_amount,
     pkg_co_imp_use_type.down_add,
     (l_balance - v_amount),
     sysdate,
     v_bank_batch_id,
     v_down_channel_no,
     v_create_user,
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_IMP_ACCOUNT_MINUS_ADJUST
prompt ===============================================
prompt
create or replace function fd_account.fd_f_imp_account_minus_adjust(v_change_id   number,
                                                         v_create_user varchar2,
                                                         v_memo        varchar2)
  return varchar2 is
  ---------------------红冲倒款账户减款记录------------------
  l_account_id    number;
  l_change_amount number;
  l_balance       number;
begin
  ---1.获取倒款账户减款记录信息
  select t.account_id, t.change_amount
    into l_account_id, l_change_amount
    from fd_trade_co_imp_fund t
   where t.change_id = v_change_id;

  ---2.锁倒款账户
  select t.balance
    into l_balance
    from fd_base_company_account_imp t
   where t.account_id = l_account_id
     for update;

  ---3.修改账户余额
  update fd_base_company_account_imp t
     set t.balance        = (l_balance + l_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_account_id;

  ---4.添加红冲记录
  insert into fd_trade_co_imp_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     use_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     partner_account,
     create_user,
     remark)
    select seq_trade_co_imp_fund_id.nextval,
           t.account_id,
           (0 - t.change_amount),
           t.change_type,
           t.use_type,
           (l_balance + l_change_amount),
           sysdate,
           t.change_id,
           pkg_sys_boolean.istrue,
           t.partner_account,
           v_create_user,
           v_memo
      from fd_trade_co_imp_fund t
     where t.change_id = v_change_id;

  ---5.修改原纪录结算状态
  update fd_trade_co_imp_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.change_id = v_change_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_IMP_DOWN_ADD_ADJ_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_imp_down_add_adj_check(v_record_id   number,
                                                       v_adjust_days number,
                                                       v_change_id   out number)
  return varchar2 is
  ------------------倒款账户下游加款红冲检查------------------
  l_result varchar2(32);
begin

  ---1.检查下游加款信息
  l_result := fd_f_adjust_down_add_check(v_record_id, v_adjust_days);
  if l_result != pkg_error_code.success then
    return pkg_error_code.success;
  end if;

  ---2.检查倒款账户信息
  select f.change_id
    into v_change_id
    from fd_trade_down_manual t
   inner join fd_trade_co_imp_fund f on t.bank_fund_id = f.bank_batch_id
   inner join fd_base_company_account_imp i on f.account_id = i.account_id
   where t.record_id = v_record_id
     and rownum <= 1;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_ADD_CHECK
prompt ============================================
prompt
create or replace function fd_account.fd_f_manual_down_add_check(v_down_channel_no varchar2,
                                                      v_down_account_id number,
                                                      v_bank_account_id number,
                                                      v_amount          number,
                                                      v_service_fee     number,
                                                      v_account_name    out varchar2,
                                                      v_channel_name    out varchar2)
  return varchar2 is
  ----------------手工操作获取下游支付账户-----------------
  l_bank_count number;
  l_company_id number;
begin
  ---1. 判断金额是否大于0
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2. 检查下游渠道
  select c.company_id,a.account_name,c.channel_name
    into l_company_id,v_account_name,v_channel_name
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
        -- and a.status = 0
        --  and c.status = 0
     and rownum <= 1;

  ---3.检查实体卡账户是否存在
  select count(1)
    into l_bank_count
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id;

  if (l_bank_count = 0) then
    return pkg_error_code.bank_account_id_error;
  end if;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_IMP_DOWN_ADD_CHECK
prompt =========================================
prompt
create or replace function fd_account.fd_f_imp_down_add_check(v_down_channel_no varchar2,
                                                   v_down_account_id number,
                                                   v_bank_account_id number,
                                                   v_imp_account_id  number,
                                                   v_amount          number,
                                                   v_service_fee     number,
                                                   v_account_name    out varchar2,
                                                   v_channel_name    out varchar2)
  return varchar2 is
  l_balance number;
begin
  ---1.检查倒款账户信息
  select i.balance
    into l_balance
    from fd_base_down_imp_map t
   inner join fd_base_company_account_imp i on t.account_id = i.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_imp_account_id
     and c.company_id = i.company_id
     and rownum <= 1;

  ---2.检查倒款账户余额
  if v_amount > l_balance then
    return pkg_error_code.balance_low;
  end if;

  ---3.检查下游加款相关信息
  return fd_f_manual_down_add_check(v_down_channel_no,
                                    v_down_account_id,
                                    v_bank_account_id,
                                    v_amount,
                                    v_service_fee,
                                    v_account_name,
                                    v_channel_name);
end;
/

prompt
prompt Creating function FD_F_IMP_MANUAL_ADD
prompt =====================================
prompt
create or replace function fd_account.fd_f_imp_manual_add(v_account_id      number,
                                               v_amount          number,
                                               v_use_type        number,
                                               v_user            varchar2,
                                               v_partner_account varchar2,
                                               v_memo            varchar2)
  return varchar2 is
  --------------------倒款账户加款---------------------
  l_imp_balance      number;
begin
  ---1.锁倒款账户
  select t.balance
    into l_imp_balance
    from fd_base_company_account_imp t
   where t.account_id = v_account_id
     for update;

  ---2.修改倒款账户余额
  update fd_base_company_account_imp t
     set t.balance        = (l_imp_balance + v_amount),
         t.last_edit_user = v_user,
         t.last_edit_time = sysdate
   where t.account_id = v_account_id;

  ---3.添加倒款资金变动
  insert into fd_trade_co_imp_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     use_type,
     balance,
     change_time,
     partner_account,
     create_user,
     remark)
  values
    (seq_trade_co_imp_fund_id.nextval,
     v_account_id,
     v_amount,
     pkg_co_imp_fund_type.add_amount,
     v_use_type,
     (l_imp_balance + v_amount),
     sysdate,
     v_partner_account,
     v_user,
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_IMP_MANUAL_ADD_ADJUST
prompt ============================================
prompt
create or replace function fd_account.fd_f_imp_manual_add_adjust(v_change_id number,
                                                      v_user      varchar2,
                                                      v_memo      varchar2)
  return varchar2 is
  --------------------红冲手工倒款-------------------
  l_account_id    number;
  l_change_amount number;
  l_balance       number;
begin
  ---1.获取原倒款记录信息
  select t.account_id, t.change_amount
    into l_account_id, l_change_amount
    from fd_trade_co_imp_fund t
   where t.change_id = v_change_id;

  ---2.锁倒款账户
  select t.balance
    into l_balance
    from fd_base_company_account_imp t
   where t.account_id = l_account_id
     for update;

  ---3.修改账户余额
  update fd_base_company_account_imp t
     set t.balance        = (l_balance - l_change_amount),
         t.last_edit_user = v_user,
         t.last_edit_time = sysdate
   where t.account_id = l_account_id;

  ---4.添加红冲记录
  insert into fd_trade_co_imp_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     use_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     partner_account,
     create_user,
     remark)
    select seq_trade_co_imp_fund_id.nextval,
           t.account_id,
           (0 - t.change_amount),
           t.change_type,
           t.use_type,
           (l_balance - l_change_amount),
           sysdate,
           t.change_id,
           pkg_sys_boolean.istrue,
           t.partner_account,
           v_user,
           v_memo
      from fd_trade_co_imp_fund t
     where t.change_id = v_change_id;

  ---5.修改原纪录结算状态
  update fd_trade_co_imp_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.change_id = v_change_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_IMP_MANUAL_ADD_ADJ_CHECK
prompt ===============================================
prompt
create or replace function fd_account.fd_f_imp_manual_add_adj_check(v_change_id   number,
                                                         v_adjust_days number)
  return varchar2 is
  --------------------检查倒款账户加款记录--------------------
  l_count       number;
  l_change_time date;
begin
  ---1.获取倒款记录
  select count(1), max(t.change_time)
    into l_count, l_change_time
    from fd_trade_co_imp_fund t
   inner join fd_base_company_account_imp i on t.account_id = i.account_id
   where t.change_id = v_change_id
     and t.change_type = pkg_co_imp_fund_type.add_amount
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if l_count = 0 then
    return pkg_error_code.data_error;
  end if;

  if l_change_time < (trunc(sysdate) - v_adjust_days) then
    return pkg_error_code.adjust_timeout;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_IMP_MANUAL_ADD_CHECK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_imp_manual_add_check(v_account_id number,
                                                     v_amount     number,
                                                     v_use_type   number)
  return varchar2 is
  -----------------检查倒款信息-----------------
  l_count number;
begin
  ---1.检查金额
  if v_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查倒款账户
  select count(1)
    into l_count
    from fd_base_company_account_imp t
   where t.account_id = v_account_id
     and t.status = 0
     and v_use_type in
         (pkg_co_imp_use_type.zfb_imp, pkg_co_imp_use_type.cft_imp,
          pkg_co_imp_use_type.other);

  if l_count = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_ADD
prompt ======================================
prompt
create or replace function fd_account.fd_f_manual_down_add(v_down_channel_no varchar2,
                                                v_down_account_id number,
                                                v_bank_account_id number,
                                                v_amount          number, ---渠道到账金额
                                                v_service_fee     number, ---公司承担手续费
                                                v_create_user     varchar2,
                                                v_partner_account varchar2,
                                                v_memo            varchar2,
                                                v_account_name    varchar2,
                                                v_channel_name    varchar2,
                                                v_v_remark_name   in varchar2, --收付款账户名称
                                                v_bank_batch_id   out number)
  return varchar2 is
  l_inner_balance          number;
  l_credit_money           number;
  l_bank_balance           number;
  l_fund_record_main_id    number;
  l_fund_record_service_id number;
  l_bank_company           number;
  ------------下游手工加款----------
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

  -----银行卡手续费（资金变动(i)6）
  -----银行卡（账户表 (f)2，账户(u)5,加款资金变动(i)7）
  -----公司手续费（账户表(f)1，账户(u)3,资金变动(i)4）
  -----下游渠道（账户(f)8，账户(u)9,下游加款记录表(i)10,资金变动(i)11）
begin
  --================1.锁账户获取参数======================
  --=========[锁公司手续费账户、锁实体卡账户、检查实体卡余额、获取seq]=======

  --1.锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---2.获取部分添加参数

  select seq_trade_down_fund_id.nextval
    into l_fund_record_main_id
    from dual;
  select seq_trade_down_fund_id.nextval
    into l_fund_record_service_id
    from dual;

  ---获取银行卡资金变动统一流水号
  select seq_bank_service_id.nextval into v_bank_batch_id from dual;

  --====================3.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡手续费的资金变动、添加实体卡加款的资金变动]===
  ---1.更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---3.添加实体卡资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id,
     remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company,
     v_amount,
     (l_bank_balance + v_amount),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.add_amount,
     pkg_bank_use_type.down_add,
     v_channel_name,
     v_account_name,
     v_memo,
     v_bank_batch_id,
     v_v_remark_name);

  --==============4.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加下游手工加款记录、添加下游资金变动]=====
  ---1.锁下游渠道账户
  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.更新渠道账户余额
  update fd_base_down_account t
     set t.inner_balance  = (l_inner_balance + v_amount + v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---3.添加下游人工加款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_fund_record_main_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_create_user,
     v_bank_batch_id,
     v_partner_account,
     v_memo);

  if v_service_fee > 0 then
    insert into fd_trade_down_manual
      (record_id,
       channel_no,
       account_id,
       has_adjust,
       add_type,
       change_amount,
       change_time,
       balance,
       create_user,
       bank_fund_id,
       partner_account,
       memo)
    values
      (l_fund_record_service_id,
       v_down_channel_no,
       v_down_account_id,
       1,
       pkg_down_manual_change_type.service_add,
       v_service_fee,
       sysdate,
       (l_inner_balance + v_amount + v_service_fee),
       v_create_user,
       v_bank_batch_id,
       v_partner_account,
       v_memo);
  
  end if;

  ---4.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_main_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.add_amount,
     v_amount,
     (l_inner_balance + v_amount),
     v_memo);

  if v_service_fee > 0 then
  
    ---4.添加下游资金变动
    insert into fd_trade_down_fund
      (record_id,
       fd_order_id,
       channel_no,
       account_id,
       trade_order_no,
       ext_order_no,
       order_source,
       create_time,
       order_time,
       change_type,
       change_amount,
       balance,
       memo)
    values
      (l_fund_record_service_id,
       0,
       v_down_channel_no,
       v_down_account_id,
       '-',
       '-',
       0,
       sysdate,
       '',
       pkg_down_fund_change_type.add_amount,
       v_service_fee,
       (l_inner_balance + v_amount + v_service_fee),
       v_memo);
  
  end if;

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_BORROW_ADD
prompt =============================================
prompt
create or replace function fd_account.fd_f_manual_down_borrow_add(v_down_channel_no   varchar2,
                                                       v_down_account_id   number,
                                                       v_borrow_account_id number,
                                                       v_amount            number, ---渠道到账金额
                                                       v_service_fee       number, ---公司承担手续费
                                                       v_create_user       varchar2,
                                                       v_partner_account   varchar2,
                                                       v_memo              varchar2,
                                                       v_account_name      varchar2,
                                                       v_channel_name      varchar2)
  return varchar2 is
  l_inner_balance          number;
  l_credit_money           number;
  l_borrow_balance         number;
  l_fund_record_main_id    number;
  l_fund_record_service_id number;
  l_borrow_company         number;
  l_bank_batch_id          number; ---渠道与借支账户流水关联的批次号，就用与银行关联的批次号
  ------------下游到借支账户加款----------
begin
  --================1.锁账户获取参数======================
  --1.锁借支账户
  select t.balance, t.company_id
    into l_borrow_balance, l_borrow_company
    from fd_base_company_account_cap t
   where t.account_id = v_borrow_account_id
     and t.account_type = pkg_co_cap_account_type.personal_borrow
     for update;

  --2.获取部分添加参数

  select seq_trade_down_fund_id.nextval
    into l_fund_record_main_id
    from dual;
  select seq_trade_down_fund_id.nextval
    into l_fund_record_service_id
    from dual;

  --3.获取银行卡资金变动统一流水号
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================2.实体卡账户=====================================
  --1.更新借支账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_borrow_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_borrow_account_id;

  --2.添加借支账户资金变动
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     create_user)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_borrow_account_id,
     v_amount,
     pkg_co_cap_fund_type.down_borrow_add,
     (l_borrow_balance + v_amount),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     l_bank_batch_id,
     v_channel_name || '|' || v_account_name || '|' || v_memo,
     v_create_user);

  --==============3.更新渠道账户==================================================
  ---1.锁下游渠道账户
  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.更新渠道账户余额
  update fd_base_down_account t
     set t.inner_balance  = (l_inner_balance + v_amount + v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---3.添加下游人工加款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_fund_record_main_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_create_user,
     l_bank_batch_id,
     v_partner_account,
     v_memo);

  if v_service_fee > 0 then
    insert into fd_trade_down_manual
      (record_id,
       channel_no,
       account_id,
       has_adjust,
       add_type,
       change_amount,
       change_time,
       balance,
       create_user,
       bank_fund_id,
       partner_account,
       memo)
    values
      (l_fund_record_service_id,
       v_down_channel_no,
       v_down_account_id,
       1,
       pkg_down_manual_change_type.service_add,
       v_service_fee,
       sysdate,
       (l_inner_balance + v_amount + v_service_fee),
       v_create_user,
       l_bank_batch_id,
       v_partner_account,
       v_memo);
  
  end if;

  ---4.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_main_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.add_amount,
     v_amount,
     (l_inner_balance + v_amount),
     v_memo);

  if v_service_fee > 0 then
  
    ---4.添加下游资金变动
    insert into fd_trade_down_fund
      (record_id,
       fd_order_id,
       channel_no,
       account_id,
       trade_order_no,
       ext_order_no,
       order_source,
       create_time,
       order_time,
       change_type,
       change_amount,
       balance,
       memo)
    values
      (l_fund_record_service_id,
       0,
       v_down_channel_no,
       v_down_account_id,
       '-',
       '-',
       0,
       sysdate,
       '',
       pkg_down_fund_change_type.add_amount,
       v_service_fee,
       (l_inner_balance + v_amount + v_service_fee),
       v_memo);
  
  end if;

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_BORROW_ADD_CK
prompt ================================================
prompt
create or replace function fd_account.fd_f_manual_down_borrow_add_ck(v_down_channel_no   varchar2,
                                                          v_down_account_id   number,
                                                          v_borrow_account_id number,
                                                          v_amount            number,
                                                          v_service_fee       number,
                                                          v_account_name      out varchar2,
                                                          v_channel_name      out varchar2)
  return varchar2 is
  ----------------下游加款到借支检查-----------------
  l_company_id    number;
  l_account_count number;
begin
  ---1. 判断金额是否大于0
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2. 检查下游渠道
  select c.company_id, a.account_name, c.channel_name
    into l_company_id, v_account_name, v_channel_name
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
        -- and a.status = 0
        --  and c.status = 0
     and rownum <= 1;

  ---3.检查实体卡账户是否存在
  select count(1)
    into l_account_count
    from fd_base_company_account_cap t
   where t.account_id = v_borrow_account_id
     and t.account_type = pkg_co_cap_account_type.personal_borrow;

  if (l_account_count = 0) then
    return pkg_error_code.co_account_not_exists;
  end if;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_COMMI_ADD
prompt ============================================
prompt
create or replace function fd_account.fd_f_manual_down_commi_add(v_down_channel_no in varchar2,
                                                      v_down_account_id in number,
                                                      v_amount          in number,
                                                      v_commi_month     in varchar2,
                                                      v_create_user     in varchar2,
                                                      v_memo            in varchar2)
  return varchar2 is
  ------------------下游佣金转渠道余额-----------------
  l_inner_balance       number;
  l_credit_money        number;
  l_fund_record_main_id number;
  l_cap_account_name    varchar2(100);
  l_bank_batch_id       number;
  l_commi_balance       number;
  ------------下游手工加款----------
begin
  select seq_bank_service_id.nextval, seq_trade_down_fund_id.nextval
    into l_bank_batch_id, l_fund_record_main_id
    from dual;

  --===============3.修改渠道佣金=============================================
  ---1.锁下游渠道
  select t.commi_balance
    into l_commi_balance
    from fd_base_down_channel t
   where t.channel_no = v_down_channel_no
     for update;

  ---2.检查佣金余额
  if v_amount > l_commi_balance then
    return pkg_error_code.balance_low;
  end if;

  ---3.修改佣金余额
  update fd_base_down_channel t
     set t.commi_balance  = (l_commi_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.channel_no = v_down_channel_no;

  ---4.添加佣金结算记录
  insert into fd_trade_commission_settle
    (report_id,
     channel_no,
     channel_type,
     commission,
     settle_month,
     settle_status,
     settle_user,
     settle_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     settle_type,
     commi_balance,
     memo)
  values
    (seq_trade_commission_settle_id.nextval,
     v_down_channel_no,
     pkg_channel_type.down_channel,
     v_amount,
     to_date(v_commi_month, 'yyyymmddhh24miss'),
     pkg_sys_boolean.istrue,
     v_create_user,
     sysdate,
     pkg_sys_boolean.isfalse,
     0,
     l_bank_batch_id,
     pkg_commi_settle_type.to_channel,
     (l_commi_balance - v_amount),
     v_memo);

  --==============4.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加下游手工加款记录、添加下游资金变动]=====
  ---1.锁下游渠道账户
  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.更新渠道账户余额
  update fd_base_down_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---3.添加下游人工加款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_fund_record_main_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_create_user,
     l_bank_batch_id,
     l_cap_account_name,
     v_memo);

  ---4.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_main_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.add_amount,
     v_amount,
     (l_inner_balance + v_amount),
     v_memo);
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_COMMI_ADD_CK
prompt ===============================================
prompt
create or replace function fd_account.fd_f_manual_down_commi_add_ck(v_down_channel_no varchar2,
                                                         v_down_account_id number,
                                                         v_amount          number)
  return varchar2 is
  ------------------下游佣金转渠道余额检查-----------------
  l_company_id    number;
  l_commi_balance number;
begin
  ---1.检查加款金额
  if v_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户
  select c.company_id, c.commi_balance
    into l_company_id, l_commi_balance
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
     and rownum <= 1;

  if v_amount > l_commi_balance then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_DEP_ADD
prompt ==========================================
prompt
create or replace function fd_account.fd_f_manual_down_dep_add(v_down_channel_no varchar2,
                                                    v_down_account_id number,
                                                    v_bank_account_id number,
                                                    v_cap_account_id  number,
                                                    v_amount          number, ---渠道到账金额
                                                    v_create_user     varchar2,
                                                    v_memo            varchar2,
                                                    v_account_name    varchar2,
                                                    v_channel_name    varchar2)
  return varchar2 is
  l_inner_balance       number;
  l_credit_money        number;
  l_bank_balance        number;
  l_fund_record_main_id number;
  l_bank_company        number;
  l_cap_balance         number;
  l_cap_account_name    varchar2(100);
  l_bank_batch_id       number;
  ------------下游手工加款----------
begin
  --================1.资产账户相关操作=================
  ---0.获取银行卡资金变动统一流水号
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --1.锁资产账户
  select t.balance, t.account_name
    into l_cap_balance, l_cap_account_name
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     for update;

  ---2.修改资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_cap_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_cap_account_id;

  ---3.添加资产账户资金变动
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     has_adjust,
     bank_batch_id,
     memo)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_cap_account_id,
     v_amount,
     pkg_co_cap_fund_type.deposit_down_add,
     (l_cap_balance - v_amount),
     sysdate,
     1,
     l_bank_batch_id,
     v_memo);

  --================2.锁账户获取参数======================

  --1.锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---2.获取部分添加参数

  select seq_trade_down_fund_id.nextval
    into l_fund_record_main_id
    from dual;

  --====================3.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡手续费的资金变动、添加实体卡加款的资金变动]===
  ---1.更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---3.添加实体卡资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company,
     v_amount,
     (l_bank_balance + v_amount),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.add_amount,
     pkg_bank_use_type.down_add,
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id);

  --==============4.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加下游手工加款记录、添加下游资金变动]=====
  ---1.锁下游渠道账户
  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.更新渠道账户余额
  update fd_base_down_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---3.添加下游人工加款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_fund_record_main_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_create_user,
     l_bank_batch_id,
     l_cap_account_name,
     v_memo);

  ---4.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_main_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.add_amount,
     v_amount,
     (l_inner_balance + v_amount),
     v_memo);

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_DEP_ADD_CK
prompt =============================================
prompt
create or replace function fd_account.fd_f_manual_down_dep_add_ck(v_down_channel_no varchar2,
                                                       v_down_account_id number,
                                                       v_bank_account_id number,
                                                       v_cap_account_id  number,
                                                       v_amount          number,
                                                       v_account_name    out varchar2,
                                                       v_channel_name    out varchar2)
  return varchar2 is
  ----------------手工操作获取下游支付账户-----------------
  l_bank_count number;
  l_company_id number;
  l_cap_count  number;
begin
  ---1. 判断金额是否大于0
  if (v_amount <= 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2. 检查下游渠道
  select c.company_id, a.account_name, c.channel_name
    into l_company_id, v_account_name, v_channel_name
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
     and rownum <= 1;

  ---3.检查实体卡账户是否存在
  select count(1)
    into l_bank_count
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id;

  if (l_bank_count = 0) then
    return pkg_error_code.bank_account_id_error;
  end if;

  ---4.检查资产账户是否存在
  select count(1)
    into l_cap_count
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     and t.account_type in
         (pkg_co_cap_account_type.deposit, pkg_co_cap_account_type.bond);

  if l_cap_count = 0 then
    return pkg_error_code.co_account_not_exists;
  end if;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_DRAW
prompt =======================================
prompt
create or replace function fd_account.fd_f_manual_down_draw(v_down_channel_no varchar2,
                                                 v_down_account_id number,
                                                 v_bank_account_id number,
                                                 v_amount          number, ---渠道到账金额
                                                 v_service_fee     number, ---公司承担手续费
                                                 v_create_user     varchar2,
                                                 v_partner_account varchar2,
                                                 v_memo            varchar2,
                                                 v_account_name    varchar2,
                                                 v_remark_name     varchar2,
                                                 v_channel_name    varchar2)
  return varchar2 is
  l_inner_balance  number;
  l_credit_money   number;
  l_bank_balance   number;
  l_fund_record_id number;
  l_bank_company   number;
  l_bank_batch_id  number;
  ------------下游手工提款----------
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

  -----银行卡手续费（资金变动(i)6）
  -----银行卡（账户表 (f)2，账户(u)5,加款资金变动(i)7）
  -----公司手续费（账户表(f)1，账户(u)3,资金变动(i)4）
  -----下游渠道（账户(f)8，账户(u)9,下游加款记录表(i)10,资金变动(i)11）
begin
  --================1.锁账户获取参数======================
  --=========[锁公司手续费账户、锁实体卡账户、检查实体卡余额、获取seq]=======

  --1.锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  if (v_amount + v_service_fee) > l_bank_balance then
    return pkg_error_code.balance_low;
  end if;

  ---2.获取部分添加参数

  select seq_trade_down_fund_id.nextval into l_fund_record_id from dual;

  ---获取银行卡资金变动统一流水号
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================3.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡手续费的资金变动、添加实体卡加款的资金变动]===
  ---1.更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_amount - v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  if (v_service_fee > 0) then
    ---2.添加手续费
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       l_bank_company,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       v_channel_name,
       v_account_name,
       v_memo,
       l_bank_batch_id,v_remark_name);

  end if;

  ---3.添加实体卡资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company,
     v_amount,
     (l_bank_balance - v_amount - v_service_fee),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.down_draw,
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id,v_remark_name);

  --==============4.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加下游手工加款记录、添加下游资金变动]=====
  ---1.锁下游渠道账户
  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.更新渠道账户余额
  update fd_base_down_account t
     set t.inner_balance  = (l_inner_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---3.添加下游人工加款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_fund_record_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.draw_amount,
     v_amount,
     sysdate,
     (l_inner_balance - v_amount),
     v_create_user,
     l_bank_batch_id,
     v_partner_account,
     v_memo);

  ---4.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.draw_amount,
     v_amount,
     (l_inner_balance - v_amount),
     v_memo);

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_DRAW_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_manual_down_draw_check(v_down_channel_no varchar2,
                                                       v_down_account_id number,
                                                       v_bank_account_id number,
                                                       v_amount          number,
                                                       v_service_fee     number,
                                                       v_account_name    out varchar2,
                                                       v_channel_name    out varchar2)
  return varchar2 is
  ----------------手工操作获取下游支付账户-----------------
  l_bank_count   number;
  l_company_id   number;
  l_bank_balance number;
begin
  ---1. 判断金额是否大于0
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2. 检查下游渠道
  select c.company_id, a.account_name, c.channel_name
    into l_company_id, v_account_name, v_channel_name
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
        --and a.status = 0
        --and c.status = 0
     and rownum <= 1;

  ---3.检查实体卡账户是否存在
  select count(1), max(t.balance)
    into l_bank_count, l_bank_balance
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id;

  if (l_bank_count = 0) then
    return pkg_error_code.bank_account_id_error;
  end if;

  if (v_amount > l_bank_balance) then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_INNER_CHECK
prompt ==============================================
prompt
create or replace function fd_account.fd_f_manual_down_inner_check(v_out_channel_no varchar2,
                                                        v_out_account_id number,
                                                        v_in_channel_no  varchar2,
                                                        v_in_account_id  number,
                                                        v_amount         number)
  return varchar2 is
  -------------------检查下游渠道内转渠道账户信息-------------------
  l_out_company  number;
  l_in_company   number;
  l_system_count number;
begin
  ---1.检查转移金额
  if v_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查出入账渠道账户关联信息
  select c.company_id
    into l_out_company
    from fd_base_down_account_map t
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   inner join fd_base_down_account a on t.account_id = a.account_id
   where t.channel_no = v_out_channel_no
     and t.account_id = v_out_account_id
     and rownum <= 2;

  select c.company_id
    into l_in_company
    from fd_base_down_account_map t
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   inner join fd_base_down_account a on t.account_id = a.account_id
   where t.channel_no = v_in_channel_no
     and t.account_id = v_in_account_id
     and rownum <= 2;

  if l_out_company != l_in_company then
    return pkg_error_code.channel_error;
  end if;

  ---3.检查渠道系统是否相同
  select count(1)
    into l_system_count
    from fd_base_down_system_map t
   where t.channel_no = v_out_channel_no
     and t.source_system_id in
         (select m.source_system_id
            from fd_base_down_system_map m
           where m.channel_no = v_in_channel_no);

  if l_system_count = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_INNER_TSFER
prompt ==============================================
prompt
create or replace function fd_account.fd_f_manual_down_inner_tsfer(v_out_channel_no varchar2,
                                                        v_out_account_id number,
                                                        v_in_channel_no  varchar2,
                                                        v_in_account_id  number,
                                                        v_amount         number,
                                                        v_hander_user    varchar2,
                                                        v_memo           varchar2)
  return varchar2 is
  -------------------下游渠道内部转账--------------------
  l_out_balance      number;
  l_out_fund_id      number;
  l_out_channel_name varchar2(32);
  l_out_company      number;
  l_in_channel_name  varchar2(32);
  l_in_company       number;
  l_in_balance       number;
  l_in_fund_id       number;
begin
  --======================出账上游渠道操作=======================
  ---0.获取出账渠道名称
  select t.channel_name, t.company_id
    into l_out_channel_name, l_out_company
    from fd_base_down_channel t
   where t.channel_no = v_out_channel_no;

  ---1.锁出账上游账户
  select t.inner_balance
    into l_out_balance
    from fd_base_down_account t
   where t.account_id = v_out_account_id
     for update;

  ---2.修改出账上游余额
  update fd_base_down_account t
     set t.inner_balance  = (l_out_balance - v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_out_account_id;

  select seq_trade_down_fund_id.nextval into l_out_fund_id from dual;

  ---3.添加出账上游提款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
  values
    (l_out_fund_id,
     v_out_channel_no,
     v_out_account_id,
     0,
     pkg_down_manual_change_type.draw_amount,
     v_amount,
     sysdate,
     (l_out_balance - v_amount),
     v_hander_user,
     l_out_channel_name,
     v_memo);

  ---4.添加出账上游资金变动
  insert into fd_trade_down_fund
    (record_id,
     channel_no,
     account_id,
     create_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_out_fund_id,
     v_out_channel_no,
     v_out_account_id,
     sysdate,
     pkg_down_fund_change_type.draw_amount,
     v_amount,
     (l_out_balance - v_amount),
     v_memo);

  --======================入账上游渠道操作=======================
  ---0.获取入账渠道名称
  select t.channel_name, t.company_id
    into l_in_channel_name, l_in_company
    from fd_base_down_channel t
   where t.channel_no = v_in_channel_no;

  ---1.锁入账上游账户
  select t.inner_balance
    into l_in_balance
    from fd_base_down_account t
   where t.account_id = v_in_account_id
     for update;

  ---2.修改入账上游余额
  update fd_base_down_account t
     set t.inner_balance  = (l_in_balance + v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_in_account_id;

  select seq_trade_down_fund_id.nextval into l_in_fund_id from dual;

  ---3.添加出账上游提款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     partner_account,
     memo)
  values
    (l_in_fund_id,
     v_in_channel_no,
     v_in_account_id,
     0,
     pkg_down_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_in_balance + v_amount),
     v_hander_user,
     l_in_channel_name,
     v_memo);

  ---4.添加出账上游资金变动
  insert into fd_trade_down_fund
    (record_id,
     channel_no,
     account_id,
     create_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_in_fund_id,
     v_in_channel_no,
     v_in_account_id,
     sysdate,
     pkg_down_fund_change_type.add_amount,
     v_amount,
     (l_in_balance + v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_RV_CHANNEL
prompt =============================================
prompt
create or replace function fd_account.fd_f_manual_down_rv_channel(v_down_channel_no varchar2,
                                                       v_down_account_id number,
                                                       v_revise_type     number,
                                                       v_revise_amount   number,
                                                       v_create_user     varchar2,
                                                       v_memo            varchar2,
                                                       v_trade_fund_id   out number)
  return varchar2 is
  -------------------渠道账户余额平账------------------
  l_inner_balance         number;
  l_down_manual_type      number;
  l_up_fund_type          number;
  l_down_fund_type        number;
  l_credit_money          number;
  l_balance_change_amount number;
begin
  ---1.获取变动记录参数
  select seq_trade_down_fund_id.nextval into v_trade_fund_id from dual;

  if (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.balance) then
    l_down_manual_type      := pkg_down_manual_change_type.balance_revise_add;
    l_up_fund_type          := 0;
    l_down_fund_type        := pkg_down_fund_change_type.add_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount < 0 and
        v_revise_type = pkg_sys_revise_type.balance) then
    l_down_manual_type      := pkg_down_manual_change_type.balance_revise_minus;
    l_up_fund_type          := 0;
    l_down_fund_type        := pkg_down_fund_change_type.add_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.debit) then
    l_down_manual_type      := pkg_down_manual_change_type.debit_revise_add;
    l_up_fund_type          := pkg_up_fund_change_type.debit_amount;
    l_down_fund_type        := pkg_down_fund_change_type.debit_amount;
    l_balance_change_amount := 0 - v_revise_amount;
  elsif (v_revise_amount < 0 and v_revise_type = pkg_sys_revise_type.debit) then
    l_down_manual_type      := pkg_down_manual_change_type.debit_revise_minus;
    l_up_fund_type          := pkg_up_fund_change_type.debit_amount;
    l_down_fund_type        := pkg_down_fund_change_type.debit_amount;
    l_balance_change_amount := 0 - v_revise_amount;
  elsif (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.refund) then
    l_down_manual_type      := pkg_down_manual_change_type.refund_revise_add;
    l_up_fund_type          := pkg_up_fund_change_type.refund_amount;
    l_down_fund_type        := pkg_down_fund_change_type.refund_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount < 0 and v_revise_type = pkg_sys_revise_type.refund) then
    l_down_manual_type      := pkg_down_manual_change_type.refund_revise_minus;
    l_up_fund_type          := pkg_up_fund_change_type.refund_amount;
    l_down_fund_type        := pkg_down_fund_change_type.refund_amount;
    l_balance_change_amount := v_revise_amount;
  else
    return pkg_error_code.data_error;
  end if;

  ---2.锁渠道账户
  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---4修改账户余额添加资金变动
  update fd_base_down_account t
     set t.inner_balance =
         (l_inner_balance + l_balance_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---5下游手工记录添加
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo)
  values
    (v_trade_fund_id,
     v_down_channel_no,
     v_down_account_id,
     0,
     0,
     l_down_manual_type,
     v_revise_amount,
     sysdate,
     (l_inner_balance + l_balance_change_amount),
     v_create_user,
     nvl2(v_memo, v_memo || ',下游平账', '下游平账'));

  ---6.下游资金变动添加
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (v_trade_fund_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     l_down_fund_type,
     v_revise_amount,
     (l_inner_balance + l_balance_change_amount),
     v_memo);

  ---7.上游资金变动（不存下游公司以免结算)
  if l_up_fund_type != 0 then
    insert into fd_trade_up_fund
      (record_id,
       down_channel_no,
       down_account_id,
       down_company_id,
       up_channel_no,
       up_account_id,
       up_company_id,
       down_draw_unit,
       down_draw_face,
       down_draw_amount,
       down_real_amount,
       up_draw_amount,
       up_real_amount,
       change_time,
       change_type,
       balance,
       memo)
    values
      (seq_trade_up_fund_id.nextval,
       v_down_channel_no,
       v_down_account_id,
       0,
       0,
       0,
       0,
       0,
       0,
       v_revise_amount,
       v_revise_amount,
       0,
       0,
       sysdate,
       l_up_fund_type,
       0,
       v_memo);
  end if;

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_RV_CHANNEL_CK
prompt ================================================
prompt
create or replace function fd_account.fd_f_manual_down_rv_channel_ck(v_down_channel_no varchar2,
                                                          v_down_account_id number,
                                                          v_revise_amount   number)
  return varchar2 is
  -------------------检查下游渠道账户手工平账渠道账户、金额是否正确--------------------
  l_down_account_id number;
begin
  ---1.检查调整金额是否正确
  if (v_revise_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户是否正确
  select t.account_id
    into l_down_account_id
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
     and rownum <= 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_or_account_error;
  
end;
/

prompt
prompt Creating function FD_F_MANUAL_DOWN_RV_TRADE_CK
prompt ==============================================
prompt
create or replace function fd_account.fd_f_manual_down_rv_trade_ck(v_down_channel_no  varchar2,
                                                        v_down_account_id  number,
                                                        v_down_draw_amount number,
                                                        v_down_real_amount number)

 return varchar2 is
  l_down_account_id number;
begin
  ---1.检查调整金额是否正确
  if (v_down_draw_amount = 0 and v_down_real_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户是否正确
  select t.account_id
    into l_down_account_id
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
     and rownum <= 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_RELATE_ADD
prompt ========================================
prompt
create or replace function fd_account.fd_f_manual_relate_add(v_down_channel_no varchar2,
                                                  v_down_account_id number,
                                                  v_up_channel_no   varchar2,
                                                  v_up_account_id   number,
                                                  v_amount          number,
                                                  v_create_user     varchar2,
                                                  v_memo            varchar2)
  return varchar2 is
  ------------------上下游绑定渠道关联加款---------------
  l_down_balance      number;
  l_up_channel_name   varchar2(100);
  l_down_record_id    number;
  l_up_record_id      number;
  l_down_channel_name varchar2(100);
  l_up_balance        number;
  l_up_company_id     number;
begin
  --========================下游渠道======================
  ---1.获取渠道名称
  select t.channel_no, t.company_id
    into l_up_channel_name, l_up_company_id
    from fd_base_up_channel t
   where t.channel_no = v_up_channel_no;

  ---2.锁下游渠道账户
  select t.inner_balance
    into l_down_balance
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---3.修改账户余额
  update fd_base_down_account t
     set t.inner_balance  = (l_down_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  select seq_trade_down_fund_id.nextval into l_down_record_id from dual;

  ---4.添加手工加款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_down_record_id,
     v_down_channel_no,
     v_down_account_id,
     0,
     pkg_sys_boolean.istrue,
     pkg_down_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_down_balance + v_amount),
     v_create_user,
     0,
     l_up_channel_name,
     v_memo);

  ---4.添加下游资金变动记录
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_down_record_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.add_amount,
     v_amount,
     (l_down_balance + v_amount),
     v_memo);

  --========================上游渠道======================
  ---1.获取渠道名称
  select t.channel_no
    into l_down_channel_name
    from fd_base_down_channel t
   where t.channel_no = v_down_channel_no;

  ---2.锁上游渠道账户
  select t.inner_balance
    into l_up_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---3.修改账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_up_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  select seq_trade_up_fund_id.nextval into l_up_record_id from dual;

  ---4.添加手工加款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     has_adjust,
     bank_fund_id)
  values
    (l_up_record_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_up_balance + v_amount),
     v_memo,
     v_create_user,
     l_down_channel_name,
     pkg_sys_boolean.istrue,
     0);

  ---5.添加上游资金变动记录
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_up_record_id,
     v_up_channel_no,
     v_up_account_id,
     l_up_company_id,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_up_balance + v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_RELATE_AMOUNT_CK
prompt ==============================================
prompt
create or replace function fd_account.fd_f_manual_relate_amount_ck(v_amount      number,
                                                        v_manual_type number)
  return varchar2 is
  -----------------检查关联操作金额-----------------
begin
  ---1.关联加款
  if v_manual_type = pkg_down_manual_change_type.add_amount and
     v_amount <= 0 then
  
    return pkg_error_code.amount_error;
  end if;

  ---2.关联提款
  if v_manual_type = pkg_down_manual_change_type.draw_amount and
     v_amount <= 0 then
  
    return pkg_error_code.amount_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_RELATE_CHECK
prompt ==========================================
prompt
create or replace function fd_account.fd_f_manual_relate_check(v_down_channel_no varchar2,
                                                    v_down_account_id number,
                                                    v_up_channel_no   varchar2,
                                                    v_up_account_id   number)
  return varchar2 is
  ----------------检查关联上下游渠道信息------------------
  l_down_channel_no varchar2(32);
  l_up_channel_no   varchar2(32);
begin
  ---1.检查渠道关联
  select t.down_channel_no
    into l_down_channel_no
    from fd_base_down_up_map t
   inner join fd_base_down_channel d on d.channel_no = t.down_channel_no
   inner join fd_base_up_channel u on u.channel_no = t.up_channel_no
   where t.down_channel_no = v_down_channel_no
     and t.up_channel_no = v_up_channel_no
     and d.company_id = u.company_id
     and rownum <= 2;

  ---2.检查下游渠道
  select t.channel_no
    into l_down_channel_no
    from fd_base_down_account_map t
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   inner join fd_base_down_account a on t.account_id = a.account_id
   where c.channel_no = v_down_channel_no
     and a.account_id = v_down_account_id
     and rownum <= 2;

  ---3.检查上游渠道
  select t.channel_no
    into l_up_channel_no
    from fd_base_up_account_map t
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   inner join fd_base_up_account a on t.account_id = a.account_id
   where c.channel_no = v_up_channel_no
     and a.account_id = v_up_account_id
     and a.account_type = pkg_up_account_type.sys_account
     and rownum <= 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_RELATE_DRAW
prompt =========================================
prompt
create or replace function fd_account.fd_f_manual_relate_draw(v_down_channel_no varchar2,
                                                   v_down_account_id number,
                                                   v_up_channel_no   varchar2,
                                                   v_up_account_id   number,
                                                   v_amount          number,
                                                   v_create_user     varchar2,
                                                   v_memo            varchar2)
  return varchar2 is
  ------------------上下游绑定渠道关联提款---------------
  l_down_balance      number;
  l_up_channel_name   varchar2(100);
  l_down_record_id    number;
  l_up_record_id      number;
  l_down_channel_name varchar2(100);
  l_up_balance        number;
  l_up_company_id     number;
begin
  --========================下游渠道======================
  ---1.获取渠道名称
  select t.channel_no, t.company_id
    into l_up_channel_name, l_up_company_id
    from fd_base_up_channel t
   where t.channel_no = v_up_channel_no;

  ---2.锁下游渠道账户
  select t.inner_balance
    into l_down_balance
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---3.修改账户余额
  update fd_base_down_account t
     set t.inner_balance  = (l_down_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  select seq_trade_down_fund_id.nextval into l_down_record_id from dual;

  ---4.添加手工加款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_down_record_id,
     v_down_channel_no,
     v_down_account_id,
     0,
     pkg_sys_boolean.istrue,
     pkg_down_manual_change_type.draw_amount,
     v_amount,
     sysdate,
     (l_down_balance - v_amount),
     v_create_user,
     0,
     l_up_channel_name,
     v_memo);

  ---4.添加下游资金变动记录
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_down_record_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.draw_amount,
     v_amount,
     (l_down_balance - v_amount),
     v_memo);

  --========================上游渠道======================
  ---1.获取渠道名称
  select t.channel_no
    into l_down_channel_name
    from fd_base_down_channel t
   where t.channel_no = v_down_channel_no;

  ---2.锁上游渠道账户
  select t.inner_balance
    into l_up_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---3.修改账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_up_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  select seq_trade_up_fund_id.nextval into l_up_record_id from dual;

  ---4.添加手工加款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     has_adjust,
     bank_fund_id)
  values
    (l_up_record_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.draw_amount,
     v_amount,
     sysdate,
     (l_up_balance - v_amount),
     v_memo,
     v_create_user,
     l_down_channel_name,
     pkg_sys_boolean.istrue,
     0);

  ---5.添加上游资金变动记录
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_up_record_id,
     v_up_channel_no,
     v_up_account_id,
     l_up_company_id,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.draw_amount,
     (l_up_balance - v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_SHORT_MSG_ADD
prompt ===========================================
prompt
create or replace function fd_account.fd_f_manual_short_msg_add(v_down_channel_no varchar2, ---短信平台下游渠道
                                                     v_down_account_id number, ---下游渠道账户
                                                     v_self_account_id number, ---短信平台手续费账户
                                                     v_amount          number, ---加款金额
                                                     v_create_user     varchar2, ---操作员
                                                     v_memo            varchar2)
  return varchar2 is
  ----------------短信平台下游渠道费用支付--------------
  l_self_balance    number;
  l_channel_balance number;
  l_fund_record_id number;
begin
  --====================手续费账户加款====================
  --1.锁手续费账户
  select t.balance
    into l_self_balance
    from fd_base_company_account_self t
   where t.account_id = v_self_account_id
     and t.account_type = pkg_co_self_account_type.short_msg_fee
     for update;

  --2.修改账户余额
  update fd_base_company_account_self t
     set t.balance =
         (l_self_balance + v_amount)
   where t.account_id = v_self_account_id
     and t.account_type = pkg_co_self_account_type.short_msg_fee;

  --3.添加手续费账户资金变动
  insert into fd_trade_co_self_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     create_user)
  values
    (seq_trade_co_self_fund_id.nextval,
     v_self_account_id,
     v_amount,
     pkg_co_self_fund_type.add_amount,
     (l_self_balance + v_amount),
     sysdate,
     0,
     0,
     0,
     v_memo,
     v_create_user);

  --====================下游渠道加款======================
  --1.锁下游渠道账户
  select t.inner_balance
    into l_channel_balance
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  --2.修改下游渠道账户余额
  update fd_base_down_account t
     set t.inner_balance =
         (l_channel_balance + v_amount)
   where t.account_id = v_down_account_id;

  --3.添加渠道人工加款记录
    select seq_trade_down_fund_id.nextval
    into l_fund_record_id
    from dual;

    insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_fund_record_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_channel_balance + v_amount),
     v_create_user,
     0,
     '-',
     v_memo);

  --4.添加渠道资金变动记录
    insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.add_amount,
     v_amount,
     (l_channel_balance + v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_SHORT_MSG_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_manual_short_msg_check(v_down_channel_no varchar2,
                                                       v_self_account_id number,
                                                       v_system_id       number,
                                                       v_amount          number,
                                                       v_down_account_id out number)
  return varchar2 is
  --------------公司短信服务费收取检查------------
  l_count              number;
  l_self_count         number;
  l_channel_company_id number;
  l_self_company_id    number;
begin
  ---1.检查金额
  if v_amount = 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查下游渠道是否为短信平台渠道
  select count(1), max(t.company_id), max(a.account_id)
    into l_count, l_channel_company_id, v_down_account_id
    from fd_base_down_channel t
   inner join fd_base_down_account_map m
      on t.channel_no = m.channel_no
   inner join fd_base_down_account a
      on m.account_id = a.account_id
   inner join fd_base_down_system_map s
      on t.channel_no = s.channel_no
   where t.channel_no = v_down_channel_no
     and s.source_system_id = v_system_id;

  if l_count != 1 then
    return pkg_error_code.channel_error;
  end if;

  ---3.检查手续费账户是否为短信平台手续费账户
  select count(1), max(t.company_id)
    into l_self_count, l_self_company_id
    from fd_base_company_account_self t
   where t.account_id = v_self_account_id
     and t.account_type = pkg_co_self_account_type.short_msg_fee;

  if l_self_count != 1 then
    return pkg_error_code.data_error;
  end if;

  if l_channel_company_id != l_self_company_id then
    return pkg_error_code.company_error;
  end if;

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function FD_F_MANUAL_TRANS_CHECK
prompt =========================================
prompt
create or replace function fd_account.fd_f_manual_trans_check(v_trans_account_id  number,
                                                   v_trans_service_fee number)
  return varchar2 is
  -----------------转账退款手续费收取账户和手续费检查-------------------
  l_trans_balance number;
begin
  ---1.检查手续费金额（红冲金额可以传负数）
  if v_trans_service_fee = 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查退款账户是否存在
  select t.balance
    into l_trans_balance
    from fd_base_company_account_cap t
   where t.account_id = v_trans_account_id
     and t.account_type in (pkg_co_cap_account_type.transfer_refund,
          pkg_co_cap_account_type.manual_refund);

  ---3.检查账户余额是否足够
  if l_trans_balance < v_trans_service_fee then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.data_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_TRANS_SERVICE_FEE
prompt ===============================================
prompt
create or replace function fd_account.fd_f_manual_trans_service_fee(v_trans_account_id  number,
                                                         v_trans_service_fee number,
                                                         v_add_user          varchar2,
                                                         v_memo              varchar2)
  return varchar2 is
  --------------添加转账退款手续费-------------
  l_trans_balance number;
begin
  ---1.锁转账退款账户
  select t.balance
    into l_trans_balance
    from fd_base_company_account_cap t
   where t.account_id = v_trans_account_id
     and t.account_type in (pkg_co_cap_account_type.transfer_refund,
          pkg_co_cap_account_type.manual_refund)
     for update;

  ---2.修改转账退款账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_trans_balance - v_trans_service_fee),
         t.last_edit_user = v_add_user,
         t.last_edit_time = sysdate
   where t.account_id = v_trans_account_id;

  ---3.添加转账退款手续费记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     memo,
     create_user)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_trans_account_id,
     v_trans_service_fee,
     pkg_co_cap_fund_type.service_fee,
     (l_trans_balance - v_trans_service_fee),
     sysdate,
     0,
     pkg_sys_boolean.istrue,
     v_memo,
     v_add_user);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_ADD
prompt ====================================
prompt
create or replace function fd_account.fd_f_manual_up_add(v_up_channel_no   varchar2,
                                              v_up_company_id   number,
                                              v_up_account_id   number,
                                              v_bank_account_id number,
                                              v_amount          number,
                                              v_service_fee     number,
                                              v_create_user     varchar2,
                                              v_partner_account varchar2,
                                              v_memo            varchar2,
                                              v_account_name    varchar2,
                                              v_remark_name     varchar2,
                                              v_channel_name    varchar2)
  return varchar2 is
  l_inner_balance   number;
  l_bank_balance    number;
  l_fund_id         number;
  l_bank_company_id number;
  l_bank_batch_id   number; ---银行卡加款变动统一流水号
  ------------上游手工加款----------
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

  -----银行卡手续费（资金变动(i)6）
  -----银行卡（账户表 (f)2，账户(u)5,加款资金变动(i)7）
  -----公司手续费（账户表(f)1，账户(u)3,资金变动(i)4）
  -----上游渠道（账户(f)8，账户(u)9,上游加款记录表(i)10,资金变动(i)11）

begin
  --===============1.锁账户获取参数==========================================
  --=========[锁实体卡账户、检查实体卡余额、获取seq]=======
  ---1.锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---2.检查相关金额（银行余额需大于加款金额）
  if (l_bank_balance < (v_amount + v_service_fee)) then
    return pkg_error_code.balance_low;
  end if;

  ---3.获取资金变动主键
  ---手续费手费资金变动编号，小于人工加款的资金变动编号
  select seq_trade_up_fund_id.nextval into l_fund_id from dual;
  ---获取银行卡加款变动统一流水号
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================2.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡手续费的资金变动、添加实体卡加款的资金变动]===
  ---1更新实体卡账户
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_amount - v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  if (v_service_fee > 0) then
    ---2.添加实体卡手续费资金变动
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id,
       remark_name)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       l_bank_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       v_channel_name,
       v_account_name,
       v_memo,
       l_bank_batch_id,
       v_remark_name);
  end if;

  ---3.添加实体卡加款资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id,
     remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company_id,
     v_amount,
     (l_bank_balance - v_amount - v_service_fee),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.up_add,
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id,
     v_remark_name);

  --==============4.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加上游手工加款记录、添加上游资金变动]=====
  ---1.锁上游渠道账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.更新上游渠道账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  ---3.添加手工加款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_memo,
     v_create_user,
     v_partner_account,
     l_bank_batch_id);

  ---4.添加资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance + v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_ADD_FORECAST
prompt =============================================
prompt
create or replace function fd_account.fd_f_manual_up_add_forecast(v_up_channel_no    varchar2,
                                                       v_amount_calc_type varchar2,
                                                       v_trade_duration   number)
  return number is
  ----------------上游建议加款金额计算--------------
  l_time_now            date := sysdate;
  l_growth_rate0        number;
  l_growth_rate1        number;
  l_growth_rate2        number;
  l_growth_rate3        number;
  l_all_growth_rate     number;
  l_last_amount         number;
  l_trade_rate0         number;
  l_trade_rate1         number;
  l_trade_rate2         number;
  l_trade_rate3         number;
  l_all_trade_ratio     number;
  l_forecast_add_amount number;
  l_before_time         date;
  l_all_rate            number;
  l_up_add_amount       number;
  l_result              varchar2(32);
begin
  --==============0.默认计算方式，按渠道的系统信息分别计算加款金额==================
  l_up_add_amount := 0;
  if v_amount_calc_type = 'default' then
    for item in (select s.source_system_id
                   from fd_base_up_system_map s
                  where s.channel_no = v_up_channel_no) loop
      begin
        --=======================1.计算系统增长率(同期与往期整体增长率)==============
        ---1.1.计算各期的交易增长率
        l_growth_rate0 := fd_f_b2e_growth_rate_calc(item.source_system_id,
                                                    trunc(l_time_now),
                                                    l_time_now);
        l_growth_rate1 := fd_f_b2e_growth_rate_calc(item.source_system_id,
                                                    trunc(l_time_now) - 1,
                                                    trunc(l_time_now));
      
        l_growth_rate2 := fd_f_b2e_growth_rate_calc(item.source_system_id,
                                                    trunc(l_time_now) - 2,
                                                    trunc(l_time_now) - 1);
      
        l_growth_rate3 := fd_f_b2e_growth_rate_calc(item.source_system_id,
                                                    trunc(l_time_now) - 3,
                                                    trunc(l_time_now) - 2);
      
        ---1.2.计算总交易增长率
        l_all_growth_rate := l_growth_rate0 * 0.5 + l_growth_rate1 * 0.3 +
                             l_growth_rate2 * 0.1 + l_growth_rate3 * 0.1;
      
        --========================2.计算同期交易金额===================================
        l_before_time := fd_f_b2e_month_date_calc(l_time_now, -1);
      
        select nvl(sum(t.trade_amount), 0)
          into l_last_amount
          from fd_report_channel_halfhour t
         where t.collect_time >= l_before_time
           and t.collect_time < l_before_time + v_trade_duration / 24
           and t.channel_type = pkg_channel_type.up_channel
           and t.order_source = item.source_system_id;
      
        --=======================3.计算渠道交易系数====================================
        --3.1计算各期渠道交易占比
        l_trade_rate0 := fd_f_b2e_trade_rate_calc(item.source_system_id,
                                                  v_up_channel_no,
                                                  trunc(l_time_now),
                                                  l_time_now);
      
        l_trade_rate1 := fd_f_b2e_trade_rate_calc(item.source_system_id,
                                                  v_up_channel_no,
                                                  l_time_now - 1,
                                                  l_time_now - 1 +
                                                  v_trade_duration / 24);
      
        l_trade_rate2 := fd_f_b2e_trade_rate_calc(item.source_system_id,
                                                  v_up_channel_no,
                                                  l_time_now - 2,
                                                  l_time_now - 2 +
                                                  v_trade_duration / 24);
      
        l_trade_rate3 := fd_f_b2e_trade_rate_calc(item.source_system_id,
                                                  v_up_channel_no,
                                                  l_time_now - 3,
                                                  l_time_now - 3 +
                                                  v_trade_duration / 24);
      
        --3.2计算去掉0占比数据后的权重总数
        select (decode(l_trade_rate0, 0, 0, 1) * 0.5 +
               decode(l_trade_rate1, 0, 0, 1) * 0.3 +
               decode(l_trade_rate2, 0, 0, 1) * 0.1 +
               decode(l_trade_rate3, 0, 0, 1) * 0.1)
          into l_all_rate
          from dual;
      
        --3.3权重总数为0不计算该次加款金额，不为零继续计算
        if l_all_rate != 0 then
          ---3.4根据各占比的实际权重计算渠道交易占比
          l_all_trade_ratio := l_trade_rate0 * 0.5 / l_all_rate +
                               l_trade_rate1 * 0.3 / l_all_rate +
                               l_trade_rate2 * 0.1 / l_all_rate +
                               l_trade_rate3 * 0.1 / l_all_rate;
        
          --==========================4.计算加款金额====================================
        
          ---4.1计算总加款金额
          l_forecast_add_amount := l_all_growth_rate * l_last_amount *
                                   l_all_trade_ratio;
          l_up_add_amount       := l_up_add_amount + l_forecast_add_amount;
        
          ---4.2保存预测各参数信息
          l_result := fd_f_b2e_forecast_save(v_up_channel_no,
                                             l_time_now,
                                             v_trade_duration,
                                             l_last_amount,
                                             l_forecast_add_amount,
                                             l_growth_rate0,
                                             l_growth_rate1,
                                             l_growth_rate2,
                                             l_growth_rate3,
                                             l_trade_rate0,
                                             l_trade_rate1,
                                             l_trade_rate2,
                                             l_trade_rate3);
        end if;
      end;
    end loop;
  end if;

  return l_up_add_amount;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_ADD_CALC
prompt =========================================
prompt
create or replace function fd_account.fd_f_manual_up_add_calc(v_up_channel_no varchar2,
                                                   v_up_max_add    number,
                                                   v_up_min_add    number)
  return number is
  ---------------调整计算的建议加款金额-------------
  l_calc_amount number;
begin
  ---1.计算建议加款
  l_calc_amount := fd_f_manual_up_add_forecast(v_up_channel_no,
                                               'default',
                                               6);

  ---2.将建议加款金额调整到最大加款金额与最小加款金额之间
  if l_calc_amount > v_up_max_add then
    l_calc_amount := v_up_max_add;
  elsif l_calc_amount < v_up_min_add then
    l_calc_amount := v_up_min_add;
  end if;

  return l_calc_amount;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_ADD_CHECK
prompt ==========================================
prompt
create or replace function fd_account.fd_f_manual_up_add_check(v_up_channel_no   varchar2,
                                                    v_up_account_id   number,
                                                    v_bank_account_id number,
                                                    v_amount          number,
                                                    v_service_fee     number,
                                                    v_up_company_id   out number,
                                                    v_account_name    out varchar2,
                                                    v_channel_name    out varchar2)
  return varchar2 is
  ----------------获取上游支付账户-----------------
  l_bank_count number;
begin
  ---1.检查金额是否正确
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查上游资金账户
  select c.company_id, a.account_name, c.channel_name
    into v_up_company_id, v_account_name, v_channel_name
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
        --  and a.status = pkg_sys_boolean.istrue
        --   and c.status = pkg_sys_boolean.istrue
     and rownum <= 1;

  ---3.检查实体卡账户是否存在
  select count(1)
    into l_bank_count
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id;

  if (l_bank_count = 0) then
    return pkg_error_code.bank_account_id_error;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_ADD_SYNC
prompt =========================================
prompt
create or replace function fd_account.fd_f_manual_up_add_sync(v_up_channel_no   varchar2,
                                                   v_up_company_id   number,
                                                   v_up_account_id   number,
                                                   v_bank_account_id number,
                                                   v_sync_add_no     number,
                                                   v_amount          number,
                                                   v_service_fee     number,
                                                   v_create_user     varchar2,
                                                   v_partner_account varchar2,
                                                   v_memo            varchar2,
                                                   v_account_name    varchar2,
                                                   v_channel_name    varchar2)
  return varchar2 is
  l_inner_balance   number;
  l_bank_balance    number;
  l_fund_id         number;
  l_bank_company_id number;
  l_sync_count      number;
  l_bank_batch_id   number; ---银行卡加款变动统一流水号
  ------------上游手工加款----------
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

  -----银行卡手续费（资金变动(i)6）
  -----银行卡（账户表 (f)2，账户(u)5,加款资金变动(i)7）
  -----公司手续费（账户表(f)1，账户(u)3,资金变动(i)4）
  -----上游渠道（账户(f)8，账户(u)9,上游加款记录表(i)10,资金变动(i)11）

begin
  --===============1.锁账户获取参数==========================================
  --=========[锁实体卡账户、检查实体卡余额、获取seq]=======
  ---1.锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---2.检查相关金额（银行余额需大于加款金额）
  if (l_bank_balance < (v_amount + v_service_fee)) then
    return pkg_error_code.balance_low;
  end if;

  ---3.获取资金变动主键
  ---手续费手费资金变动编号，小于人工加款的资金变动编号
  select seq_trade_up_fund_id.nextval into l_fund_id from dual;
  ---获取银行卡加款变动统一流水号
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================2.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡手续费的资金变动、添加实体卡加款的资金变动]===
  ---1更新实体卡账户
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_amount - v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  if (v_service_fee > 0) then
    ---2.添加实体卡手续费资金变动
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       l_bank_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       v_channel_name,
       v_account_name,
       v_memo,
       l_bank_batch_id);
  end if;

  ---3.添加实体卡加款资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company_id,
     v_amount,
     (l_bank_balance - v_amount - v_service_fee),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.up_add,
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id);

  --==============4.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加上游手工加款记录、添加上游资金变动]=====
  ---1.锁上游渠道账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.检查记录是否同步   
  select count(1)
    into l_sync_count
    from fd_trade_up_manual t
   where t.change_time >= sysdate - 30
     and t.change_time <= sysdate
     and t.up_sync_add_no = v_sync_add_no
     and t.manual_change_type = pkg_up_manual_change_type.add_amount;

  if l_sync_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  ---3.更新上游渠道账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  ---4.添加手工加款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id,
     up_sync_add_no)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_memo,
     v_create_user,
     v_partner_account,
     l_bank_batch_id,
     v_sync_add_no);

  ---5.添加资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance + v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_ADD_SYNC_CHECK
prompt ===============================================
prompt
create or replace function fd_account.fd_f_manual_up_add_sync_check(v_up_channel_no   varchar2,
                                                         v_bank_card_no    varchar2,
                                                         v_amount          number,
                                                         v_service_fee     number,
                                                         v_up_company_id   out number,
                                                         v_account_id      out number,
                                                         v_bank_account_id out number,
                                                         v_account_name    out varchar2,
                                                         v_channel_name    out varchar2)
  return varchar2 is
  ----------------获取上游支付账户-----------------
  l_bank_count number;
begin
  ---1.检查金额是否正确
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查上游资金账户
  select c.company_id, a.account_id, a.account_name, c.channel_name
    into v_up_company_id, v_account_id, v_account_name, v_channel_name
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
        --  and a.status = pkg_sys_boolean.istrue
        --   and c.status = pkg_sys_boolean.istrue
     and rownum <= 2;

  ---3.检查实体卡账户是否存在
  select count(1), max(t.account_id)
    into l_bank_count, v_bank_account_id
    from fd_bank_account_info t
   where t.card_no = v_bank_card_no;

  if (l_bank_count != 1) then
    return pkg_error_code.bank_account_id_error;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_UP_CHANNEL_MANNUL
prompt ========================================
prompt
create or replace function fd_account.fd_f_up_channel_mannul(v_up_channel_no      varchar2,
                                                  v_up_company_id      number,
                                                  v_manual_change_type number,
                                                  v_amount             number,
                                                  v_create_user        varchar2,
                                                  v_memo               varchar2)
  return varchar2 is
  ---------------------上游渠道操作（加款、提款）-------------------
  l_up_account_id         number;
  l_inner_balance         number;
  l_fund_id               number;
  l_fund_type             number;
  l_balance_change_amount number;
begin
  ---1.获取上游渠道关联账户
  select t.account_id
    into l_up_account_id
    from fd_base_up_account_map t
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   inner join fd_base_up_account a on t.account_id = a.account_id
   where t.channel_no = v_up_channel_no;

  ---2.获取参数
  if v_manual_change_type = pkg_up_manual_change_type.add_amount then
    l_fund_type             := pkg_up_fund_change_type.add_amount;
    l_balance_change_amount := v_amount;
  elsif v_manual_change_type = pkg_up_manual_change_type.draw_amount then
    l_fund_type             := pkg_up_fund_change_type.draw_amount;
    l_balance_change_amount := -1 * v_amount;
  else
    return pkg_error_code.param_error;
  end if;

  select seq_trade_up_fund_id.nextval into l_fund_id from dual;

  ---1.锁上游渠道账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = l_up_account_id
     for update;

  ---2.更新上游渠道账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance + l_balance_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = l_up_account_id;

  ---3.添加手工加款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_fund_id,
     v_up_channel_no,
     l_up_account_id,
     v_manual_change_type,
     v_amount,
     sysdate,
     (l_inner_balance + l_balance_change_amount),
     v_memo,
     v_create_user,
     '',
     '');

  ---4.添加资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     l_up_account_id,
     v_up_company_id,
     v_amount,
     v_amount,
     sysdate,
     l_fund_type,
     (l_inner_balance + l_balance_change_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_BIND_ADD
prompt =========================================
prompt
create or replace function fd_account.fd_f_manual_up_bind_add(v_up_channel_no varchar2,
                                                   l_company_id    number,
                                                   v_amount        number,
                                                   v_create_user   varchar2,
                                                   v_memo          varchar2)
  return varchar2 is
  --------------------空充上游关联加款空充下游和18自由充上游-----------------
  l_bind_system_name  varchar2(32) := 'QXKC';
  l_bind_qx_company   number := 11; ---千行
  l_bind_hz_company   number := 1; ---汇智
  l_qxkc_down_channel varchar2(32) := '';
  l_qx18_up_channel   varchar2(32) := '';
  l_hzkc_down_channel varchar2(32) := '10009';
  l_hz18_up_channel   varchar2(32) := 'twschf';
  l_use_kc_down       varchar2(32);
  l_use_18_up         varchar2(32);
  l_use_company       number;
  l_count             number;
  l_result            varchar2(32);

begin
  ---1.检查上游渠道是否为空充系统渠道
  select count(1)
    into l_count
    from fd_base_up_system_map t
   inner join fd_base_source_system s on t.source_system_id =
                                         s.source_system_id
   where t.channel_no = v_up_channel_no
     and s.source_system_name = l_bind_system_name;

  if l_count > 0 then
    if l_company_id = l_bind_qx_company then
      ---2.千行渠道关联加款
      l_use_kc_down := l_qxkc_down_channel;
      l_use_18_up   := l_qx18_up_channel;
      l_use_company := l_bind_qx_company;
    elsif l_company_id = l_bind_hz_company then
      ---3.汇智渠道关联加款
      l_use_kc_down := l_hzkc_down_channel;
      l_use_18_up   := l_hz18_up_channel;
      l_use_company := l_bind_hz_company;
    else
      return pkg_error_code.data_error;
    end if;
  
    ---========================空充下游关联加款============================
    l_result := fd_f_down_channel_mannul(l_use_kc_down,
                                         pkg_down_manual_change_type.add_amount,
                                         v_amount,
                                         v_create_user,
                                         v_memo);
    if l_result != pkg_error_code.success then
      return l_result;
    end if;
  
    ---========================18上游关联加款============================
    l_result := fd_f_up_channel_mannul(l_use_18_up,
                                       l_use_company,
                                       pkg_up_manual_change_type.add_amount,
                                       v_amount,
                                       v_create_user,
                                       v_memo);
    if l_result != pkg_error_code.success then
      return l_result;
    end if;
  
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_BIND_DRAW
prompt ==========================================
prompt
create or replace function fd_account.fd_f_manual_up_bind_draw(v_up_channel_no varchar2,
                                                    l_company_id    number,
                                                    v_amount        number,
                                                    v_create_user   varchar2,
                                                    v_memo          varchar2)
  return varchar2 is
  --------------------空充上游关联加款空充下游和18自由充上游-----------------
  l_bind_system_name  varchar2(32) := 'QXKC';
  l_bind_qx_company   number := 1; ---千行
  l_bind_hz_company   number := 11; ---汇智
  l_qxkc_down_channel varchar2(32) := '10009';
  l_qx18_up_channel   varchar2(32) := 'twschf';
  l_hzkc_down_channel varchar2(32) := '';
  l_hz18_up_channel   varchar2(32) := '';
  l_use_kc_down       varchar2(32);
  l_use_18_up         varchar2(32);
  l_use_company       number;
  l_count             number;
  l_result            varchar2(32);

begin
  ---1.检查上游渠道是否为空充系统渠道
  select count(1)
    into l_count
    from fd_base_up_system_map t
   inner join fd_base_source_system s on t.source_system_id =
                                         s.source_system_id
   where t.channel_no = v_up_channel_no
     and s.source_system_name = l_bind_system_name;

  if l_count > 0 then
    if l_company_id = l_bind_qx_company then
      ---2.千行渠道关联加款
      l_use_kc_down := l_qxkc_down_channel;
      l_use_18_up   := l_qx18_up_channel;
      l_use_company := l_bind_qx_company;
    elsif l_company_id = l_bind_hz_company then
      ---3.汇智渠道关联加款
      l_use_kc_down := l_hzkc_down_channel;
      l_use_18_up   := l_hz18_up_channel;
      l_use_company := l_bind_hz_company;
    else
      return pkg_error_code.data_error;
    end if;
  
    ---========================空充下游关联提款============================
    l_result := fd_f_down_channel_mannul(l_use_kc_down,
                                         pkg_down_manual_change_type.draw_amount,
                                         v_amount,
                                         v_create_user,
                                         v_memo);
    if l_result != pkg_error_code.success then
      return l_result;
    end if;
  
    ---========================18上游关联提款============================
    l_result := fd_f_up_channel_mannul(l_use_18_up,
                                       l_use_company,
                                       pkg_up_manual_change_type.draw_amount,
                                       v_amount,
                                       v_create_user,
                                       v_memo);
    if l_result != pkg_error_code.success then
      return l_result;
    end if;
  
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_BORROW_ADD
prompt ===========================================
prompt
create or replace function fd_account.fd_f_manual_up_borrow_add(v_up_channel_no  varchar2,
                                                     v_up_company_id  number,
                                                     v_up_account_id  number,
                                                     v_cap_account_id number,
                                                     v_amount         number,
                                                     v_create_user    varchar2,
                                                     v_memo           varchar2)
  return varchar2 is
  l_inner_balance    number;
  l_cap_balance      number;
  l_fund_id          number;
  l_cap_company_id   number;
  l_bank_batch_id    number; ---银行卡加款变动统一流水号
  l_cap_account_name varchar2(32);
  ------------资产账户上游加款----------

begin
  --===============1.锁账户获取参数==========================================
  ---1.锁资产账户
  select t.balance, t.company_id, t.account_name
    into l_cap_balance, l_cap_company_id, l_cap_account_name
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     for update;

  ---2.获取资金变动主键
  select seq_trade_up_fund_id.nextval into l_fund_id from dual;
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================2.修改资产账户余额=====================================
  ---1.更新资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_cap_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_cap_account_id;

  ---2.添加资产账户资金变动
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     bank_batch_id,
     memo)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_cap_account_id,
     v_amount,
     pkg_co_cap_fund_type.borrow_up_add,
     (l_cap_balance - v_amount),
     sysdate,
     l_bank_batch_id,
     v_memo);

  --==============3.更新渠道账户==================================================
  ---1.锁上游渠道账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.更新上游渠道账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  ---3.添加手工加款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.cap_add,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_memo,
     v_create_user,
     l_cap_account_name,
     l_bank_batch_id);

  ---4.添加资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance + v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_BORROW_ADD_CK
prompt ==============================================
prompt
create or replace function fd_account.fd_f_manual_up_borrow_add_ck(v_up_channel_no  varchar2,
                                                        v_up_account_id  number,
                                                        v_cap_account_id number,
                                                        v_amount         number,
                                                        v_up_company_id  out number)
  return varchar2 is
  ----------------获取上游支付账户-----------------
  l_cap_count number;
begin
  ---1.检查金额是否正确
  if (v_amount <= 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查上游资金账户
  select c.company_id
    into v_up_company_id
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and rownum <= 1;

  ---3.检查实体卡账户是否存在
  select count(1)
    into l_cap_count
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     and t.account_type in (pkg_co_cap_account_type.borrow,
          pkg_co_cap_account_type.short_borrow,
          pkg_co_cap_account_type.personal_borrow,
          pkg_co_cap_account_type.activity);

  if (l_cap_count = 0) then
    return pkg_error_code.co_account_not_exists;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_CHANNEL_CHECK
prompt ==============================================
prompt
create or replace function fd_account.fd_f_manual_up_channel_check(v_up_channel_no varchar2,
                                                        v_up_account_id number,
                                                        v_up_max_add    out number,
                                                        v_up_min_add    out number)
  return varchar2 is
  ------------------检查计算建议加款的渠道的信息--------------------
begin
  ---1.检查渠道、账户的对应关系
  select c.max_add, c.min_add
    into v_up_max_add, v_up_min_add
    from fd_base_up_account_map t
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   inner join fd_base_up_account a on t.account_id = a.account_id
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_COMMI_ADD
prompt ==========================================
prompt
create or replace function fd_account.fd_f_manual_up_commi_add(v_up_channel_no in varchar2,
                                                    v_up_account_id in number,
                                                    v_amount        in number,
                                                    v_commi_month   in varchar2,
                                                    v_create_user   in varchar2,
                                                    v_memo          in varchar2)
  return varchar2 is
  ------------------上游佣金转渠道余额-----------------
  l_inner_balance number;
  l_fund_id       number;
  l_bank_batch_id number;
  l_commi_balance number;
  l_channel_name  varchar2(100);
  l_company_id    number;
begin

  --===============1.修改渠道佣金=============================================
  select seq_bank_service_id.nextval, seq_trade_up_fund_id.nextval
    into l_bank_batch_id, l_fund_id
    from dual;

  ---1.锁下游渠道
  select t.commi_balance, t.channel_name, t.company_id
    into l_commi_balance, l_channel_name, l_company_id
    from fd_base_up_channel t
   where t.channel_no = v_up_channel_no
     for update;

  ---2.检查佣金余额
  if v_amount > l_commi_balance then
    return pkg_error_code.balance_low;
  end if;

  ---3.修改佣金余额
  update fd_base_up_channel t
     set t.commi_balance  = (l_commi_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.channel_no = v_up_channel_no;

  ---4.添加佣金结算记录
  insert into fd_trade_commission_settle
    (report_id,
     channel_no,
     channel_type,
     commission,
     settle_month,
     settle_status,
     settle_user,
     settle_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     settle_type,
     commi_balance,
     memo)
  values
    (seq_trade_commission_settle_id.nextval,
     v_up_channel_no,
     pkg_channel_type.up_channel,
     v_amount,
     to_date(v_commi_month, 'yyyymmddhh24miss'),
     pkg_sys_boolean.istrue,
     v_create_user,
     sysdate,
     pkg_sys_boolean.isfalse,
     0,
     l_bank_batch_id,
     pkg_commi_settle_type.to_channel,
     (l_commi_balance - v_amount),
     v_memo);

  --==============2.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加下游手工加款记录、添加下游资金变动]=====
  ---1.锁下游渠道账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.更新渠道账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  ---3.添加手工加款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.cap_add,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_memo,
     v_create_user,
     l_channel_name,
     l_bank_batch_id);

  ---4.添加资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     l_company_id,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance + v_amount),
     v_memo);
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_COMMI_ADD_CK
prompt =============================================
prompt
create or replace function fd_account.fd_f_manual_up_commi_add_ck(v_up_channel_no varchar2,
                                                       v_up_account_id number,
                                                       v_amount        number)
  return varchar2 is
  ------------------上游佣金转渠道余额检查-----------------
  l_company_id    number;
  l_commi_balance number;
begin
  ---1.检查加款金额
  if v_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户
  select c.company_id, c.commi_balance
    into l_company_id, l_commi_balance
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and rownum <= 1;

  if v_amount > l_commi_balance then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_DEP_ADD
prompt ========================================
prompt
create or replace function fd_account.fd_f_manual_up_dep_add(v_up_channel_no  varchar2,
                                                  v_up_company_id  number,
                                                  v_up_account_id  number,
                                                  v_cap_account_id number,
                                                  v_amount         number,
                                                  v_create_user    varchar2,
                                                  v_memo           varchar2)
  return varchar2 is
  l_inner_balance    number;
  l_cap_balance      number;
  l_fund_id          number;
  l_cap_company_id   number;
  l_bank_batch_id    number; ---银行卡加款变动统一流水号
  l_cap_account_name varchar2(32);
  ------------资产账户上游加款----------

begin
  --===============1.锁账户获取参数==========================================
  ---1.锁资产账户
  select t.balance, t.company_id, t.account_name
    into l_cap_balance, l_cap_company_id, l_cap_account_name
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     for update;

  ---2.获取资金变动主键
  select seq_trade_up_fund_id.nextval into l_fund_id from dual;
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================2.修改资产账户余额=====================================
  ---1.更新资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_cap_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_cap_account_id;

  ---2.添加资产账户资金变动
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     bank_batch_id,
     memo)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_cap_account_id,
     v_amount,
     pkg_co_cap_fund_type.deposit_up_add,
     (l_cap_balance + v_amount),
     sysdate,
     l_bank_batch_id,
     v_memo);

  --==============3.更新渠道账户==================================================
  ---1.锁上游渠道账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.更新上游渠道账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  ---3.添加手工加款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.cap_add,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_memo,
     v_create_user,
     l_cap_account_name,
     l_bank_batch_id);

  ---4.添加资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance + v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_DEP_ADD_CK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_manual_up_dep_add_ck(v_up_channel_no  varchar2,
                                                     v_up_account_id  number,
                                                     v_cap_account_id number,
                                                     v_amount         number,
                                                     v_up_company_id  out number)
  return varchar2 is
  ----------------获取上游支付账户-----------------
  l_cap_count number;
begin
  ---1.检查金额是否正确
  if (v_amount <= 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查上游资金账户
  select c.company_id
    into v_up_company_id
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and rownum <= 1;

  ---3.检查实体卡账户是否存在
  select count(1)
    into l_cap_count
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     and t.account_type in
         (pkg_co_cap_account_type.deposit, pkg_co_cap_account_type.bond);

  if (l_cap_count = 0) then
    return pkg_error_code.co_account_not_exists;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_DRAW
prompt =====================================
prompt
create or replace function fd_account.fd_f_manual_up_draw(v_up_channel_no   varchar2,
                                               v_up_company_id   number,
                                               v_up_account_id   number,
                                               v_bank_account_id number,
                                               v_amount          number,
                                               v_service_fee     number,
                                               v_create_user     varchar2,
                                               v_partner_account varchar2,
                                               v_memo            varchar2,
                                               v_account_name    varchar2,
                                               v_remark_name     varchar2,
                                               v_channel_name    varchar2)
  return varchar2 is
  l_inner_balance   number;
  l_bank_balance    number;
  l_fund_id         number;
  l_bank_company_id number;
  l_bank_batch_id   number; ---银行卡加款变动统一流水号
  ------------上游手工提款----------
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

  -----银行卡手续费（资金变动(i)6）
  -----银行卡（账户表 (f)2，账户(u)5,加款资金变动(i)7）
  -----公司手续费（账户表(f)1，账户(u)3,资金变动(i)4）
  -----上游渠道（账户(f)8，账户(u)9,上游加款记录表(i)10,资金变动(i)11）

begin
  --===============1.锁账户获取参数==========================================
  --=========[锁实体卡账户、检查实体卡余额、获取seq]=======
  ---1.锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---3.获取资金变动主键
  ---手续费手费资金变动编号，小于人工加款的资金变动编号
  select seq_trade_up_fund_id.nextval into l_fund_id from dual;
  ---获取银行卡加款变动统一流水号
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================2.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡手续费的资金变动、添加实体卡加款的资金变动]===
  ---1更新实体卡账户
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + v_amount - v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  if (v_service_fee > 0) then
    ---2.添加实体卡手续费资金变动
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       l_bank_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       v_channel_name,
       v_account_name,
       v_memo,
       l_bank_batch_id,v_remark_name);
  end if;

  ---3.添加实体卡加款资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company_id,
     v_amount,
     (l_bank_balance + v_amount - v_service_fee),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.add_amount,
     pkg_bank_use_type.up_draw,
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id,v_remark_name);

  --==============4.更新渠道账户==================================================
  ---1.锁上游渠道账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.更新上游渠道账户余额
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  ---3.添加手工加款的提款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.draw_amount,
     v_amount,
     sysdate,
     (l_inner_balance - v_amount),
     v_memo,
     v_create_user,
     v_partner_account,
     l_bank_batch_id);

  ---4.添加资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.draw_amount,
     (l_inner_balance - v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_DRAW_CHECK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_manual_up_draw_check(v_up_channel_no   varchar2,
                                                     v_up_account_id   number,
                                                     v_bank_account_id number,
                                                     v_amount          number,
                                                     v_service_fee     number,
                                                     v_up_company_id   out number,
                                                     v_account_name    out varchar2,
                                                     v_channel_name    out varchar2)
  return varchar2 is
  ----------------获取上游支付账户-----------------
  l_bank_count number;
begin
  ---1.检查金额是否正确
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查上游资金账户
  select c.company_id, a.account_name, c.channel_name
    into v_up_company_id, v_account_name, v_channel_name
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
        --and a.status = pkg_sys_boolean.istrue
        -- and c.status = pkg_sys_boolean.istrue
     and rownum <= 1;

  ---3.检查实体卡账户是否存在
  select count(1)
    into l_bank_count
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id;

  if (l_bank_count = 0) then
    return pkg_error_code.bank_account_id_error;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_INNER_CHECK
prompt ============================================
prompt
create or replace function fd_account.fd_f_manual_up_inner_check(v_out_channel_no varchar2,
                                                      v_out_account_id number,
                                                      v_in_channel_no  varchar2,
                                                      v_in_account_id  number,
                                                      v_amount         number)
  return varchar2 is
  -------------------检查上游渠道内转渠道账户信息-------------------
  l_out_company  number;
  l_in_company   number;
  l_system_count number;
begin
  ---1.检查转移金额
  if v_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查出入账渠道账户关联信息
  select c.company_id
    into l_out_company
    from fd_base_up_account_map t
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   inner join fd_base_up_account a on t.account_id = a.account_id
   where t.channel_no = v_out_channel_no
     and t.account_id = v_out_account_id
     and rownum <= 2;

  select c.company_id
    into l_in_company
    from fd_base_up_account_map t
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   inner join fd_base_up_account a on t.account_id = a.account_id
   where t.channel_no = v_in_channel_no
     and t.account_id = v_in_account_id
     and rownum <= 2;

  if l_out_company != l_in_company then
    return pkg_error_code.channel_error;
  end if;

  ---3.检查渠道系统是否相同
  select count(1)
    into l_system_count
    from fd_base_up_system_map t
   where t.channel_no = v_out_channel_no
     and t.source_system_id in
         (select m.source_system_id
            from fd_base_up_system_map m
           where m.channel_no = v_in_channel_no);

  if l_system_count = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_INNER_TRANSFER
prompt ===============================================
prompt
create or replace function fd_account.fd_f_manual_up_inner_transfer(v_out_channel_no varchar2,
                                                         v_out_account_id number,
                                                         v_in_channel_no  varchar2,
                                                         v_in_account_id  number,
                                                         v_amount         number,
                                                         v_hander_user    varchar2,
                                                         v_memo           varchar2)
  return varchar2 is
  -------------------上游渠道内部转账--------------------
  l_out_balance      number;
  l_out_fund_id      number;
  l_out_channel_name varchar2(32);
  l_out_company      number;
  l_in_channel_name  varchar2(32);
  l_in_company       number;
  l_in_balance       number;
  l_in_fund_id       number;
begin
  --======================出账上游渠道操作=======================
  ---0.获取出账渠道名称
  select t.channel_name, t.company_id
    into l_out_channel_name, l_out_company
    from fd_base_up_channel t
   where t.channel_no = v_out_channel_no;

  ---1.锁出账上游账户
  select t.inner_balance
    into l_out_balance
    from fd_base_up_account t
   where t.account_id = v_out_account_id
     for update;

  ---2.修改出账上游余额
  update fd_base_up_account t
     set t.inner_balance  = (l_out_balance - v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_out_account_id;

  select seq_trade_up_fund_id.nextval into l_out_fund_id from dual;

  ---3.添加出账上游提款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     has_adjust)
  values
    (l_out_fund_id,
     v_out_channel_no,
     v_out_account_id,
     0,
     pkg_up_manual_change_type.draw_amount,
     v_amount,
     sysdate,
     (l_out_balance - v_amount),
     v_memo,
     v_hander_user,
     l_out_channel_name,
     pkg_sys_boolean.istrue);

  ---4.添加出账上游资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_out_fund_id,
     v_out_channel_no,
     v_out_account_id,
     l_out_company,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.draw_amount,
     (l_out_balance - v_amount),
     v_memo);

  --======================入账上游渠道操作=======================
  ---0.获取入账渠道名称
  select t.channel_name, t.company_id
    into l_in_channel_name, l_in_company
    from fd_base_up_channel t
   where t.channel_no = v_in_channel_no;

  ---1.锁入账上游账户
  select t.inner_balance
    into l_in_balance
    from fd_base_up_account t
   where t.account_id = v_in_account_id
     for update;

  ---2.修改入账上游余额
  update fd_base_up_account t
     set t.inner_balance  = (l_in_balance + v_amount),
         t.last_edit_user = v_hander_user,
         t.last_edit_time = sysdate
   where t.account_id = v_in_account_id;

  select seq_trade_up_fund_id.nextval into l_in_fund_id from dual;

  ---3.添加入账上游加款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     has_adjust)
  values
    (l_in_fund_id,
     v_in_channel_no,
     v_in_account_id,
     0,
     pkg_up_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_in_balance + v_amount),
     v_memo,
     v_hander_user,
     l_in_channel_name,
     pkg_sys_boolean.istrue);

  ---4.添加入账上游资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_in_fund_id,
     v_in_channel_no,
     v_in_account_id,
     l_in_company,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_in_balance + v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_RV_CHANNEL
prompt ===========================================
prompt
create or replace function fd_account.fd_f_manual_up_rv_channel(v_up_channel_no varchar2,
                                                     v_up_account_id number,
                                                     v_revise_type   number,
                                                     v_revise_amount number,
                                                     v_create_user   varchar2,
                                                     v_memo          varchar2,
                                                     v_trade_fund_id out number)
  return varchar2 is
  -------------------上游渠道账户平账------------------
  l_inner_balance         number;
  l_up_manual_type        number;
  l_fund_type             number;
  l_balance_change_amount number;
begin
  ---1.获取渠道资金变动参数
  select seq_trade_up_fund_id.nextval into v_trade_fund_id from dual;

  if (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.balance) then
    l_up_manual_type        := pkg_up_manual_change_type.balance_revise_add;
    l_fund_type             := pkg_up_fund_change_type.add_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount < 0 and
        v_revise_type = pkg_sys_revise_type.balance) then
    l_up_manual_type        := pkg_up_manual_change_type.balance_revise_minus;
    l_fund_type             := pkg_up_fund_change_type.add_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.debit) then
    l_up_manual_type        := pkg_up_manual_change_type.debit_revise_add;
    l_fund_type             := pkg_up_fund_change_type.debit_amount;
    l_balance_change_amount := 0 - v_revise_amount;
  elsif (v_revise_amount < 0 and v_revise_type = pkg_sys_revise_type.debit) then
    l_up_manual_type        := pkg_up_manual_change_type.debit_revise_minus;
    l_fund_type             := pkg_up_fund_change_type.debit_amount;
    l_balance_change_amount := 0 - v_revise_amount;
  elsif (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.refund) then
    l_up_manual_type        := pkg_up_manual_change_type.refund_revise_add;
    l_fund_type             := pkg_up_fund_change_type.refund_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount < 0 and v_revise_type = pkg_sys_revise_type.refund) then
    l_up_manual_type        := pkg_up_manual_change_type.refund_revise_minus;
    l_fund_type             := pkg_up_fund_change_type.refund_amount;
    l_balance_change_amount := v_revise_amount;
  else
    return pkg_error_code.data_error;
  end if;

  ---2.锁渠道账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---3.修改账户余额添加资金变动
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance + l_balance_change_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     has_adjust)
  values
    (v_trade_fund_id,
     v_up_channel_no,
     v_up_account_id,
     0,
     l_up_manual_type,
     v_revise_amount,
     sysdate,
     (l_inner_balance + l_balance_change_amount),
     nvl2(v_memo, v_memo || ',上游平账', '上游平账'),
     v_create_user,
     0);

  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (v_trade_fund_id,
     v_up_channel_no,
     v_up_account_id,
     0,
     v_revise_amount,
     v_revise_amount,
     sysdate,
     l_fund_type,
     (l_inner_balance + l_balance_change_amount),
     v_memo);

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_RV_CHANNEL_CK
prompt ==============================================
prompt
create or replace function fd_account.fd_f_manual_up_rv_channel_ck(v_up_channel_no  varchar2,
                                                        v_up_account_id  number,
                                                        v_account_amount number)
  return varchar2 is
  -------------------检查手工平账渠道账户、金额是否正确--------------------
  l_company_id number;
begin

  ---1.检查金额是否正确
  if (v_account_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户是否正确
  select c.company_id
    into l_company_id
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and rownum <= 2;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function FD_F_MANUAL_UP_RV_TRADE_CK
prompt ============================================
prompt
create or replace function fd_account.fd_f_manual_up_rv_trade_ck(v_up_channel_no  varchar2,
                                                      v_up_account_id  number,
                                                      v_up_draw_amount number,
                                                      v_up_real_amount number)

 return varchar2 is
  l_up_account_id number;
begin
  ---1.检查调整金额是否正确
  if (v_up_draw_amount = 0 and v_up_real_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户是否正确
  select t.account_id
    into l_up_account_id
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and rownum <= 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function FD_F_QUERY_CHANNEL_BALANCE
prompt ============================================
prompt
create or replace function fd_account.fd_f_query_channel_balance(v_channel_no    varchar2,
                                                      v_channel_type  number,
                                                      v_query_balance out number,
                                                      v_inner_balance out number,
                                                      v_credit_money  out number)
  return varchar2 is
  --------------------查询系统渠道余额-------------------
  l_count number;
begin
  if v_channel_type = pkg_channel_type.down_channel then
    ---1.下游渠道余额
    select count(1),
           sum(a.query_balance),
           sum(a.inner_balance),
           sum(a.credit_money)
      into l_count, v_query_balance, v_inner_balance, v_credit_money
      from fd_base_down_account_map t
     inner join fd_base_down_channel c on t.channel_no = c.channel_no
     inner join fd_base_down_account a on t.account_id = a.account_id
     where c.channel_no = v_channel_no;
  
    if l_count = 0 then
      return pkg_error_code.channel_error;
    end if;
  else
    ---2.上游渠道余额
    select count(1), sum(a.query_balance), sum(a.inner_balance)
      into l_count, v_query_balance, v_inner_balance
      from fd_base_up_account_map t
     inner join fd_base_up_channel c on t.channel_no = c.channel_no
     inner join fd_base_up_account a on t.account_id = a.account_id
     where c.channel_no = v_channel_no;
  
    if l_count = 0 then
      return pkg_error_code.channel_error;
    end if;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_RECV_BALANCE_OFFSET
prompt ==========================================
prompt
create or replace function fd_account.fd_f_recv_balance_offset(l_front_account_id number,
                                                    l_back_account_id  number,
                                                    l_front_balance    number,
                                                    l_back_balance     number,
                                                    l_offset_balance   number)
  return varchar2 is
  ------------------结算账户余额相抵扣------------------
begin
  ---1.正向结算账号抵扣余额
  update fd_base_company_account_recv t
     set t.balance = (l_front_balance - l_offset_balance)
   where t.account_id = l_front_account_id;

  ---2.添加正向抵扣的资金变动
  insert into fd_trade_co_recv_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     has_adjust,
     bank_batch_id,
     handle_user,
     remark)
  values
    (seq_trade_co_recv_fund_id.nextval,
     l_front_account_id,
     l_offset_balance,
     pkg_co_fund_recv_type.minus_amount,
     (l_front_balance - l_offset_balance),
     0,
     0,
     'sys_auto',
     '系统自动抵扣');

  ---3.反向结算账号抵扣余额
  update fd_base_company_account_recv t
     set t.balance = (l_back_balance - l_offset_balance)
   where t.account_id = l_back_account_id;

  ---4.添加反向抵扣的资金变动  
  insert into fd_trade_co_recv_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     has_adjust,
     bank_batch_id,
     handle_user,
     remark)
  values
    (seq_trade_co_recv_fund_id.nextval,
     l_back_account_id,
     l_offset_balance,
     pkg_co_fund_recv_type.minus_amount,
     (l_back_balance - l_offset_balance),
     0,
     0,
     'sys_auto',
     '系统自动抵扣');

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_SYNC_QUERY_BALANCE
prompt =========================================
prompt
create or replace function fd_account.fd_f_sync_query_balance(v_channel_no    varchar2, ---渠道编号
                                                   v_channel_type  number, ---渠道类型1.上游渠道 2.下游渠道
                                                   v_query_balance number ---查询余额
                                                   ) return varchar2 is
  -------------------同步渠道查询余额------------------

  l_account_id number;
begin
  if v_channel_type = pkg_channel_type.up_channel then
    ---1.上游渠道同步查询余额
    select t.account_id
      into l_account_id
      from fd_base_up_account_map t
     where t.channel_no = v_channel_no
       and rownum <= 2;
  
    update fd_base_up_account t
       set t.query_balance = v_query_balance
     where t.account_id = l_account_id;
  elsif v_channel_type = pkg_channel_type.down_channel then
    ---2.下游渠道同步查询余额
    select t.account_id
      into l_account_id
      from fd_base_down_account_map t
     where t.channel_no = v_channel_no
       and rownum <= 2;
  
    update fd_base_down_account t
       set t.query_balance = v_query_balance
     where t.account_id = l_account_id;
  
  else
    return pkg_error_code.channel_error;
  end if;

  ---3.检查同步是否成功
  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_AC_PAY_ACCOUNT_GET
prompt ===============================================
prompt
create or replace function fd_account.fd_f_trade_ac_pay_account_get(v_order_source  number,
                                                         v_up_channel_no varchar2,
                                                         v_up_account_id number)
  return varchar2 is

  -----------------获取上游支付账户编号------------------
  l_up_account_id number;
begin

  ---1.获取上游渠道唯一账户，当有多个账户时，请使用其它方式获取
  select t.account_id
    into l_up_account_id
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   inner join fd_base_up_system_map s on t.channel_no = s.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and s.source_system_id = v_order_source
        --and a.status = 0
        --and c.status = 0
     and rownum <= 1;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_TRADE_ALL_PAY_CHECK
prompt ==========================================
prompt
create or replace function fd_account.fd_f_trade_all_pay_check(v_down_channel_no    varchar2,
                                                    v_up_channel_no      varchar2,
                                                    v_up_bill_channel_no varchar2,
                                                    v_order_face         number,
                                                    v_order_amount       number,
                                                    v_up_account_id      out number,
                                                    v_up_bill_account_id out number,
                                                    v_system_id          out number)
  return varchar2 is
  -------------------检查非冲支付相关信息-----------------
  l_result            varchar2(32);
  l_down_company      number;
  l_up_company        number;
  l_up_bill_company   number;
  l_down_sys_count    number;
  l_up_sys_count      number;
  l_up_bill_sys_count number;
begin
  ---0.检查金额
  if (v_order_face <= 0) or (v_order_amount <= 0) then
    return pkg_error_code.amount_error;
  end if;

  ---1.检查上下游渠道公司信息
  select t.company_id
    into l_down_company
    from fd_base_down_channel t
   where t.channel_no = v_down_channel_no;

  select t.company_id
    into l_up_company
    from fd_base_up_channel t
   where t.channel_no = v_up_channel_no;

  if l_down_company != l_up_company then
    return pkg_error_code.channel_error;
  end if;

  ---2.检查上下游渠道系统信息
  select count(1), max(t.source_system_id)
    into l_down_sys_count, v_system_id
    from fd_base_down_system_map t
   inner join fd_base_source_system s on t.source_system_id =
                                         s.source_system_id
   where t.channel_no = v_down_channel_no
     and s.source_system_name = 'NRG';

  if l_down_sys_count = 0 then
    return pkg_error_code.data_error;
  end if;

  select count(1)
    into l_up_sys_count
    from fd_base_up_system_map t
   inner join fd_base_source_system s on t.source_system_id =
                                         s.source_system_id
   where t.channel_no = v_up_channel_no
     and s.source_system_name = 'NRG';

  if l_up_sys_count = 0 then
    return pkg_error_code.data_error;
  end if;

  ---3.检查下游渠道信息
  l_result := fd_f_trade_down_amount_check(v_down_channel_no,
                                           v_order_amount);
  if (l_result != pkg_error_code.success) then
    return l_result;
  end if;

  ---4.检查上游渠道信息
  l_result := fd_f_trade_pay_account_get(v_system_id,
                                         v_up_channel_no,
                                         v_up_account_id);
  if (l_result != pkg_error_code.success) then
    return l_result;
  end if;

  ---5.检查预存话费上游渠道信息
  if nvl(v_up_bill_channel_no, 'null') != 'null' then
    select t.company_id
      into l_up_bill_company
      from fd_base_up_channel t
     where t.channel_no = v_up_bill_channel_no;
  
    if l_up_bill_company != l_up_company then
      return pkg_error_code.channel_error;
    end if;
  
    select count(1)
      into l_up_bill_sys_count
      from fd_base_up_system_map t
     inner join fd_base_source_system s on t.source_system_id =
                                           s.source_system_id
     where t.channel_no = v_up_bill_channel_no
       and s.source_system_name = 'NRG';
  
    if l_up_bill_sys_count = 0 then
      return pkg_error_code.data_error;
    end if;
  
    l_result := fd_f_trade_pay_account_get(v_system_id,
                                           v_up_bill_channel_no,
                                           v_up_bill_account_id);
  end if;

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_ALL_REFUND_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_trade_all_refund_check(v_order_source       number,
                                                       v_trade_order_no     varchar2,
                                                       v_down_refund_amount number,
                                                       v_up_refund_amount   number,
                                                       v_bill_refund_amount number)
  return varchar2 is
  ---------------------检查非冲订单退款相关订单信息---------------------
  l_down_debit_count number;
  l_up_debit_count   number;
  l_down_debit       number;
  l_up_debit         number;
begin
  ---1.检查下游扣款信息是否存在
  select nvl(sum(decode(t.change_type,
                        pkg_down_fund_change_type.debit_amount,
                        1,
                        0)),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_down_fund_change_type.debit_amount,
                        1,
                        -1) * t.change_amount),
             0)
    into l_down_debit_count, l_down_debit
    from fd_trade_down_fund t
   where t.order_source = v_order_source
     and t.trade_order_no = v_trade_order_no
     and t.change_type in (pkg_down_fund_change_type.debit_amount,
          pkg_down_fund_change_type.refund_amount);

  if l_down_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---2.检查上游扣款信息是否存在
  select nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        0)),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.up_draw_amount),
             0)
    into l_up_debit_count, l_up_debit
    from fd_trade_up_fund t
   where t.order_source = v_order_source
     and t.trade_order_no = v_trade_order_no
     and t.change_type in (pkg_up_fund_change_type.debit_amount,
          pkg_up_fund_change_type.refund_amount);

  if l_up_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---3.检查下游退款金额是否大于下游扣款金额
  if v_down_refund_amount > l_down_debit then
    return pkg_error_code.amount_error;
  end if;

  ---4.检查上游退款金额是否大于上游扣款金额
  if (v_up_refund_amount + v_bill_refund_amount) > l_up_debit then
    return pkg_error_code.amount_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_ALL_SYS_GET
prompt ========================================
prompt
create or replace function fd_account.fd_f_trade_all_sys_get(v_down_channel_no varchar2,
                                                  v_order_source    out number)
  return varchar2 is
  --------------------获取渠道的系统信息------------------
begin
  ---1.获取下游渠道的系统信息
  select m.source_system_id
    into v_order_source
    from fd_base_down_channel t
   inner join fd_base_down_system_map m on t.channel_no = m.channel_no
   inner join fd_base_source_system s on m.source_system_id =
                                         s.source_system_id
   where t.channel_no = v_down_channel_no
     and s.source_system_name = 'NRG'
     and rownum <= 1;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_BACK_MOVE
prompt ======================================
prompt
create or replace function fd_account.fd_f_trade_back_move(v_order_source    number,
                                                v_down_channel_no varchar2,
                                                v_trade_order_no  varchar2)
  return varchar2 is
  -------------------交易资金变动由离线库转移到当前库-----------------
  l_order_bk_count         number;
  l_fd_order_id            number;
  l_order_add_count        number;
  l_order_del_count        number;
  l_down_fund_add_count    number;
  l_down_fund_del_count    number;
  l_down_fund_hs_add_count number;
  l_down_fund_hs_del_count number;
  l_up_fund_add_count      number;
  l_up_fund_del_count      number;
  l_up_fund_hs_add_count   number;
  l_up_fund_hs_del_count   number;
begin
  ---1.检查离线库订单是否存在
  select count(1), max(t.fd_order_id)
    into l_order_bk_count, l_fd_order_id
    from fd_trade_order_main_hs t ---@agentbackupdb t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1;

  if l_order_bk_count = 0 then
    return pkg_error_code.order_not_exists;
  end if;

  ---3.离线库存在订单，将订单转移到当前库
  ---3.1订单主表数据
  insert into fd_trade_order_main
    (fd_order_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     business_type,
     carrier_no,
     province_no,
     city_no,
     total_face,
     recharge_unit,
     recharge_account_no)
    select fd_order_id,
           down_channel_no,
           down_account_id,
           down_company_id,
           trade_order_no,
           ext_order_no,
           order_source,
           create_time,
           order_time,
           business_type,
           carrier_no,
           province_no,
           city_no,
           total_face,
           recharge_unit,
           recharge_account_no
      from fd_trade_order_main_hs t ---@agentbackupdb t
     where t.fd_order_id = l_fd_order_id;
  l_order_add_count := sql%rowcount;

  if l_order_add_count = 0 then
    return pkg_error_code.data_error;
  end if;

  ---3.2删除离线库订单主表数据
  delete from fd_trade_order_main_hs t ---@agentbackupdb t
   where t.fd_order_id = l_fd_order_id;
  l_order_del_count := sql%rowcount;

  if l_order_del_count != l_order_add_count then
    return pkg_error_code.data_error;
  end if;

  ---3.3下游资金变动数据
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee) ----添加手续费
    select record_id,
           fd_order_id,
           channel_no,
           account_id,
           trade_order_no,
           ext_order_no,
           order_source,
           create_time,
           order_time,
           change_type,
           change_amount,
           balance,
           memo,
           service_fee
      from fd_trade_down_fund_hs t ---@agentbackupdb t
     where t.fd_order_id = l_fd_order_id;
  l_down_fund_add_count := sql%rowcount;

  ---3.4删除历史库下游资金变动数据
  delete from fd_trade_down_fund_hs t ---@agentbackupdb t
   where t.fd_order_id = l_fd_order_id;
  l_down_fund_del_count := sql%rowcount;

  if l_down_fund_del_count != l_down_fund_add_count then
    return pkg_error_code.data_error;
  end if;

  if l_down_fund_add_count = 0 then
    ---3.3下游资金变动数据
    insert into fd_trade_down_fund
      (record_id,
       fd_order_id,
       channel_no,
       account_id,
       trade_order_no,
       ext_order_no,
       order_source,
       create_time,
       order_time,
       change_type,
       change_amount,
       balance,
       memo,
       service_fee) ----添加手续费
      select record_id,
             fd_order_id,
             channel_no,
             account_id,
             trade_order_no,
             ext_order_no,
             order_source,
             create_time,
             order_time,
             change_type,
             change_amount,
             balance,
             memo,
             service_fee
        from fd_trade_down_fund_hs t
       where t.fd_order_id = l_fd_order_id;
    l_down_fund_hs_add_count := sql%rowcount;
  
    ---3.4删除历史库下游资金变动数据
    delete from fd_trade_down_fund_hs t
     where t.fd_order_id = l_fd_order_id;
    l_down_fund_hs_del_count := sql%rowcount;
  
    if l_down_fund_hs_del_count != l_down_fund_hs_add_count then
      return pkg_error_code.data_error;
    end if;
  end if;

  ---3.5上游资金变动数据
  insert into fd_trade_up_fund
    (record_id,
     fd_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_batch_id,
     settle_status,
     settle_time,
     memo,
     order_time)
    select record_id,
           fd_order_id,
           trade_order_no,
           order_source,
           trade_delivery_no,
           down_channel_no,
           down_account_id,
           down_company_id,
           up_channel_no,
           up_account_id,
           up_company_id,
           down_draw_unit,
           down_draw_face,
           down_draw_amount,
           down_real_amount,
           up_draw_unit,
           up_draw_face,
           up_draw_amount,
           up_real_amount,
           change_time,
           change_type,
           bill_type,
           business_type,
           carrier_no,
           province_no,
           balance,
           profits,
           down_commission,
           up_commission,
           settle_amount,
           settle_batch_id,
           settle_status,
           settle_time,
           memo,
           order_time
      from fd_trade_up_fund_hs t ---@agentbackupdb t
     where t.fd_order_id = l_fd_order_id;
  l_up_fund_add_count := sql%rowcount;

  ---3.6删除历史库上游资金变动数据
  delete from fd_trade_up_fund_hs t ---@agentbackupdb t
   where t.fd_order_id = l_fd_order_id;
  l_up_fund_del_count := sql%rowcount;

  if l_up_fund_del_count != l_up_fund_add_count then
    return pkg_error_code.data_error;
  end if;

  if l_up_fund_add_count = 0 then
    insert into fd_trade_up_fund
      (record_id,
       fd_order_id,
       trade_order_no,
       order_source,
       trade_delivery_no,
       down_channel_no,
       down_account_id,
       down_company_id,
       up_channel_no,
       up_account_id,
       up_company_id,
       down_draw_unit,
       down_draw_face,
       down_draw_amount,
       down_real_amount,
       up_draw_unit,
       up_draw_face,
       up_draw_amount,
       up_real_amount,
       change_time,
       change_type,
       bill_type,
       business_type,
       carrier_no,
       province_no,
       balance,
       profits,
       down_commission,
       up_commission,
       settle_amount,
       settle_batch_id,
       settle_status,
       settle_time,
       memo,
       order_time)
      select record_id,
             fd_order_id,
             trade_order_no,
             order_source,
             trade_delivery_no,
             down_channel_no,
             down_account_id,
             down_company_id,
             up_channel_no,
             up_account_id,
             up_company_id,
             down_draw_unit,
             down_draw_face,
             down_draw_amount,
             down_real_amount,
             up_draw_unit,
             up_draw_face,
             up_draw_amount,
             up_real_amount,
             change_time,
             change_type,
             bill_type,
             business_type,
             carrier_no,
             province_no,
             balance,
             profits,
             down_commission,
             up_commission,
             settle_amount,
             settle_batch_id,
             settle_status,
             settle_time,
             memo,
             order_time
        from fd_trade_up_fund_hs t
       where t.fd_order_id = l_fd_order_id;
    l_up_fund_hs_add_count := sql%rowcount;
  
    ---3.6删除历史库上游资金变动数据
    delete from fd_trade_up_fund_hs t where t.fd_order_id = l_fd_order_id;
    l_up_fund_hs_del_count := sql%rowcount;
  
    if l_up_fund_hs_del_count != l_up_fund_hs_add_count then
      return pkg_error_code.data_error;
    end if;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_BUSINESS_TYPE_GET
prompt ==============================================
prompt
create or replace function fd_account.fd_f_trade_business_type_get(v_order_source  number,
                                                        v_business_type number)
  return varchar2 is
  -----------------根据外部系统业务类型获取记账系统业务类型-----------------
  l_system_name      varchar2(32);
  l_fd_business_type number;
begin
  ---1.获取系统名称
  select t.source_system_name
    into l_system_name
    from fd_base_source_system t
   where t.source_system_id = v_order_source;

  ---2.获取外部业务类型对应的记账系统的业务类型
  ---*******************************************
  ---@当系统不为记账系统时，业务类型从配置表中获取
  ---@记账系统直接使用输入的业务类型
  ---*******************************************
  if l_system_name != 'FDS' then
    select t.local_business_type
      into l_fd_business_type
      from fd_system_business_map t
     where t.source_system_id = v_order_source
       and t.outer_business_type = v_business_type;
  else
    l_fd_business_type := v_business_type;
  end if;

  return l_fd_business_type;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_AC_ACCOUNT_T
prompt ==============================================
prompt
create or replace function fd_account.fd_f_trade_down_ac_account_t(v_down_channel_no varchar2,
                                                        v_down_account_id number)
  return varchar2 is
  ----------------手工操作获取下游支付账户-----------------
  l_company_id number;
begin
  ---1. 检查下游渠道
  select c.company_id
    into l_company_id
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
     and rownum <= 1;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_ADD_RD_CHECK
prompt ==============================================
prompt
create or replace function fd_account.fd_f_trade_down_add_rd_check(v_record_no varchar2)
  return varchar2 is
  ----------------下游重复加款检查-----------------
  l_count number;
begin
  select count(1)
    into l_count
    from fd_trade_down_manual t
   where t.ext_record_no = v_record_no;

  if l_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_AMOUNT_FEE_CK
prompt ===============================================
prompt
create or replace function fd_account.fd_f_trade_down_amount_fee_ck(v_down_channel_no varchar2,
                                                         v_order_amount    number)
  return varchar2 is

  l_account_id number;
  ----------------------------检查下游账户余额-----------------------------

begin

  ---1.粗检下游账户余额
  select t.account_id
    into l_account_id
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and (a.inner_balance + a.credit_money) > v_order_amount
     and rownum <= 1;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.balance_low;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_FEE_REFUND
prompt ============================================
prompt
create or replace function fd_account.fd_f_trade_down_fee_refund(v_order_source    in number,
                                                      v_down_channel_no in varchar2,
                                                      v_trade_order_no  in varchar2,
                                                      v_trade_refund_no varchar2,
                                                      v_refund_unit     number,
                                                      v_refund_face     number,
                                                      v_refund_amount   number,
                                                      v_real_refund     number,
                                                      v_order_date      varchar2,
                                                      v_service_fee     number,
                                                      v_memo            varchar2)
  return varchar2 is
  l_fd_order_id       number;
  l_down_account_id   number;
  l_order_source      number;
  l_trade_order_no    varchar2(32);
  l_ext_order_no      varchar2(32);
  l_down_channel_no   varchar2(32);
  l_refund_count      number;
  l_total_amount      number;
  l_total_refund      number;
  l_inner_balance     number;
  l_down_fund_id      number;
  l_down_order_face   number;
  l_down_order_amount number;
  l_result            varchar2(32);

  l_debit_count       number;
  l_total_refund_face number;
  l_business_type     number;

  ------------下游订单退款------------
begin
  --===========================检查订单重复退款、金额错误==========================
  ---1.锁下游订单
  select t.fd_order_id,
         t.order_source,
         t.down_channel_no,
         t.down_account_id,
         t.ext_order_no,
         t.trade_order_no,
         t.total_face,
         t.down_order_amount,
         t.business_type
    into l_fd_order_id,
         l_order_source,
         l_down_channel_no,
         l_down_account_id,
         l_ext_order_no,
         l_trade_order_no,
         l_down_order_face,
         l_down_order_amount,
         l_business_type
    from fd_trade_order_main t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1
     for update;

  ---2.检测订单重复退款
  select count(1)
    into l_refund_count
    from fd_trade_down_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = l_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  ---2.1检查退款时是否有扣款
  select count(1)
    into l_debit_count
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and t.order_source = l_order_source
     and rownum <= 1;

  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---3.获取订单扣款、已退款金额
  select nvl(sum(t.change_amount), 0)
    into l_total_amount
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and t.order_source = l_order_source
     and rownum <= 1;

  select nvl(sum(t.refund_amount), 0), nvl(sum(t.refund_face), 0)
    into l_total_refund, l_total_refund_face
    from fd_trade_down_refund t
   where t.fd_order_id = l_fd_order_id;

  ---4.检查退款金额是否超过订单总金额
  if (v_refund_amount > (l_total_amount - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;

  --==================================修改账户余额===============================
  ---5.获取并修改账户余额
  select t.inner_balance
    into l_inner_balance
    from fd_base_down_account t
   where t.account_id = l_down_account_id
     for update;
  ----（退款金额已扣除手续费）
  update fd_base_down_account t
     set t.inner_balance = (l_inner_balance + v_refund_amount)
   where t.account_id = l_down_account_id;

  --===================添加数据变动记录=============
  ---6.添加退款记录
  select seq_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into fd_trade_down_refund
    (record_id,
     channel_no,
     account_id,
     fd_order_id,
     trade_order_no,
     trade_refund_no,
     order_source,
     refund_time,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund, ---删掉了退款类型
     memo)
    select l_down_fund_id,
           t.down_channel_no,
           t.down_account_id,
           t.fd_order_id,
           t.trade_order_no,
           v_trade_refund_no,
           t.order_source,
           sysdate,
           t.business_type,
           t.carrier_no,
           t.province_no,
           v_refund_unit,
           v_refund_face,
           v_refund_amount,
           v_real_refund,
           v_memo
      from fd_trade_order_main t
     where t.fd_order_id = l_fd_order_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---7.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee)
  values
    (l_down_fund_id,
     l_fd_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     l_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_date, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_down_fund_change_type.refund_amount,
     v_refund_amount,
     (l_inner_balance + v_refund_amount), ---退手续费
     v_memo,
     v_service_fee); ---退手续费

  --===========================订单差异信息记录=================================

  ---10调用差异调整函数
  l_result := fd_f_trade_fund_differ_add(l_fd_order_id,
                                         pkg_trade_type.down_refund,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         pkg_bill_type.front,
                                         l_down_order_face,
                                         l_down_order_amount,
                                         v_refund_face,
                                         v_refund_amount,
                                         0);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_MANUAL_ADD
prompt ============================================
prompt
create or replace function fd_account.fd_f_trade_down_manual_add(v_down_channel_no varchar2,
                                                      v_down_account_id number,
                                                      v_bank_account_id number,
                                                      v_amount          number,
                                                      v_service_fee     number,
                                                      v_create_user     varchar2,
                                                      v_partner_account varchar2,
                                                      v_memo            varchar2)
  return varchar2 is
  l_inner_balance          number;
  l_credit_money           number;
  l_bank_balance           number;
  l_company_balance        number;
  l_fund_record_id         number;
  l_service_company_id     number;
  l_service_fund_record_id number;
  l_service_bank_fund_id   number;
  l_company_account_id     number;
  l_bank_company           number;
  l_bank_fund_id           number;
  ------------下游手工加款----------
begin

  --================1.锁账户、检查、获取数据======================
  ---1.1.锁下游支付账户、实体卡账户、公司手续费账户

  select t.balance, t.company_id
    into l_bank_balance, l_bank_company
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  select t.company_id
    into l_service_company_id
    from fd_base_down_channel t
   where t.channel_no = v_down_channel_no;

  select t.account_id, t.balance
    into l_company_account_id, l_company_balance
    from fd_base_company_account_self t
   where t.company_id = l_service_company_id
     and t.account_type = pkg_co_self_account_type.service_fee
     and rownum <= 1
     for update;

  ---1.2 检查金额是否正确
  if ((l_bank_balance + v_amount) < v_service_fee) then
    return pkg_error_code.balance_low;
  end if;

  ---1.3.获取部分添加参数
  select seq_trade_down_fund_id.nextval, seq_bank_cash_fund_id.nextval
    into l_fund_record_id, l_bank_fund_id
    from dual;

  select seq_trade_down_fund_id.nextval, seq_bank_cash_fund_id.nextval
    into l_service_fund_record_id, l_service_bank_fund_id
    from dual;

  --==================2.添加手续费相关操作=======================
  if (v_service_fee > 0) then
    ---2.1.添加手续费账户资金变动
    insert into fd_trade_co_self_fund
      (change_id,
       account_id,
       change_amount,
       change_type,
       balance,
       change_time)
    values
      (l_service_bank_fund_id,
       l_company_account_id,
       v_service_fee,
       pkg_co_self_fund_type.add_amount,
       (l_company_balance + v_service_fee),
       sysdate);
  
    ---2.2.添加手续费实体卡资金变动
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark)
    values
      (l_service_bank_fund_id,
       v_bank_account_id,
       l_bank_company,
       v_service_fee,
       (l_bank_balance + v_amount - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       v_down_channel_no,
       v_down_account_id,
       v_memo);
  
    ---2.3修改手续费账户余额
    update fd_base_company_account_self t
       set t.balance        = (l_company_balance + v_service_fee),
           t.last_edit_user = v_create_user,
           t.last_edit_time = sysdate
     where t.account_id = l_company_account_id;
  end if;

  --=================3.下游加款相关操作=================

  ---3.1.添加下游加款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo)
  values
    (l_fund_record_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_create_user,
     l_bank_fund_id,
     v_partner_account,
     v_memo);
  ---3.2.添加实体卡资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (l_bank_fund_id,
     v_bank_account_id,
     l_bank_company,
     v_amount,
     (l_bank_balance + v_amount),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.add_amount,
     pkg_bank_use_type.down_add,
     v_down_channel_no,
     v_down_account_id,
     v_memo,
     l_service_bank_fund_id);

  ---3.3.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     sysdate,
     '',
     pkg_down_fund_change_type.add_amount,
     v_amount,
     (l_inner_balance + v_amount),
     v_memo);

  ---3.4.修改资金账户、实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + v_amount - v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  update fd_base_down_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_MANUAL_ADD_T
prompt ==============================================
prompt
create or replace function fd_account.fd_f_trade_down_manual_add_t(v_down_channel_no varchar2,
                                                        v_down_account_id number,
                                                        v_record_no       varchar2,
                                                        v_amount          number,
                                                        v_service_fee     number,
                                                        v_create_user     varchar2,
                                                        v_pay_time        varchar2,
                                                        v_partner_account varchar2,
                                                        v_memo            varchar2)
  return varchar2 is
  l_inner_balance          number;
  l_credit_money           number;
  l_fund_record_id         number;
  l_pay_time               date;
  l_service_fund_record_id number;
  l_bank_fund_id           number;
  l_count                  number;
  ------------下游手工加款----------
begin
  ---1.锁下游支付账户、实体卡账户、公司手续费账户

  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---1.1检查并发同步
  select count(1)
    into l_count
    from fd_trade_down_manual t
   where t.ext_record_no = v_record_no;

  if l_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  ---2.获取部分添加参数
  select seq_trade_down_fund_id.nextval into l_fund_record_id from dual;

  select seq_trade_down_fund_id.nextval,
         seq_bank_cash_fund_id.nextval,
         to_date(nvl(v_pay_time, to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss')),
                 'yyyy-mm-dd hh24:mi:ss')
    into l_service_fund_record_id, l_bank_fund_id, l_pay_time
    from dual;

  ---3.修改资金账户、实体卡账户余额

  update fd_base_down_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = l_pay_time
   where t.account_id = v_down_account_id;

  ---4.添加下游加款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo,
     service_id,
     ext_record_no)
  values
    (l_fund_record_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.add_amount,
     v_amount,
     l_pay_time,
     (l_inner_balance + v_amount),
     v_create_user,
     l_bank_fund_id,
     v_partner_account,
     v_memo,
     l_service_fund_record_id,
     v_record_no);

  ---6.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     l_pay_time,
     '',
     pkg_down_fund_change_type.add_amount,
     v_amount,
     (l_inner_balance + v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_MANUAL_ADD_TX
prompt ===============================================
prompt
create or replace function fd_account.fd_f_trade_down_manual_add_tx(v_down_channel_no varchar2,
                                                        v_down_account_id number,
                                                        v_record_no       varchar2,
                                                        v_amount          number,
                                                        v_service_fee     number,
                                                        v_create_user     varchar2,
                                                        v_pay_time        varchar2,
                                                        v_partner_account varchar2,
                                                        v_memo            varchar2)
  return varchar2 is
  l_inner_balance          number;
  l_credit_money           number;
  l_company_balance        number;
  l_fund_record_id         number;
  l_pay_time               date;
  l_service_company_id     number;
  l_service_fund_record_id number;
  l_bank_fund_id           number;
  l_company_account_id     number;
  ------------下游手工加款----------
begin
  ---1.锁下游支付账户、实体卡账户、公司手续费账户

  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.获取部分添加参数
  select seq_trade_down_fund_id.nextval into l_fund_record_id from dual;

  select seq_trade_down_fund_id.nextval,
         seq_bank_cash_fund_id.nextval,
         to_date(nvl(v_pay_time, to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss')),
                 'yyyy-mm-dd hh24:mi:ss')
    into l_service_fund_record_id, l_bank_fund_id, l_pay_time
    from dual;

  ---3.修改资金账户、实体卡账户余额

  update fd_base_down_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = l_pay_time
   where t.account_id = v_down_account_id;

  ---4.添加下游加款记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     bank_fund_id,
     partner_account,
     memo,
     service_id,
     ext_record_no)
  values
    (l_fund_record_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     pkg_down_manual_change_type.add_amount,
     v_amount,
     l_pay_time,
     (l_inner_balance + v_amount),
     v_create_user,
     l_bank_fund_id,
     v_partner_account,
     v_memo,
     l_service_fund_record_id,
     v_record_no);

  ---6.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     '-',
     '-',
     0,
     l_pay_time,
     '',
     pkg_down_fund_change_type.add_amount,
     v_amount,
     (l_inner_balance + v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_MA_ACCOUNT_T
prompt ==============================================
prompt
create or replace function fd_account.fd_f_trade_down_ma_account_t(v_down_channel_no varchar2,
                                                        v_change_type     varchar2,
                                                        v_service_fee     number,
                                                        v_down_account_id out number)
  return varchar2 is
  ----------------手工操作获取下游支付账户-----------------
  l_company_id       number;
begin
  ---1. 检查下游渠道
  select t.account_id, c.company_id
    into v_down_account_id, l_company_id
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
/*     and a.status = 0
     and c.status = 0*/
     and rownum <= 1;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_TRADE_FUND_MS_DIFFER_ADD
prompt ===============================================
prompt
create or replace function fd_account.fd_f_trade_fund_ms_differ_add(v_fd_order_id   number, --订单编号
                                                         v_trade_type    number, --交易类型（1.下游扣款2.上游扣款3.上游退款4.下游退款5.转账退款）
                                                         v_channel_no    varchar2, --渠道编号
                                                         v_account_id    number, --账户编号
                                                         v_business_type number, --业务类型
                                                         v_bill_type     number, --利润类型
                                                         v_order_face    number, --订单面值
                                                         v_order_amount  number, --订单扣款金额
                                                         v_down_face     number, --下游扣款或上游中的下游扣款面值
                                                         v_down_amount   number, --下游扣款或上游中的下游扣款金额
                                                         v_up_face       number --上游扣款面值
                                                         ) return varchar2 is
  ---------------------------------------------
  --功能：短信平台记录资金变动相关统计差异数据专用
  --创建人：周荣省
  --创建时间：2019-05-20
  ---------------------------------------------
  l_today_date         date := trunc(sysdate);
  l_differ_count       number;
  l_down_adjust_face   number := 0; ---资金变动差异表中，下游退款造成多冲时，需要用来抵消上游资金变动中的下游扣款面值
  l_down_adjust_unit   number := 0; ---同上的规格
  l_down_adjust_amount number := 0; ---同上的金额
  l_down_adjust_real   number := 0; ---同上的真实金额
  l_up_many_face       number := 0; ---资金变动差异表中记录的上游多冲的面值
  l_up_many_amount     number := 0; ---同上的金额
  l_to_front_face      number := 0; ---资金变动差异表中记录的需要由前向转为后向的面值
  l_to_front_unit      number := 0; ---同上的规格
  l_to_front_amount    number := 0; ---同上的金额
  l_to_front_real      number := 0; ---同上的真实金额
  l_down_first_face    number := 0; ---订单差异表中下有扣款比上游资金变动中下游扣款多的面值
  l_down_first_amount  number := 0; ---同上金额
  l_use_bill_type      number := v_bill_type;

  --l_total_many_face   number; ---当天单笔订单总多冲面值
  l_total_many_amount number; ---同上金额
  --l_bill_many_face    number; ---当天单笔订单退款bill_type的多冲面值
  l_bill_many_amount  number; ---同上金额
  l_refund_many_face  number;
  l_down_draw_unit    number;
  l_down_draw_face    number;
  l_down_draw_amount  number;
  l_down_real_amount  number;
  l_down_refund_face  number;
  l_real_order_face   number;
  l_all_up_face       number;
  l_down_up_differ    number;
  l_main_differ_count number;
  l_many_face_now     number; ---退款红冲后多冲值
  l_many_face_red     number; ---退款红冲前多冲值
  l_all_down_amount   number;
  l_all_up_amount     number;

begin
  --=======================数据计算========================
  ---1.计算差异报表需要的数据
  if v_trade_type = pkg_trade_type.down_debit then
  
    --1.1下游扣款
    l_down_first_face   := v_down_face;
    l_down_first_amount := v_down_amount;
  elsif v_trade_type = pkg_trade_type.up_debit then
  
    --1.2上游扣款
    l_down_first_face   := -1 * v_down_face;
    l_down_first_amount := -1 * v_down_amount;
    --1.2.1不存在下游扣款，则是多充
    select nvl(sum(decode(t.change_type,
                          pkg_up_fund_change_type.debit_amount,
                          1,
                          -1) * t.change_amount),
               0)
      into l_all_down_amount
      from fd_trade_down_fund t
     where t.fd_order_id = v_fd_order_id
       and t.change_type in (pkg_up_fund_change_type.debit_amount,
            pkg_up_fund_change_type.refund_amount);
    if l_all_down_amount = 0 then
      l_up_many_face   := 0;
      l_up_many_amount := v_order_amount;
    end if;
  
  elsif v_trade_type = pkg_trade_type.up_refund then
  
    --1.3上游退款
    l_down_first_face   := v_down_face;
    l_down_first_amount := v_down_amount;
  
    ---1.3.1计算当前多冲的总金额
    select nvl(sum(t.up_many_amount), 0)
      into l_total_many_amount
      from fd_trade_up_fund_differ t
     where t.fd_order_id = v_fd_order_id;
    ---1.3.5判断是否存在多充
    if l_total_many_amount > 0 then
      l_up_many_face   := 0;
      l_up_many_amount := -1 * v_order_amount;
    end if;
  
  elsif v_trade_type = pkg_trade_type.down_refund or
        v_trade_type = pkg_trade_type.transfer_refund then
    --1.4下游退款、转账退款
    ---1.4.1计算当前总上游扣款
    select nvl(sum(decode(t.change_type,
                          pkg_up_fund_change_type.debit_amount,
                          1,
                          -1) * t.up_draw_amount),
               0)
      into l_all_up_amount
      from fd_trade_up_fund t
     where t.fd_order_id = v_fd_order_id
       and t.change_type in (pkg_up_fund_change_type.debit_amount,
            pkg_up_fund_change_type.refund_amount);
    if l_all_up_amount != 0 then
      --上游扣款总金额不为0，下游退款造成多充
      l_up_many_face   := 0;
      l_up_many_amount := v_order_amount;
    end if;
  
    ---1.4.2有多冲需要计算多冲造成的差异
    if l_up_many_amount > 0 then
      select t.down_draw_unit,
             t.down_draw_face,
             t.down_draw_amount,
             t.down_real_amount,
             t.bill_type
        into l_down_draw_unit,
             l_down_draw_face,
             l_down_draw_amount,
             l_down_real_amount,
             l_use_bill_type
        from fd_trade_up_fund t
       where t.fd_order_id = v_fd_order_id
         and t.change_type = pkg_up_fund_change_type.debit_amount
         and t.down_draw_amount > 0
         and rownum <= 1;
    
      l_down_adjust_face   := -1 * l_up_many_face;
      l_down_adjust_unit   := -1 * l_down_draw_unit;
      l_down_adjust_amount := -1 * l_down_draw_amount;
      l_down_adjust_real   := -1 * l_down_real_amount;
    
    end if;
  
    ---1.4.3上下游扣款时间差异
    l_down_first_face   := 0;
    l_down_first_amount := -1 * v_order_amount;
  elsif v_trade_type = pkg_trade_type.refund_red then
    ---1.5下游退款红冲
    l_down_first_face   := 0;
    l_down_first_amount := v_order_amount;
    ---1.5.1计算当前总上游扣款
    select nvl(sum(decode(t.change_type,
                          pkg_up_fund_change_type.debit_amount,
                          1,
                          -1) * t.up_draw_amount),
               0)
      into l_all_up_amount
      from fd_trade_up_fund t
     where t.fd_order_id = v_fd_order_id
       and t.change_type in (pkg_up_fund_change_type.debit_amount,
            pkg_up_fund_change_type.refund_amount);
  
    if l_all_up_amount != 0 then
      --上游扣款总金额不为0，下游退款造成多充
      l_up_many_face   := 0;
      l_up_many_amount := -1 * v_order_amount;
    end if;
  
    if l_up_many_amount != 0 then
      select t.down_draw_unit,
             t.down_draw_face,
             t.down_draw_amount,
             t.down_real_amount,
             t.bill_type
        into l_down_draw_unit,
             l_down_draw_face,
             l_down_draw_amount,
             l_down_real_amount,
             l_use_bill_type
        from fd_trade_up_fund t
       where t.fd_order_id = v_fd_order_id
         and t.change_type = pkg_up_fund_change_type.debit_amount
         and t.down_draw_face > 0
         and rownum <= 1;
    
      l_down_adjust_face   := -1 * l_up_many_face;
      l_down_adjust_unit   := l_down_draw_unit;
      l_down_adjust_amount := l_down_draw_amount;
      l_down_adjust_real   := l_down_real_amount;
    
    end if;
  else
    --1.6错误数据
    return pkg_error_code.success;
  end if;

  --=======================数据收集=======================

  if l_up_many_amount != 0 then
    ---2.检查差异表订单数据是否存在
    select count(1)
      into l_differ_count
      from fd_trade_up_fund_differ t
     where t.record_date = l_today_date
       and t.fd_order_id = v_fd_order_id
       and t.channel_no = v_channel_no
       and t.account_id = v_account_id
       and t.business_type = v_business_type
       and t.bill_type = l_use_bill_type;
  
    ---3.添加差异数据
    if l_differ_count = 0 then
      insert into fd_trade_up_fund_differ
        (differ_id,
         record_date,
         fd_order_id,
         channel_no,
         account_id,
         business_type,
         bill_type,
         down_adjust_face,
         down_adjust_unit,
         down_adjust_amount,
         down_adjust_real,
         up_many_face,
         up_many_amount,
         to_front_face,
         to_front_unit,
         to_front_amount,
         to_front_real)
      values
        (seq_trade_up_fund_differ_id.nextval,
         l_today_date,
         v_fd_order_id,
         v_channel_no,
         v_account_id,
         v_business_type,
         l_use_bill_type,
         l_down_adjust_face,
         l_down_adjust_unit,
         l_down_adjust_amount,
         l_down_adjust_real,
         l_up_many_face,
         l_up_many_amount,
         l_to_front_face,
         l_to_front_unit,
         l_to_front_amount,
         l_to_front_real);
    
    else
      update fd_trade_up_fund_differ t
         set t.down_adjust_face   = t.down_adjust_face + l_down_adjust_face,
             t.down_adjust_unit   = t.down_adjust_unit + l_down_adjust_unit,
             t.down_adjust_amount = t.down_adjust_amount +
                                    l_down_adjust_amount,
             t.down_adjust_real   = t.down_adjust_real + l_down_adjust_real,
             t.up_many_face       = t.up_many_face + l_up_many_face,
             t.up_many_amount     = t.up_many_amount + l_up_many_amount,
             t.to_front_face      = t.to_front_face + l_to_front_face,
             t.to_front_unit      = t.to_front_unit + l_to_front_unit,
             t.to_front_amount    = t.to_front_amount + l_to_front_amount,
             t.to_front_real      = t.to_front_real + l_to_front_real
       where t.record_date = l_today_date
         and t.fd_order_id = v_fd_order_id
         and t.channel_no = v_channel_no
         and t.account_id = v_account_id
         and t.business_type = v_business_type
         and t.bill_type = l_use_bill_type;
    
    end if;
    if sql%rowcount = 0 then
      return pkg_error_code.data_error;
    end if;
  end if;

  ---4.记录上下游扣款时间产生的差异
  select count(1)
    into l_main_differ_count
    from fd_trade_order_main_differ t
   where t.record_date = l_today_date
     and t.fd_order_id = v_fd_order_id
     and t.channel_no = v_channel_no
     and t.account_id = v_account_id
     and t.business_type = v_business_type;

  if l_main_differ_count = 0 then
    insert into fd_trade_order_main_differ
      (differ_id,
       record_date,
       fd_order_id,
       channel_no,
       account_id,
       business_type,
       down_first_face,
       down_first_amount)
    values
      (seq_trade_order_main_differ_id.nextval,
       l_today_date,
       v_fd_order_id,
       v_channel_no,
       v_account_id,
       v_business_type,
       l_down_first_face,
       l_down_first_amount);
  
  else
    update fd_trade_order_main_differ t
       set t.down_first_face   = (t.down_first_face + l_down_first_face),
           t.down_first_amount = (t.down_first_amount + l_down_first_amount)
     where t.record_date = l_today_date
       and fd_order_id = v_fd_order_id
       and t.channel_no = v_channel_no
       and t.account_id = v_account_id
       and t.business_type = business_type;
  
  end if;
  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_MS_REFUND
prompt ===========================================
prompt
create or replace function fd_account.fd_f_trade_down_ms_refund(v_order_source    in number,
                                                     v_down_channel_no in varchar2,
                                                     v_trade_order_no  in varchar2,
                                                     v_trade_refund_no varchar2,
                                                     v_refund_unit     number,
                                                     v_refund_face     number,
                                                     v_refund_amount   number,
                                                     v_real_refund     number,
                                                     v_order_date      varchar2,
                                                     v_service_fee     number,
                                                     v_memo            varchar2)
  return varchar2 is
  l_fd_order_id       number;
  l_down_account_id   number;
  l_order_source      number;
  l_trade_order_no    varchar2(32);
  l_ext_order_no      varchar2(32);
  l_down_channel_no   varchar2(32);
  l_refund_count      number;
  l_total_amount      number;
  l_total_refund      number;
  l_inner_balance     number;
  l_down_fund_id      number;
  l_down_order_face   number;
  l_down_order_amount number;
  l_result            varchar2(32);

  l_debit_count       number;
  l_total_refund_face number;
  l_business_type     number;

  -----------------------------
  --功能：短信平台下游订单退款专用
  --创建人：周荣省
  --创建时间：2019-05-20
  -----------------------------
begin
  --===========================检查订单重复退款、金额错误==========================
  ---1.锁下游订单
  select t.fd_order_id,
         t.order_source,
         t.down_channel_no,
         t.down_account_id,
         t.ext_order_no,
         t.trade_order_no,
         t.total_face,
         t.down_order_amount,
         t.business_type
    into l_fd_order_id,
         l_order_source,
         l_down_channel_no,
         l_down_account_id,
         l_ext_order_no,
         l_trade_order_no,
         l_down_order_face,
         l_down_order_amount,
         l_business_type
    from fd_trade_order_main t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1
     for update;

  ---2.检测订单重复退款
  select count(1)
    into l_refund_count
    from fd_trade_down_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = l_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  ---2.1检查退款时是否有扣款
  select count(1)
    into l_debit_count
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and t.order_source = l_order_source
     and rownum <= 1;

  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---3.获取订单扣款、已退款金额
  select nvl(sum(t.change_amount), 0)
    into l_total_amount
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and t.order_source = l_order_source
     and rownum <= 1;

  select nvl(sum(t.refund_amount), 0), nvl(sum(t.refund_face), 0)
    into l_total_refund, l_total_refund_face
    from fd_trade_down_refund t
   where t.fd_order_id = l_fd_order_id;

  ---4.检查退款金额是否超过订单总金额
  if (v_refund_amount > (l_total_amount - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;

  --==================================修改账户余额===============================
  ---5.获取并修改账户余额
  select t.inner_balance
    into l_inner_balance
    from fd_base_down_account t
   where t.account_id = l_down_account_id
     for update;
  ----（退款金额已扣除手续费）
  update fd_base_down_account t
     set t.inner_balance = (l_inner_balance + v_refund_amount)
   where t.account_id = l_down_account_id;

  --===================添加数据变动记录=============
  ---6.添加退款记录
  select seq_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into fd_trade_down_refund
    (record_id,
     channel_no,
     account_id,
     fd_order_id,
     trade_order_no,
     trade_refund_no,
     order_source,
     refund_time,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund, ---删掉了退款类型
     memo)
    select l_down_fund_id,
           t.down_channel_no,
           t.down_account_id,
           t.fd_order_id,
           t.trade_order_no,
           v_trade_refund_no,
           t.order_source,
           sysdate,
           t.business_type,
           t.carrier_no,
           t.province_no,
           v_refund_unit,
           v_refund_face,
           v_refund_amount,
           v_real_refund,
           v_memo
      from fd_trade_order_main t
     where t.fd_order_id = l_fd_order_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---7.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee)
  values
    (l_down_fund_id,
     l_fd_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     l_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_date, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_down_fund_change_type.refund_amount,
     v_refund_amount,
     (l_inner_balance + v_refund_amount), ---退手续费
     v_memo,
     v_service_fee); ---退手续费

  --===========================订单差异信息记录=================================

  ---10调用差异调整函数
  l_result := fd_f_trade_fund_ms_differ_add(l_fd_order_id,
                                            pkg_trade_type.down_refund,
                                            v_down_channel_no,
                                            l_down_account_id,
                                            l_business_type,
                                            pkg_bill_type.front,
                                            l_down_order_face,
                                            l_down_order_amount,
                                            v_refund_face,
                                            v_refund_amount,
                                            0);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_ORDER_FEE_MUS
prompt ===============================================
prompt
create or replace function fd_account.fd_f_trade_down_order_fee_mus(v_order_source    number,
                                                         v_down_channel_no varchar2,
                                                         v_trade_order_no  varchar2,
                                                         v_ext_order_no    varchar2,
                                                         v_order_time      varchar2,
                                                         v_order_amount    number,
                                                         v_service_fee     number,
                                                         v_memo            varchar2)
  return varchar2 is
  -------------------下游扣款----------------------
  l_credit_money      number;
  l_fd_order_id       number;
  l_pay_count         number;
  l_inner_balance     number;
  l_down_account_id   number;
  l_order_main_amount number;
  l_total_face        number;
  l_business_type     number;
  l_result            varchar2(32);
begin

  ----===============================锁订单，检查是否重复扣款================================
  ---1.锁订单，检查扣款是否存在
  select t.fd_order_id,
         t.down_account_id,
         t.down_order_amount,
         t.total_face,
         t.business_type
    into l_fd_order_id,
         l_down_account_id,
         l_order_main_amount,
         l_total_face,
         l_business_type
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查是否存在扣款记录
  select count(1)
    into l_pay_count
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and rownum <= 1;

  if (l_pay_count > 0) then
    return pkg_error_code.success;
  end if;

  ---3.检查从订单查询的扣款与本次扣款是否一致
  if l_order_main_amount != v_order_amount then
    return pkg_error_code.amount_error;
  end if;

  --=========================锁账户，检查余额并扣款=====================================
  ---3.获取下游账户信息
  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  ---4.下游扣款检查账户余额
  if (v_order_amount > (l_inner_balance + l_credit_money)) then
    return pkg_error_code.balance_low;
  end if;

  ---5.下游扣款（扣款金额已除去手续费）
  update fd_base_down_account t
     set t.inner_balance = (l_inner_balance - v_order_amount)
   where t.account_id = l_down_account_id;

  ---6.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee)
  values
    (seq_trade_down_fund_id.nextval,
     l_fd_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     v_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_down_fund_change_type.debit_amount,
     v_order_amount,
     (l_inner_balance - v_order_amount), 
     v_memo,
     v_service_fee); ---加上手续费

  ---7.扣款成功记录订单差异表
  l_result := fd_f_trade_fund_differ_add(l_fd_order_id,
                                         pkg_trade_type.down_debit,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         pkg_bill_type.front,
                                         l_total_face,
                                         l_order_main_amount,
                                         l_total_face,
                                         v_order_amount,
                                         0);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_ORDER_MINUS
prompt =============================================
prompt
create or replace function fd_account.fd_f_trade_down_order_minus(v_order_source    number,
                                                       v_down_channel_no varchar2,
                                                       v_trade_order_no  varchar2,
                                                       v_ext_order_no    varchar2,
                                                       v_order_time      varchar2,
                                                       v_order_amount    number,
                                                       v_memo            varchar2)
  return varchar2 is
  -------------------下游扣款----------------------
  l_credit_money    number;
  l_fd_order_id     number;
  l_pay_count       number;
  l_inner_balance   number;
  l_down_account_id number;
  l_result          varchar2(32);
begin

  ----===============================锁订单，检查是否重复扣款================================
  ---1.锁订单，检查扣款是否存在
  select t.fd_order_id, t.down_account_id
    into l_fd_order_id, l_down_account_id
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查是否存在扣款记录
  select count(1)
    into l_pay_count
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and rownum <= 1;

  if (l_pay_count > 0) then
    return pkg_error_code.success;
  end if;

  --=========================锁账户，检查余额并扣款=====================================
  ---3.获取下游账户信息
  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  ---4.下游扣款检查账户余额
  if (v_order_amount >= (l_inner_balance + l_credit_money)) then
    return pkg_error_code.balance_low;
  end if;

  ---5.下游扣款
  update fd_base_down_account t
     set t.inner_balance = (l_inner_balance - v_order_amount)
   where t.account_id = l_down_account_id;

  ---6.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (seq_trade_down_fund_id.nextval,
     l_fd_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     v_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_down_fund_change_type.debit_amount,
     v_order_amount,
     (l_inner_balance - v_order_amount),
     v_memo);

  ---7.扣款成功记录订单差异表
  /*  l_result := fd_f_trade_fund_differ_add(l_fd_order_id,
  v_order_face,
  v_order_amount,
  0,
  0,
  0,
  0,
  v_down_face,
  v_down_amount);*/

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_ORDER_MINUS_T
prompt ===============================================
prompt
create or replace function fd_account.fd_f_trade_down_order_minus_t(v_order_source    number,
                                                         v_down_channel_no varchar2,
                                                         v_trade_order_no  varchar2,
                                                         v_ext_order_no    varchar2,
                                                         v_order_time      varchar2,
                                                         v_order_amount    number,
                                                         v_pay_time        varchar2,
                                                         v_memo            varchar2)
  return varchar2 is
  -------------------下游扣款----------------------
  l_credit_money    number;
  l_fd_order_id     number;
  l_pay_count       number;
  l_inner_balance   number;
  l_down_account_id number;
  l_result          varchar2(32);
begin

  ----===============================锁订单，检查是否重复扣款================================
  ---1.锁订单，检查扣款是否存在
  select t.fd_order_id, t.down_account_id
    into l_fd_order_id, l_down_account_id
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查是否存在扣款记录
  select count(1)
    into l_pay_count
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and rownum <= 1;

  if (l_pay_count > 0) then
    return pkg_error_code.success;
  end if;

  --=========================锁账户，检查余额并扣款=====================================
  ---3.获取下游账户信息
  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  ---4.下游扣款检查账户余额
  if (v_order_amount > (l_inner_balance + l_credit_money)) then
    return pkg_error_code.balance_low;
  end if;

  ---5.下游扣款
  update fd_base_down_account t
     set t.inner_balance  = (l_inner_balance - v_order_amount),
         t.last_edit_time = sysdate
   where t.account_id = l_down_account_id;

  ---6.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (seq_trade_down_fund_id.nextval,
     l_fd_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     v_ext_order_no,
     v_order_source,
     to_date(v_pay_time, 'yyyy-mm-dd hh24:mi:ss'),
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_down_fund_change_type.debit_amount,
     v_order_amount,
     (l_inner_balance - v_order_amount),
     v_memo);

  ---7.扣款成功记录订单差异表
  /*  l_result := fd_f_trade_fund_differ_add(l_fd_order_id,
  v_order_face,
  v_order_amount,
  0,
  0,
  0,
  0,
  v_down_face,
  v_down_amount);*/

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_ORDER_MS_MUS
prompt ==============================================
prompt
create or replace function fd_account.fd_f_trade_down_order_ms_mus(v_order_source    number,
                                                        v_down_channel_no varchar2,
                                                        v_trade_order_no  varchar2,
                                                        v_ext_order_no    varchar2,
                                                        v_order_time      varchar2,
                                                        v_order_amount    number,
                                                        v_service_fee     number,
                                                        v_memo            varchar2)
  return varchar2 is
  -------------------------------------------
  --功能：短信平台下游扣款专用
  --创建人：周荣省
  --创建时间：2019-05-20
  -------------------------------------------
  l_credit_money      number;
  l_fd_order_id       number;
  l_pay_count         number;
  l_inner_balance     number;
  l_down_account_id   number;
  l_order_main_amount number;
  l_total_face        number;
  l_business_type     number;
  l_result            varchar2(32);
begin

  ----===============================锁订单，检查是否重复扣款================================
  ---1.锁订单，检查扣款是否存在
  select t.fd_order_id,
         t.down_account_id,
         t.down_order_amount,
         t.total_face,
         t.business_type
    into l_fd_order_id,
         l_down_account_id,
         l_order_main_amount,
         l_total_face,
         l_business_type
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查是否存在扣款记录
  select count(1)
    into l_pay_count
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and rownum <= 1;

  if (l_pay_count > 0) then
    return pkg_error_code.success;
  end if;

  ---3.检查从订单查询的扣款与本次扣款是否一致
  if l_order_main_amount != v_order_amount then
    return pkg_error_code.amount_error;
  end if;

  --=========================锁账户，检查余额并扣款=====================================
  ---3.获取下游账户信息
  select t.inner_balance, t.credit_money
    into l_inner_balance, l_credit_money
    from fd_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  ---4.下游扣款检查账户余额
  if (v_order_amount > (l_inner_balance + l_credit_money)) then
    return pkg_error_code.balance_low;
  end if;

  ---5.下游扣款（扣款金额已除去手续费）
  update fd_base_down_account t
     set t.inner_balance = (l_inner_balance - v_order_amount)
   where t.account_id = l_down_account_id;

  ---6.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee)
  values
    (seq_trade_down_fund_id.nextval,
     l_fd_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     v_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_down_fund_change_type.debit_amount,
     v_order_amount,
     (l_inner_balance - v_order_amount),
     v_memo,
     v_service_fee); ---加上手续费

  ---7.扣款成功记录订单差异表
  l_result := fd_f_trade_fund_ms_differ_add(l_fd_order_id,
                                            pkg_trade_type.down_debit,
                                            v_down_channel_no,
                                            l_down_account_id,
                                            l_business_type,
                                            pkg_bill_type.front,
                                            l_total_face,
                                            l_order_main_amount,
                                            l_total_face,
                                            v_order_amount,
                                            0);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_REFUND
prompt ========================================
prompt
create or replace function fd_account.fd_f_trade_down_refund(v_order_source    in number,
                                                  v_down_channel_no in varchar2,
                                                  v_trade_order_no  in varchar2,
                                                  v_trade_refund_no varchar2,
                                                  v_refund_unit     number,
                                                  v_refund_face     number,
                                                  v_refund_amount   number,
                                                  v_real_refund     number,
                                                  v_memo            varchar2)
  return varchar2 is
  l_fd_order_id     number;
  l_down_account_id number;
  l_order_source    number;
  l_trade_order_no  varchar2(32);
  l_ext_order_no    varchar2(32);
  l_down_channel_no varchar2(32);
  l_order_time      date;
  l_refund_count    number;
  l_total_amount    number;
  l_total_refund    number;
  l_inner_balance   number;
  l_down_fund_id    number;

  ------------下游订单退款------------
begin
  --===========================检查订单重复退款、金额错误==========================
  ---1.锁下游订单
  select t.fd_order_id,
         t.order_source,
         t.down_channel_no,
         t.down_account_id,
         t.ext_order_no,
         t.trade_order_no,
         t.order_time
    into l_fd_order_id,
         l_order_source,
         l_down_channel_no,
         l_down_account_id,
         l_ext_order_no,
         l_trade_order_no,
         l_order_time
    from fd_trade_order_main t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1
     for update;

  ---2.检测订单重复退款
  select count(1)
    into l_refund_count
    from fd_trade_down_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = l_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  ---3.获取订单扣款、已退款金额
  select t.change_amount
    into l_total_amount
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and t.order_source = l_order_source
     and rownum <= 1;

  select sum(t.change_amount)
    into l_total_refund
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.refund_amount
     and t.order_source = l_order_source;

  ---4.检查退款金额是否超过订单总金额
  if (v_refund_amount > (l_total_amount - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;

  --==================================修改账户余额===============================
  ---5.获取并修改账户余额
  select t.inner_balance
    into l_inner_balance
    from fd_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  update fd_base_down_account t
     set t.inner_balance = (l_inner_balance + v_refund_amount)
   where t.account_id = l_down_account_id;

  --===================添加数据变动记录=============
  ---6.添加退款记录
  select seq_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into fd_trade_down_refund
    (record_id,
     channel_no,
     account_id,
     fd_order_id,
     trade_order_no,
     trade_refund_no,
     order_source,
     refund_time,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund,
     memo)
    select l_down_fund_id,
           t.down_channel_no,
           t.down_account_id,
           t.fd_order_id,
           t.trade_order_no,
           v_trade_refund_no,
           t.order_source,
           sysdate,
           t.business_type,
           t.carrier_no,
           t.province_no,
           v_refund_unit,
           v_refund_face,
           v_refund_amount,
           v_real_refund,
           v_memo
      from fd_trade_order_main t
     where t.fd_order_id = l_fd_order_id;

  ---7.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_down_fund_id,
     l_fd_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     l_ext_order_no,
     v_order_source,
     sysdate,
     l_order_time,
     pkg_down_fund_change_type.refund_amount,
     v_refund_amount,
     (l_inner_balance + v_refund_amount),
     v_memo);

  ---8.检查上游中的下游扣款与订单的下游扣款是否一致
  ---9.上游中的下游扣款大于订单的下游扣款计算差异调整金额
  ---10调用差异调整函数

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_REFUND_T
prompt ==========================================
prompt
create or replace function fd_account.fd_f_trade_down_refund_t(v_order_source    in number,
                                                    v_down_channel_no in varchar2,
                                                    v_trade_order_no  in varchar2,
                                                    v_trade_refund_no varchar2,
                                                    v_business_type   number,
                                                    v_carrier_no      varchar2,
                                                    v_province_no     varchar2,
                                                    v_refund_unit     number,
                                                    v_refund_face     number,
                                                    v_refund_amount   number,
                                                    v_real_refund     number,
                                                    v_ext_order_no    varchar2,
                                                    v_refund_time     varchar2,
                                                    v_order_time      varchar2,
                                                    v_memo            varchar2)
  return varchar2 is
  l_fd_order_id     number;
  l_down_account_id number;
  l_order_source    number;
  l_trade_order_no  varchar2(32);
  l_ext_order_no    varchar2(32);
  l_down_channel_no varchar2(32);
  l_refund_time     date;
  l_order_time      date;
  l_refund_count    number;
  l_inner_balance   number;
  l_down_fund_id    number;
  l_business_type   number;
  l_carrier_no      varchar2(32);
  l_province_no     varchar2(32);

  l_cn_refund_count number;
  l_cn_fd_order_id  number;
  ------------下游订单退款------------
begin
  --===========================检查订单重复退款、金额错误==========================
  ---1.锁下游订单
  select to_date(v_refund_time, 'yyyy-mm-dd hh24:mi:ss'),
         to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss')
    into l_refund_time, l_order_time
    from dual;

  begin
    select t.fd_order_id,
           t.order_source,
           t.down_channel_no,
           t.down_account_id,
           t.ext_order_no,
           t.trade_order_no,
           t.order_time
      into l_fd_order_id,
           l_order_source,
           l_down_channel_no,
           l_down_account_id,
           l_ext_order_no,
           l_trade_order_no,
           l_order_time
      from fd_trade_order_main t
     where t.order_source = v_order_source
       and t.down_channel_no = v_down_channel_no
       and t.trade_order_no = v_trade_order_no
       and rownum <= 1
       for update;
    --===============================---
    select t.business_type, t.carrier_no, t.province_no
      into l_business_type, l_carrier_no, l_province_no
      from fd_trade_order_main t
     where t.fd_order_id = l_fd_order_id;
  exception
    when no_data_found then
      --===============================---
      select seq_trade_order_main_id.nextval into l_fd_order_id from dual;
    
      select count(1), max(t.fd_order_id)
        into l_cn_refund_count, l_cn_fd_order_id
        from fd_trade_up_fund t
       where t.trade_order_no = v_trade_order_no
         and t.order_source = v_order_source
         and rownum <= 1;
    
      if (l_cn_refund_count > 0) then
        l_fd_order_id := l_cn_fd_order_id;
      end if;
    
      select t.account_id, a.inner_balance
        into l_down_account_id, l_inner_balance
        from fd_base_down_account_map t
       inner join fd_base_down_account a on t.account_id = a.account_id
       where t.channel_no = v_down_channel_no
         and t.is_main_channel = 0;
  end;
  ---2.检测订单重复退款
  select count(1)
    into l_refund_count
    from fd_trade_down_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = l_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  /*  ---3.获取订单扣款、已退款金额
  select t.change_amount
    into l_total_amount
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and t.order_source = l_order_source
     and rownum <= 1;
  
  select sum(t.change_amount)
    into l_total_refund
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.refund_amount
     and t.order_source = l_order_source;
  
  ---4.检查退款金额是否超过订单总金额
  if (v_refund_amount > (l_total_amount - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;*/

  --==================================修改账户余额===============================
  ---5.获取并修改账户余额
  select t.inner_balance
    into l_inner_balance
    from fd_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  update fd_base_down_account t
     set t.inner_balance = (l_inner_balance + v_refund_amount)
   where t.account_id = l_down_account_id;

  --===================添加数据变动记录=============
  ---6.添加退款记录
  select seq_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into fd_trade_down_refund
    (record_id,
     channel_no,
     account_id,
     fd_order_id,
     trade_order_no,
     trade_refund_no,
     order_source,
     refund_time,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund,
     memo)
  --===============================---
  values
    (l_down_fund_id,
     v_down_channel_no,
     l_down_account_id,
     l_fd_order_id,
     v_trade_order_no,
     v_trade_refund_no,
     v_order_source,
     sysdate,
     v_business_type,
     v_carrier_no,
     v_province_no,
     v_refund_unit,
     v_refund_face,
     v_refund_amount,
     v_real_refund,
     v_memo);
  /*    select l_down_fund_id,
        t.down_channel_no,
        t.down_account_id,
        t.fd_order_id,
        t.trade_order_no,
        v_trade_refund_no,
        t.order_source,
        sysdate,
        t.business_type,
        t.carrier_no,
        t.province_no,
        v_refund_unit,
        v_refund_face,
        v_refund_amount,
        v_real_refund,
        v_memo
   from fd_trade_order_main t
  where t.fd_order_id = l_fd_order_id;*/

  ---7.添加下游资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_down_fund_id,
     l_fd_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     v_ext_order_no,
     v_order_source,
     l_refund_time,
     l_order_time,
     pkg_down_fund_change_type.refund_amount,
     v_refund_amount,
     (l_inner_balance + v_refund_amount),
     v_memo);

  ---8.检查上游中的下游扣款与订单的下游扣款是否一致
  ---9.上游中的下游扣款大于订单的下游扣款计算差异调整金额
  ---10调用差异调整函数

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_RV_TRADE
prompt ==========================================
prompt
create or replace function fd_account.fd_f_trade_down_rv_trade(v_down_channel_no  varchar2,
                                                    v_down_account_id  number,
                                                    v_down_company_id  number,
                                                    v_adjust_record_no varchar2,
                                                    v_down_draw_amount number,
                                                    v_down_real_amount number,
                                                    v_business_type    number,
                                                    v_bill_type        number,
                                                    v_create_user      varchar2,
                                                    v_memo             varchar2)
  return varchar2 is
  l_trade_fund_id    number;
  l_inner_balance    number;
  l_trade_up_fund_id number;
  l_adjust_count     number;

  --------------------下游渠道交易平账-----------------------
begin
  ---1.锁下游支付账户
  select t.inner_balance,
         seq_trade_down_fund_id.nextval,
         seq_trade_up_fund_id.nextval
    into l_inner_balance, l_trade_fund_id, l_trade_up_fund_id
    from fd_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.检查平账是否已处理
  select count(1)
    into l_adjust_count
    from fd_trade_down_manual t
   where t.ext_record_no = v_adjust_record_no;

  if l_adjust_count > 0 then
    return pkg_error_code.success;
  end if;

  ---3.若交易扣款不等于0，则需修改账户余额
  if v_down_draw_amount != 0 then
    update fd_base_down_account t
       set t.inner_balance  = (l_inner_balance - v_down_draw_amount),
           t.last_edit_user = v_create_user,
           t.last_edit_time = sysdate
     where t.account_id = v_down_account_id;
  
  end if;

  ---4.添加平账对应的下游手工记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo,
     ext_record_no)
  values
    (l_trade_fund_id,
     v_down_channel_no,
     v_down_account_id,
     0,
     0,
     pkg_down_manual_change_type.trade_revise,
     v_down_draw_amount,
     sysdate,
     (l_inner_balance - v_down_draw_amount),
     v_create_user,
     nvl2(v_memo, v_memo || ',下游交易平账', '下游交易平账'),
     v_adjust_record_no);

  ---5.添加平账对应的下游资金变动添加(通过trade_order_no关联上游资金变动)
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_trade_fund_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     'SARV' || l_trade_up_fund_id,
     pkg_down_fund_change_type.debit_amount,
     v_down_draw_amount,
     (l_inner_balance - v_down_draw_amount),
     v_memo);

  ---6.为了计算佣金利润，添加下游对应的上游资金变动（上游下游公司相同避免结算)
  insert into fd_trade_up_fund
    (record_id,
     trade_order_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     balance,
     memo)
  values
    (l_trade_up_fund_id,
     'SARV' || l_trade_up_fund_id,
     v_down_channel_no,
     v_down_account_id,
     v_down_company_id,
     0,
     0,
     v_down_company_id,
     0,
     0,
     v_down_draw_amount,
     v_down_real_amount,
     0,
     0,
     sysdate,
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     v_business_type,
     0,
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_RV_TRADE_CK
prompt =============================================
prompt
create or replace function fd_account.fd_f_trade_down_rv_trade_ck(v_down_channel_no  varchar2,
                                                       v_down_draw_amount number,
                                                       v_down_real_amount number,
                                                       v_down_account_id  out number,
                                                       v_down_company_id  out number)

 return varchar2 is
begin
  ---1.检查调整金额是否正确
  if (v_down_draw_amount = 0 and v_down_real_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户是否正确
  select t.account_id, c.company_id
    into v_down_account_id, v_down_company_id
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and rownum <= 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function FD_F_TRADE_DOWN_TRANS_REFUND
prompt ==============================================
prompt
create or replace function fd_account.fd_f_trade_down_trans_refund(v_order_source      in number,
                                                        v_down_channel_no   in varchar2,
                                                        v_trade_order_no    in varchar2,
                                                        v_trade_refund_no   in varchar2,
                                                        v_refund_account_id in number,
                                                        v_refund_unit       in number,
                                                        v_refund_face       in number,
                                                        v_refund_amount     in number,
                                                        v_real_refund       in number,
                                                        v_service_fee       in number,
                                                        v_refund_user       in varchar2,
                                                        v_memo              in varchar2)
  return varchar2 is
  --------------------转账退款-------------------
  l_fd_order_id       number;
  l_refund_count      number;
  l_total_amount      number;
  l_total_refund      number;
  l_account_count     number;
  l_account_balance   number;
  l_down_account_id   number;
  l_inner_balance     number;
  l_down_refund_id    number;
  l_down_draw_id      number;
  l_business_type     number;
  l_carrier_no        varchar2(32);
  l_province_no       varchar2(32);
  l_ext_order_no      varchar2(32);
  l_order_time        date;
  l_down_order_face   number;
  l_down_order_amount number;
  l_debit_count       number;
  l_result            varchar2(32);
  l_total_refund_face number;
  l_cap_company_id    number;
  l_down_company_id   number;
begin
  ---0.检查金额
  if v_service_fee < 0 or v_refund_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---1.检查转账退款账户
  select count(1), max(t.company_id)
    into l_account_count, l_cap_company_id
    from fd_base_company_account_cap t
   where t.account_type in (pkg_co_cap_account_type.transfer_refund,
          pkg_co_cap_account_type.manual_refund)
     and t.account_id = v_refund_account_id
     and t.status = pkg_sys_boolean.istrue;

  if l_account_count = 0 then
    return pkg_error_code.co_account_not_exists;
  end if;

  ---2.锁下游订单
  select t.fd_order_id,
         t.down_account_id,
         t.business_type,
         t.carrier_no,
         t.province_no,
         t.ext_order_no,
         t.order_time,
         t.total_face,
         t.down_order_amount,
         t.down_company_id
    into l_fd_order_id,
         l_down_account_id,
         l_business_type,
         l_carrier_no,
         l_province_no,
         l_ext_order_no,
         l_order_time,
         l_down_order_face,
         l_down_order_amount,
         l_down_company_id
    from fd_trade_order_main t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1
     for update;

  ---2.1检查公司是否相同
  if l_cap_company_id != l_down_company_id then
    return pkg_error_code.channel_or_account_error;
  end if;

  ---2.检测订单重复退款
  select count(1)
    into l_refund_count
    from fd_trade_down_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.fd_order_id = l_fd_order_id
     and t.order_source = v_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  ---3.1检查退款时是否有扣款
  select count(1)
    into l_debit_count
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and t.order_source = v_order_source
     and rownum <= 1;

  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---4.获取订单扣款、已退款金额
  select nvl(sum(t.change_amount), 0)
    into l_total_amount
    from fd_trade_down_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_down_fund_change_type.debit_amount
     and t.order_source = v_order_source
     and rownum <= 1;

  select nvl(sum(t.refund_amount), 0), nvl(sum(t.refund_face), 0)
    into l_total_refund, l_total_refund_face
    from fd_trade_down_refund t
   where t.fd_order_id = l_fd_order_id;

  ---5.检查退款金额是否超过订单总金额(用户在下游支付的金额比系统的高所以退款减去5元进行判断)
  /*  if (v_refund_amount-5 > (l_total_amount - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;*/

  if v_refund_face > (l_down_order_face - l_total_refund_face) then
    return pkg_error_code.amount_error;
  end if;

  ---6.锁转账退款账户
  select t.balance
    into l_account_balance
    from fd_base_company_account_cap t
   where t.account_type in (pkg_co_cap_account_type.transfer_refund,
          pkg_co_cap_account_type.manual_refund)
     and t.account_id = v_refund_account_id
     and t.status = pkg_sys_boolean.istrue
     for update;

  ---7.修改退款账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_account_balance - v_refund_amount -
                            v_service_fee),
         t.last_edit_user = v_refund_user,
         t.last_edit_time = sysdate
   where t.account_id = v_refund_account_id;

  select seq_trade_down_fund_id.nextval into l_down_refund_id from dual;
  select seq_trade_down_fund_id.nextval into l_down_draw_id from dual;

  ---8.添加转账退款资金变动
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     record_no,
     create_user,
     fd_order_id,
     transfer_refund_id,
     transfer_draw_id)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_refund_account_id,
     v_refund_amount,
     pkg_co_cap_fund_type.minus_amount,
     (l_account_balance - v_refund_amount),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     0,
     v_memo,
     v_trade_refund_no,
     v_refund_user,
     l_fd_order_id,
     l_down_refund_id,
     l_down_draw_id);

  ---8.1添加手续费记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     record_no,
     create_user,
     fd_order_id,
     transfer_refund_id,
     transfer_draw_id)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_refund_account_id,
     v_service_fee,
     pkg_co_cap_fund_type.service_fee,
     (l_account_balance - v_refund_amount - v_service_fee),
     sysdate,
     0,
     pkg_sys_boolean.isfalse,
     0,
     v_memo,
     v_trade_refund_no,
     v_refund_user,
     0,
     0,
     0);

  ---9.获取下游渠道余额
  select t.inner_balance
    into l_inner_balance
    from fd_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  ---10.添加下游退款记录
  insert into fd_trade_down_refund
    (record_id,
     channel_no,
     account_id,
     fd_order_id,
     trade_order_no,
     trade_refund_no,
     order_source,
     refund_time,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund,
     memo)
  values
    (l_down_refund_id,
     v_down_channel_no,
     l_down_account_id,
     l_fd_order_id,
     v_trade_order_no,
     v_trade_refund_no,
     v_order_source,
     sysdate,
     l_business_type,
     l_carrier_no,
     l_province_no,
     v_refund_unit,
     v_refund_face,
     v_refund_amount,
     v_real_refund,
     v_memo);

  ---11.添加下游退款资金变动
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee)
  values
    (l_down_refund_id,
     l_fd_order_id,
     v_down_channel_no,
     l_down_account_id,
     v_trade_order_no,
     l_ext_order_no,
     v_order_source,
     sysdate,
     l_order_time,
     pkg_down_fund_change_type.refund_amount,
     v_refund_amount,
     (l_inner_balance + v_refund_amount),
     v_memo,
     0);
  ---12.添加下游提款记录
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     create_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee)
  values
    (l_down_draw_id,
     l_fd_order_id,
     v_down_channel_no,
     l_down_account_id,
     sysdate,
     pkg_down_fund_change_type.draw_amount,
     v_refund_amount,
     (l_inner_balance + v_refund_amount - v_refund_amount),
     v_memo,
     0);
  --===========================订单差异信息记录=================================
  l_result := fd_f_trade_fund_differ_add(l_fd_order_id,
                                         pkg_trade_type.transfer_refund,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         pkg_bill_type.front,
                                         l_down_order_face,
                                         l_down_order_amount,
                                         v_refund_face,
                                         v_refund_amount,
                                         0);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_HS_MOVE
prompt ====================================
prompt
create or replace function fd_account.fd_f_trade_hs_move(v_order_source    number,
                                              v_down_channel_no varchar2,
                                              v_trade_order_no  varchar2)
  return varchar2 is
  -------------------历史库中的数据转移到当前库--------------------
  l_order_count         number;
  l_order_hs_count      number;
  l_fd_order_id         number;
  l_order_add_count     number;
  l_down_fund_add_count number;
  l_up_fund_add_count   number;
  l_order_del_count     number;
  l_down_fund_del_count number;
  l_up_fund_del_count   number;
begin
  ---1.检查当前库订单是否存在
  select count(1)
    into l_order_count
    from fd_trade_order_main t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1;

  if l_order_count > 0 then
    return pkg_error_code.success;
  end if;

  ---2.当前库订单不存在，检查历史表订单是否存在
  select count(1), max(t.fd_order_id)
    into l_order_hs_count, l_fd_order_id
    from fd_trade_order_main_hs t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1;

  ---2.1.历史表数据不存在，获取离线库数据
  if l_order_hs_count = 0 then
    return fd_f_trade_back_move(v_order_source,
                                v_down_channel_no,
                                v_trade_order_no);
  end if;

  ---3.历史表订单存在，获取历史库订单及其变动数据存入当前库
  ---3.1订单主表数据
  insert into fd_trade_order_main
    (fd_order_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     business_type,
     carrier_no,
     province_no,
     city_no,
     total_face,
     recharge_unit,
     recharge_account_no)
    select fd_order_id,
           down_channel_no,
           down_account_id,
           down_company_id,
           trade_order_no,
           ext_order_no,
           order_source,
           create_time,
           order_time,
           business_type,
           carrier_no,
           province_no,
           city_no,
           total_face,
           recharge_unit,
           recharge_account_no
      from fd_trade_order_main_hs t
     where t.fd_order_id = l_fd_order_id;
  l_order_add_count := sql%rowcount;

  if l_order_add_count = 0 then
    return pkg_error_code.data_error;
  end if;

  ---3.2删除历史库订单主表数据
  delete from fd_trade_order_main_hs t where t.fd_order_id = l_fd_order_id;
  l_order_del_count := sql%rowcount;

  if l_order_del_count != l_order_add_count then
    return pkg_error_code.data_error;
  end if;

  ---3.3下游资金变动数据
  insert into fd_trade_down_fund
    (record_id,
     fd_order_id,
     channel_no,
     account_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     change_type,
     change_amount,
     balance,
     memo,
     service_fee) ----添加手续费
    select record_id,
           fd_order_id,
           channel_no,
           account_id,
           trade_order_no,
           ext_order_no,
           order_source,
           create_time,
           order_time,
           change_type,
           change_amount,
           balance,
           memo,
           service_fee
      from fd_trade_down_fund_hs t
     where t.fd_order_id = l_fd_order_id;
  l_down_fund_add_count := sql%rowcount;

  ---3.4删除历史库下游资金变动数据
  delete from fd_trade_down_fund_hs t where t.fd_order_id = l_fd_order_id;
  l_down_fund_del_count := sql%rowcount;

  if l_down_fund_del_count != l_down_fund_add_count then
    return pkg_error_code.data_error;
  end if;

  ---3.5上游资金变动数据
  insert into fd_trade_up_fund
    (record_id,
     fd_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_batch_id,
     settle_status,
     settle_time,
     memo,
     order_time)
    select record_id,
           fd_order_id,
           trade_order_no,
           order_source,
           trade_delivery_no,
           down_channel_no,
           down_account_id,
           down_company_id,
           up_channel_no,
           up_account_id,
           up_company_id,
           down_draw_unit,
           down_draw_face,
           down_draw_amount,
           down_real_amount,
           up_draw_unit,
           up_draw_face,
           up_draw_amount,
           up_real_amount,
           change_time,
           change_type,
           bill_type,
           business_type,
           carrier_no,
           province_no,
           balance,
           profits,
           down_commission,
           up_commission,
           settle_amount,
           settle_batch_id,
           settle_status,
           settle_time,
           memo,
           order_time
      from fd_trade_up_fund_hs t
     where t.fd_order_id = l_fd_order_id;
  l_up_fund_add_count := sql%rowcount;

  ---3.6删除历史库上游资金变动数据
  delete from fd_trade_up_fund_hs t where t.fd_order_id = l_fd_order_id;
  l_up_fund_del_count := sql%rowcount;

  if l_up_fund_del_count != l_up_fund_add_count then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_OPERAT_MONEY_CHECK
prompt ===============================================
prompt
create or replace function fd_account.fd_f_trade_operat_money_check(v_amount      number,
                                                         v_service_fee number)
  return varchar2 is
  ------------------------------------人工加减款金额检查------------------------------------

begin

  ---1. 判断金额是否大于0
  if (v_amount <= 0 or v_service_fee < 0) then
    return pkg_error_code.amount_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_ORDER_EXIST_CHECK
prompt ==============================================
prompt
create or replace function fd_account.fd_f_trade_order_exist_check(v_order_source    number,
                                                        v_down_channel_no varchar2,
                                                        v_trade_order_no  varchar2,
                                                        v_fd_order_id     out number)
  return varchar2 is

  ----------------------------检查订单是否存在-----------------------------

begin
  ---1.检查订单是否存在
  select t.fd_order_id
    into v_fd_order_id
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and rownum <= 1;

  return pkg_error_code.success;
exception
  when others then
    ---2.返回订单不存在
    return pkg_error_code.order_or_account_not_exists;
end;
/

prompt
prompt Creating function FD_F_TRADE_ORDER_CREATE_II
prompt ============================================
prompt
create or replace function fd_account.fd_f_trade_order_create_ii(v_order_source        number,
                                                      v_down_channel_no     varchar2,
                                                      v_trade_order_no      varchar2,
                                                      v_ext_order_no        varchar2,
                                                      v_recharge_account_no varchar2,
                                                      v_business_type       number,
                                                      v_carrier_no          varchar2,
                                                      v_province_no         varchar2,
                                                      v_city_no             varchar2,
                                                      v_total_face          number,
                                                      v_recharge_unit       number,
                                                      v_order_amount        number,
                                                      v_order_time          varchar2)
  return varchar2 is

  l_result          varchar2(32);
  l_fd_order_id     number;
  l_down_account_id number;
  l_down_company_id number;
  ----------------------------检查并创建订单-----------------------------

begin
  ---1.检查订单是否存在
  l_result := fd_f_trade_order_exist_check(v_order_source,
                                           v_down_channel_no,
                                           v_trade_order_no,
                                           l_fd_order_id);

  if (l_result = pkg_error_code.success) then
    return pkg_error_code.success;
  end if;

  ---2.获取下游账户和公司
  select t.account_id, c.company_id
    into l_down_account_id, l_down_company_id
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   inner join fd_base_down_system_map s on t.channel_no = s.channel_no
   where t.channel_no = v_down_channel_no
     and s.source_system_id = v_order_source
        --  and a.status = 0
        --  and c.status = 0
     and rownum <= 2;

  ---3.添加订单
  select seq_trade_order_main_id.nextval into l_fd_order_id from dual;

  insert into fd_trade_order_main
    (fd_order_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     business_type,
     carrier_no,
     province_no,
     city_no,
     total_face,
     recharge_unit,
     recharge_account_no,
     down_order_amount)
  values
    (l_fd_order_id,
     v_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_trade_order_no,
     v_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_business_type,
     v_carrier_no,
     v_province_no,
     v_city_no,
     v_total_face,
     v_recharge_unit,
     v_recharge_account_no,
     v_order_amount);

  return pkg_error_code.success;

EXCEPTION
  WHEN others THEN
    ---4.订单添加失败，检查是否并发添加
  
    fd_p_write_log('fd_p_trade_up_order_pay' || v_trade_order_no,
                   sqlerrm,
                   1);
    l_result := fd_f_trade_order_exist_check(v_order_source,
                                             v_down_channel_no,
                                             v_trade_order_no,
                                             l_fd_order_id);
  
    if l_result != pkg_error_code.success then
      return pkg_error_code.order_insert_fail;
    end if;
  
    return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_ORDER_CREATE_T
prompt ===========================================
prompt
create or replace function fd_account.fd_f_trade_order_create_t(v_order_source        number,
                                                     v_down_channel_no     varchar2,
                                                     v_trade_order_no      varchar2,
                                                     v_ext_order_no        varchar2,
                                                     v_recharge_account_no varchar2,
                                                     v_business_type       number,
                                                     v_carrier_no          varchar2,
                                                     v_province_no         varchar2,
                                                     v_city_no             varchar2,
                                                     v_total_face          number,
                                                     v_recharge_unit       number,
                                                     v_order_time          varchar2)
  return varchar2 is

  l_result          varchar2(32);
  l_fd_order_id     number;
  l_down_account_id number;
  l_down_company_id number;
  l_dn_refund_count number;
  l_dn_order_id     number;
  l_up_refund_count number;
  l_up_order_id     number;
  ----------------------------检查并创建订单-----------------------------

begin
  ---1.检查订单是否存在
  l_result := fd_f_trade_order_exist_check(v_order_source,
                                           v_down_channel_no,
                                           v_trade_order_no,
                                           l_fd_order_id);

  if (l_result = pkg_error_code.success) then
    return pkg_error_code.success;
  end if;

  ---2.获取下游账户和公司
  select t.account_id, c.company_id
    into l_down_account_id, l_down_company_id
    from fd_base_down_account_map t
   inner join fd_base_down_account a on t.account_id = a.account_id
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   inner join fd_base_down_system_map s on t.channel_no = s.channel_no
   where t.channel_no = v_down_channel_no
     and s.source_system_id = v_order_source
    -- and a.status = 0
   --  and c.status = 0
     and rownum <= 1;

  ---3.添加订单
  select seq_trade_order_main_id.nextval into l_fd_order_id from dual;

  --======================================================
  select count(1), max(t.fd_order_id)
    into l_dn_refund_count, l_dn_order_id
    from fd_trade_down_refund t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source;

  select count(1), max(t.fd_order_id)
    into l_up_refund_count, l_up_order_id
    from fd_trade_up_refund t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source;

  if (l_dn_refund_count > 0) then
    l_fd_order_id := l_dn_order_id;
  elsif (l_up_refund_count > 0) then
    l_fd_order_id := l_up_order_id;
  end if;

  --======================================================

  insert into fd_trade_order_main
    (fd_order_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     business_type,
     carrier_no,
     province_no,
     city_no,
     total_face,
     recharge_unit,
     recharge_account_no)
  values
    (l_fd_order_id,
     v_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_trade_order_no,
     v_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_business_type,
     v_carrier_no,
     v_province_no,
     v_city_no,
     v_total_face,
     v_recharge_unit,
     v_recharge_account_no);
  return pkg_error_code.success;
EXCEPTION
  WHEN Dup_val_on_index THEN
    ---4.订单添加失败，检查是否并发添加
    l_result := fd_f_trade_order_exist_check(v_order_source,
                                             v_down_channel_no,
                                             v_trade_order_no,
                                             l_fd_order_id);

    return l_result;

end;
/

prompt
prompt Creating function FD_F_TRADE_ORDER_FACE_CHECK
prompt =============================================
prompt
create or replace function fd_account.fd_f_trade_order_face_check(v_trade_order_no  in varchar2,
                                                       v_down_order_face in number,
                                                       v_down_draw_face  in number)
  return varchar2 is
  --------------上游扣款订单面值检查--------------
  l_order_face number;
begin
  select t.total_face
    into l_order_face
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no;

  if ((v_down_order_face > l_order_face) or
     (v_down_draw_face > l_order_face)) then
  
    return pkg_error_code.order_face_too_max;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_PAY_HS_MOVE
prompt ========================================
prompt
create or replace function fd_account.fd_f_trade_pay_hs_move(v_order_source    number,
                                                  v_down_channel_no varchar2,
                                                  v_trade_order_no  varchar2,
                                                  v_order_time      varchar2)
  return varchar2 is
  ---------------------支付扣款从历史库获取一个月前订单数据------------------
  l_end_time date := add_months(trunc(sysdate + 3, 'dd'), -1);
  l_result   varchar2(32);
begin
  if to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss') < l_end_time then
    l_result := fd_f_trade_hs_move(v_order_source,
                                   v_down_channel_no,
                                   v_trade_order_no);

    if (l_result = pkg_error_code.success or
       l_result = pkg_error_code.order_not_exists) then
      return pkg_error_code.success;
    end if;
    return l_result;
  end if;
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_REAL_AMOUNT_GET
prompt ============================================
prompt
create or replace function fd_account.fd_f_trade_real_amount_get(v_channel_no   varchar2,
                                                      v_channel_type number,
                                                      v_draw_amount  number,
                                                      v_real_amount  number)
  return number is
  --------------获取交易真实金额，去掉应舍去佣金差异-------------
  l_need_commi    number;
  l_amount_differ number;
  l_max_differ    number := 0.02; ---舍去差异的最大值
begin
  l_amount_differ := (v_draw_amount - v_real_amount); ---扣款金额差异
  ---1.获取渠道是否需要后返佣金信息
  if v_channel_type = pkg_channel_type.up_channel then
    select t.need_commi
      into l_need_commi
      from fd_base_up_channel t
     where t.channel_no = v_channel_no;
  else
    select t.need_commi
      into l_need_commi
      from fd_base_down_channel t
     where t.channel_no = v_channel_no;
  end if;

  ---2.需要后返佣金或差异大于最大配置值或小于最大配置值取反的值，返回真实金额
  if l_need_commi = pkg_sys_boolean.istrue or
     l_amount_differ > l_max_differ or l_amount_differ < (0 - l_max_differ) then
    return v_real_amount;
  end if;

  ---3.需要返回扣款金额为真实金额，返回扣款金额
  return v_draw_amount;
end;
/

prompt
prompt Creating function FD_F_TRADE_REAL_AMOUNT_GET2
prompt =============================================
prompt
create or replace function fd_account.fd_f_trade_real_amount_get2(v_channel_no   varchar2,
                                                       v_channel_type number,
                                                       v_business_type number,
                                                       v_draw_amount  number,
                                                       v_real_amount  number)
  return number is
  --------------获取交易真实金额，去掉应舍去佣金差异-------------
  l_need_commi    number;
  l_amount_differ number;
  l_max_differ    number := 0.02; ---舍去差异的最大值
begin
  ---0.话费不做差异取舍
  if v_business_type=pkg_business_type.huafei then
        return v_real_amount;
  end if;

  l_amount_differ := (v_draw_amount - v_real_amount); ---扣款金额差异
  ---1.获取渠道是否需要后返佣金信息
  if v_channel_type = pkg_channel_type.up_channel then
    select t.need_commi
      into l_need_commi
      from fd_base_up_channel t
     where t.channel_no = v_channel_no;
  else
    select t.need_commi
      into l_need_commi
      from fd_base_down_channel t
     where t.channel_no = v_channel_no;
  end if;

  ---2.需要后返佣金或差异大于最大配置值或小于最大配置值取反的值，返回真实金额
  if l_need_commi = pkg_sys_boolean.istrue or
     l_amount_differ > l_max_differ or l_amount_differ < (0 - l_max_differ) then
    return v_real_amount;
  end if;

  ---3.需要返回扣款金额为真实金额，返回扣款金额
  return v_draw_amount;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_AC_ACCOUNT_T
prompt ============================================
prompt
create or replace function fd_account.fd_f_trade_up_ac_account_t(v_up_channel_no varchar2,
                                                      v_up_account_id number,
                                                      v_up_company_id out number)
  return varchar2 is
  ----------------获取上游支付账户-----------------
begin
  ---1.检查上游资金账户
  select c.company_id
    into v_up_company_id
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and rownum <= 1;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_AC_REVISE_CHECK
prompt ===============================================
prompt
create or replace function fd_account.fd_f_trade_up_ac_revise_check(v_up_channel_no  varchar2,
                                                         v_up_account_id  number,
                                                         v_account_amount number,
                                                         v_profit_amount  number,
                                                         v_commis_amount  number)
  return varchar2 is
  -------------------检查手工平账渠道账户、金额是否正确--------------------
  l_up_account_id number;
begin
  ---1.检查渠道账户是否正确
  select t.account_id
    into l_up_account_id
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and a.status = 0
     and c.status = 0
     and rownum <= 2;

  ---2.检查金额是否正确
  if (v_account_amount = 0 and v_profit_amount = 0 and v_commis_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_ADD_RD_CHECK
prompt ============================================
prompt
create or replace function fd_account.fd_f_trade_up_add_rd_check(v_record_no varchar2)
  return varchar2 is
  ----------------上游重复加款检查-----------------
  l_count number;
begin
  select count(1)
    into l_count
    from fd_trade_up_manual t
   where t.ext_record_no = v_record_no;

  if l_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_MANUAL_ACCOUNT_T
prompt ================================================
prompt
create or replace function fd_account.fd_f_trade_up_manual_account_t(v_up_channel_no varchar2,
                                                          v_change_type   varchar2,
                                                          v_service_fee   number,
                                                          v_up_account_id out number,
                                                          v_up_company_id out number)
  return varchar2 is
  ----------------获取上游支付账户-----------------
begin
  ---1.检查上游资金账户
  select t.account_id, c.company_id
    into v_up_account_id, v_up_company_id
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
/*     and a.status = 0
     and c.status = 0*/
     and rownum <= 1;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_MANUAL_ADD
prompt ==========================================
prompt
create or replace function fd_account.fd_f_trade_up_manual_add(v_up_channel_no   varchar2,
                                                    v_up_account_id   number,
                                                    v_bank_account_id number,
                                                    v_up_company_id   number,
                                                    v_amount          number,
                                                    v_service_fee     number,
                                                    v_create_user     varchar2,
                                                    v_partner_account varchar2,
                                                    v_memo            varchar2)
  return varchar2 is
  l_inner_balance        number;
  l_bank_balance         number;
  l_co_balance           number;
  l_fund_id              number;
  l_service_fund_id      number;
  l_co_account_id        number;
  l_bank_company_id      number;
  l_bank_fund_id         number;
  l_bank_service_fund_id number;
  ------------上游手工加款----------
begin
  --===============1.锁账户检查金额==============
  ---1.1.锁资金账户、实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---1.2.检查相关金额
  if (l_bank_balance < (v_amount + v_service_fee)) then
    return pkg_error_code.balance_low;
  end if;

  ---1.3.获取资金变动主键
  select seq_trade_up_fund_id.nextval, seq_bank_cash_fund_id.nextval
    into l_service_fund_id, l_bank_fund_id
    from dual;
  select seq_trade_up_fund_id.nextval, seq_bank_cash_fund_id.nextval
    into l_fund_id, l_bank_service_fund_id
    from dual;

  --==================2.手续费相关操作=====================
  if (v_service_fee > 0) then
    ---2.1.锁公司手续费账户
    select t.account_id, t.balance
      into l_co_account_id, l_co_balance
      from fd_base_company_account_self t
     where t.company_id = v_up_company_id
       and t.account_type = pkg_co_self_account_type.service_fee
       and rownum <= 1
       for update;
  
    ---2.2.添加公司后续费账户资金变动
    insert into fd_trade_co_self_fund
      (change_id,
       account_id,
       change_amount,
       change_type,
       balance,
       change_time)
    values
      (l_bank_service_fund_id,
       l_co_account_id,
       v_service_fee,
       pkg_co_self_fund_type.add_amount,
       (l_co_balance + v_service_fee),
       sysdate);
  
    ---2.3.添加手续费实体卡资金变动
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark)
    values
      (l_bank_service_fund_id,
       v_bank_account_id,
       l_bank_company_id,
       v_service_fee,
       (l_bank_balance - v_amount - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       v_up_channel_no,
       v_up_account_id,
       v_memo);
  
    ---2.5.更新手续费账户余额
    update fd_base_company_account_self t
       set t.balance        = (l_co_balance + v_service_fee),
           t.last_edit_user = v_create_user,
           t.last_edit_time = sysdate
     where t.account_id = l_co_account_id;
  end if;

  --===============3.上游加款相关操作=================
  ---3.1.添加手工加款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.add_amount,
     v_amount,
     sysdate,
     (l_inner_balance + v_amount),
     v_memo,
     v_create_user,
     v_partner_account,
     l_bank_fund_id);

  ---3.2.添加实体卡资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (l_bank_fund_id,
     v_bank_account_id,
     l_bank_company_id,
     v_amount,
     (l_bank_balance - v_amount),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.up_add,
     v_up_channel_no,
     v_up_account_id,
     v_memo,
     l_bank_service_fund_id);

  ---3.3.添加资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_amount,
     v_amount,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance + v_amount),
     v_memo);

  ---3.4.更新资金账户、实体卡账户
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_amount - v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_up_account_id;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_MANUAL_ADD_T
prompt ============================================
prompt
create or replace function fd_account.fd_f_trade_up_manual_add_t(v_up_channel_no   varchar2,
                                                      v_up_account_id   number,
                                                      v_up_company_id   number,
                                                      v_record_no       varchar2,
                                                      v_amount          number,
                                                      v_service_fee     number,
                                                      v_create_user     varchar2,
                                                      v_pay_time        varchar2,
                                                      v_partner_account varchar2,
                                                      v_memo            varchar2)
  return varchar2 is
  l_inner_balance        number;
  l_fund_id              number;
  l_service_fund_id      number;
  l_pay_time             date;
  l_service_bank_fund_id number;
  l_count                number;
  ------------上游手工加款----------
begin
  --===============1.锁账户检查金额==============
  ---1.1.锁资金账户、实体卡账户

  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---1.2检查并发同步
  select count(1)
    into l_count
    from fd_trade_up_manual t
   where t.ext_record_no = v_record_no;

  if l_count > 0 then
    return pkg_error_code.data_repeat;
  end if;

  ---1.3.获取资金变动主键
  select seq_trade_up_fund_id.nextval into l_service_fund_id from dual;
  select seq_trade_up_fund_id.nextval,
         seq_bank_cash_fund_id.nextval,
         to_date(nvl(v_pay_time, to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss')),
                 'yyyy-mm-dd hh24:mi:ss')
    into l_fund_id, l_service_bank_fund_id, l_pay_time
    from dual;

  --===============3.上游加款相关操作=================
  ---3.1.更新资金账户、实体卡账户
  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = l_pay_time
   where t.account_id = v_up_account_id;

  ---3.2.添加手工加款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id,
     service_id,
     ext_record_no)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.add_amount,
     v_amount,
     l_pay_time,
     (l_inner_balance + v_amount),
     v_memo,
     v_create_user,
     v_partner_account,
     l_service_bank_fund_id,
     l_service_fund_id,
     v_record_no);

  ---3.3.添加资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_amount,
     v_amount,
     l_pay_time,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance + v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_MANUAL_ADD_TX
prompt =============================================
prompt
create or replace function fd_account.fd_f_trade_up_manual_add_tx(v_up_channel_no   varchar2,
                                                      v_up_account_id   number,
                                                      v_up_company_id   number,
                                                      v_record_no       varchar2,
                                                      v_amount          number,
                                                      v_service_fee     number,
                                                      v_create_user     varchar2,
                                                      v_pay_time        varchar2,
                                                      v_partner_account varchar2,
                                                      v_memo            varchar2)
  return varchar2 is
  l_inner_balance        number;
  l_co_balance           number;
  l_fund_id              number;
  l_service_fund_id      number;
  l_pay_time             date;
  l_co_account_id        number;
  l_service_bank_fund_id number;
  ------------上游手工加款----------
begin
  --===============1.锁账户检查金额==============
  ---1.1.锁资金账户、实体卡账户

  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---1.3.获取资金变动主键
  select seq_trade_up_fund_id.nextval into l_service_fund_id from dual;
  select seq_trade_up_fund_id.nextval,
         seq_bank_cash_fund_id.nextval,
         to_date(nvl(v_pay_time, to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss')),
                 'yyyy-mm-dd hh24:mi:ss')
    into l_fund_id, l_service_bank_fund_id, l_pay_time
    from dual;


  --===============3.上游加款相关操作=================
  ---3.1.添加手工加款记录
  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     bank_fund_id,
     service_id,
     ext_record_no)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.add_amount,
     v_amount,
     l_pay_time,
     (l_inner_balance + v_amount),
     v_memo,
     v_create_user,
     v_partner_account,
     l_service_bank_fund_id,
     l_service_fund_id,
     v_record_no);

  ---3.3.添加资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_amount,
     v_amount,
     l_pay_time,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance + v_amount),
     v_memo);

  ---3.4.更新资金账户、实体卡账户

  update fd_base_up_account t
     set t.inner_balance  = (l_inner_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = l_pay_time
   where t.account_id = v_up_account_id;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_ORDER_MINUS
prompt ===========================================
prompt
create or replace function fd_account.fd_f_trade_up_order_minus(v_order_source      number,
                                                     v_trade_order_no    varchar2,
                                                     v_trade_delivery_no varchar2,
                                                     v_up_channel_no     varchar2,
                                                     v_up_account_id     number,
                                                     v_up_draw_unit      number,
                                                     v_up_draw_face      number,
                                                     v_up_draw_amount    number,
                                                     v_up_real_amount    number,
                                                     v_down_draw_unit    number,
                                                     v_down_draw_face    number,
                                                     v_down_draw_amount  number,
                                                     v_down_real_amount  number,
                                                     v_bill_type         number,
                                                     v_order_time        varchar2,
                                                     v_up_service_fee    number,
                                                     v_memo              varchar2)
  return varchar2 is
  l_down_order_all_unit number;
  l_down_order_all_face number;
  l_down_debit_now_unit number;
  l_down_debit_now_face number;
  l_down_draw_unit      number;
  l_down_draw_face      number;
  l_down_draw_amount    number;
  l_down_real_amount    number;

  l_up_company_id   number;
  l_down_channel_no varchar2(32);
  l_down_company_id number;
  l_inner_balance   number;
  l_query_balance   number;
  l_fd_order_id     number;
  l_pay_count       number;
  l_settle_status   number;
  l_down_account_id number;
  l_business_type   number;
  l_carrier_no      varchar2(32);
  l_province_no     varchar2(32);
  l_city_no         varchar2(32);

  l_profits          number;
  l_down_commission  number;
  l_up_commission    number;
  l_refund_face      number;
  l_refund_unit      number;
  l_order_all_amount number;
  l_order_all_unit   number;
  l_order_all_face   number;
  l_result           varchar2(32);
  -------------------上游减款----------------------
begin

  --===============================检查订单支付情况==================================
  ---1.锁支付订单
  select t.fd_order_id,
         t.down_channel_no,
         t.down_account_id,
         t.down_company_id,
         t.recharge_unit,
         t.total_face,
         t.business_type,
         t.carrier_no,
         t.province_no,
         t.city_no,
         t.down_order_amount
    into l_fd_order_id,
         l_down_channel_no,
         l_down_account_id,
         l_down_company_id,
         l_order_all_unit,
         l_order_all_face,
         l_business_type,
         l_carrier_no,
         l_province_no,
         l_city_no,
         l_order_all_amount
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查订单是否已支付
  select count(1)
    into l_pay_count
    from fd_trade_up_fund t
   where t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  if (l_pay_count > 0) then
    return pkg_error_code.success;
  end if;

  ---3.计算下游规格、订单金额
  select nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_unit),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_face),
             0)
    into l_down_debit_now_unit, l_down_debit_now_face
    from fd_trade_up_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type in (pkg_up_fund_change_type.debit_amount,
          pkg_up_fund_change_type.refund_amount);

  ---4.计算出下游退款金额
  select nvl(sum(t.refund_face), 0), nvl(sum(t.refund_unit), 0)
    into l_refund_face, l_refund_unit
    from fd_trade_down_refund t
   where t.fd_order_id = l_fd_order_id;

  ---5.计算扣款金额
  l_down_order_all_face := l_order_all_face - l_refund_face; ---订单实际总面值
  l_down_order_all_unit := l_order_all_unit - l_refund_unit; --订单实际总规格
  if ((l_down_order_all_face) <= l_down_debit_now_face) then
    l_down_draw_unit   := 0;
    l_down_draw_face   := 0;
    l_down_draw_amount := 0;
    l_down_real_amount := 0;
  elsif ((l_down_order_all_face - l_down_debit_now_face) < v_up_draw_face) then
    l_down_draw_unit   := l_down_order_all_unit - l_down_debit_now_unit;
    l_down_draw_face   := l_down_order_all_face - l_down_debit_now_face;
    l_down_draw_amount := (l_down_draw_face / v_down_draw_face) *
                          v_down_draw_amount;
    l_down_real_amount := (l_down_draw_face / v_down_draw_face) *
                          v_down_real_amount;
  else
    l_down_draw_unit   := v_up_draw_unit;
    l_down_draw_face   := v_up_draw_face;
    l_down_draw_amount := v_down_draw_amount *
                          (v_up_draw_face / v_down_draw_face);
    l_down_real_amount := v_down_real_amount *
                          (v_up_draw_face / v_down_draw_face);
  end if;

  --===================================获取公司结算信息=================================

  ---4. 是否需要结算给公司
  select t.company_id
    into l_up_company_id
    from fd_base_up_channel t
   where t.channel_no = v_up_channel_no;

  l_settle_status := pkg_settle_status.no_need;
  if (l_up_company_id != l_down_company_id) then
    l_settle_status := pkg_settle_status.wait_settle;
  end if;

  --======================================上游减款=====================================

  ---5.1获取并修改账户余额
  select t.query_balance, t.inner_balance
    into l_query_balance, l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  update fd_base_up_account t
     set t.inner_balance = (l_inner_balance - v_up_draw_amount)
   where t.account_id = v_up_account_id;

  l_profits         := l_down_real_amount - v_up_real_amount;
  l_down_commission := l_down_draw_amount - l_down_real_amount;
  l_up_commission   := v_up_draw_amount - v_up_real_amount;

  ---6.添加上游资金变动
  insert into fd_trade_up_fund
    (record_id,
     fd_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     order_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     memo)
  values
    (seq_trade_up_fund_id.nextval,
     l_fd_order_id,
     v_trade_order_no,
     v_order_source,
     v_trade_delivery_no,
     l_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_up_channel_no,
     v_up_account_id,
     l_up_company_id,
     l_down_draw_unit,
     l_down_draw_face,
     l_down_draw_amount,
     l_down_real_amount,
     v_up_draw_unit,
     v_up_draw_face,
     v_up_draw_amount,
     v_up_real_amount,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     l_business_type,
     l_carrier_no,
     l_province_no,
     (l_inner_balance - v_up_draw_amount),
     l_profits,
     l_down_commission,
     l_up_commission,
     0,
     l_settle_status,
     v_memo);

  ---7.添加订单差异表数据
  l_result := fd_f_trade_fund_differ_add(l_fd_order_id,
                                         pkg_trade_type.up_debit,
                                         l_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         v_bill_type,
                                         l_order_all_face,
                                         l_order_all_amount,
                                         l_down_draw_face,
                                         l_down_draw_amount,
                                         v_up_draw_face);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_ORDER_MINUS2
prompt ============================================
prompt
create or replace function fd_account.fd_f_trade_up_order_minus2(v_order_source      number,
                                                      v_trade_order_no    varchar2,
                                                      v_trade_delivery_no varchar2,
                                                      v_up_channel_no     varchar2,
                                                      v_up_account_id     number,
                                                      v_up_draw_unit      number,
                                                      v_up_draw_face      number,
                                                      v_up_draw_amount    number,
                                                      v_up_real_amount    number,
                                                      v_down_draw_unit    number,
                                                      v_down_draw_face    number,
                                                      v_down_draw_amount  number,
                                                      v_down_real_amount  number,
                                                      v_bill_type         number,
                                                      v_order_time        varchar2,
                                                      v_up_service_fee    number,
                                                      v_memo              varchar2,
                                                      v_out_change_time   varchar2)
  return varchar2 is
  l_down_order_all_unit number;
  l_down_order_all_face number;
  l_down_debit_now_unit number;
  l_down_debit_now_face number;
  l_down_draw_unit      number;
  l_down_draw_face      number;
  l_down_draw_amount    number;
  l_down_real_amount    number;

  l_up_company_id   number;
  l_down_channel_no varchar2(32);
  l_down_company_id number;
  l_inner_balance   number;
  l_query_balance   number;
  l_fd_order_id     number;
  l_pay_count       number;
  l_settle_status   number;
  l_down_account_id number;
  l_business_type   number;
  l_carrier_no      varchar2(32);
  l_province_no     varchar2(32);
  l_city_no         varchar2(32);

  l_profits          number;
  l_down_commission  number;
  l_up_commission    number;
  l_refund_face      number;
  l_refund_unit      number;
  l_order_all_amount number;
  l_order_all_unit   number;
  l_order_all_face   number;
  l_result           varchar2(32);
  -------------------上游减款----------------------
begin

  --===============================检查订单支付情况==================================
  ---1.锁支付订单
  select t.fd_order_id,
         t.down_channel_no,
         t.down_account_id,
         t.down_company_id,
         t.recharge_unit,
         t.total_face,
         t.business_type,
         t.carrier_no,
         t.province_no,
         t.city_no,
         t.down_order_amount
    into l_fd_order_id,
         l_down_channel_no,
         l_down_account_id,
         l_down_company_id,
         l_order_all_unit,
         l_order_all_face,
         l_business_type,
         l_carrier_no,
         l_province_no,
         l_city_no,
         l_order_all_amount
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查订单是否已支付
  select count(1)
    into l_pay_count
    from fd_trade_up_fund t
   where t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  if (l_pay_count > 0) then
    return pkg_error_code.success;
  end if;

  ---3.计算下游规格、订单金额
  select nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_unit),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_face),
             0)
    into l_down_debit_now_unit, l_down_debit_now_face
    from fd_trade_up_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type in
         (pkg_up_fund_change_type.debit_amount,
          pkg_up_fund_change_type.refund_amount);

  ---4.计算出下游退款金额
  select nvl(sum(t.refund_face), 0), nvl(sum(t.refund_unit), 0)
    into l_refund_face, l_refund_unit
    from fd_trade_down_refund t
   where t.fd_order_id = l_fd_order_id;

  ---5.计算扣款金额
  l_down_order_all_face := l_order_all_face - l_refund_face; ---订单实际总面值
  l_down_order_all_unit := l_order_all_unit - l_refund_unit; --订单实际总规格
  if ((l_down_order_all_face) <= l_down_debit_now_face) then
    l_down_draw_unit   := 0;
    l_down_draw_face   := 0;
    l_down_draw_amount := 0;
    l_down_real_amount := 0;
  elsif ((l_down_order_all_face - l_down_debit_now_face) < v_up_draw_face) then
    l_down_draw_unit   := l_down_order_all_unit - l_down_debit_now_unit;
    l_down_draw_face   := l_down_order_all_face - l_down_debit_now_face;
    l_down_draw_amount := (l_down_draw_face / v_down_draw_face) *
                          v_down_draw_amount;
    l_down_real_amount := (l_down_draw_face / v_down_draw_face) *
                          v_down_real_amount;
  else
    l_down_draw_unit   := v_up_draw_unit;
    l_down_draw_face   := v_up_draw_face;
    l_down_draw_amount := v_down_draw_amount *
                          (v_up_draw_face / v_down_draw_face);
    l_down_real_amount := v_down_real_amount *
                          (v_up_draw_face / v_down_draw_face);
  end if;

  --===================================获取公司结算信息=================================

  ---4. 是否需要结算给公司
  select t.company_id
    into l_up_company_id
    from fd_base_up_channel t
   where t.channel_no = v_up_channel_no;

  l_settle_status := pkg_settle_status.no_need;
  if (l_up_company_id != l_down_company_id) then
    l_settle_status := pkg_settle_status.wait_settle;
  end if;

  --======================================上游减款=====================================

  ---5.1获取并修改账户余额
  select t.query_balance, t.inner_balance
    into l_query_balance, l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  update fd_base_up_account t
     set t.inner_balance =
         (l_inner_balance - v_up_draw_amount)
   where t.account_id = v_up_account_id;

  l_profits         := l_down_real_amount - v_up_real_amount;
  l_down_commission := l_down_draw_amount - l_down_real_amount;
  l_up_commission   := v_up_draw_amount - v_up_real_amount;

  ---6.添加上游资金变动
  insert into fd_trade_up_fund
    (record_id,
     fd_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     order_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     memo,
     out_change_time)
  values
    (seq_trade_up_fund_id.nextval,
     l_fd_order_id,
     v_trade_order_no,
     v_order_source,
     v_trade_delivery_no,
     l_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_up_channel_no,
     v_up_account_id,
     l_up_company_id,
     l_down_draw_unit,
     l_down_draw_face,
     l_down_draw_amount,
     l_down_real_amount,
     v_up_draw_unit,
     v_up_draw_face,
     v_up_draw_amount,
     v_up_real_amount,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     l_business_type,
     l_carrier_no,
     l_province_no,
     (l_inner_balance - v_up_draw_amount),
     l_profits,
     l_down_commission,
     l_up_commission,
     0,
     l_settle_status,
     v_memo,
     to_date(v_out_change_time, 'yyyy-mm-dd hh24:mi:ss'));

  ---7.添加订单差异表数据
  l_result := fd_f_trade_fund_differ_add(l_fd_order_id,
                                         pkg_trade_type.up_debit,
                                         l_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         v_bill_type,
                                         l_order_all_face,
                                         l_order_all_amount,
                                         l_down_draw_face,
                                         l_down_draw_amount,
                                         v_up_draw_face);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_ORDER_MINUS_MS
prompt ==============================================
prompt
create or replace function fd_account.fd_f_trade_up_order_minus_ms(v_order_source      number,
                                                        v_trade_order_no    varchar2,
                                                        v_trade_delivery_no varchar2,
                                                        v_up_channel_no     varchar2,
                                                        v_up_account_id     number,
                                                        v_up_draw_unit      number,
                                                        v_up_draw_face      number,
                                                        v_up_draw_amount    number,
                                                        v_up_real_amount    number,
                                                        v_down_draw_unit    number,
                                                        v_down_draw_face    number,
                                                        v_down_draw_amount  number,
                                                        v_down_real_amount  number,
                                                        v_bill_type         number,
                                                        v_order_time        varchar2,
                                                        v_up_service_fee    number,
                                                        v_memo              varchar2,
                                                        v_out_change_time   varchar2)
  return varchar2 is
  l_down_order_all_unit   number;
  l_down_order_all_face   number;
  l_down_debit_now_unit   number;
  l_down_debit_now_face   number;
  l_down_debit_now_amount number;
  l_down_draw_unit        number;
  l_down_draw_face        number;
  l_down_draw_amount      number;
  l_down_real_amount      number;

  l_up_company_id   number;
  l_down_channel_no varchar2(32);
  l_down_company_id number;
  l_inner_balance   number;
  l_query_balance   number;
  l_fd_order_id     number;
  l_pay_count       number;
  l_settle_status   number;
  l_down_account_id number;
  l_business_type   number;
  l_carrier_no      varchar2(32);
  l_province_no     varchar2(32);
  l_city_no         varchar2(32);

  l_profits          number;
  l_down_commission  number;
  l_up_commission    number;
  l_refund_face      number;
  l_refund_unit      number;
  l_order_all_amount number;
  l_order_all_unit   number;
  l_order_all_face   number;
  l_result           varchar2(32);
  -----------------------------------------
  --功能：短信平台上游扣款专用
  --创建人：周荣省
  --创建时间：2019-05-20
  -----------------------------------------
begin

  --===============================检查订单支付情况==================================
  ---1.锁支付订单
  select t.fd_order_id,
         t.down_channel_no,
         t.down_account_id,
         t.down_company_id,
         t.recharge_unit,
         t.total_face,
         t.business_type,
         t.carrier_no,
         t.province_no,
         t.city_no,
         t.down_order_amount
    into l_fd_order_id,
         l_down_channel_no,
         l_down_account_id,
         l_down_company_id,
         l_order_all_unit,
         l_order_all_face,
         l_business_type,
         l_carrier_no,
         l_province_no,
         l_city_no,
         l_order_all_amount
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查订单是否已支付
  select count(1)
    into l_pay_count
    from fd_trade_up_fund t
   where t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  if (l_pay_count > 0) then
    return pkg_error_code.success;
  end if;

  ---3.计算下游规格、订单金额
  select nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_unit),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_face),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_amount),
             0)
    into l_down_debit_now_unit,
         l_down_debit_now_face,
         l_down_debit_now_amount
    from fd_trade_up_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type in (pkg_up_fund_change_type.debit_amount,
          pkg_up_fund_change_type.refund_amount);
  --4.计算下游扣款金额
  if l_down_debit_now_amount = 0 then
    --下游无扣款
    l_down_draw_unit   := v_down_draw_unit;
    l_down_draw_face   := v_down_draw_face;
    l_down_draw_amount := v_down_draw_amount;
    l_down_real_amount := v_down_real_amount;
  else
    l_down_draw_unit   := 0;
    l_down_draw_face   := 0;
    l_down_draw_amount := 0;
    l_down_real_amount := 0;
  end if;
  --===================================获取公司结算信息=================================

  ---4. 是否需要结算给公司
  select t.company_id
    into l_up_company_id
    from fd_base_up_channel t
   where t.channel_no = v_up_channel_no;

  l_settle_status := pkg_settle_status.no_need;
  if (l_up_company_id != l_down_company_id) then
    l_settle_status := pkg_settle_status.wait_settle;
  end if;

  --======================================上游减款=====================================

  ---5.1获取并修改账户余额
  select t.query_balance, t.inner_balance
    into l_query_balance, l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  update fd_base_up_account t
     set t.inner_balance = (l_inner_balance - v_up_draw_amount)
   where t.account_id = v_up_account_id;

  l_profits         := l_down_real_amount - v_up_real_amount;
  l_down_commission := l_down_draw_amount - l_down_real_amount;
  l_up_commission   := v_up_draw_amount - v_up_real_amount;

  ---6.添加上游资金变动
  insert into fd_trade_up_fund
    (record_id,
     fd_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     order_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     memo,
     out_change_time)
  values
    (seq_trade_up_fund_id.nextval,
     l_fd_order_id,
     v_trade_order_no,
     v_order_source,
     v_trade_delivery_no,
     l_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_up_channel_no,
     v_up_account_id,
     l_up_company_id,
     l_down_draw_unit,
     l_down_draw_face,
     l_down_draw_amount,
     l_down_real_amount,
     v_up_draw_unit,
     v_up_draw_face,
     v_up_draw_amount,
     v_up_real_amount,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     l_business_type,
     l_carrier_no,
     l_province_no,
     (l_inner_balance - v_up_draw_amount),
     l_profits,
     l_down_commission,
     l_up_commission,
     0,
     l_settle_status,
     v_memo,
     to_date(v_out_change_time, 'yyyy-mm-dd hh24:mi:ss'));

  ---7.添加订单差异表数据
  l_result := fd_f_trade_fund_ms_differ_add(l_fd_order_id,
                                            pkg_trade_type.up_debit,
                                            l_down_channel_no,
                                            l_down_account_id,
                                            l_business_type,
                                            v_bill_type,
                                            l_order_all_face,
                                            l_order_all_amount,
                                            l_down_draw_face,
                                            l_down_draw_amount,
                                            v_up_draw_face);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_ORDER_MINUS_T
prompt =============================================
prompt
create or replace function fd_account.fd_f_trade_up_order_minus_t(v_order_source      number,
                                                       v_trade_order_no    varchar2,
                                                       v_trade_delivery_no varchar2,
                                                       v_up_channel_no     varchar2,
                                                       v_up_account_id     number,
                                                       v_up_draw_unit      number,
                                                       v_up_draw_face      number,
                                                       v_up_draw_amount    number,
                                                       v_up_real_amount    number,
                                                       v_down_draw_unit    number,
                                                       v_down_draw_face    number,
                                                       v_down_draw_amount  number,
                                                       v_down_real_amount  number,
                                                       v_bill_type         number,
                                                       v_pay_time          varchar2,
                                                       v_order_time        varchar2,
                                                       v_memo              varchar2)
  return varchar2 is
  l_down_order_all_unit number;
  l_down_order_all_face number;
  l_down_debit_now_unit number;
  l_down_debit_now_face number;
  l_down_draw_unit      number;
  l_down_draw_face      number;
  l_down_draw_amount    number;
  l_down_real_amount    number;

  l_up_company_id   number;
  l_down_channel_no varchar2(32);
  l_down_company_id number;
  l_inner_balance   number;
  l_query_balance   number;
  l_fd_order_id     number;
  l_pay_count       number;
  l_settle_status   number;
  l_down_account_id number;
  l_business_type   number;
  l_carrier_no      varchar2(32);
  l_province_no     varchar2(32);
  l_city_no         varchar2(32);

  l_profits         number;
  l_down_commission number;
  l_up_commission   number;
  l_has_up_trade    number;
  -------------------上游减款----------------------
begin

  --===============================检查订单支付情况==================================
  ---1.锁支付订单
  select t.fd_order_id,
         t.down_channel_no,
         t.down_account_id,
         t.down_company_id,
         t.recharge_unit,
         t.total_face,
         t.business_type,
         t.carrier_no,
         t.province_no,
         t.city_no,
         t.has_up_trade
    into l_fd_order_id,
         l_down_channel_no,
         l_down_account_id,
         l_down_company_id,
         l_down_order_all_unit,
         l_down_order_all_face,
         l_business_type,
         l_carrier_no,
         l_province_no,
         l_city_no,
         l_has_up_trade
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查订单是否已支付
  select count(1)
    into l_pay_count
    from fd_trade_up_fund t
   where t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  if (l_pay_count > 0) then
    return pkg_error_code.success;
  end if;

  ---3.计算下游规格、订单金额
  select sum(t.down_draw_unit), sum(t.down_draw_face)
    into l_down_debit_now_unit, l_down_debit_now_face
    from fd_trade_up_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type = pkg_up_fund_change_type.debit_amount;

  if (l_down_order_all_face <= l_down_debit_now_face) then
    l_down_draw_unit   := 0;
    l_down_draw_face   := 0;
    l_down_draw_amount := 0;
    l_down_real_amount := 0;
  elsif ((l_down_order_all_face - l_down_debit_now_face) < v_down_draw_face) then
    l_down_draw_unit   := l_down_order_all_unit - l_down_debit_now_unit;
    l_down_draw_face   := l_down_order_all_face - l_down_debit_now_face;
    l_down_draw_amount := (l_down_draw_face / v_down_draw_face) *
                          v_down_draw_amount;
    l_down_real_amount := (l_down_draw_face / v_down_draw_face) *
                          v_down_real_amount;
  else
    l_down_draw_unit   := v_down_draw_unit;
    l_down_draw_face   := v_down_draw_face;
    l_down_draw_amount := v_down_draw_amount;
    l_down_real_amount := v_down_real_amount;
  end if;

  --===================================获取公司结算信息=================================

  ---4. 是否需要结算给公司
  select t.company_id
    into l_up_company_id
    from fd_base_up_channel t
   where t.channel_no = v_up_channel_no;

  l_settle_status := pkg_settle_status.no_need;
  if (l_up_company_id != l_down_company_id) then
    l_settle_status := pkg_settle_status.wait_settle;
  end if;

  --======================================上游减款=====================================
  ---5.0修改订单中的下游支付状态
  if l_has_up_trade = 1 then
    update fd_trade_order_main t
       set t.has_up_trade = 0
     where t.fd_order_id = l_fd_order_id;
  end if;

  ---5.1获取并修改账户余额
  select t.query_balance, t.inner_balance
    into l_query_balance, l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  update fd_base_up_account t
     set t.inner_balance = (l_inner_balance - v_up_draw_amount)
   where t.account_id = v_up_account_id;

  l_profits         := l_down_real_amount - v_up_real_amount;
  l_down_commission := l_down_draw_amount - l_down_real_amount;
  l_up_commission   := v_up_draw_amount - v_up_real_amount;

  ---6.添加上游资金变动
  insert into fd_trade_up_fund
    (record_id,
     fd_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     order_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     memo)
  values
    (seq_trade_up_fund_id.nextval,
     l_fd_order_id,
     v_trade_order_no,
     v_order_source,
     v_trade_delivery_no,
     l_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_up_channel_no,
     v_up_account_id,
     l_up_company_id,
     l_down_draw_unit,
     l_down_draw_face,
     l_down_draw_amount,
     l_down_real_amount,
     v_up_draw_unit,
     v_up_draw_face,
     v_up_draw_amount,
     v_up_real_amount,
     to_date(v_pay_time, 'yyyy-mm-dd hh24:mi:ss'),
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     l_business_type,
     l_carrier_no,
     l_province_no,
     (l_inner_balance - v_up_draw_amount),
     l_profits,
     l_down_commission,
     l_up_commission,
     0,
     l_settle_status,
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_ORDER_REFUND
prompt ============================================
prompt
create or replace function fd_account.fd_f_trade_up_order_refund(v_order_source          number,
                                                      v_down_channel_no       varchar2,
                                                      v_up_channel_no         varchar2,
                                                      v_trade_order_no        varchar2,
                                                      v_trade_delivery_no     varchar2,
                                                      v_trade_refund_no       varchar2,
                                                      v_bill_type             number,
                                                      v_business_type         number,
                                                      v_carrier_no            varchar2,
                                                      v_province_no           varchar2,
                                                      v_up_refund_unit        number,
                                                      v_up_refund_face        number,
                                                      v_up_refund_amount      number,
                                                      v_up_refund_real_amount number,
                                                      v_order_time            varchar2,
                                                      v_service_fee           number,
                                                      v_memo                  varchar2)
  return varchar2 is

  ------------上游订单退款------------
  l_fd_order_id      number;
  l_refund_count     number;
  l_up_company_id    number;
  l_settle_amount    number;
  l_settle_status    number;
  l_query_balance    number;
  l_inner_balance    number;
  l_down_account_id  number;
  l_down_company_id  number;
  l_total_pay        number;
  l_total_refund     number;
  l_up_account_id    number;
  l_up_fund_id       number;
  l_down_refund_face number;
  l_up_refund_face   number;
  l_up_draw_face     number;
  l_order_face       number;
  l_face_differ      number;
  l_up_down_face     number;
  l_up_down_unit     number;
  l_up_down_amount   number;
  l_up_down_real     number;

  l_up_all_down_face   number;
  l_up_all_down_unit   number;
  l_up_all_down_amount number;
  l_up_all_down_real   number;

  l_order_amount  number;
  l_up_all_face   number;
  l_debit_count   number;
  l_business_type number;
  l_result        varchar2(32);
begin
  --=============================检查订单重复退款、金额错误==============================
  ---1.锁下游订单
  select t.fd_order_id,
         t.down_account_id,
         t.down_company_id,
         t.total_face,
         t.down_order_amount,
         t.business_type
    into l_fd_order_id,
         l_down_account_id,
         l_down_company_id,
         l_order_face,
         l_order_amount,
         l_business_type
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查重复退款
  select count(1)
    into l_refund_count
    from fd_trade_up_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = v_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  ---2.1检查退款时是否有扣款
  select count(1)
    into l_debit_count
    from fd_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---3.获取上游支付扣款、已退款金额
  select t.up_draw_amount,
         t.up_account_id,
         t.settle_amount,
         t.up_company_id,
         t.up_draw_face
    into l_total_pay,
         l_up_account_id,
         l_settle_amount,
         l_up_company_id,
         l_up_draw_face
    from fd_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  select nvl(sum(t.up_draw_amount), 0), nvl(sum(t.up_draw_face), 0)
    into l_total_refund, l_up_refund_face
    from fd_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.refund_amount;

  ---4.检查退款金额是否超过上游支付总金额
  if (v_up_refund_amount > (l_total_pay - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;

  ---5.计算上游资金变动的下游信息
  select nvl(sum(t.refund_face), 0)
    into l_down_refund_face
    from fd_trade_down_refund t
   where t.fd_order_id = l_fd_order_id;

  select nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.up_draw_face),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_unit),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_face),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_amount),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_real_amount),
             0)
    into l_up_all_face,
         l_up_all_down_unit,
         l_up_all_down_face,
         l_up_all_down_amount,
         l_up_all_down_real
    from fd_trade_up_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type in
         (pkg_up_fund_change_type.debit_amount,
          pkg_up_fund_change_type.refund_amount);

  l_face_differ := l_up_all_face - (l_order_face - l_down_refund_face);
  if (l_face_differ >= v_up_refund_face) then
    l_up_down_face   := 0;
    l_up_down_unit   := 0;
    l_up_down_amount := 0;
    l_up_down_real   := 0;
  elsif l_face_differ > 0 then
    l_up_down_face   := v_up_refund_face - l_face_differ;
    l_up_down_unit   := l_up_all_down_unit *
                        (v_up_refund_face / l_up_all_down_face) *
                        (1 - (l_face_differ / v_up_refund_face));
    l_up_down_amount := l_up_all_down_amount *
                        (v_up_refund_face / l_up_all_down_face) *
                        (1 - (l_face_differ / v_up_refund_face));
    l_up_down_real   := l_up_all_down_real *
                        (v_up_refund_face / l_up_all_down_face) *
                        (1 - (l_face_differ / v_up_refund_face));
  else
    l_up_down_face   := v_up_refund_face;
    l_up_down_unit   := l_up_all_down_unit *
                        (v_up_refund_face / l_up_all_down_face);
    l_up_down_amount := l_up_all_down_amount *
                        (v_up_refund_face / l_up_all_down_face);
    l_up_down_real   := l_up_all_down_real *
                        (v_up_refund_face / l_up_all_down_face);
  end if;

  --=============================获取退款结算信息=================================
  ---5.获取公司结算状态
  l_settle_status := pkg_settle_status.no_need;
  if (l_up_company_id != l_down_company_id) then
    l_settle_status := pkg_settle_status.wait_settle;
  end if;

  --==================================上游退款===================================
  ---6.获取并修改账户余额
  select t.query_balance, t.inner_balance
    into l_query_balance, l_inner_balance
    from fd_base_up_account t
   where t.account_id = l_up_account_id
     for update;

  update fd_base_up_account t
     set t.inner_balance =
         (l_inner_balance + v_up_refund_amount)
   where t.account_id = l_up_account_id;

  ---7.添加上游退款记录
  select seq_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into fd_trade_up_refund
    (record_id,
     channel_no,
     account_id,
     fd_order_id,
     trade_order_no,
     trade_delivery_no,
     trade_refund_no,
     order_source,
     refund_time,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund,
     memo)
  values
    (l_up_fund_id,
     v_up_channel_no,
     l_up_account_id,
     l_fd_order_id,
     v_trade_order_no,
     v_trade_delivery_no,
     v_trade_refund_no,
     v_order_source,
     sysdate,
     v_bill_type,
     v_business_type,
     v_carrier_no,
     v_province_no,
     v_up_refund_unit,
     v_up_refund_face,
     v_up_refund_amount,
     v_up_refund_real_amount,
     v_memo);

  ---8.添加上游资金变动
  insert into fd_trade_up_fund
    (record_id,
     fd_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     order_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     memo)
    select l_up_fund_id,
           l_fd_order_id,
           v_trade_order_no,
           v_order_source,
           v_trade_delivery_no,
           v_down_channel_no,
           l_down_account_id,
           l_down_company_id,
           v_up_channel_no,
           l_up_account_id,
           l_up_company_id,
           l_up_down_unit,
           l_up_down_face,
           l_up_down_amount,
           l_up_down_real,
           v_up_refund_unit,
           v_up_refund_face,
           v_up_refund_amount,
           v_up_refund_real_amount,
           sysdate,
           to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
           pkg_up_fund_change_type.refund_amount,
           v_bill_type,
           v_business_type,
           v_carrier_no,
           v_province_no,
           (l_inner_balance + v_up_refund_amount),
           t.profits,
           t.down_commission,
           (v_up_refund_amount - v_up_refund_real_amount),
           l_settle_amount,
           l_settle_status,
           v_memo
      from fd_trade_up_fund t
     where t.fd_order_id = l_fd_order_id
       and t.trade_delivery_no = v_trade_delivery_no
       and t.change_type = pkg_up_fund_change_type.debit_amount
       and rownum <= 1;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---9.记录差异信息
  l_result := fd_f_trade_fund_differ_add(l_fd_order_id,
                                         pkg_trade_type.up_refund,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         v_bill_type,
                                         l_order_face,
                                         l_order_amount,
                                         l_up_down_face,
                                         l_up_down_amount,
                                         v_up_refund_face);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_ORDER_REFUND2
prompt =============================================
prompt
create or replace function fd_account.fd_f_trade_up_order_refund2(v_order_source          number,
                                                       v_down_channel_no       varchar2,
                                                       v_up_channel_no         varchar2,
                                                       v_trade_order_no        varchar2,
                                                       v_trade_delivery_no     varchar2,
                                                       v_trade_refund_no       varchar2,
                                                       v_bill_type             number,
                                                       v_business_type         number,
                                                       v_carrier_no            varchar2,
                                                       v_province_no           varchar2,
                                                       v_up_refund_unit        number,
                                                       v_up_refund_face        number,
                                                       v_up_refund_amount      number,
                                                       v_up_refund_real_amount number,
                                                       v_order_time            varchar2,
                                                       v_service_fee           number,
                                                       v_memo                  varchar2,
                                                       v_out_change_time       varchar2)
  return varchar2 is

  ------------上游订单退款------------
  l_fd_order_id      number;
  l_refund_count     number;
  l_up_company_id    number;
  l_settle_amount    number;
  l_settle_status    number;
  l_query_balance    number;
  l_inner_balance    number;
  l_down_account_id  number;
  l_down_company_id  number;
  l_total_pay        number;
  l_total_refund     number;
  l_up_account_id    number;
  l_up_fund_id       number;
  l_down_refund_face number;
  l_up_refund_face   number;
  l_up_draw_face     number;
  l_order_face       number;
  l_face_differ      number;
  l_up_down_face     number;
  l_up_down_unit     number;
  l_up_down_amount   number;
  l_up_down_real     number;

  l_up_all_down_face   number;
  l_up_all_down_unit   number;
  l_up_all_down_amount number;
  l_up_all_down_real   number;

  l_order_amount  number;
  l_up_all_face   number;
  l_debit_count   number;
  l_business_type number;
  l_result        varchar2(32);
begin
  --=============================检查订单重复退款、金额错误==============================
  ---1.锁下游订单
  select t.fd_order_id,
         t.down_account_id,
         t.down_company_id,
         t.total_face,
         t.down_order_amount,
         t.business_type
    into l_fd_order_id,
         l_down_account_id,
         l_down_company_id,
         l_order_face,
         l_order_amount,
         l_business_type
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查重复退款
  select count(1)
    into l_refund_count
    from fd_trade_up_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = v_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  ---2.1检查退款时是否有扣款
  select count(1)
    into l_debit_count
    from fd_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---3.获取上游支付扣款、已退款金额
  select t.up_draw_amount,
         t.up_account_id,
         t.settle_amount,
         t.up_company_id,
         t.up_draw_face
    into l_total_pay,
         l_up_account_id,
         l_settle_amount,
         l_up_company_id,
         l_up_draw_face
    from fd_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  select nvl(sum(t.up_draw_amount), 0), nvl(sum(t.up_draw_face), 0)
    into l_total_refund, l_up_refund_face
    from fd_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.refund_amount;

  ---4.检查退款金额是否超过上游支付总金额
  if (v_up_refund_amount > (l_total_pay - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;

  ---5.计算上游资金变动的下游信息
  select nvl(sum(t.refund_face), 0)
    into l_down_refund_face
    from fd_trade_down_refund t
   where t.fd_order_id = l_fd_order_id;

  select nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.up_draw_face),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_unit),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_face),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_amount),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_real_amount),
             0)
    into l_up_all_face,
         l_up_all_down_unit,
         l_up_all_down_face,
         l_up_all_down_amount,
         l_up_all_down_real
    from fd_trade_up_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type in
         (pkg_up_fund_change_type.debit_amount,
          pkg_up_fund_change_type.refund_amount);

  l_face_differ := l_up_all_face - (l_order_face - l_down_refund_face);
  if (l_face_differ >= v_up_refund_face) then
    l_up_down_face   := 0;
    l_up_down_unit   := 0;
    l_up_down_amount := 0;
    l_up_down_real   := 0;
  elsif l_face_differ > 0 then
    l_up_down_face   := v_up_refund_face - l_face_differ;
    l_up_down_unit   := l_up_all_down_unit *
                        (v_up_refund_face / l_up_all_down_face) *
                        (1 - (l_face_differ / v_up_refund_face));
    l_up_down_amount := l_up_all_down_amount *
                        (v_up_refund_face / l_up_all_down_face) *
                        (1 - (l_face_differ / v_up_refund_face));
    l_up_down_real   := l_up_all_down_real *
                        (v_up_refund_face / l_up_all_down_face) *
                        (1 - (l_face_differ / v_up_refund_face));
  else
    l_up_down_face   := v_up_refund_face;
    l_up_down_unit   := l_up_all_down_unit *
                        (v_up_refund_face / l_up_all_down_face);
    l_up_down_amount := l_up_all_down_amount *
                        (v_up_refund_face / l_up_all_down_face);
    l_up_down_real   := l_up_all_down_real *
                        (v_up_refund_face / l_up_all_down_face);
  end if;

  --=============================获取退款结算信息=================================
  ---5.获取公司结算状态
  l_settle_status := pkg_settle_status.no_need;
  if (l_up_company_id != l_down_company_id) then
    l_settle_status := pkg_settle_status.wait_settle;
  end if;

  --==================================上游退款===================================
  ---6.获取并修改账户余额
  select t.query_balance, t.inner_balance
    into l_query_balance, l_inner_balance
    from fd_base_up_account t
   where t.account_id = l_up_account_id
     for update;

  update fd_base_up_account t
     set t.inner_balance =
         (l_inner_balance + v_up_refund_amount)
   where t.account_id = l_up_account_id;

  ---7.添加上游退款记录
  select seq_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into fd_trade_up_refund
    (record_id,
     channel_no,
     account_id,
     fd_order_id,
     trade_order_no,
     trade_delivery_no,
     trade_refund_no,
     order_source,
     refund_time,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund,
     memo)
  values
    (l_up_fund_id,
     v_up_channel_no,
     l_up_account_id,
     l_fd_order_id,
     v_trade_order_no,
     v_trade_delivery_no,
     v_trade_refund_no,
     v_order_source,
     sysdate,
     v_bill_type,
     v_business_type,
     v_carrier_no,
     v_province_no,
     v_up_refund_unit,
     v_up_refund_face,
     v_up_refund_amount,
     v_up_refund_real_amount,
     v_memo);

  ---8.添加上游资金变动
  insert into fd_trade_up_fund
    (record_id,
     fd_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     order_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     memo,
     out_change_time)
    select l_up_fund_id,
           l_fd_order_id,
           v_trade_order_no,
           v_order_source,
           v_trade_delivery_no,
           v_down_channel_no,
           l_down_account_id,
           l_down_company_id,
           v_up_channel_no,
           l_up_account_id,
           l_up_company_id,
           l_up_down_unit,
           l_up_down_face,
           l_up_down_amount,
           l_up_down_real,
           v_up_refund_unit,
           v_up_refund_face,
           v_up_refund_amount,
           v_up_refund_real_amount,
           sysdate,
           to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
           pkg_up_fund_change_type.refund_amount,
           v_bill_type,
           v_business_type,
           v_carrier_no,
           v_province_no,
           (l_inner_balance + v_up_refund_amount),
           t.profits,
           t.down_commission,
           (v_up_refund_amount - v_up_refund_real_amount),
           l_settle_amount,
           l_settle_status,
           v_memo,
           to_date(v_out_change_time, 'yyyy-mm-dd hh24:mi:ss')
      from fd_trade_up_fund t
     where t.fd_order_id = l_fd_order_id
       and t.trade_delivery_no = v_trade_delivery_no
       and t.change_type = pkg_up_fund_change_type.debit_amount
       and rownum <= 1;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---9.记录差异信息
  l_result := fd_f_trade_fund_differ_add(l_fd_order_id,
                                         pkg_trade_type.up_refund,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         v_bill_type,
                                         l_order_face,
                                         l_order_amount,
                                         l_up_down_face,
                                         l_up_down_amount,
                                         v_up_refund_face);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_ORDER_REFUND_MS
prompt ===============================================
prompt
create or replace function fd_account.fd_f_trade_up_order_refund_ms(v_order_source          number,
                                                         v_down_channel_no       varchar2,
                                                         v_up_channel_no         varchar2,
                                                         v_trade_order_no        varchar2,
                                                         v_trade_delivery_no     varchar2,
                                                         v_trade_refund_no       varchar2,
                                                         v_bill_type             number,
                                                         v_business_type         number,
                                                         v_carrier_no            varchar2,
                                                         v_province_no           varchar2,
                                                         v_up_refund_unit        number,
                                                         v_up_refund_face        number,
                                                         v_up_refund_amount      number,
                                                         v_up_refund_real_amount number,
                                                         v_order_time            varchar2,
                                                         v_service_fee           number,
                                                         v_memo                  varchar2,
                                                         v_out_change_time       varchar2)
  return varchar2 is

  ----------------------------
  --功能：短信平台上游订单退款专用
  --创建人：周荣省
  --创建时间：2019-05-20
  ----------------------------
  l_fd_order_id        number;
  l_refund_count       number;
  l_up_company_id      number;
  l_settle_amount      number;
  l_settle_status      number;
  l_query_balance      number;
  l_inner_balance      number;
  l_down_account_id    number;
  l_down_company_id    number;
  l_total_pay          number;
  l_total_refund       number;
  l_up_account_id      number;
  l_up_fund_id         number;
  l_down_refund_face   number;
  l_down_refund_amount number;
  l_up_refund_face     number;
  l_up_draw_face       number;
  l_order_face         number;
  l_face_differ        number;
  l_up_down_face       number;
  l_up_down_unit       number;
  l_up_down_amount     number;
  l_up_down_real       number;

  l_up_all_down_face   number;
  l_up_all_down_unit   number;
  l_up_all_down_amount number;
  l_up_all_down_real   number;

  l_order_amount  number;
  l_up_all_face   number;
  l_debit_count   number;
  l_business_type number;
  l_result        varchar2(32);
begin
  --=============================检查订单重复退款、金额错误==============================
  ---1.锁下游订单
  select t.fd_order_id,
         t.down_account_id,
         t.down_company_id,
         t.total_face,
         t.down_order_amount,
         t.business_type
    into l_fd_order_id,
         l_down_account_id,
         l_down_company_id,
         l_order_face,
         l_order_amount,
         l_business_type
    from fd_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;

  ---2.检查重复退款
  select count(1)
    into l_refund_count
    from fd_trade_up_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = v_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  ---2.1检查退款时是否有扣款
  select count(1)
    into l_debit_count
    from fd_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---3.获取上游支付扣款、已退款金额
  select t.up_draw_amount,
         t.up_account_id,
         t.settle_amount,
         t.up_company_id,
         t.up_draw_face
    into l_total_pay,
         l_up_account_id,
         l_settle_amount,
         l_up_company_id,
         l_up_draw_face
    from fd_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.debit_amount
     and rownum <= 1;

  select nvl(sum(t.up_draw_amount), 0), nvl(sum(t.up_draw_face), 0)
    into l_total_refund, l_up_refund_face
    from fd_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = pkg_up_fund_change_type.refund_amount;

  ---4.检查退款金额是否超过上游支付总金额
  if (v_up_refund_amount > (l_total_pay - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;

  ---5.计算上游资金变动的下游信息
  select nvl(sum(t.refund_face), 0), nvl(sum(t.refund_amount), 0)
    into l_down_refund_face, l_down_refund_amount
    from fd_trade_down_refund t
   where t.fd_order_id = l_fd_order_id;

  select nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.up_draw_face),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_unit),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_face),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_draw_amount),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_up_fund_change_type.debit_amount,
                        1,
                        -1) * t.down_real_amount),
             0)
    into l_up_all_face,
         l_up_all_down_unit,
         l_up_all_down_face,
         l_up_all_down_amount,
         l_up_all_down_real
    from fd_trade_up_fund t
   where t.fd_order_id = l_fd_order_id
     and t.change_type in (pkg_up_fund_change_type.debit_amount,
          pkg_up_fund_change_type.refund_amount);

  if l_down_refund_amount > 0 then
    --下游已经退款
    l_up_down_face   := 0;
    l_up_down_unit   := 0;
    l_up_down_amount := 0;
    l_up_down_real   := 0;
  else
    l_up_down_face   := l_up_all_down_face;
    l_up_down_unit   := l_up_all_down_unit;
    l_up_down_amount := l_up_all_down_amount;
    l_up_down_real   := l_up_all_down_real;
  end if;

  --=============================获取退款结算信息=================================
  ---5.获取公司结算状态
  l_settle_status := pkg_settle_status.no_need;
  if (l_up_company_id != l_down_company_id) then
    l_settle_status := pkg_settle_status.wait_settle;
  end if;

  --==================================上游退款===================================
  ---6.获取并修改账户余额
  select t.query_balance, t.inner_balance
    into l_query_balance, l_inner_balance
    from fd_base_up_account t
   where t.account_id = l_up_account_id
     for update;

  update fd_base_up_account t
     set t.inner_balance = (l_inner_balance + v_up_refund_amount)
   where t.account_id = l_up_account_id;

  ---7.添加上游退款记录
  select seq_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into fd_trade_up_refund
    (record_id,
     channel_no,
     account_id,
     fd_order_id,
     trade_order_no,
     trade_delivery_no,
     trade_refund_no,
     order_source,
     refund_time,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund,
     memo)
  values
    (l_up_fund_id,
     v_up_channel_no,
     l_up_account_id,
     l_fd_order_id,
     v_trade_order_no,
     v_trade_delivery_no,
     v_trade_refund_no,
     v_order_source,
     sysdate,
     v_bill_type,
     v_business_type,
     v_carrier_no,
     v_province_no,
     v_up_refund_unit,
     v_up_refund_face,
     v_up_refund_amount,
     v_up_refund_real_amount,
     v_memo);

  ---8.添加上游资金变动
  insert into fd_trade_up_fund
    (record_id,
     fd_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     order_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     memo,
     out_change_time)
    select l_up_fund_id,
           l_fd_order_id,
           v_trade_order_no,
           v_order_source,
           v_trade_delivery_no,
           v_down_channel_no,
           l_down_account_id,
           l_down_company_id,
           v_up_channel_no,
           l_up_account_id,
           l_up_company_id,
           l_up_down_unit,
           l_up_down_face,
           l_up_down_amount,
           l_up_down_real,
           v_up_refund_unit,
           v_up_refund_face,
           v_up_refund_amount,
           v_up_refund_real_amount,
           sysdate,
           to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
           pkg_up_fund_change_type.refund_amount,
           v_bill_type,
           v_business_type,
           v_carrier_no,
           v_province_no,
           (l_inner_balance + v_up_refund_amount),
           t.profits,
           t.down_commission,
           (v_up_refund_amount - v_up_refund_real_amount),
           l_settle_amount,
           l_settle_status,
           v_memo,
           to_date(v_out_change_time, 'yyyy-mm-dd hh24:mi:ss')
      from fd_trade_up_fund t
     where t.fd_order_id = l_fd_order_id
       and t.trade_delivery_no = v_trade_delivery_no
       and t.change_type = pkg_up_fund_change_type.debit_amount
       and rownum <= 1;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---9.记录差异信息
  l_result := fd_f_trade_fund_ms_differ_add(l_fd_order_id,
                                            pkg_trade_type.up_refund,
                                            v_down_channel_no,
                                            l_down_account_id,
                                            l_business_type,
                                            v_bill_type,
                                            l_order_face,
                                            l_order_amount,
                                            l_up_down_face,
                                            l_up_down_amount,
                                            v_up_refund_face);

  return l_result;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_ORDER_REFUND_T
prompt ==============================================
prompt
create or replace function fd_account.fd_f_trade_up_order_refund_t(v_order_source          number,
                                                        v_down_channel_no       varchar2,
                                                        v_up_channel_no         varchar2,
                                                        v_trade_order_no        varchar2,
                                                        v_trade_delivery_no     varchar2,
                                                        v_trade_refund_no       varchar2,
                                                        v_bill_type             number,
                                                        v_business_type         number,
                                                        v_carrier_no            varchar2,
                                                        v_province_no           varchar2,
                                                        v_down_draw_unit        number,
                                                        v_down_draw_face        number,
                                                        v_down_draw_amount      number,
                                                        v_down_real_amount      number,
                                                        v_up_refund_unit        number,
                                                        v_up_refund_face        number,
                                                        v_up_refund_amount      number,
                                                        v_up_refund_real_amount number,
                                                        v_refund_time           varchar2,
                                                        v_memo                  varchar2)
  return varchar2 is

  ------------上游订单退款------------
  l_fd_order_id     number;
  l_refund_count    number;
  l_up_company_id   number;
  l_settle_amount   number;
  l_settle_status   number;
  l_query_balance   number;
  l_inner_balance   number;
  l_down_account_id number;
  l_down_company_id number;
  l_up_account_id   number;
  l_up_fund_id      number;

  l_business_type   number;
  l_carrier_no      varchar2(32);
  l_province_no     varchar2(32);
  l_cn_refund_count number;
  l_cn_fd_order_id  number;
begin
  --=============================检查订单重复退款、金额错误==============================
  ---1.锁下游订单
  begin
    select t.fd_order_id, t.down_account_id, t.down_company_id
      into l_fd_order_id, l_down_account_id, l_down_company_id
      from fd_trade_order_main t
     where t.trade_order_no = v_trade_order_no
       and t.order_source = v_order_source
       and rownum <= 1
       for update;
    --===============================---
    select t.business_type, t.carrier_no, t.province_no
      into l_business_type, l_carrier_no, l_province_no
      from fd_trade_order_main t
     where t.fd_order_id = l_fd_order_id;

    select t.up_account_id, t.up_company_id, t.settle_amount
      into l_up_account_id, l_up_company_id, l_settle_amount
      from fd_trade_up_fund t
     where t.trade_order_no = v_trade_order_no
       and t.trade_delivery_no = v_trade_delivery_no
       and t.order_source = v_order_source
       and t.change_type = pkg_up_fund_change_type.debit_amount
       and rownum <= 1;
  exception
    when no_data_found then
      --===============================---
      l_settle_amount := v_up_refund_amount;

      select seq_trade_order_main_id.nextval into l_fd_order_id from dual;

      select count(1), max(t.fd_order_id)
        into l_cn_refund_count, l_cn_fd_order_id
        from fd_trade_down_fund t
       where t.trade_order_no = v_trade_order_no
         and t.order_source = v_order_source
         and rownum <= 1;

      if (l_cn_refund_count > 0) then
        l_fd_order_id := l_cn_fd_order_id;
      end if;

      select t.account_id, c.company_id
        into l_down_account_id, l_down_company_id
        from fd_base_down_account_map t
       inner join fd_base_down_channel c on t.channel_no = c.channel_no
       where t.channel_no = v_down_channel_no
         and t.is_main_channel = 0;

      select t.account_id, c.company_id
        into l_up_account_id, l_up_company_id
        from fd_base_up_account_map t
       inner join fd_base_up_channel c on t.channel_no = c.channel_no
       where t.channel_no = v_up_channel_no
         and t.is_main_channel = 0;
  end;

  ---2.检查重复退款
  select count(1)
    into l_refund_count
    from fd_trade_up_refund t
   where t.trade_refund_no = v_trade_refund_no
     and t.order_source = v_order_source
     and rownum <= 1;

  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;

  --=============================获取退款结算信息=================================
  ---5.获取公司结算状态
  l_settle_status := pkg_settle_status.no_need;
  if (l_up_company_id != l_down_company_id) then
    l_settle_status := pkg_settle_status.wait_settle;
  end if;

  --==================================上游退款===================================
  ---6.获取并修改账户余额
  select t.query_balance, t.inner_balance
    into l_query_balance, l_inner_balance
    from fd_base_up_account t
   where t.account_id = l_up_account_id
     for update;

  update fd_base_up_account t
     set t.inner_balance = (l_inner_balance + v_up_refund_amount)
   where t.account_id = l_up_account_id;

  ---7.添加上游退款记录
  select seq_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into fd_trade_up_refund
    (record_id,
     channel_no,
     account_id,
     fd_order_id,
     trade_order_no,
     trade_delivery_no,
     trade_refund_no,
     order_source,
     refund_time,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     refund_unit,
     refund_face,
     refund_amount,
     real_refund,
     memo)
  values
    (l_up_fund_id,
     v_up_channel_no,
     l_up_account_id,
     l_fd_order_id,
     v_trade_order_no,
     v_trade_delivery_no,
     v_trade_refund_no,
     v_order_source,
     to_date(v_refund_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_bill_type,
     v_business_type,
     v_carrier_no,
     v_province_no,
     v_up_refund_unit,
     v_up_refund_face,
     v_up_refund_amount,
     v_up_refund_real_amount,
     v_memo);

  ---8.添加上游资金变动

  insert into fd_trade_up_fund
    (record_id,
     fd_order_id,
     trade_order_no,
     order_source,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     memo)
  values
    (l_up_fund_id,
     l_fd_order_id,
     v_trade_order_no,
     v_order_source,
     v_trade_delivery_no,
     v_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_up_channel_no,
     l_up_account_id,
     l_up_company_id,
     0,
     0,
     0,
     0,
     v_up_refund_unit,
     v_up_refund_face,
     v_up_refund_amount,
     v_up_refund_real_amount,
     to_date(v_refund_time, 'yyyy-mm-dd hh24:mi:ss'),
     pkg_up_fund_change_type.refund_amount,
     v_bill_type,
     v_business_type,
     v_carrier_no,
     v_province_no,
     (l_inner_balance + v_up_refund_amount),
     ((v_up_refund_face / v_down_draw_face) * v_down_real_amount -
     v_up_refund_real_amount),
     (v_up_refund_face / v_down_draw_face) *
     (v_down_draw_amount - v_down_real_amount),
     (v_up_refund_amount - v_up_refund_real_amount),
     l_settle_amount,
     l_settle_status,
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_RV_TRADE
prompt ========================================
prompt
create or replace function fd_account.fd_f_trade_up_rv_trade(v_up_channel_no    varchar2,
                                                  v_up_account_id    number,
                                                  v_up_company_id    number,
                                                  v_adjust_record_no varchar2,
                                                  v_up_draw_amount   number,
                                                  v_up_real_amount   number,
                                                  v_business_type    number,
                                                  v_bill_type        number,
                                                  v_create_user      varchar2,
                                                  v_memo             varchar2)
  return varchar2 is
  l_inner_balance    number;
  l_trade_up_fund_id number;
  l_adjust_count     number;
  --------------------下游渠道交易平账-----------------------
begin

  ---1.锁支付账户
  select t.inner_balance, seq_trade_up_fund_id.nextval
    into l_inner_balance, l_trade_up_fund_id
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.检查平账是否已处理
  select count(1)
    into l_adjust_count
    from fd_trade_up_manual t
   where t.ext_record_no = v_adjust_record_no;

  if l_adjust_count > 0 then
    return pkg_error_code.success;
  end if;

  ---3.交易扣款不为零，需要修改支付账户余额
  if v_up_draw_amount != 0 then
    update fd_base_up_account t
       set t.inner_balance  = (l_inner_balance - v_up_draw_amount),
           t.last_edit_user = v_create_user,
           t.last_edit_time = sysdate
     where t.account_id = v_up_account_id;
  end if;

  ---4.添加平账上游人工操作记录

  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     has_adjust,
     ext_record_no)
  values
    (l_trade_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     0,
     pkg_up_manual_change_type.trade_revise,
     v_up_draw_amount,
     sysdate,
     (l_inner_balance - v_up_draw_amount),
     v_memo,
     v_create_user,
     0,
     v_adjust_record_no);

  ---5.添加平账上游资金变动（上游下游公司相同避免结算)
  insert into fd_trade_up_fund
    (record_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     balance,
     memo)
  values
    (l_trade_up_fund_id,
     0,
     0,
     v_up_company_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     0,
     0,
     0,
     0,
     v_up_draw_amount,
     v_up_real_amount,
     sysdate,
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     v_business_type,
     (l_inner_balance - v_up_draw_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_RV_TRADE_CK
prompt ===========================================
prompt
create or replace function fd_account.fd_f_trade_up_rv_trade_ck(v_up_channel_no  varchar2,
                                                     v_up_draw_amount number,
                                                     v_up_real_amount number,
                                                     v_up_account_id  out number,
                                                     v_up_company_id  out number)

 return varchar2 is
begin
  ---1.检查调整金额是否正确
  if (v_up_draw_amount = 0 and v_up_real_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户是否正确
  select t.account_id, c.company_id
    into v_up_account_id, v_up_company_id
    from fd_base_up_account_map t
   inner join fd_base_up_account a on t.account_id = a.account_id
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and rownum <= 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function FD_F_TRADE_UP_STATUS_CHECK
prompt ============================================
prompt
create or replace function fd_account.fd_f_trade_up_status_check(v_up_channel_no varchar2)
  return varchar2 is
  ----------------检查渠道状态是否为2----------------
  l_channel_status number;
begin
  select t.status
    into l_channel_status
    from fd_base_up_channel t
   where t.channel_no = v_up_channel_no
     and t.status != 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.failure;

end;
/

prompt
prompt Creating function FD_P_APPLY_DOWN_RV_CHANNEL
prompt ============================================
prompt
create or replace function fd_account.fd_p_apply_down_rv_channel(v_apply_id        in number,
                                                      v_down_channel_no in varchar2, ---下游渠道编号
                                                      v_down_account_id in number, ---下游支付账户             
                                                      v_revise_amount   in number, ---账户调整金额（可正、可负）
                                                      v_create_user     in varchar2, ---操作人
                                                      v_memo            in varchar2 ---备注
                                                      ) return varchar2 is
  --------------平账、下游手工渠道账户平账---------------
  PRAGMA AUTONOMOUS_TRANSACTION;
  l_fund_id number;
  l_result  varchar2(32);
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游渠道平账',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_revise_amount=' || v_revise_amount));

  ---2.检查渠道与金额是否正确
  l_result := fd_f_manual_down_rv_channel_ck(v_down_channel_no,
                                             v_down_account_id,
                                             v_revise_amount);
  if (l_result != pkg_error_code.success) then
    rollback;
    return l_result;
  end if;

  ---3.渠道账户平账
  l_result := fd_f_manual_down_rv_channel(v_down_channel_no,
                                          v_down_account_id,
                                          1,
                                          v_revise_amount,
                                          v_create_user,
                                          v_memo,
                                          l_fund_id);
  if (l_result != pkg_error_code.success) then
    rollback;
    return l_result;
  end if;

  ---4.完成平账申请记录
  l_result := fd_f_apply_rv_complete(v_apply_id,
                                     v_down_channel_no,
                                     v_down_account_id,
                                     pkg_apply_rv_type.apply_balance_rv,
                                     0,
                                     0,
                                     v_revise_amount,
                                     v_revise_amount,
                                     v_create_user,
                                     l_fund_id,
                                     v_memo);
  if (l_result != pkg_error_code.success) then
    rollback;
    return l_result;
  end if;

  commit;
  return pkg_error_code.success;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_manual_down_rv_channel', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function FD_P_APPLY_DOWN_RV_TRADE
prompt ==========================================
prompt
create or replace function fd_account.fd_p_apply_down_rv_trade(v_apply_id         in number,
                                                    v_down_channel_no  in varchar2, ---下游渠道编号
                                                    v_down_account_id  in number, ---下游支付账户
                                                    v_down_draw_amount in number, ---下游扣款金额
                                                    v_down_real_amount in number, ---下游真实金额
                                                    v_business_type    in number, ---业务类型
                                                    v_bill_type        in number, ---交易类型，1前向，2后向
                                                    v_create_user      in varchar2, ---操作人
                                                    v_memo             in varchar2 ---备注
                                                    ) return varchar2 is
  --------------------下游渠道交易平账-----------------------
  PRAGMA AUTONOMOUS_TRANSACTION;
  l_fund_id number;
  l_result  varchar2(32);
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游渠道交易平账',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id));

  ---2.检查下游渠道及账户
  l_result := fd_f_manual_down_rv_trade_ck(v_down_channel_no,
                                           v_down_account_id,
                                           v_down_draw_amount,
                                           v_down_real_amount);
  if (l_result != pkg_error_code.success) then
    rollback;
    return l_result;
  end if;

  ---3.下游渠道交易平账
  l_result := fd_f_manual_down_rv_trade(v_down_channel_no,
                                        v_down_account_id,
                                        v_down_draw_amount,
                                        v_down_real_amount,
                                        v_business_type,
                                        v_bill_type,
                                        v_create_user,
                                        v_memo,
                                        null,
                                        l_fund_id);
  if (l_result != pkg_error_code.success) then
    rollback;
    return l_result;
  end if;

  ---4.完成平账申请记录
  l_result := fd_f_apply_rv_complete(v_apply_id,
                                     v_down_channel_no,
                                     v_down_account_id,
                                     pkg_apply_rv_type.apply_trade_rv,
                                     v_business_type,
                                     v_bill_type,
                                     v_down_draw_amount,
                                     v_down_real_amount,
                                     v_create_user,
                                     l_fund_id,
                                     v_memo);
  if (l_result != pkg_error_code.success) then
    rollback;
    return l_result;
  end if;

  commit;
  return pkg_error_code.success;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_manual_down_rv_trade', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function FD_P_APPLY_UP_RV_CHANNEL
prompt ==========================================
prompt
create or replace function fd_account.fd_p_apply_up_rv_channel(v_apply_id      number,
                                                    v_up_channel_no in varchar2, ---上游游渠道编号
                                                    v_up_account_id in number, ---上游支付账户编号
                                                    v_revise_amount in number, ---账户调整金额（可正、可负）
                                                    v_create_user   in varchar2, ---操作人
                                                    v_memo          in varchar2 ---备注
                                                    ) return varchar2 is
  --------------平账、上游手工渠道账户平账---------------
  PRAGMA AUTONOMOUS_TRANSACTION;
  l_fund_id number;
  l_result  varchar2(32);
begin
  ---1.记录操作日志
  fd_p_write_handle_log('上游渠道平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_revise_amount=' || v_revise_amount));

  ---2.检查渠道与金额是否正确
  l_result := fd_f_manual_up_rv_channel_ck(v_up_channel_no,
                                           v_up_account_id,
                                           v_revise_amount);
  if (l_result != pkg_error_code.success) then
    rollback;
    return l_result;
  end if;

  ---3.渠道账户平账
  l_result := fd_f_manual_up_rv_channel(v_up_channel_no,
                                        v_up_account_id,
                                        1,
                                        v_revise_amount,
                                        v_create_user,
                                        v_memo,
                                        l_fund_id);
  if (l_result != pkg_error_code.success) then
    rollback;
    return l_result;
  end if;

  ---4.完成平账申请记录
  l_result := fd_f_apply_rv_complete(v_apply_id,
                                     v_up_channel_no,
                                     v_up_account_id,
                                     pkg_apply_rv_type.apply_balance_rv,
                                     0,
                                     0,
                                     v_revise_amount,
                                     v_revise_amount,
                                     v_create_user,
                                     l_fund_id,
                                     v_memo);
  if (l_result != pkg_error_code.success) then
    rollback;
    return l_result;
  end if;

  commit;
  return pkg_error_code.success;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_manual_up_rv_channel', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function FD_P_APPLY_UP_RV_TRADE
prompt ========================================
prompt
create or replace function fd_account.fd_p_apply_up_rv_trade(v_apply_id       number,
                                                  v_up_channel_no  in varchar2, ---上游渠道编号
                                                  v_up_account_id  in number, ---上游支付账户
                                                  v_up_draw_amount in number, ---上游扣款金额
                                                  v_up_real_amount in number, ---上游真实金额
                                                  v_business_type  in number, ---业务类型
                                                  v_bill_type      in number, ---交易类型，1前向，2后向
                                                  v_create_user    in varchar2, ---操作人
                                                  v_memo           in varchar2 ---备注
                                                  ) return varchar2 is
  --------------------上游渠道交易平账-----------------------
  PRAGMA AUTONOMOUS_TRANSACTION;
  l_fund_id number;
  l_result  varchar2(32);
begin
  ---1.记录操作日志
  fd_p_write_handle_log('上游渠道交易平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id));

  ---2.检查下游渠道及账户
  l_result := fd_f_manual_up_rv_trade_ck(v_up_channel_no,
                                         v_up_account_id,
                                         v_up_draw_amount,
                                         v_up_real_amount);
  if (l_result != pkg_error_code.success) then
    rollback;
    return l_result;
  end if;

  ---3.下游渠道交易平账
  l_result := fd_f_manual_up_rv_trade(v_up_channel_no,
                                      v_up_account_id,
                                      v_up_draw_amount,
                                      v_up_real_amount,
                                      v_business_type,
                                      v_bill_type,
                                      v_create_user,
                                      v_memo,
                                      l_fund_id);
  if (l_result != pkg_error_code.success) then
    rollback;
    return l_result;
  end if;

  ---4.完成平账申请记录
  l_result := fd_f_apply_rv_complete(v_apply_id,
                                     v_up_channel_no,
                                     v_up_account_id,
                                     pkg_apply_rv_type.apply_trade_rv,
                                     v_business_type,
                                     v_bill_type,
                                     v_up_draw_amount,
                                     v_up_real_amount,
                                     v_create_user,
                                     l_fund_id,
                                     v_memo);
  if (l_result != pkg_error_code.success) then
    rollback;
    return l_result;
  end if;

  commit;
  return pkg_error_code.success;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_manual_up_rv_trade', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function INCOME_F_DOWN_CHANNEL_GROUPING
prompt ================================================
prompt
create or replace function fd_account.income_f_down_channel_grouping(v_down_group_id     number, ---下游收入单元分组编号
                                                          v_down_group_name   varchar2, ---下游收入单元分组名称
                                                          v_down_channel_no   varchar2, ---下游收入单元渠道名称
                                                          v_down_channel_name varchar2 ---渠道名称
                                                          ) return varchar2 is
  ----------------下游渠道收入单元分组--------------
  l_down_group_count   number;
  l_down_channel_count number;
begin
  --1.检查分组数据是否存在
  select count(1)
    into l_down_group_count
    from fd_system_dictionary t
   where t.belong_enum = 'DownIncomeGroup'
     and t.value = v_down_group_id;

  --2.分组不存在创建分组
  if l_down_group_count = 0 then
    insert into fd_system_dictionary
      (id,
       value,
       description,
       belong_enum,
       sort_id,
       group_id,
       belong_system,
       status)
    values
      (seq_system_dictionary_id.nextval,
       v_down_group_id,
       v_down_group_name,
       'DownIncomeGroup',
       0,
       '*',
       '*',
       0);
  end if;

  --3.检查渠道分组数据是否存在
  select count(1)
    into l_down_channel_count
    from income_down_group_map t
   where t.channel_no = v_down_channel_no;

  --4.创建修改渠道分组信息
  if l_down_channel_count > 0 then
    update income_down_group_map t
       set t.down_group_id = v_down_group_id,
           t.sync_status   = 1,
           t.channel_name  = v_down_channel_name
     where t.channel_no = v_down_channel_no;
  else
    insert into income_down_group_map
      (id, channel_no, down_group_id, channel_name)
    values
      (seq_income_down_group_mapid.nextval,
       v_down_channel_no,
       v_down_group_id,
       v_down_channel_name);
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function INCOME_F_UP_EXCLUDE_SYNC
prompt ==========================================
prompt
create or replace function fd_account.income_f_up_exclude_sync(v_up_channel_no varchar2,
                                                    v_need_exclude  number)
  return varchar2 is
  --------------上游收入单元排除统计渠道-------------
  l_count number;
begin
  ---1.检查排除信息是否存在
  select count(1)
    into l_count
    from income_exclude_up t
   where t.channel_no = v_up_channel_no;

  if l_count > 0 then
    ---2.排除的修改为需要统计，删除排除信息
    if v_need_exclude = 1 then
      delete from income_exclude_up t where t.channel_no = v_up_channel_no;
    end if;
  else
    ---3.添加需要排除的渠道
    if v_need_exclude = 0 then
      insert into income_exclude_up
        (id, channel_no)
      values
        (seq_income_exclude_upid.nextval, v_up_channel_no);
    end if;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_ADD_ADJUST
prompt =======================================
prompt
create or replace function fd_account.sup_f_down_add_adjust(v_up_channel_no    varchar2,
                                                 v_bank_relate_id   number,
                                                 v_add_change_time  date,
                                                 v_adjust_relate_id number,
                                                 v_memo             varchar2,
                                                 v_created_by       varchar2)
  return varchar2 is
  ------------------上游加款关联下游红冲------------------
  l_down_channel_no varchar2(32);
  l_down_account_id number;
  l_down_balance    number;
  l_credit_amount   number;
  l_add_amount      number;
  l_record_id       number;
  l_down_fund_id    number;
begin
  ---1.获取sup对应下游加款记录
  select t.record_id, t.down_channel_no, t.down_account_id, t.change_amount
    into l_record_id, l_down_channel_no, l_down_account_id, l_add_amount
    from sup_trade_down_manual t
   where t.change_time >= (v_add_change_time - 5 / 24 / 60)
     and t.change_time < (v_add_change_time + 5 / 24 / 60)
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_type = pkg_sup_down_manual_type.add_amount
     and t.bank_relate_id = v_bank_relate_id
     and t.down_channel_no =
         (select m.sup_down_channel_no
            from sup_base_relate_add_map m
           where m.sup_up_channel_no = v_up_channel_no);

  ---2.锁下游渠道账户
  select t.balance, t.credit_amount
    into l_down_balance, l_credit_amount
    from sup_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  ---3.检查下游账户余额
  if l_add_amount > (l_down_balance + l_credit_amount) then
    return pkg_error_code.balance_low;
  end if;

  ---4.下游渠道账户减款
  update sup_base_down_account t
     set t.balance =
         (l_down_balance - l_add_amount)
   where t.account_id = l_down_account_id;

  ---5.红冲下游加款记录
  select seq_sup_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into sup_trade_down_manual
    (record_id,
     down_channel_no,
     down_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     change_amount,
     balance,
     bank_card_no,
     bank_relate_id,
     memo,
     created_by)
    select l_down_fund_id,
           t.down_channel_no,
           t.down_account_id,
           0,
           l_record_id,
           pkg_sup_down_manual_type.red_add,
           sysdate,
           (-1 * l_add_amount),
           (l_down_balance - l_add_amount),
           t.bank_card_no,
           v_adjust_relate_id,
           v_memo,
           v_created_by
      from sup_trade_down_manual t
     where t.record_id = l_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---6.修改原纪录红冲状态 
  update sup_trade_down_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---7.红冲下游加款资金变动记录  
  insert into sup_trade_down_fund
    (record_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     source_system_id,
     change_type,
     change_face,
     change_amount,
     change_time,
     balance,
     memo)
    select l_down_fund_id,
           t.down_channel_no,
           t.down_account_id,
           t.down_company_id,
           t.source_system_id,
           t.change_type,
           (-1 * t.change_face),
           (-1 * l_add_amount),
           sysdate,
           (l_down_balance - l_add_amount),
           v_memo
      from sup_trade_down_fund t
     where t.record_id = l_record_id;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_BALANCE_RV
prompt =======================================
prompt
create or replace function fd_account.sup_f_down_balance_rv(v_down_channel_no varchar2,
                                                 v_rv_amount       number,
                                                 v_down_account_id number,
                                                 v_down_company_id number,
                                                 v_system_id       number,
                                                 v_memo            varchar2,
                                                 v_create_user     varchar2)
  return varchar2 is
  -----------------sup下游渠道账户余额平账----------------
  l_down_balance  number;
  l_down_fund_id  number;
  l_credit_amount number;

begin
  ---1.锁下游渠道账户
  select t.balance, t.credit_amount
    into l_down_balance, l_credit_amount
    from sup_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.检查下游账户余额
  if (v_rv_amount + l_down_balance + l_credit_amount < 0) then
    return pkg_error_code.balance_low;
  end if;

  ---3.下游渠道余额平账
  update sup_base_down_account t
     set t.balance =
         (l_down_balance + v_rv_amount)
   where t.account_id = v_down_account_id;

  ---4.添加下游余额平账记录
  select seq_sup_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into sup_trade_down_manual
    (record_id,
     down_channel_no,
     down_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     change_amount,
     balance,
     memo,
     created_by)
  values
    (l_down_fund_id,
     v_down_channel_no,
     v_down_account_id,
     pkg_sys_boolean.istrue,
     0,
     pkg_sup_down_manual_type.balance_revise,
     sysdate,
     v_rv_amount,
     (l_down_balance + v_rv_amount),
     v_memo,
     v_create_user);

  ---5.添加下游资金变动记录
  insert into sup_trade_down_fund
    (record_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     source_system_id,
     change_type,
     change_face,
     change_amount,
     change_time,
     balance,
     memo)
  values
    (l_down_fund_id,
     v_down_channel_no,
     v_down_account_id,
     v_down_company_id,
     v_system_id,
     pkg_sup_down_fund_type.add_amount,
     0,
     v_rv_amount,
     sysdate,
     (l_down_balance + v_rv_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_BALANCE_RV_CHECK
prompt =============================================
prompt
create or replace function fd_account.sup_f_down_balance_rv_check(v_down_channel_no varchar2,
                                                       v_rv_amount       number,
                                                       v_down_account_id out number,
                                                       v_down_company_id out number,
                                                       v_system_id       out number)
  return varchar2 is
  -----------------下游余额平账基础信息检查----------------
  l_channel_count number;
  l_down_balance  number;
  l_credit_amount number;

begin
  ---1.检查平账金额
  if v_rv_amount = 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查下游渠道及账户信息
  select count(1),
         max(t.account_id),
         max(t.company_id),
         max(t.source_system_id),
         max(a.balance),
         max(a.credit_amount)
    into l_channel_count,
         v_down_account_id,
         v_down_company_id,
         v_system_id,
         l_down_balance,
         l_credit_amount
    from sup_base_down_channel t
   inner join sup_base_down_account a
      on t.account_id = a.account_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   where t.channel_no = v_down_channel_no;

  if l_channel_count != 1 then
    return pkg_error_code.channel_error;
  end if;

  ---3.检查下游账户余额
  if (v_rv_amount + l_down_balance + l_credit_amount < 0) then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_CHANNEL_ADD
prompt ========================================
prompt
create or replace function fd_account.sup_f_down_channel_add(v_down_channel_no varchar2,
                                                  v_down_account_id number,
                                                  v_down_company_id number,
                                                  v_system_id       number,
                                                  v_bank_relate_id  number,
                                                  v_add_face        number,
                                                  v_add_amount      number,
                                                  v_memo            varchar2,
                                                  v_created_by      varchar2)
  return varchar2 is
  -----------------下游渠道加款-------------
  l_down_balance number;
  l_down_fund_id number;
begin
  ---1.锁下游渠道账户
  select t.balance
    into l_down_balance
    from sup_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.下游渠道账户加款
  update sup_base_down_account t
     set t.balance =
         (l_down_balance + v_add_amount)
   where t.account_id = v_down_account_id;

  ---3.添加下游加款记录
  select seq_sup_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into sup_trade_down_manual
    (record_id,
     down_channel_no,
     down_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     change_amount,
     balance,
     bank_relate_id,
     memo,
     created_by)
  values
    (l_down_fund_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     0,
     pkg_sup_down_manual_type.add_amount,
     sysdate,
     v_add_amount,
     (l_down_balance + v_add_amount),
     v_bank_relate_id,
     v_memo,
     v_created_by);

  ---4.添加下游资金变动记录
  insert into sup_trade_down_fund
    (record_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     source_system_id,
     change_type,
     change_face,
     change_amount,
     change_time,
     balance,
     memo)
  values
    (l_down_fund_id,
     v_down_channel_no,
     v_down_account_id,
     v_down_company_id,
     v_system_id,
     pkg_sup_down_fund_type.add_amount,
     v_add_face,
     v_add_amount,
     sysdate,
     (l_down_balance + v_add_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_CHANNEL_CREATE
prompt ===========================================
prompt
create or replace function fd_account.sup_f_down_channel_create(v_channel_no   varchar2,
                                                     v_channel_name varchar2,
                                                     v_company_id   number,
                                                     v_system_id    number,
                                                     v_status       number,
                                                     v_operate_user varchar2,
                                                     v_operate_time varchar2)
  return varchar2 is
  ---------------创建sup下游渠道-------------
  l_down_account_id number;
begin
  ---1.添加下游渠道信息
  select seq_sup_base_down_account_id.nextval
    into l_down_account_id
    from dual;

  insert into sup_base_down_channel
    (channel_no,
     channel_name,
     company_id,
     source_system_id,
     account_id,
     status,
     created_by,
     created_time)
  values
    (v_channel_no,
     v_channel_name,
     v_company_id,
     v_system_id,
     l_down_account_id,
     v_status,
     v_operate_user,
     to_date(v_operate_time, 'yyyy-mm-dd hh24:mi:ss'));

  ---2.添加下游渠道账户信息
  insert into sup_base_down_account
    (account_id,
     account_name,
     balance,
     credit_amount,
     created_by,
     created_time)
  values
    (l_down_account_id,
     v_channel_name,
     0,
     0,
     v_operate_user,
     to_date(v_operate_time, 'yyyy-mm-dd hh24:mi:ss'));

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_CHANNEL_DRAW
prompt =========================================
prompt
create or replace function fd_account.sup_f_down_channel_draw(v_down_channel_no varchar2,
                                                   v_down_account_id number,
                                                   v_down_company_id number,
                                                   v_system_id       number,
                                                   v_bank_relate_id  number,
                                                   v_draw_face       number,
                                                   v_draw_amount     number,
                                                   v_memo            varchar2,
                                                   v_create_user     varchar2)
  return varchar2 is
  -----------------下游渠道减款-------------
  l_down_balance  number;
  l_down_fund_id  number;
  l_credit_amount number;

begin
  ---1.锁下游渠道账户
  select t.balance, t.credit_amount
    into l_down_balance, l_credit_amount
    from sup_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.检查下游渠道账户余额
  if (l_down_balance + l_credit_amount - v_draw_amount < 0) then
    return pkg_error_code.balance_low;
  end if;

  ---3.下游渠道账户减款
  update sup_base_down_account t
     set t.balance =
         (l_down_balance - v_draw_amount)
   where t.account_id = v_down_account_id;

  ---4.添加下游减款记录
  select seq_sup_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into sup_trade_down_manual
    (record_id,
     down_channel_no,
     down_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     change_amount,
     balance,
     bank_relate_id,
     memo,
     created_by)
  values
    (l_down_fund_id,
     v_down_channel_no,
     v_down_account_id,
     1,
     0,
     pkg_sup_down_manual_type.pick_amount,
     sysdate,
     v_draw_amount,
     (l_down_balance - v_draw_amount),
     v_bank_relate_id,
     v_memo,
     v_create_user);

  ---5.添加下游资金变动记录
  insert into sup_trade_down_fund
    (record_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     source_system_id,
     change_type,
     change_face,
     change_amount,
     change_time,
     balance,
     memo)
  values
    (l_down_fund_id,
     v_down_channel_no,
     v_down_account_id,
     v_down_company_id,
     v_system_id,
     pkg_sup_down_fund_type.pick_amount,
     v_draw_face,
     v_draw_amount,
     sysdate,
     (l_down_balance - v_draw_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_CHANNEL_UPDATE
prompt ===========================================
prompt
create or replace function fd_account.sup_f_down_channel_update(v_channel_no   varchar2,
                                                     v_channel_name varchar2,
                                                     v_company_id   number,
                                                     v_system_id    number,
                                                     v_status       number,
                                                     v_operate_user varchar2,
                                                     v_operate_time varchar2)
  return varchar2 is
  ---------------修改sup下游渠道信息-------------
begin
  ---1.修改下游渠道信息
  update sup_base_down_channel t
     set channel_name     = v_channel_name,
         company_id       = v_company_id,
         source_system_id = v_system_id,
         status           = v_status,
         last_edit_user   = v_operate_user,
         last_edit_time   = to_date(v_operate_time, 'yyyy-mm-dd hh24:mi:ss')
   where t.channel_no = v_channel_no;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_DRAW_ADJUST
prompt ========================================
prompt
create or replace function fd_account.sup_f_down_draw_adjust(v_up_channel_no    varchar2,
                                                  v_bank_relate_id   number,
                                                  v_draw_change_time date,
                                                  v_adjust_relate_id number,
                                                  v_memo             varchar2,
                                                  v_created_by       varchar2)
  return varchar2 is
  ------------------上游提款关联下游红冲------------------
  l_down_channel_no varchar2(32);
  l_down_account_id number;
  l_down_balance    number;
  l_credit_amount   number;
  l_draw_amount     number;
  l_record_id       number;
  l_down_fund_id    number;
begin
  ---1.获取sup对应下游减款记录
  select t.record_id, t.down_channel_no, t.down_account_id, t.change_amount
    into l_record_id, l_down_channel_no, l_down_account_id, l_draw_amount
    from sup_trade_down_manual t
   where t.change_time >= (v_draw_change_time - 5 / 24 / 60)
     and t.change_time < (v_draw_change_time + 60 / 24 / 60)
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_type = pkg_sup_down_manual_type.pick_amount
     and t.bank_relate_id = v_bank_relate_id
     and t.down_channel_no =
         (select m.sup_down_channel_no
            from sup_base_relate_add_map m
           where m.sup_up_channel_no = v_up_channel_no);

  ---2.锁下游渠道账户
  select t.balance, t.credit_amount
    into l_down_balance, l_credit_amount
    from sup_base_down_account t
   where t.account_id = l_down_account_id
     for update;

  ---4.下游渠道账户加款
  update sup_base_down_account t
     set t.balance =
         (l_down_balance + l_draw_amount)
   where t.account_id = l_down_account_id;

  ---5.红冲下游加款记录
  select seq_sup_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into sup_trade_down_manual
    (record_id,
     down_channel_no,
     down_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     change_amount,
     balance,
     bank_card_no,
     bank_relate_id,
     memo,
     created_by)
    select l_down_fund_id,
           t.down_channel_no,
           t.down_account_id,
           pkg_sys_boolean.istrue,
           l_record_id,
           pkg_sup_down_manual_type.red_pick,
           sysdate,
           (-1 * l_draw_amount),
           (l_down_balance + l_draw_amount),
           t.bank_card_no,
           v_adjust_relate_id,
           v_memo,
           v_created_by
      from sup_trade_down_manual t
     where t.record_id = l_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---6.修改原纪录红冲状态
  update sup_trade_down_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---7.红冲下游加款资金变动记录
  insert into sup_trade_down_fund
    (record_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     source_system_id,
     change_type,
     change_face,
     change_amount,
     change_time,
     balance,
     memo)
    select l_down_fund_id,
           t.down_channel_no,
           t.down_account_id,
           t.down_company_id,
           t.source_system_id,
           t.change_type,
           t.change_face,
           (-1 * l_draw_amount),
           sysdate,
           (l_down_balance + l_draw_amount),
           v_memo
      from sup_trade_down_fund t
     where t.record_id = l_record_id;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_ORDER_REFUND
prompt =========================================
prompt
create or replace function fd_account.sup_f_down_order_refund(v_down_channel_no varchar2,
                                                   v_down_account_id number,
                                                   v_down_company_id number,
                                                   v_system_id       number,
                                                   v_trade_order_no  varchar2,
                                                   v_trade_refund_no varchar2,
                                                   v_refund_face     number,
                                                   v_refund_amount   number,
                                                   v_order_time      varchar2,
                                                   v_change_time     varchar2,
                                                   v_memo            varchar2)
  return varchar2 is
  ------------------------下游订单退款-----------------------
  l_sup_order_id      number;
  l_refund_count      number;
  l_debit_count       number;
  l_down_balance      number;
  l_complete_face     number;
  l_complete_amount   number;
  l_all_debit_face    number;
  l_all_debit_amount  number;
  l_all_refund_face   number;
  l_all_refund_amount number;
  l_order_count       number;
begin
  ---1.检查订单
  select count(1)
    into l_order_count
    from sup_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.source_system_id = v_system_id;

  if l_order_count = 0 then
    return pkg_error_code.order_not_exists;
  end if;

  ---2.锁订单
  select t.sup_order_id, t.complete_face, t.complete_amount
    into l_sup_order_id, l_complete_face, l_complete_amount
    from sup_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.source_system_id = v_system_id
     for update;

  ---3.检查退款的扣款数据是否存在
  select count(1)
    into l_debit_count
    from sup_trade_down_fund t
   where t.sup_order_id = l_sup_order_id
     and t.trade_order_no = v_trade_order_no
     and t.change_type = pkg_sup_down_fund_type.debit_amount;

  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---4.检查重复退款
  select count(1)
    into l_refund_count
    from sup_trade_down_fund t
   where t.sup_order_id = l_sup_order_id
     and t.trade_order_no = v_trade_order_no
     and t.trade_refund_no = v_trade_refund_no
     and t.change_type = pkg_sup_down_fund_type.refund_amount;

  if l_refund_count > 0 then
    return pkg_error_code.success;
  end if;

  ---5.检查退款金额是否正确
  select nvl(sum(decode(t.change_type,
                        pkg_sup_down_fund_type.debit_amount,
                        1,
                        0) * t.change_face),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_sup_down_fund_type.debit_amount,
                        1,
                        0) * t.change_amount),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_sup_down_fund_type.refund_amount,
                        1,
                        0) * t.change_face),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_sup_down_fund_type.refund_amount,
                        1,
                        0) * t.change_amount),
             0)
    into l_all_debit_face,
         l_all_debit_amount,
         l_all_refund_face,
         l_all_refund_amount
    from sup_trade_down_fund t
   where t.sup_order_id = l_sup_order_id
     and t.trade_order_no = v_trade_order_no
     and t.change_type in
         (pkg_sup_down_fund_type.debit_amount,
          pkg_sup_down_fund_type.refund_amount);

  if v_refund_face > (l_all_debit_face - l_all_refund_face) or
     v_refund_amount > (l_all_debit_amount - l_all_refund_amount) then
  
    return pkg_error_code.amount_error;
  end if;

  ---6.订单完成金额修改
  update sup_trade_order_main t
     set t.complete_face  =
         (l_complete_face + v_refund_face),
         t.complete_amount =
         (l_complete_amount + v_refund_amount)
   where t.sup_order_id = l_sup_order_id;

  ---7.账户退款
  select t.balance
    into l_down_balance
    from sup_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  update sup_base_down_account t
     set t.balance =
         (l_down_balance + v_refund_amount)
   where t.account_id = v_down_account_id;

  ---8.添加资金变动
  insert into sup_trade_down_fund
    (record_id,
     sup_order_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     source_system_id,
     trade_order_no,
     trade_refund_no,
     change_type,
     change_face,
     change_amount,
     change_time,
     trade_order_time,
     trade_change_time,
     balance,
     memo)
  values
    (seq_sup_trade_down_fund_id.nextval,
     l_sup_order_id,
     v_down_channel_no,
     v_down_account_id,
     v_down_company_id,
     v_system_id,
     v_trade_order_no,
     v_trade_refund_no,
     pkg_sup_down_fund_type.refund_amount,
     v_refund_face,
     v_refund_amount,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     (l_down_balance + v_refund_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_PAY_CHECK
prompt ======================================
prompt
create or replace function fd_account.sup_f_down_pay_check(v_down_channel_no     varchar2,
                                                v_business_type       number,
                                                v_order_unit          number,
                                                v_order_face          number,
                                                v_order_amount        number,
                                                v_company_id          out number,
                                                v_system_id           out number,
                                                v_down_account_id     out number,
                                                v_local_business_type out number)
  return varchar2 is
  --------------------下游支付扣款信息检查----------------
  l_channel_count  number;
  l_business_count number;
  l_down_balance   number;
  l_down_credit    number;
begin
  ---1.检查金额
  if v_order_unit <= 0 or v_order_face <= 0 or v_order_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道信息
  select count(1),
         max(t.company_id),
         max(t.source_system_id),
         max(t.account_id),
         max(a.balance),
         max(a.credit_amount)
    into l_channel_count,
         v_company_id,
         v_system_id,
         v_down_account_id,
         l_down_balance,
         l_down_credit
    from sup_base_down_channel t
   inner join sup_base_down_account a
      on t.account_id = a.account_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   where t.channel_no = v_down_channel_no;

  if l_channel_count != 1 then
    return pkg_error_code.channel_error;
  end if;

  ---3.获取本地业务类型
  select count(1), max(t.local_business_type)
    into l_business_count, v_local_business_type
    from fd_system_business_map t
   where t.source_system_id = v_system_id
     and t.outer_business_type = v_business_type;

  if l_business_count != 1 then
    return pkg_error_code.business_type_not_exists;
  end if;

  ---4.检查渠道余额
  if v_order_amount > (l_down_balance + l_down_credit) then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_REFUND_CHECK
prompt =========================================
prompt
create or replace function fd_account.sup_f_down_refund_check(v_down_channel_no varchar2,
                                                   v_refund_face     number,
                                                   v_refund_amount   number,
                                                   v_system_id       out number,
                                                   v_down_company_id out number,
                                                   v_down_account_id out number)
  return varchar2 is
  --------------------下游退款基本信息检查-----------------
  l_channel_count number;
begin
  ---1.检查退款金额
  if v_refund_face <= 0 or v_refund_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道信息
  select count(1),
         max(t.source_system_id),
         max(t.company_id),
         max(t.account_id)
    into l_channel_count, v_system_id, v_down_company_id, v_down_account_id
    from sup_base_down_channel t
   inner join sup_base_down_account a
      on t.account_id = a.account_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   where t.channel_no = v_down_channel_no;

  if l_channel_count != 1 then
    return pkg_error_code.channel_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_TRADE_DEBIT
prompt ========================================
prompt
create or replace function fd_account.sup_f_down_trade_debit(v_down_channel_no varchar2,
                                                  v_down_account_id number,
                                                  v_company_id      number,
                                                  v_system_id       number,
                                                  v_sup_order_id    number,
                                                  v_trade_order_no  varchar2,
                                                  v_business_type   number,
                                                  v_order_face      number,
                                                  v_order_amount    number,
                                                  v_order_time      varchar2,
                                                  v_change_time     varchar2,
                                                  v_memo            varchar2)
  return varchar2 is
  -----------------下游交易扣款------------
  l_order_face      number;
  l_order_amount    number;
  l_down_channel_no varchar2(32);
  l_business_type   number;
  l_down_fund_count number;
  l_down_balance    number;
  l_down_credit     number;
begin
  ---1.锁订单数据
  select t.down_channel_no, t.business_type, t.order_face, t.order_amount
    into l_down_channel_no, l_business_type, l_order_face, l_order_amount
    from sup_trade_order_main t
   where t.sup_order_id = v_sup_order_id
     for update;

  ---2.检查订单信息与扣款信息是否匹配
  if l_down_channel_no != v_down_channel_no or
     l_business_type != v_business_type or l_order_face != v_order_face or
     l_order_amount != v_order_amount then
  
    return pkg_error_code.param_error;
  end if;

  ---3.检查下游扣款是否存在
  select count(1)
    into l_down_fund_count
    from sup_trade_down_fund t
   where t.sup_order_id = v_sup_order_id
     and t.change_type = pkg_sup_down_fund_type.debit_amount
     and rownum <= 1;

  if l_down_fund_count > 0 then
    return pkg_error_code.success;
  end if;

  ---4.锁账户信息
  select t.balance, t.credit_amount
    into l_down_balance, l_down_credit
    from sup_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---5.检查账户余额
  if v_order_amount > (l_down_balance + l_down_credit) then
    return pkg_error_code.balance_low;
  end if;

  ---6.下游渠道扣款
  update sup_base_down_account t
     set t.balance =
         (l_down_balance - v_order_amount)
   where t.account_id = v_down_account_id;

  ---7.添加下游资金变动
  insert into sup_trade_down_fund
    (record_id,
     sup_order_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     source_system_id,
     trade_order_no,
     change_type,
     change_face,
     change_amount,
     change_time,
     trade_order_time,
     trade_change_time,
     balance,
     memo)
  values
    (seq_sup_trade_down_fund_id.nextval,
     v_sup_order_id,
     v_down_channel_no,
     v_down_account_id,
     v_company_id,
     v_system_id,
     v_trade_order_no,
     pkg_sup_down_fund_type.debit_amount,
     v_order_face,
     v_order_amount,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     (l_down_balance - v_order_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_TRADE_RV
prompt =====================================
prompt
create or replace function fd_account.sup_f_down_trade_rv(v_down_channel_no varchar2,
                                               v_rv_count        number,
                                               v_rv_face         number,
                                               v_rv_amount       number,
                                               v_down_account_id number,
                                               v_down_company_id number,
                                               v_system_id       number,
                                               v_bill_type       number,
                                               v_business_type   number,
                                               v_memo            varchar2,
                                               v_create_user     varchar2)
  return varchar2 is
  -----------------sup下游渠道账户交易平账----------------
  l_down_balance  number;
  l_down_fund_id  number;
  l_up_fund_id    number;
  l_credit_amount number;

begin
  ---1.锁下游渠道账户
  select t.balance, t.credit_amount
    into l_down_balance, l_credit_amount
    from sup_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.检查下游账户余额
  if (l_down_balance + l_credit_amount - v_rv_amount < 0) then
    return pkg_error_code.balance_low;
  end if;

  ---3.下游渠道交易平账
  update sup_base_down_account t
     set t.balance =
         (l_down_balance - v_rv_amount)
   where t.account_id = v_down_account_id;

  ---4.添加下游交易平账记录
  select seq_sup_trade_down_fund_id.nextval into l_down_fund_id from dual;

  insert into sup_trade_down_manual
    (record_id,
     down_channel_no,
     down_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     change_amount,
     balance,
     memo,
     created_by)
  values
    (l_down_fund_id,
     v_down_channel_no,
     v_down_account_id,
     pkg_sys_boolean.istrue,
     0,
     pkg_sup_down_manual_type.trade_revise,
     sysdate,
     v_rv_amount,
     (l_down_balance - v_rv_amount),
     v_memo,
     v_create_user);

  ---5.添加下游资金变动记录
  insert into sup_trade_down_fund
    (record_id,
     trade_order_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     source_system_id,
     change_type,
     change_face,
     change_amount,
     change_time,
     balance,
     memo)
  values
    (l_down_fund_id,
     ('SARV' || to_char(sysdate, 'yyyymmddhh24miss')),
     v_down_channel_no,
     v_down_account_id,
     v_down_company_id,
     v_system_id,
     pkg_sup_down_fund_type.debit_amount,
     0,
     v_rv_amount,
     sysdate,
     (l_down_balance - v_rv_amount),
     v_memo);

  ---6.添加对应上游资金变动记录
  select seq_sup_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into sup_trade_up_fund
    (record_id,
     source_system_id,
     trade_order_no,
     up_channel_no,
     up_account_id,
     up_company_id,
     bill_type,
     business_type,
     change_type,
     change_time,
     down_draw_count,
     down_draw_face,
     down_draw_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo)
  values
    (l_up_fund_id,
     v_system_id,
     ('SARV' || to_char(sysdate, 'yyyymmddhh24miss')),
     v_down_channel_no,
     v_down_account_id,
     v_down_company_id,
     v_bill_type,
     v_business_type,
     pkg_sup_up_fund_type.debit_amount,
     sysdate,
     v_rv_count,
     v_rv_face,
     v_rv_amount,
     0,
     0,
     0,
     0,
     0,
     0,
     0,
     0,
     0,
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_DOWN_TRADE_RV_CHECK
prompt ===========================================
prompt
create or replace function fd_account.sup_f_down_trade_rv_check(v_down_channel_no varchar2,
                                                     v_rv_count        number,
                                                     v_rv_face         number,
                                                     v_rv_amount       number,
                                                     v_business_type   number,
                                                     v_down_account_id out number,
                                                     v_down_company_id out number,
                                                     v_system_id       out number)
  return varchar2 is
  -----------------下游交易平账基础信息检查----------------
  l_channel_count  number;
  l_down_balance   number;
  l_credit_amount  number;
  l_business_count number;

begin
  ---1.检查交易平账金额
  if v_rv_amount = 0 or v_rv_count = 0 or v_rv_face = 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查业务类型
  select count(1)
    into l_business_count
    from fd_system_business_statis_map t
   where t.local_business_type = v_business_type;

  if l_business_count != 1 then
    return pkg_error_code.data_error;
  end if;

  ---3.检查下游渠道及账户信息
  select count(1),
         max(t.account_id),
         max(t.company_id),
         max(t.source_system_id),
         max(a.balance),
         max(a.credit_amount)
    into l_channel_count,
         v_down_account_id,
         v_down_company_id,
         v_system_id,
         l_down_balance,
         l_credit_amount
    from sup_base_down_channel t
   inner join sup_base_down_account a
      on t.account_id = a.account_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   where t.channel_no = v_down_channel_no;

  if l_channel_count != 1 then
    return pkg_error_code.channel_error;
  end if;

  ---4.检查下游账户余额
  if (l_down_balance + l_credit_amount - v_rv_amount < 0) then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_HISTORY_DOWN_FUND_MOVE
prompt ==============================================
prompt
create or replace function fd_account.sup_f_history_down_fund_move(v_system_id      number,
                                                        v_trade_order_no varchar2)
  return varchar2 is
  --------------历史库下游资金变动转移当前库-------------
  l_down_fund_count        number;
  l_down_fund_add_count    number;
  l_down_fund_delete_count number;
begin
  ---1.检查历史表下游资金变动是否存在
  select count(1)
    into l_down_fund_count
    from sup_trade_down_fund_hs t
   where t.trade_order_no = v_trade_order_no
     and t.source_system_id = v_system_id;

  if l_down_fund_count != 0 then
    ---2.历史表下游资金变动转移当前库
    insert into sup_trade_down_fund
      (record_id,
       sup_order_id,
       down_channel_no,
       down_account_id,
       down_company_id,
       source_system_id,
       trade_order_no,
       trade_refund_no,
       change_type,
       change_face,
       change_amount,
       change_time,
       trade_order_time,
       trade_change_time,
       balance,
       memo)
      select t.record_id,
             t.sup_order_id,
             t.down_channel_no,
             t.down_account_id,
             t.down_company_id,
             t.source_system_id,
             t.trade_order_no,
             t.trade_refund_no,
             t.change_type,
             t.change_face,
             t.change_amount,
             t.change_time,
             t.trade_order_time,
             t.trade_change_time,
             t.balance,
             t.memo
        from sup_trade_down_fund_hs t
       where t.trade_order_no = v_trade_order_no
         and t.source_system_id = v_system_id;

    l_down_fund_add_count := sql%rowcount;

    ---3.删除历史表资金变动记录
    delete from sup_trade_down_fund_hs t
     where t.trade_order_no = v_trade_order_no
       and t.source_system_id = v_system_id;

    l_down_fund_delete_count := sql%rowcount;

    ---4.检查数据是否一致
    if l_down_fund_add_count != l_down_fund_delete_count or
       l_down_fund_count != l_down_fund_add_count then

      return pkg_error_code.data_error;
    end if;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_HISTORY_ORDER_MOVE
prompt ==========================================
prompt
create or replace function fd_account.sup_f_history_order_move(v_system_id      number,
                                                    v_trade_order_no varchar2)
  return varchar2 is
  ----------------历史库订单转移当前库--------------
  l_order_count        number;
  l_order_add_count    number;
  l_order_delete_count number;
begin
  ---1.检查订单是否存在历史库
  select count(1)
    into l_order_count
    from sup_trade_order_main_hs t
   where t.trade_order_no = v_trade_order_no
     and t.source_system_id = v_system_id;

  if l_order_count > 0 then
    ---2.订单转移当前库
    insert into sup_trade_order_main
      (sup_order_id,
       down_channel_no,
       down_account_id,
       down_company_id,
       source_system_id,
       create_time,
       trade_order_no,
       trade_order_time,
       business_type,
       carrier_no,
       provice_no,
       city_no,
       order_unit,
       order_face,
       order_amount,
       complete_face,
       complete_amount)
      select t.sup_order_id,
             t.down_channel_no,
             t.down_account_id,
             t.down_company_id,
             t.source_system_id,
             t.create_time,
             t.trade_order_no,
             t.trade_order_time,
             t.business_type,
             t.carrier_no,
             t.provice_no,
             t.city_no,
             t.order_unit,
             t.order_face,
             t.order_amount,
             t.complete_face,
             t.complete_amount
        from sup_trade_order_main_hs t
       where t.trade_order_no = v_trade_order_no
         and t.source_system_id = v_system_id;
  
    l_order_add_count := sql%rowcount;
  
    ---3.删除历史库订单数据
    delete from sup_trade_order_main_hs t
     where t.trade_order_no = v_trade_order_no
       and t.source_system_id = v_system_id;
  
    l_order_delete_count := sql%rowcount;
  
    ---4.检查数据是否一致
    if l_order_add_count != l_order_delete_count or
       l_order_count != l_order_add_count then
    
      return pkg_error_code.data_error;
    end if;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_HISTORY_UP_FUND_MOVE
prompt ============================================
prompt
create or replace function fd_account.sup_f_history_up_fund_move(v_system_id      number,
                                                      v_trade_order_no varchar2)
  return varchar2 is
  ----------------上游资金变动转移当前库--------------
  l_up_fund_count        number;
  l_up_fund_add_count    number;
  l_up_fund_delete_count number;
begin
  ---1.检查历史表中上游资金变动数据是否存在
  select count(1)
    into l_up_fund_count
    from sup_trade_up_fund_hs t
   where t.trade_order_no = v_trade_order_no
     and t.source_system_id = v_system_id;

  if l_up_fund_count != 0 then
    ---2.历史表中数据转移当前库
    insert into sup_trade_up_fund
      (record_id,
       sup_order_id,
       source_system_id,
       trade_order_no,
       trade_delivery_no,
       trade_refund_no,
       down_channel_no,
       down_account_id,
       down_company_id,
       up_channel_no,
       up_account_id,
       up_company_id,
       change_type,
       change_time,
       trade_order_time,
       trade_change_time,
       bill_type,
       business_type,
       carrier_no,
       province_no,
       city_no,
       down_draw_count,
       down_draw_unit,
       down_draw_face,
       down_draw_amount,
       up_draw_count,
       up_draw_unit,
       up_draw_face,
       up_draw_amount,
       way_change_count,
       way_change_face,
       way_change_amount,
       physical_change_count,
       physical_change_face,
       physical_change_amount,
       way_count_balance,
       way_face_balance,
       way_card_balance,
       physical_count_balance,
       physical_face_balance,
       physical_card_balance,
       electronic_count_balance,
       electronic_face_balance,
       electronic_card_balance,
       memo)
      select t.record_id,
             t.sup_order_id,
             t.source_system_id,
             t.trade_order_no,
             t.trade_delivery_no,
             t.trade_refund_no,
             t.down_channel_no,
             t.down_account_id,
             t.down_company_id,
             t.up_channel_no,
             t.up_account_id,
             t.up_company_id,
             t.change_type,
             t.change_time,
             t.trade_order_time,
             t.trade_change_time,
             t.bill_type,
             t.business_type,
             t.carrier_no,
             t.province_no,
             t.city_no,
             t.down_draw_count,
             t.down_draw_unit,
             t.down_draw_face,
             t.down_draw_amount,
             t.up_draw_count,
             t.up_draw_unit,
             t.up_draw_face,
             t.up_draw_amount,
             t.way_change_count,
             t.way_change_face,
             t.way_change_amount,
             t.physical_change_count,
             t.physical_change_face,
             t.physical_change_amount,
             t.way_count_balance,
             t.way_face_balance,
             t.way_card_balance,
             t.physical_count_balance,
             t.physical_face_balance,
             t.physical_card_balance,
             t.electronic_count_balance,
             t.electronic_face_balance,
             t.electronic_card_balance,
             t.memo
        from sup_trade_up_fund_hs t
       where t.trade_order_no = v_trade_order_no
         and t.source_system_id = v_system_id;
  
    l_up_fund_add_count := sql%rowcount;
  
    ---3.删除历史表中数据
    delete from sup_trade_up_fund_hs t
     where t.trade_order_no = v_trade_order_no
       and t.source_system_id = v_system_id;
  
    l_up_fund_delete_count := sql%rowcount;
  
    ---4.检查数据是否一致
    if l_up_fund_add_count != l_up_fund_delete_count or
       l_up_fund_add_count != l_up_fund_count then
    
      return pkg_error_code.data_error;
    end if;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_HISTORY_TRADE_MOVE
prompt ==========================================
prompt
create or replace function fd_account.sup_f_history_trade_move(v_system_id      number,
                                                    v_trade_order_no varchar2,
                                                    v_order_time     varchar2)
  return varchar2 is
  -----------------交易历史数据转移当前库---------------
  l_result varchar2(32);
begin
  ---1.检查是否为85天前的订单，超过85天去历史库取一次数据，历史库存3个月前的数据
  if to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss') < trunc(sysdate) - 85 then
  
    ---2.转移历史表订单数据
    l_result := sup_f_history_order_move(v_system_id, v_trade_order_no);
    if l_result != pkg_error_code.success then
      return l_result;
    end if;
  
    ---3.转移历史表下游资金变动数据
    l_result := sup_f_history_down_fund_move(v_system_id, v_trade_order_no);
    if l_result != pkg_error_code.success then
      return l_result;
    end if;
  
    ---4.转移历史表上游资金变动数据
    l_result := sup_f_history_up_fund_move(v_system_id, v_trade_order_no);
    if l_result != pkg_error_code.success then
      return l_result;
    end if;
  
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_PRO_UP_ADD_ADJUST
prompt =========================================
prompt
create or replace function fd_account.sup_f_pro_up_add_adjust(v_up_channel_no    varchar2,
                                                   v_bank_relate_id   number,
                                                   v_add_change_time  date,
                                                   v_adjust_relate_id number,
                                                   v_memo             varchar2,
                                                   v_created_by       varchar2)
  return varchar2 is
  ---------------sup上游加款绑定的生产系统上游加款红冲--------------
  l_record_id      number;
  l_pro_channel_no varchar2(32);
  l_pro_account_id number;
  v_pro_add_amount number;
  l_inner_balance  number;
  l_up_fund_id     number;
begin
  ---1.获取sup对应生产系统上游加款记录
  select t.record_id, t.channel_no, t.account_id, t.change_amount
    into l_record_id, l_pro_channel_no, l_pro_account_id, v_pro_add_amount
    from fd_trade_up_manual t
   where t.change_time >= (v_add_change_time - 5 / 24 / 60)
     and t.change_time < (v_add_change_time + 5 / 24 / 60)
     and t.manual_change_type = pkg_up_manual_change_type.add_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.bank_fund_id = v_bank_relate_id
     and t.channel_no =
         (select m.pro_up_channel_no
            from sup_base_relate_add_map m
           where m.sup_up_channel_no = v_up_channel_no);

  ---2.锁上游账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = l_pro_account_id
     for update;

  ---3.上游账户减款
  update fd_base_up_account t
     set t.inner_balance =
         (l_inner_balance - v_pro_add_amount)
   where t.account_id = l_pro_account_id;

  ---4.上游加款记录红冲
  select seq_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     has_adjust,
     bank_fund_id)
    select l_up_fund_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           pkg_up_manual_change_type.red_recharge,
           (-1 * v_pro_add_amount),
           sysdate,
           (l_inner_balance - v_pro_add_amount),
           v_memo,
           v_created_by,
           t.partner_account,
           pkg_sys_boolean.istrue,
           v_adjust_relate_id
      from fd_trade_up_manual t
     where t.record_id = l_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---5.修改原上游加款记录红冲状态
  update fd_trade_up_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---6.上游加款记录资金变动红冲
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
    select l_up_fund_id,
           t.up_channel_no,
           t.up_account_id,
           t.up_company_id,
           (-1 * v_pro_add_amount),
           (-1 * v_pro_add_amount),
           sysdate,
           t.change_type,
           (l_inner_balance - v_pro_add_amount),
           v_memo
      from fd_trade_up_fund t
     where t.record_id = l_record_id;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_PRO_UP_CHANNEL_ADD
prompt ==========================================
prompt
create or replace function fd_account.sup_f_pro_up_channel_add(v_up_channel_no  varchar2,
                                                    v_up_account_id  number,
                                                    v_up_company_id  number,
                                                    v_bank_relate_id number,
                                                    v_add_amount     number,
                                                    v_memo           varchar2,
                                                    v_create_user    varchar2)
  return varchar2 is
  ----------------sup对应生产系统上游渠道加款---------------
  l_inner_balance number;
  l_up_fund_id    number;
begin
  ---1.锁账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.更新上游渠道账户余额
  update fd_base_up_account t
     set t.inner_balance =
         (l_inner_balance + v_add_amount)
   where t.account_id = v_up_account_id;

  ---3.添加加款记录
  select seq_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     bank_fund_id)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.add_amount,
     v_add_amount,
     sysdate,
     (l_inner_balance + v_add_amount),
     v_memo,
     v_create_user,
     v_bank_relate_id);

  ---4.添加资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_add_amount,
     v_add_amount,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance + v_add_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_PRO_UP_CHANNEL_DRAW
prompt ===========================================
prompt
create or replace function fd_account.sup_f_pro_up_channel_draw(v_up_channel_no  varchar2,
                                                     v_up_account_id  number,
                                                     v_up_company_id  number,
                                                     v_bank_relate_id number,
                                                     v_draw_amount    number,
                                                     v_memo           varchar2,
                                                     v_create_user    varchar2)
  return varchar2 is
  ----------------sup对应生产系统上游渠道减款---------------
  l_inner_balance number;
  l_up_fund_id    number;

begin
  ---1.锁账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.更新上游渠道账户余额
  update fd_base_up_account t
     set t.inner_balance =
         (l_inner_balance - v_draw_amount)
   where t.account_id = v_up_account_id;

  ---3.添加减款记录
  select seq_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     bank_fund_id)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_up_manual_change_type.draw_amount,
     v_draw_amount,
     sysdate,
     (l_inner_balance - v_draw_amount),
     v_memo,
     v_create_user,
     v_bank_relate_id);

  ---4.添加资金变动
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_draw_amount,
     v_draw_amount,
     sysdate,
     pkg_up_fund_change_type.draw_amount,
     (l_inner_balance - v_draw_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_PRO_UP_DRAW_ADJUST
prompt ==========================================
prompt
create or replace function fd_account.sup_f_pro_up_draw_adjust(v_up_channel_no    varchar2,
                                                    v_bank_relate_id   number,
                                                    v_draw_change_time date,
                                                    v_adjust_relate_id number,
                                                    v_memo             varchar2,
                                                    v_created_by       varchar2)
  return varchar2 is
  ---------------sup上游提款绑定的生产系统上游减款红冲--------------
  l_record_id       number;
  l_pro_channel_no  varchar2(32);
  l_pro_account_id  number;
  v_pro_draw_amount number;
  l_inner_balance   number;
  l_up_fund_id      number;
begin
  ---1.获取sup对应生产系统上游减款记录
  select t.record_id, t.channel_no, t.account_id, t.change_amount
    into l_record_id, l_pro_channel_no, l_pro_account_id, v_pro_draw_amount
    from fd_trade_up_manual t
   where t.change_time > (v_draw_change_time - 5 / 24 / 60)
     and t.change_time < (v_draw_change_time + 5 / 24 / 60)
     and t.manual_change_type = pkg_up_manual_change_type.draw_amount
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.bank_fund_id = v_bank_relate_id
     and t.channel_no =
         (select m.pro_up_channel_no
            from sup_base_relate_add_map m
           where m.sup_up_channel_no = v_up_channel_no);

  ---2.锁上游账户
  select t.inner_balance
    into l_inner_balance
    from fd_base_up_account t
   where t.account_id = l_pro_account_id
     for update;

  ---3.上游账户加款
  update fd_base_up_account t
     set t.inner_balance =
         (l_inner_balance + v_pro_draw_amount)
   where t.account_id = l_pro_account_id;

  ---4.上游加款记录红冲
  select seq_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     partner_account,
     has_adjust,
     bank_fund_id)
    select l_up_fund_id,
           t.channel_no,
           t.account_id,
           t.record_id,
           pkg_up_manual_change_type.red_draw,
           (-1 * v_pro_draw_amount),
           sysdate,
           (l_inner_balance + v_pro_draw_amount),
           v_memo,
           v_created_by,
           t.partner_account,
           pkg_sys_boolean.istrue,
           v_adjust_relate_id
      from fd_trade_up_manual t
     where t.record_id = l_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---5.修改原上游加款记录红冲状态
  update fd_trade_up_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---6.上游加款记录资金变动红冲
  insert into fd_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     balance,
     memo)
    select l_up_fund_id,
           t.up_channel_no,
           t.up_account_id,
           t.up_company_id,
           (-1 * v_pro_draw_amount),
           (-1 * v_pro_draw_amount),
           sysdate,
           t.change_type,
           (l_inner_balance + v_pro_draw_amount),
           v_memo
      from fd_trade_up_fund t
     where t.record_id = l_record_id;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_SYNC_CHANNEL_CHECK
prompt ==========================================
prompt
create or replace function fd_account.sup_f_sync_channel_check(v_company_id      number,
                                                    v_system_id       number,
                                                    v_statistics_type number,
                                                    v_channel_type    number)
  return varchar2 is
  ---------------检查同步渠道的信息是否正确-------------
  l_company_count    number;
  l_sys_count        number;
  l_statistics_count number;
begin
  ---1.检查公司是否存在
  select count(1)
    into l_company_count
    from fd_base_company_info t
   where t.company_id = v_company_id;

  if l_company_count != 1 then
    return pkg_error_code.company_error;
  end if;

  ---2.检查系统是否存在
  select count(1)
    into l_sys_count
    from fd_base_source_system t
   where t.source_system_id = v_system_id;
  if l_sys_count != 1 then
    return pkg_error_code.sys_info_error;
  end if;

  ---3.检查分类是否存在
  if v_channel_type = 1 then
    select count(1)
      into l_statistics_count
      from fd_system_business_statis_map t
     where t.statistics_type = v_statistics_type;
  
    if l_statistics_count = 0 then
      return pkg_error_code.param_error;
    end if;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_SYNC_UP_TRANSFER_CHECK
prompt ==============================================
prompt
create or replace function fd_account.sup_f_sync_up_transfer_check(v_up_channel_no varchar2,
                                                        v_card_count    number,
                                                        v_card_face     number,
                                                        v_card_amount   number,
                                                        v_up_account_id out number,
                                                        v_company_id    out number,
                                                        v_system_id     out number)
  return varchar2 is
  --------------------sup渠道账户余额转移检查--------------------
  l_count number;
begin
  ---1.检查转移数据是否正确  
  if v_card_count <= 0 or v_card_face <= 0 or v_card_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道信息
  select count(1),
         max(t.account_id),
         max(t.company_id),
         max(t.source_system_id)
    into l_count, v_up_account_id, v_company_id, v_system_id
    from sup_base_up_channel t
   inner join sup_base_up_account a
      on t.account_id = a.account_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   where t.channel_no = v_up_channel_no;

  if l_count != 1 then
    return pkg_error_code.channel_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_TRADE_ORDER_CREATE
prompt ==========================================
prompt
create or replace function fd_account.sup_f_trade_order_create(v_system_id       number,
                                                    v_company_id      number,
                                                    v_down_channel_no varchar2,
                                                    v_down_account_id number,
                                                    v_trade_order_no  varchar2,
                                                    v_business_type   number,
                                                    v_carrier_no      varchar2,
                                                    v_provice_no      varchar2,
                                                    v_city_no         varchar2,
                                                    v_order_unit      number,
                                                    v_order_face      number,
                                                    v_order_amount    number,
                                                    v_order_time      varchar2,
                                                    v_sup_order_id    out number)
  return varchar2 is
  ---------------订单创建------------
  l_order_count number;
begin
  ---1.检查订单是否存在
  select count(1), max(t.sup_order_id)
    into l_order_count, v_sup_order_id
    from sup_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.source_system_id = v_system_id;

  if l_order_count > 0 then
    return pkg_error_code.success;
  end if;

  ---2.不存在创建订单
  select seq_sup_trade_order_main_id.nextval into v_sup_order_id from dual;

  insert into sup_trade_order_main
    (sup_order_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     source_system_id,
     create_time,
     trade_order_no,
     trade_order_time,
     business_type,
     carrier_no,
     provice_no,
     city_no,
     order_unit,
     order_face,
     order_amount)
  values
    (v_sup_order_id,
     v_down_channel_no,
     v_down_account_id,
     v_company_id,
     v_system_id,
     sysdate,
     v_trade_order_no,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_business_type,
     v_carrier_no,
     v_provice_no,
     v_city_no,
     v_order_unit,
     v_order_face,
     v_order_amount);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_ADD_ADJUST
prompt =====================================
prompt
create or replace function fd_account.sup_f_up_add_adjust(v_add_record_id  number,
                                               v_bank_relate_id number,
                                               v_memo           varchar2,
                                               v_created_by     varchar2)
  return varchar2 is
  -------------------上游加款红冲-----------------
  l_up_account_id       number;
  l_way_count           number;
  l_way_face            number;
  l_way_amount          number;
  l_way_count_balance   number;
  l_way_face_balance    number;
  l_way_amount_balance  number;
  l_phy_count_balance   number;
  l_phy_face_balance    number;
  l_phy_amount_balance  number;
  l_elec_count_balance  number;
  l_elec_face_balance   number;
  l_elec_amount_balance number;
  l_adjust_fund_id      number;
begin
  ---1.获取加款记录信息
  select t.up_account_id,
         t.way_change_count,
         t.way_change_face,
         t.way_change_amount
    into l_up_account_id, l_way_count, l_way_face, l_way_amount
    from sup_trade_up_manual t
   where t.record_id = v_add_record_id
     and t.change_type = pkg_sup_up_manual_type.add_amount
     and t.has_adjust = pkg_sys_boolean.isfalse;

  ---2.锁sup上游渠道账户
  select t.on_way_count,
         t.on_way_face,
         t.on_way_balance,
         t.physical_card_count,
         t.physical_card_face,
         t.physical_card_balance,
         t.electronic_card_count,
         t.electronic_card_face,
         t.electronic_card_balance
    into l_way_count_balance,
         l_way_face_balance,
         l_way_amount_balance,
         l_phy_count_balance,
         l_phy_face_balance,
         l_phy_amount_balance,
         l_elec_count_balance,
         l_elec_face_balance,
         l_elec_amount_balance
    from sup_base_up_account t
   where t.account_id = l_up_account_id
     for update;

  ---3.检查上游账户余额
  if l_way_count > l_way_count_balance or l_way_face > l_way_face_balance or
     l_way_amount > l_way_amount_balance then
    return pkg_error_code.balance_low;
  end if;

  ---4.上游渠道账户减款
  update sup_base_up_account t
     set t.on_way_count  =
         (l_way_count_balance - l_way_count),
         t.on_way_face   =
         (l_way_face_balance - l_way_face),
         t.on_way_balance =
         (l_way_amount_balance - l_way_amount)
   where t.account_id = l_up_account_id;

  ---5.添加上游加款红冲记录
  select seq_sup_trade_up_fund_id.nextval into l_adjust_fund_id from dual;

  insert into sup_trade_up_manual
    (record_id,
     up_channel_no,
     up_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     bank_card_no,
     bank_relate_id,
     memo,
     created_by)
    select l_adjust_fund_id,
           t.up_channel_no,
           t.up_account_id,
           pkg_sys_boolean.istrue,
           v_add_record_id,
           pkg_sup_up_manual_type.red_add,
           sysdate,
           (-1 * l_way_count),
           (-1 * l_way_face),
           (-1 * l_way_amount),
           (l_way_count_balance - l_way_count),
           (l_way_face_balance - l_way_face),
           (l_way_amount_balance - l_way_amount),
           l_phy_count_balance,
           l_phy_face_balance,
           l_phy_amount_balance,
           l_elec_count_balance,
           l_elec_face_balance,
           l_elec_amount_balance,
           t.bank_card_no,
           v_bank_relate_id,
           v_memo,
           v_created_by
      from sup_trade_up_manual t
     where t.record_id = v_add_record_id
       and t.change_type = pkg_sup_up_manual_type.add_amount
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---6.修改原加款记录状态
  update sup_trade_up_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_add_record_id
     and t.change_type = pkg_sup_up_manual_type.add_amount
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---7.添加上游资金变动红冲记录
  insert into sup_trade_up_fund
    (record_id,
     source_system_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo)
    select l_adjust_fund_id,
           t.source_system_id,
           t.up_channel_no,
           t.up_account_id,
           t.up_company_id,
           t.change_type,
           sysdate,
           (-1 * l_way_count),
           (-1 * l_way_face),
           (-1 * l_way_amount),
           (l_way_count_balance - l_way_count),
           (l_way_face_balance - l_way_face),
           (l_way_amount_balance - l_way_amount),
           l_phy_count_balance,
           l_phy_face_balance,
           l_phy_amount_balance,
           l_elec_count_balance,
           l_elec_face_balance,
           l_elec_amount_balance,
           v_memo
      from sup_trade_up_fund t
     where t.record_id = v_add_record_id
       and t.change_type = pkg_sup_up_fund_type.add_amount;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_ADD_ADJUST_CHECK
prompt ===========================================
prompt
create or replace function fd_account.sup_f_up_add_adjust_check(v_add_record_id   number,
                                                     v_up_channel_no   out varchar2,
                                                     v_change_time     out date,
                                                     v_bank_record_id  out number,
                                                     v_bank_service_id out number,
                                                     v_bank_relate_id  out number)
  return varchar2 is
  -----------------sup上游加款红冲检查---------------
  l_up_add_count number;
  l_add_amount   number;
  l_bank_card_no varchar2(64);
  l_bank_count   number;
begin
  ---1.检查加款记录
  select count(1),
         max(t.up_channel_no),
         max(t.change_time),
         max(t.bank_record_id),
         max(t.bank_service_id),
         max(t.way_change_amount),
         max(t.bank_card_no),
         max(t.bank_relate_id)
    into l_up_add_count,
         v_up_channel_no,
         v_change_time,
         v_bank_record_id,
         v_bank_service_id,
         l_add_amount,
         l_bank_card_no,
         v_bank_relate_id
    from sup_trade_up_manual t
   where t.record_id = v_add_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_type = pkg_sup_up_manual_type.add_amount;

  if l_up_add_count != 1 then
    return pkg_error_code.data_error;
  end if;

  ---2.检查银行流水记录
  select count(1)
    into l_bank_count
    from fd_bank_cash_fund t
   inner join fd_bank_account_info a
      on t.account_id = a.account_id
   where t.record_id = v_bank_record_id
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.use_type = pkg_bank_use_type.up_add
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.service_id = v_bank_relate_id
     and t.change_amount = l_add_amount
     and a.card_no = l_bank_card_no;

  if l_bank_count != 1 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_ADD_BANK_ADJUST
prompt ==========================================
prompt
create or replace function fd_account.sup_f_up_add_bank_adjust(v_bank_record_id   number,
                                                    v_bank_service_id  number,
                                                    v_bank_relate_id   number,
                                                    v_memo             varchar2,
                                                    v_created_user     varchar2,
                                                    v_adjust_relate_id out number)
  return varchar2 is
  ---------------上游加款银行记录红冲--------------
  l_service_count   number;
  l_bank_balance    number;
  l_bank_account_id number;
  l_service_fee     number;
  l_add_amount      number;
begin
  ---1.获取银行扣款信息
  select t.account_id, t.change_amount
    into l_bank_account_id, l_add_amount
    from fd_bank_cash_fund t
   where t.record_id = v_bank_record_id
     and t.service_id = v_bank_relate_id
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.use_type = pkg_bank_use_type.up_add;

  ---2.获取银行手续费信息
  select count(1), nvl(max(t.change_amount), 0)
    into l_service_count, l_service_fee
    from fd_bank_cash_fund t
   where t.record_id = v_bank_service_id
     and t.account_id = l_bank_account_id
     and t.service_id = v_bank_relate_id
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.use_type = pkg_bank_use_type.service_fee;

  --===============红冲银行记录===================================
  ---3.锁银行账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;

  ---4.银行卡账户余额加款
  update fd_bank_account_info t
     set t.balance =
         (l_bank_balance + l_add_amount + l_service_fee)
   where t.account_id = l_bank_account_id;

  select seq_bank_service_id.nextval into v_adjust_relate_id from dual;

  if l_service_count > 0 then
    ---5.红冲银行卡手续费记录
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
      select seq_bank_cash_fund_id.nextval,
             l_bank_account_id,
             v_bank_service_id,
             t.company_id,
             (-1 * l_service_fee),
             (l_bank_balance + l_service_fee),
             sysdate,
             v_created_user,
             t.change_type,
             t.use_type,
             0,
             t.link_channel_name,
             t.link_account_name,
             v_memo,
             v_adjust_relate_id,
             t.remark_name
        from fd_bank_cash_fund t
       where t.record_id = v_bank_service_id
         and t.account_id = l_bank_account_id
         and t.service_id = v_bank_relate_id
         and t.has_adjust = pkg_sys_boolean.isfalse
         and t.use_type = pkg_bank_use_type.service_fee;
  
    if sql%rowcount != 1 then
      return pkg_error_code.data_error;
    end if;
  
    ---6.修改原手续费状态
    update fd_bank_cash_fund t
       set t.has_adjust = pkg_sys_boolean.istrue
     where t.record_id = v_bank_service_id
       and t.account_id = l_bank_account_id
       and t.service_id = v_bank_relate_id
       and t.has_adjust = pkg_sys_boolean.isfalse
       and t.use_type = pkg_bank_use_type.service_fee;
  
    if sql%rowcount != 1 then
      return pkg_error_code.data_error;
    end if;
  end if;

  ---8.红冲银行卡扣款记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
    select seq_bank_cash_fund_id.nextval,
           l_bank_account_id,
           v_bank_record_id,
           t.company_id,
           (-1 * l_add_amount),
           (l_bank_balance + l_add_amount + l_service_fee),
           sysdate,
           v_created_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           v_adjust_relate_id,
           t.remark_name
      from fd_bank_cash_fund t
     where t.record_id = v_bank_record_id
       and t.service_id = v_bank_relate_id
       and t.has_adjust = pkg_sys_boolean.isfalse
       and t.change_type = pkg_bank_fund_change_type.minus_amount
       and t.use_type = pkg_bank_use_type.up_add;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---9.修改原银行扣款记录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_bank_record_id
     and t.service_id = v_bank_relate_id
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.use_type = pkg_bank_use_type.up_add;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_ADD_BANK_MINUS
prompt =========================================
prompt
create or replace function fd_account.sup_f_up_add_bank_minus(v_bank_account_id number,
                                                   v_add_amount      number,
                                                   v_service_fee     number,
                                                   v_channel_name    varchar2,
                                                   v_account_name    varchar2,
                                                   v_memo            varchar2,
                                                   v_remark_name     varchar2,
                                                   v_create_user     varchar2,
                                                   v_bank_card_no    out varchar2,
                                                   v_bank_fund_id    out number,
                                                   v_bank_service_id out number,
                                                   v_bank_relate_id  out number)
  return varchar2 is
  -------------------sup上游加款对应银行账户减款------------------
  l_bank_balance    number;
  l_bank_company_id number;
begin
  ---1.锁银行账户
  select t.balance, t.company_id, t.card_no
    into l_bank_balance, l_bank_company_id, v_bank_card_no
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---2.检查银行账户余额
  if ((v_add_amount + v_service_fee) > l_bank_balance) then
    return pkg_error_code.balance_low;
  end if;

  ---3.获取资金变动主键
  select seq_bank_cash_fund_id.nextval, seq_bank_service_id.nextval
    into v_bank_service_id, v_bank_relate_id
    from dual;

  select seq_bank_cash_fund_id.nextval into v_bank_fund_id from dual;

  ---4.银行账户减款
  update fd_bank_account_info t
     set t.balance =
         (l_bank_balance - v_add_amount - v_service_fee)
   where t.account_id = v_bank_account_id;

  ---5.添加银行账户手续费变动记录
  if (v_service_fee > 0) then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id,remark_name)
    values
      (v_bank_service_id,
       v_bank_account_id,
       l_bank_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       v_channel_name,
       v_account_name,
       v_memo,
       v_bank_relate_id,v_remark_name);
  end if;

  ---6.添加银行账户出账变动记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (v_bank_fund_id,
     v_bank_account_id,
     l_bank_company_id,
     v_add_amount,
     (l_bank_balance - v_add_amount - v_service_fee),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.up_add,
     v_channel_name,
     v_account_name,
     v_memo,
     v_bank_relate_id,v_remark_name);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_ADD_CHECK
prompt ====================================
prompt
create or replace function fd_account.sup_f_up_add_check(v_up_channel_no       varchar2,
                                              v_bank_account_id     number,
                                              v_add_count           number,
                                              v_add_face            number,
                                              v_add_amount          number,
                                              v_service_fee         number,
                                              v_up_account_id       out number,
                                              v_up_company_id       out number,
                                              v_system_id           out number,
                                              v_up_channel_name     out varchar2,
                                              v_up_account_name     out varchar2,
                                              v_sup_down_channel_no out varchar2,
                                              v_sup_down_accout_id  out number,
                                              v_18_up_channel_no    out varchar2,
                                              v_18_up_accout_id     out number)
  return varchar2 is
  -----------------上游加款基础信息检查----------------
  l_channel_count number;
  l_bank_count    number;
  l_bank_balance  number;
  l_relate_count  number;

begin
  ---1.检查金额及手续费信息
  if v_add_count <= 0 or v_add_face <= 0 or v_add_amount <= 0 or
     v_service_fee < 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查上游渠道信息
  select count(1),
         max(t.account_id),
         max(t.company_id),
         max(t.source_system_id),
         max(t.channel_name),
         max(a.account_name)
    into l_channel_count,
         v_up_account_id,
         v_up_company_id,
         v_system_id,
         v_up_channel_name,
         v_up_account_name
    from sup_base_up_channel t
   inner join sup_base_up_account a
      on t.account_id = a.account_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   where t.channel_no = v_up_channel_no;

  if l_channel_count != 1 then
    return pkg_error_code.channel_error;
  end if;

  ---3.检查关联的下游渠道和18上游渠道信息
  select count(1),
         max(sd.channel_no),
         max(sa.account_id),
         max(fc.channel_no),
         max(fa.account_id)
    into l_relate_count,
         v_sup_down_channel_no,
         v_sup_down_accout_id,
         v_18_up_channel_no,
         v_18_up_accout_id
    from sup_base_relate_add_map t
   inner join sup_base_down_channel sd
      on t.sup_down_channel_no = sd.channel_no
   inner join sup_base_down_account sa
      on sd.account_id = sa.account_id
   inner join fd_base_up_channel fc
      on t.pro_up_channel_no = fc.channel_no
   inner join fd_base_up_account_map fm
      on fc.channel_no = fm.channel_no
   inner join fd_base_up_account fa
      on fm.account_id = fa.account_id
   where t.sup_up_channel_no = v_up_channel_no
     and sd.company_id = v_up_company_id
     and sd.source_system_id = v_system_id
     and fc.company_id = v_up_company_id;

  if l_relate_count != 1 then
    return pkg_error_code.success;
  end if;

  ---3.检查银行账户信息
  select count(1), max(t.balance)
    into l_bank_count, l_bank_balance
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     and t.company_id = v_up_company_id;

  if (l_bank_count != 1) then
    return pkg_error_code.bank_account_id_error;
  end if;

  ---4.检查银行账户余额
  if (v_add_amount + v_service_fee) > l_bank_balance then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_BALANCE_RV
prompt =====================================
prompt
create or replace function fd_account.sup_f_up_balance_rv(v_up_channel_no varchar2,
                                               v_rv_type       number,
                                               v_rv_count      number,
                                               v_rv_face       number,
                                               v_rv_amount     number,
                                               v_up_account_id number,
                                               v_up_company_id number,
                                               v_system_id     number,
                                               v_memo          varchar2,
                                               v_create_user   varchar2)
  return varchar2 is
  -----------------sup上游渠道账户平账----------------
  l_way_count      number;
  l_way_face       number;
  l_way_balance    number;
  l_phy_count      number;
  l_phy_face       number;
  l_phy_balance    number;
  l_elec_count     number;
  l_elec_face      number;
  l_elec_balance   number;
  l_up_fund_id     number;
  l_way_rv_count   number := 0;
  l_way_rv_face    number := 0;
  l_way_rv_amount  number := 0;
  l_phy_rv_count   number := 0;
  l_phy_rv_face    number := 0;
  l_phy_rv_amount  number := 0;
  l_elec_rv_count  number := 0;
  l_elec_rv_face   number := 0;
  l_elec_rv_amount number := 0;

begin
  ---1.锁上游渠道账户
  select t.on_way_count,
         t.on_way_face,
         t.on_way_balance,
         t.physical_card_count,
         t.physical_card_face,
         t.physical_card_balance,
         t.electronic_card_count,
         t.electronic_card_face,
         t.electronic_card_balance
    into l_way_count,
         l_way_face,
         l_way_balance,
         l_phy_count,
         l_phy_face,
         l_phy_balance,
         l_elec_count,
         l_elec_face,
         l_elec_balance
    from sup_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.检查上游账户余额
  if (v_rv_type = 1) then
    if ((v_rv_amount + l_way_balance) < 0 or (v_rv_count + l_way_count) < 0 or
       (v_rv_face + l_way_face) < 0) then
      return pkg_error_code.balance_low;
    end if;
    l_way_rv_count  := v_rv_count;
    l_way_rv_face   := v_rv_face;
    l_way_rv_amount := v_rv_amount;
  
  elsif (v_rv_type = 2) then
    if ((v_rv_amount + l_phy_balance) < 0 or (v_rv_count + l_phy_count) < 0 or
       (v_rv_face + l_phy_face) < 0) then
      return pkg_error_code.balance_low;
    end if;
    l_phy_rv_count  := v_rv_count;
    l_phy_rv_face   := v_rv_face;
    l_phy_rv_amount := v_rv_amount;
  
  elsif (v_rv_type = 3) then
    if ((v_rv_amount + l_elec_balance) < 0 or
       (v_rv_count + l_elec_count) < 0 or (v_rv_face + l_elec_face) < 0) then
      return pkg_error_code.balance_low;
    end if;
    l_elec_rv_count  := v_rv_count;
    l_elec_rv_face   := v_rv_face;
    l_elec_rv_amount := v_rv_amount;
  
  else
    return pkg_error_code.data_error;
  end if;

  ---3.上游渠道平账
  update sup_base_up_account t
     set t.on_way_count           =
         (l_way_count + l_way_rv_count),
         t.on_way_face            =
         (l_way_face + l_way_rv_face),
         t.on_way_balance         =
         (l_way_balance + l_way_rv_amount),
         t.physical_card_count    =
         (l_phy_count + l_phy_rv_count),
         t.physical_card_face     =
         (l_phy_face + l_phy_rv_face),
         t.physical_card_balance  =
         (l_phy_balance + l_phy_rv_amount),
         t.electronic_card_count  =
         (l_elec_count + l_elec_rv_count),
         t.electronic_card_face   =
         (l_elec_face + l_elec_rv_face),
         t.electronic_card_balance =
         (l_elec_balance + l_elec_rv_amount)
   where t.account_id = v_up_account_id;

  ---4.添加上游平账记录
  select seq_sup_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into sup_trade_up_manual
    (record_id,
     up_channel_no,
     up_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     physical_change_count,
     physical_change_face,
     physical_change_amount,
     electronic_change_count,
     electronic_change_face,
     electronic_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo,
     created_by)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_sys_boolean.istrue,
     0,
     pkg_sup_up_manual_type.balance_revise,
     sysdate,
     l_way_rv_count,
     l_way_rv_face,
     l_way_rv_amount,
     l_phy_rv_count,
     l_phy_rv_face,
     l_phy_rv_amount,
     l_elec_rv_count,
     l_elec_rv_face,
     l_elec_rv_amount,
     (l_way_count + l_way_rv_count),
     (l_way_face + l_way_rv_face),
     (l_way_balance + l_way_rv_amount),
     (l_phy_count + l_phy_rv_count),
     (l_phy_face + l_phy_rv_face),
     (l_phy_balance + l_phy_rv_amount),
     (l_elec_count + l_elec_rv_count),
     (l_elec_face + l_elec_rv_face),
     (l_elec_balance + l_elec_rv_amount),
     v_memo,
     v_create_user);

  ---5.添加上游资金变动记录
  insert into sup_trade_up_fund
    (record_id,
     source_system_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     physical_change_count,
     physical_change_face,
     physical_change_amount,
     up_draw_count,
     up_draw_face,
     up_draw_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo)
  values
    (l_up_fund_id,
     v_system_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     pkg_sup_up_fund_type.add_amount,
     sysdate,
     l_way_rv_count,
     l_way_rv_face,
     l_way_rv_amount,
     l_phy_rv_count,
     l_phy_rv_face,
     l_phy_rv_amount,
     l_elec_rv_count,
     l_elec_rv_face,
     l_elec_rv_amount,
     (l_way_count + l_way_rv_count),
     (l_way_face + l_way_rv_face),
     (l_way_balance + l_way_rv_amount),
     (l_phy_count + l_phy_rv_count),
     (l_phy_face + l_phy_rv_face),
     (l_phy_balance + l_phy_rv_amount),
     (l_elec_count + l_elec_rv_count),
     (l_elec_face + l_elec_rv_face),
     (l_elec_balance + l_elec_rv_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_BALANCE_RV_CHECK
prompt ===========================================
prompt
create or replace function fd_account.sup_f_up_balance_rv_check(v_up_channel_no varchar2,
                                                     v_rv_type       number,
                                                     v_rv_count      number,
                                                     v_rv_face       number,
                                                     v_rv_amount     number,
                                                     v_up_account_id out number,
                                                     v_up_company_id out number,
                                                     v_system_id     out number)
  return varchar2 is
  -----------------上游余额平账基础信息检查----------------
  l_channel_count number;
  l_up_count      number;
  l_up_face       number;
  l_up_balance    number;
  l_way_count     number;
  l_way_face      number;
  l_way_balance   number;
  l_phy_count     number;
  l_phy_face      number;
  l_phy_balance   number;
  l_elec_count    number;
  l_elec_face     number;
  l_elec_balance  number;

begin
  ---1.检查平账金额
  if v_rv_amount = 0 or v_rv_count = 0 or v_rv_face = 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查上游渠道及账户信息
  select count(1),
         max(t.account_id),
         max(t.company_id),
         max(t.source_system_id),
         max(a.on_way_count),
         max(a.on_way_face),
         max(a.on_way_balance),
         max(a.physical_card_count),
         max(a.physical_card_face),
         max(a.physical_card_balance),
         max(a.electronic_card_count),
         max(a.electronic_card_face),
         max(a.electronic_card_balance)
    into l_channel_count,
         v_up_account_id,
         v_up_company_id,
         v_system_id,
         l_way_count,
         l_way_face,
         l_way_balance,
         l_phy_count,
         l_phy_face,
         l_phy_balance,
         l_elec_count,
         l_elec_face,
         l_elec_balance
    from sup_base_up_channel t
   inner join sup_base_up_account a
      on t.account_id = a.account_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   where t.channel_no = v_up_channel_no;

  if l_channel_count != 1 then
    return pkg_error_code.channel_error;
  end if;

  ---3.检查上游账户余额
  if (v_rv_type = 1) then
    l_up_count   := l_way_count;
    l_up_face    := l_way_face;
    l_up_balance := l_way_balance;
  elsif (v_rv_type = 2) then
    l_up_count   := l_phy_count;
    l_up_face    := l_phy_face;
    l_up_balance := l_phy_balance;
  elsif (v_rv_type = 3) then
    l_up_count   := l_elec_count;
    l_up_face    := l_elec_face;
    l_up_balance := l_elec_balance;
  else
    return pkg_error_code.data_error;
  end if;

  if ((v_rv_amount + l_up_balance) < 0 or (v_rv_face + l_up_face) < 0 or
     (v_rv_count + l_up_count) < 0) then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_CHANNEL_ADD
prompt ======================================
prompt
create or replace function fd_account.sup_f_up_channel_add(v_up_channel_no   varchar2,
                                                v_up_account_id   number,
                                                v_up_company_id   number,
                                                v_system_id       number,
                                                v_bank_card_no    varchar2,
                                                v_bank_fund_id    number,
                                                v_bank_service_id number,
                                                v_bank_relate_id  number,
                                                v_add_count       number,
                                                v_add_face        number,
                                                v_add_amount      number,
                                                v_memo            varchar2,
                                                v_create_user     varchar2)
  return varchar2 is
  -------------------sup上游渠道加款-------------------
  l_way_count   number;
  l_way_face    number;
  l_way_balance number;
  l_phy_count   number;
  l_phy_face    number;
  l_phy_amount  number;
  l_elec_count  number;
  l_elec_face   number;
  l_elec_amount number;
  l_up_fund_id  number;
begin
  ---1.锁上游渠道账户
  select t.on_way_count,
         t.on_way_face,
         t.on_way_balance,
         t.physical_card_count,
         t.physical_card_face,
         t.physical_card_balance,
         t.electronic_card_count,
         t.electronic_card_face,
         t.electronic_card_balance
    into l_way_count,
         l_way_face,
         l_way_balance,
         l_phy_count,
         l_phy_face,
         l_phy_amount,
         l_elec_count,
         l_elec_face,
         l_elec_amount
    from sup_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.上游渠道加款
  update sup_base_up_account t
     set t.on_way_count  =
         (l_way_count + v_add_count),
         t.on_way_face   =
         (l_way_face + v_add_face),
         t.on_way_balance =
         (l_way_balance + v_add_amount)
   where t.account_id = v_up_account_id;

  ---3.添加加款记录
  select seq_sup_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into sup_trade_up_manual
    (record_id,
     up_channel_no,
     up_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     bank_card_no,
     bank_record_id,
     bank_service_id,
     bank_relate_id,
     memo,
     created_by)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     1,
     0,
     pkg_sup_up_manual_type.add_amount,
     sysdate,
     v_add_count,
     v_add_face,
     v_add_amount,
     (l_way_count + v_add_count),
     (l_way_face + v_add_face),
     (l_way_balance + v_add_amount),
     l_phy_count,
     l_phy_face,
     l_phy_amount,
     l_elec_count,
     l_elec_face,
     l_elec_amount,
     v_bank_card_no,
     v_bank_fund_id,
     v_bank_service_id,
     v_bank_relate_id,
     v_memo,
     v_create_user);

  ---4.添加上游资金变动记录
  insert into sup_trade_up_fund
    (record_id,
     source_system_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo)
  values
    (l_up_fund_id,
     v_system_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     pkg_sup_up_fund_type.add_amount,
     sysdate,
     v_add_count,
     v_add_face,
     v_add_amount,
     (l_way_count + v_add_count),
     (l_way_face + v_add_face),
     (l_way_balance + v_add_amount),
     l_phy_count,
     l_phy_face,
     l_phy_amount,
     l_elec_count,
     l_elec_face,
     l_elec_amount,
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_CHANNEL_CREATE
prompt =========================================
prompt
create or replace function fd_account.sup_f_up_channel_create(v_channel_no      varchar2,
                                                   v_channel_name    varchar2,
                                                   v_company_id      number,
                                                   v_system_id       number,
                                                   v_statistics_type number,
                                                   v_status          number,
                                                   v_operate_user    varchar2,
                                                   v_operate_time    varchar2)
  return varchar2 is
  ---------------创建sup上游渠道-------------
  l_up_account_id number;
begin
  ---1.添加sup上游渠道信息
  select seq_sup_base_up_account_id.nextval into l_up_account_id from dual;

  insert into sup_base_up_channel
    (channel_no,
     channel_name,
     company_id,
     source_system_id,
     account_id,
     statistics_type,
     status,
     warn_balance,
     created_by,
     created_time)
  values
    (v_channel_no,
     v_channel_name,
     v_company_id,
     v_system_id,
     l_up_account_id,
     v_statistics_type,
     v_status,
     0,
     v_operate_user,
     to_date(v_operate_time, 'yyyy-mm-dd hh24:mi:ss'));

  ---2.添加sup账户信息
  insert into sup_base_up_account
    (account_id,
     account_name,
     on_way_count,
     on_way_face,
     on_way_balance,
     physical_card_count,
     physical_card_face,
     physical_card_balance,
     electronic_card_count,
     electronic_card_face,
     electronic_card_balance,
     created_by,
     created_time)
  values
    (l_up_account_id,
     v_channel_name,
     0,
     0,
     0,
     0,
     0,
     0,
     0,
     0,
     0,
     v_operate_user,
     to_date(v_operate_time, 'yyyy-mm-dd hh24:mi:ss'));

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_CHANNEL_DRAW
prompt =======================================
prompt
create or replace function fd_account.sup_f_up_channel_draw(v_up_channel_no  varchar2,
                                                 v_up_account_id  number,
                                                 v_up_company_id  number,
                                                 v_draw_type      number,
                                                 v_draw_count     number,
                                                 v_draw_face      number,
                                                 v_draw_amount    number,
                                                 v_bank_card_no   varchar2,
                                                 v_system_id      number,
                                                 v_bank_fund_id   number,
                                                 v_bank_relate_id number,
                                                 v_memo           varchar2,
                                                 v_create_user    varchar2)
  return varchar2 is
  -------------------sup上游渠道减款-------------------
  l_way_count        number;
  l_way_face         number;
  l_way_balance      number;
  l_phy_count        number;
  l_phy_face         number;
  l_phy_balance      number;
  l_elec_count       number;
  l_elec_face        number;
  l_elec_balance     number;
  l_up_fund_id       number;
  l_way_draw_count   number := 0;
  l_way_draw_face    number := 0;
  l_way_draw_amount  number := 0;
  l_phy_draw_count   number := 0;
  l_phy_draw_face    number := 0;
  l_phy_draw_amount  number := 0;
  l_elec_draw_count  number := 0;
  l_elec_draw_face   number := 0;
  l_elec_draw_amount number := 0;

begin
  ---1.锁上游渠道账户
  select t.on_way_count,
         t.on_way_face,
         t.on_way_balance,
         t.physical_card_count,
         t.physical_card_face,
         t.physical_card_balance,
         t.electronic_card_count,
         t.electronic_card_face,
         t.electronic_card_balance
    into l_way_count,
         l_way_face,
         l_way_balance,
         l_phy_count,
         l_phy_face,
         l_phy_balance,
         l_elec_count,
         l_elec_face,
         l_elec_balance
    from sup_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.检查上游账户余额
  if (v_draw_type = 1) then
    l_way_draw_count  := v_draw_count;
    l_way_draw_face   := v_draw_face;
    l_way_draw_amount := v_draw_amount;
    if (v_draw_amount > l_way_balance or v_draw_count > l_way_count or
       v_draw_face > l_way_face) then
      return pkg_error_code.balance_low;
    end if;
  
  elsif (v_draw_type = 2) then
    l_phy_draw_count  := v_draw_count;
    l_phy_draw_face   := v_draw_face;
    l_phy_draw_amount := v_draw_amount;
    if (v_draw_amount > l_phy_balance or v_draw_count > l_phy_count or
       v_draw_face > l_phy_face) then
      return pkg_error_code.balance_low;
    end if;
  
  elsif (v_draw_type = 3) then
    l_elec_draw_count  := v_draw_count;
    l_elec_draw_face   := v_draw_face;
    l_elec_draw_amount := v_draw_amount;
    if (v_draw_amount > l_elec_balance or v_draw_count > l_elec_count or
       v_draw_face > l_elec_face) then
      return pkg_error_code.balance_low;
    end if;
  
  else
    return pkg_error_code.data_error;
  end if;

  ---3.上游渠道减款(按类型)
  update sup_base_up_account t
     set t.on_way_count           =
         (l_way_count - l_way_draw_count),
         t.on_way_face            =
         (l_way_face - l_way_draw_face),
         t.on_way_balance         =
         (l_way_balance - l_way_draw_amount),
         t.physical_card_count    =
         (l_phy_count - l_phy_draw_count),
         t.physical_card_face     =
         (l_phy_face - l_phy_draw_face),
         t.physical_card_balance  =
         (l_phy_balance - l_phy_draw_amount),
         t.electronic_card_count  =
         (l_elec_count - l_elec_draw_count),
         t.electronic_card_face   =
         (l_elec_face - l_elec_draw_face),
         t.electronic_card_balance =
         (l_elec_balance - l_elec_draw_amount)
   where t.account_id = v_up_account_id;

  ---4.添加减款记录
  select seq_sup_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into sup_trade_up_manual
    (record_id,
     up_channel_no,
     up_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     physical_change_count,
     physical_change_face,
     physical_change_amount,
     electronic_change_count,
     electronic_change_face,
     electronic_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     bank_card_no,
     bank_record_id,
     bank_relate_id,
     memo,
     created_by)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     1,
     0,
     pkg_sup_up_manual_type.pick_amount,
     sysdate,
     l_way_draw_count,
     l_way_draw_face,
     l_way_draw_amount,
     l_phy_draw_count,
     l_phy_draw_face,
     l_phy_draw_amount,
     l_elec_draw_count,
     l_elec_draw_face,
     l_elec_draw_amount,
     (l_way_count - l_way_draw_count),
     (l_way_face - l_way_draw_face),
     (l_way_balance - l_way_draw_amount),
     (l_phy_count - l_phy_draw_count),
     (l_phy_face - l_phy_draw_face),
     (l_phy_balance - l_phy_draw_amount),
     (l_elec_count - l_elec_draw_count),
     (l_elec_face - l_elec_draw_face),
     (l_elec_balance - l_elec_draw_amount),
     v_bank_card_no,
     v_bank_fund_id,
     v_bank_relate_id,
     v_memo,
     v_create_user);

  ---5.添加上游资金变动记录
  insert into sup_trade_up_fund
    (record_id,
     source_system_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     physical_change_count,
     physical_change_face,
     physical_change_amount,
     up_draw_count,
     up_draw_face,
     up_draw_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo)
  values
    (l_up_fund_id,
     v_system_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     pkg_sup_up_fund_type.pick_amount,
     sysdate,
     l_way_draw_count,
     l_way_draw_face,
     l_way_draw_amount,
     l_phy_draw_count,
     l_phy_draw_face,
     l_phy_draw_amount,
     l_elec_draw_count,
     l_elec_draw_face,
     l_elec_draw_amount,
     (l_way_count - l_way_draw_count),
     (l_way_face - l_way_draw_face),
     (l_way_balance - l_way_draw_amount),
     (l_phy_count - l_phy_draw_count),
     (l_phy_face - l_phy_draw_face),
     (l_phy_balance - l_phy_draw_amount),
     (l_elec_count - l_elec_draw_count),
     (l_elec_face - l_elec_draw_face),
     (l_elec_balance - l_elec_draw_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_CHANNEL_UPDATE
prompt =========================================
prompt
create or replace function fd_account.sup_f_up_channel_update(v_channel_no      varchar2,
                                                   v_channel_name    varchar2,
                                                   v_company_id      number,
                                                   v_system_id       number,
                                                   v_statistics_type number,
                                                   v_status          number,
                                                   v_operate_user    varchar2,
                                                   v_operate_time    varchar2)
  return varchar2 is
  ---------------修改sup上游渠道信息-------------
begin
  ---1.修改上游渠道信息
  update sup_base_up_channel t
     set t.channel_name     = v_channel_name,
         t.company_id       = v_company_id,
         t.source_system_id = v_system_id,
         t.statistics_type  = v_statistics_type,
         t.status           = v_status,
         t.last_edit_user   = v_operate_user,
         t.last_edit_time   = to_date(v_operate_time,
                                      'yyyy-mm-dd hh24:mi:ss')
   where t.channel_no = v_channel_no;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_DRAW_ADJUST
prompt ======================================
prompt
create or replace function fd_account.sup_f_up_draw_adjust(v_draw_record_id number,
                                                v_adjust_relate_id number,
                                                v_memo           varchar2,
                                                v_created_by     varchar2)
  return varchar2 is
  -------------------上游减款红冲-----------------
  l_up_account_id       number;
  l_way_count           number;
  l_way_face            number;
  l_way_amount          number;
  l_phy_count           number;
  l_phy_face            number;
  l_phy_amount          number;
  l_elec_count          number;
  l_elec_face           number;
  l_elec_amount         number;
  l_way_count_balance   number;
  l_way_face_balance    number;
  l_way_amount_balance  number;
  l_phy_count_balance   number;
  l_phy_face_balance    number;
  l_phy_amount_balance  number;
  l_elec_count_balance  number;
  l_elec_face_balance   number;
  l_elec_amount_balance number;
  l_adjust_fund_id      number;
begin
  ---1.获取减款记录信息
  select t.up_account_id,
         t.way_change_count,
         t.way_change_face,
         t.way_change_amount,
         t.physical_change_count,
         t.physical_change_face,
         t.physical_change_amount,
         t.electronic_change_count,
         t.electronic_change_face,
         t.electronic_change_amount
    into l_up_account_id,
         l_way_count,
         l_way_face,
         l_way_amount,
         l_phy_count,
         l_phy_face,
         l_phy_amount,
         l_elec_count,
         l_elec_face,
         l_elec_amount
    from sup_trade_up_manual t
   where t.record_id = v_draw_record_id
     and t.change_type = pkg_sup_up_manual_type.pick_amount
     and t.has_adjust = pkg_sys_boolean.isfalse;

  ---2.锁sup上游渠道账户
  select t.on_way_count,
         t.on_way_face,
         t.on_way_balance,
         t.physical_card_count,
         t.physical_card_face,
         t.physical_card_balance,
         t.electronic_card_count,
         t.electronic_card_face,
         t.electronic_card_balance
    into l_way_count_balance,
         l_way_face_balance,
         l_way_amount_balance,
         l_phy_count_balance,
         l_phy_face_balance,
         l_phy_amount_balance,
         l_elec_count_balance,
         l_elec_face_balance,
         l_elec_amount_balance
    from sup_base_up_account t
   where t.account_id = l_up_account_id
     for update;

  ---3.上游渠道账户加款
  update sup_base_up_account t
     set t.on_way_count           =
         (l_way_count_balance + l_way_count),
         t.on_way_face            =
         (l_way_face_balance + l_way_face),
         t.on_way_balance         =
         (l_way_amount_balance + l_way_amount),
         t.physical_card_count    =
         (l_phy_count_balance + l_phy_count),
         t.physical_card_face     =
         (l_phy_face_balance + l_phy_face),
         t.physical_card_balance  =
         (l_phy_amount_balance + l_phy_amount),
         t.electronic_card_count  =
         (l_elec_count_balance + l_elec_count),
         t.electronic_card_face   =
         (l_elec_face_balance + l_elec_face),
         t.electronic_card_balance =
         (l_elec_amount_balance + l_elec_amount)
   where t.account_id = l_up_account_id;

  ---4.添加上游减款红冲记录
  select seq_sup_trade_up_fund_id.nextval into l_adjust_fund_id from dual;

  insert into sup_trade_up_manual
    (record_id,
     up_channel_no,
     up_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     physical_change_count,
     physical_change_face,
     physical_change_amount,
     electronic_change_count,
     electronic_change_face,
     electronic_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     bank_card_no,
     bank_relate_id,
     memo,
     created_by)
    select l_adjust_fund_id,
           t.up_channel_no,
           t.up_account_id,
           pkg_sys_boolean.istrue,
           v_draw_record_id,
           pkg_sup_up_manual_type.red_pick,
           sysdate,
           (-1 * l_way_count),
           (-1 * l_way_face),
           (-1 * l_way_amount),
           (-1 * l_phy_count),
           (-1 * l_phy_face),
           (-1 * l_phy_amount),
           (-1 * l_elec_count),
           (-1 * l_elec_face),
           (-1 * l_elec_amount),
           (l_way_count_balance + l_way_count),
           (l_way_face_balance + l_way_face),
           (l_way_amount_balance + l_way_amount),
           (l_phy_count_balance + l_phy_count),
           (l_phy_face_balance + l_phy_face),
           (l_phy_amount_balance + l_phy_amount),
           (l_elec_count_balance + l_elec_count),
           (l_elec_face_balance + l_elec_face),
           (l_elec_amount_balance + l_elec_amount),
           t.bank_card_no,
           v_adjust_relate_id,
           v_memo,
           v_created_by
      from sup_trade_up_manual t
     where t.record_id = v_draw_record_id
       and t.change_type = pkg_sup_up_manual_type.pick_amount
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---6.修改原减款记录红冲状态
  update sup_trade_up_manual t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_draw_record_id
     and t.change_type = pkg_sup_up_manual_type.pick_amount
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---7.添加上游资金变动红冲记录
  insert into sup_trade_up_fund
    (record_id,
     source_system_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     physical_change_count,
     physical_change_face,
     physical_change_amount,
     up_draw_count,
     up_draw_face,
     up_draw_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo)
    select l_adjust_fund_id,
           t.source_system_id,
           t.up_channel_no,
           t.up_account_id,
           t.up_company_id,
           t.change_type,
           sysdate,
           (-1 * l_way_count),
           (-1 * l_way_face),
           (-1 * l_way_amount),
           (-1 * l_phy_count),
           (-1 * l_phy_face),
           (-1 * l_phy_amount),
           (-1 * l_elec_count),
           (-1 * l_elec_face),
           (-1 * l_elec_amount),
           (l_way_count_balance + l_way_count),
           (l_way_face_balance + l_way_face),
           (l_way_amount_balance + l_way_amount),
           (l_phy_count_balance + l_phy_count),
           (l_phy_face_balance + l_phy_face),
           (l_phy_amount_balance + l_phy_amount),
           (l_elec_count_balance + l_elec_count),
           (l_elec_face_balance + l_elec_face),
           (l_elec_amount_balance + l_elec_amount),
           v_memo
      from sup_trade_up_fund t
     where t.record_id = v_draw_record_id
       and t.change_type = pkg_sup_up_fund_type.pick_amount;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_DRAW_ADJUST_CHECK
prompt ============================================
prompt
create or replace function fd_account.sup_f_up_draw_adjust_check(v_draw_record_id number,
                                                      v_up_channel_no  out varchar2,
                                                      v_change_time    out date,
                                                      v_bank_record_id out number,
                                                      v_bank_relate_id out number)
  return varchar2 is
  -----------------sup上游减款红冲检查---------------
  l_up_draw_count  number;
  l_up_draw_amount number;
  l_bank_balance   number;
  l_bank_card_no   varchar2(64);
  l_bank_count     number;
begin
  ---1.检查减款记录
  select count(1),
         max(t.up_channel_no),
         max(t.change_time),
         max(t.bank_record_id),
         max(t.bank_card_no),
         max(t.bank_relate_id)
    into l_up_draw_count,
         v_up_channel_no,
         v_change_time,
         v_bank_record_id,
         l_bank_card_no,
         v_bank_relate_id
    from sup_trade_up_manual t
   where t.record_id = v_draw_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_type = pkg_sup_up_manual_type.pick_amount;

  if l_up_draw_count != 1 then
    return pkg_error_code.data_error;
  end if;

  ---2.检查银行流水记录

  select count(1), max(t.balance)
    into l_bank_count, l_bank_balance
    from fd_bank_cash_fund t
   inner join fd_bank_account_info a
      on t.account_id = a.account_id
   where t.record_id = v_bank_record_id
     and t.change_type = pkg_bank_fund_change_type.add_amount
     and t.use_type = pkg_bank_use_type.up_draw
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.service_id = v_bank_relate_id
     and a.card_no = l_bank_card_no;

  if l_bank_count != 1 then
    return pkg_error_code.data_error;
  end if;

  ---3.检查银行余额
  if l_bank_balance < l_up_draw_amount then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_DRAW_BANK_ADJUST
prompt ===========================================
prompt
create or replace function fd_account.sup_f_up_draw_bank_adjust(v_bank_record_id   number,
                                                     v_bank_relate_id   number,
                                                     v_memo             varchar2,
                                                     v_created_user     varchar2,
                                                     v_adjust_relate_id out number)
  return varchar2 is
  ---------------上游减款银行记录红冲--------------
  l_bank_balance    number;
  l_bank_account_id number;
  l_draw_amount     number;
begin
  ---1.获取银行加款信息
  select t.account_id, t.change_amount
    into l_bank_account_id, l_draw_amount
    from fd_bank_cash_fund t
   where t.record_id = v_bank_record_id
     and t.service_id = v_bank_relate_id
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_type = pkg_bank_fund_change_type.add_amount
     and t.use_type = pkg_bank_use_type.up_draw;

  ---2.锁银行账户
  select t.balance
    into l_bank_balance
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id
     for update;
     
  ---3.检查银行余额
  if l_bank_balance < l_draw_amount then
    return pkg_error_code.balance_low;
  end if;

  ---3.银行卡账户余额减款
  update fd_bank_account_info t
     set t.balance =
         (l_bank_balance - l_draw_amount)
   where t.account_id = l_bank_account_id;

  select seq_bank_service_id.nextval into v_adjust_relate_id from dual;

  ---4.红冲银行卡减款记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
    select seq_bank_cash_fund_id.nextval,
           l_bank_account_id,
           v_bank_record_id,
           t.company_id,
           (-1 * l_draw_amount),
           (l_bank_balance - l_draw_amount),
           sysdate,
           v_created_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           v_adjust_relate_id,
           t.remark_name
      from fd_bank_cash_fund t
     where t.record_id = v_bank_record_id
       and t.service_id = v_bank_relate_id
       and t.has_adjust = pkg_sys_boolean.isfalse
       and t.change_type = pkg_bank_fund_change_type.add_amount
       and t.use_type = pkg_bank_use_type.up_draw;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  ---5.修改原银行加款记录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = v_bank_record_id
     and t.service_id = v_bank_relate_id
     and t.has_adjust = pkg_sys_boolean.isfalse
     and t.change_type = pkg_bank_fund_change_type.add_amount
     and t.use_type = pkg_bank_use_type.up_draw;

  if sql%rowcount != 1 then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_DRAW_BANK_PLUS
prompt =========================================
prompt
create or replace function fd_account.sup_f_up_draw_bank_plus(v_bank_account_id number,
                                                   v_draw_amount     number,
                                                   v_channel_name    varchar2,
                                                   v_account_name    varchar2,
                                                   v_create_user     varchar2,
                                                   v_memo            varchar2,
                                                   v_remark_name     varchar2,
                                                   v_bank_card_no    out varchar2,
                                                   v_bank_relate_id  out number,
                                                   v_bank_fund_id    out number)
  return varchar2 is
  -------------------sup上游加款对应银行账户加款------------------
  l_bank_balance    number;
  l_bank_company_id number;

begin
  ---1.锁银行账户
  select t.balance, t.company_id, t.card_no
    into l_bank_balance, l_bank_company_id, v_bank_card_no
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---2.获取资金变动主键
  select seq_bank_service_id.nextval, seq_bank_cash_fund_id.nextval
    into v_bank_relate_id, v_bank_fund_id
    from dual;

  ---3.银行账户加款
  update fd_bank_account_info t
     set t.balance =
         (l_bank_balance + v_draw_amount)
   where t.account_id = v_bank_account_id;

  ---4.添加银行账户出账变动记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id,remark_name)
  values
    (v_bank_fund_id,
     v_bank_account_id,
     l_bank_company_id,
     v_draw_amount,
     (l_bank_balance + v_draw_amount),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.add_amount,
     pkg_bank_use_type.up_draw,
     v_channel_name,
     v_account_name,
     v_memo,
     v_bank_relate_id,v_remark_name);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_DRAW_CHECK
prompt =====================================
prompt
create or replace function fd_account.sup_f_up_draw_check(v_bank_account_id     number,
                                               v_up_channel_no       varchar2,
                                               v_draw_type           number,
                                               v_draw_count          number,
                                               v_draw_face           number,
                                               v_draw_amount         number,
                                               v_up_account_id       out number,
                                               v_up_company_id       out number,
                                               v_system_id           out number,
                                               v_up_channel_name     out varchar2,
                                               v_up_account_name     out varchar2,
                                               v_sup_down_channel_no out varchar2,
                                               v_sup_down_accout_id  out number,
                                               v_18_up_channel_no    out varchar2,
                                               v_18_up_accout_id     out number)
  return varchar2 is
  -----------------上游提款基础信息检查----------------
  l_channel_count number;
  l_bank_count    number;
  l_relate_count  number;
  l_up_count      number;
  l_up_face       number;
  l_up_balance    number;
  l_down_balance  number;
  l_way_count     number;
  l_way_face      number;
  l_way_balance   number;
  l_phy_count     number;
  l_phy_face      number;
  l_phy_balance   number;
  l_elec_count    number;
  l_elec_face     number;
  l_elec_balance  number;
  l_credit_amount number;

begin
  ---1.检查提款金额
  if v_draw_count <= 0 or v_draw_face <= 0 or v_draw_amount <= 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查上游渠道信息
  select count(1),
         max(t.account_id),
         max(t.company_id),
         max(t.source_system_id),
         max(t.channel_name),
         max(a.account_name),
         max(a.on_way_count),
         max(a.on_way_face),
         max(a.on_way_balance),
         max(a.physical_card_count),
         max(a.physical_card_face),
         max(a.physical_card_balance),
         max(a.electronic_card_count),
         max(a.electronic_card_face),
         max(a.electronic_card_balance)
    into l_channel_count,
         v_up_account_id,
         v_up_company_id,
         v_system_id,
         v_up_channel_name,
         v_up_account_name,
         l_way_count,
         l_way_face,
         l_way_balance,
         l_phy_count,
         l_phy_face,
         l_phy_balance,
         l_elec_count,
         l_elec_face,
         l_elec_balance
    from sup_base_up_channel t
   inner join sup_base_up_account a
      on t.account_id = a.account_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   where t.channel_no = v_up_channel_no;

  if l_channel_count != 1 then
    return pkg_error_code.channel_error;
  end if;

  ---3.检查关联的下游渠道和18上游渠道信息
  select count(1),
         max(sd.channel_no),
         max(sa.account_id),
         max(fc.channel_no),
         max(fa.account_id)
    into l_relate_count,
         v_sup_down_channel_no,
         v_sup_down_accout_id,
         v_18_up_channel_no,
         v_18_up_accout_id
    from sup_base_relate_add_map t
   inner join sup_base_down_channel sd
      on t.sup_down_channel_no = sd.channel_no
   inner join sup_base_down_account sa
      on sd.account_id = sa.account_id
   inner join fd_base_up_channel fc
      on t.pro_up_channel_no = fc.channel_no
   inner join fd_base_up_account_map fm
      on fc.channel_no = fm.channel_no
   inner join fd_base_up_account fa
      on fm.account_id = fa.account_id
   where t.sup_up_channel_no = v_up_channel_no
     and sd.company_id = v_up_company_id
     and sd.source_system_id = v_system_id
     and fc.company_id = v_up_company_id;

  if l_relate_count != 1 then
    return pkg_error_code.channel_error;
  end if;

  ---4.检查银行账户信息
  select count(1)
    into l_bank_count
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     and t.company_id = v_up_company_id;

  if (l_bank_count != 1) then
    return pkg_error_code.bank_account_id_error;
  end if;

  ---5.检查上游账户余额(按类型检查)
  if (v_draw_type = 1) then
    l_up_count := l_way_count;
    l_up_face := l_way_face;
    l_up_balance := l_way_balance;
  elsif (v_draw_type = 2) then
    l_up_count := l_phy_count;
    l_up_face := l_phy_face;
    l_up_balance := l_phy_balance;
  elsif (v_draw_type = 3) then
    l_up_count := l_elec_count;
    l_up_face := l_elec_face;
    l_up_balance := l_elec_balance;
  else
    return pkg_error_code.data_error;
  end if;

  if (v_draw_amount > l_up_balance or v_draw_face > l_up_face or
     v_draw_count > l_up_count) then
    return pkg_error_code.balance_low;
  end if;

  ---6.检查下游账户余额
  select t.balance,t.credit_amount
    into l_down_balance,l_credit_amount
    from sup_base_down_account t
   where t.account_id = v_sup_down_accout_id;

  if (l_down_balance + l_credit_amount - v_draw_amount < 0) then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_ELECTRONIC_STORAGE
prompt =============================================
prompt
create or replace function fd_account.sup_f_up_electronic_storage(v_up_channel_no varchar2,
                                                       v_up_account_id number,
                                                       v_company_id    number,
                                                       v_system_id     number,
                                                       v_card_count    number,
                                                       v_card_face     number,
                                                       v_card_amount   number,
                                                       v_change_time   varchar2,
                                                       v_memo          varchar2,
                                                       v_create_by     varchar2)
  return varchar2 is
  --------------------电子卡密入库-------------------
  l_on_way_count            number;
  l_on_way_face             number;
  l_on_way_balance          number;
  l_physical_card_count     number;
  l_physical_card_face      number;
  l_physical_card_balance   number;
  l_electronic_card_count   number;
  l_electronic_card_face    number;
  l_electronic_card_balance number;
  l_up_fund_id              number;
begin
  ---1.锁上游渠道账户
  select t.on_way_count,
         t.on_way_face,
         t.on_way_balance,
         t.physical_card_count,
         t.physical_card_face,
         t.physical_card_balance,
         t.electronic_card_count,
         t.electronic_card_face,
         t.electronic_card_balance
    into l_on_way_count,
         l_on_way_face,
         l_on_way_balance,
         l_physical_card_count,
         l_physical_card_face,
         l_physical_card_balance,
         l_electronic_card_count,
         l_electronic_card_face,
         l_electronic_card_balance
    from sup_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.检查账户余额
  if v_card_count > l_on_way_count or v_card_face > l_on_way_face or
     v_card_amount > l_on_way_balance then
    return pkg_error_code.balance_low;
  end if;

  ---3.电子卡密入库，在途减款、电子卡密余额加款
  update sup_base_up_account t
     set t.on_way_count           =
         (l_on_way_count - v_card_count),
         t.on_way_face            =
         (l_on_way_face - v_card_face),
         t.on_way_balance         =
         (l_on_way_balance - v_card_amount),
         t.electronic_card_count  =
         (l_electronic_card_count + v_card_count),
         t.electronic_card_face   =
         (l_electronic_card_face + v_card_face),
         t.electronic_card_balance =
         (l_electronic_card_balance + v_card_amount)
   where t.account_id = v_up_account_id;

  ---4.电子卡密入库操作记录
  select seq_sup_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into sup_trade_up_manual
    (record_id,
     up_channel_no,
     up_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     physical_change_count,
     physical_change_face,
     physical_change_amount,
     electronic_change_count,
     electronic_change_face,
     electronic_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     trade_change_time,
     memo,
     created_by)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     0,
     0,
     pkg_sup_up_manual_type.electronic_storage,
     sysdate,
     -v_card_count,
     -v_card_face,
     -v_card_amount,
     0,
     0,
     0,
     v_card_count,
     v_card_face,
     v_card_amount,
     (l_on_way_count - v_card_count),
     (l_on_way_face - v_card_face),
     (l_on_way_balance - v_card_amount),
     l_physical_card_count,
     l_physical_card_face,
     l_physical_card_balance,
     (l_electronic_card_count + v_card_count),
     (l_electronic_card_face + v_card_face),
     (l_electronic_card_balance + v_card_amount),
     to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_memo,
     v_create_by);

  ---5.电子卡密入库资金变动记录
  insert into sup_trade_up_fund
    (record_id,
     source_system_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     change_type,
     change_time,
     trade_order_time,
     trade_change_time,
     up_draw_count,
     up_draw_face,
     up_draw_amount,
     way_change_count,
     way_change_face,
     way_change_amount,
     physical_change_count,
     physical_change_face,
     physical_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo)
  values
    (l_up_fund_id,
     v_system_id,
     v_up_channel_no,
     v_up_account_id,
     v_company_id,
     pkg_sup_up_fund_type.move_amount,
     sysdate,
     to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_card_count,
     v_card_face,
     v_card_amount,
     -v_card_count,
     -v_card_face,
     -v_card_amount,
     0,
     0,
     0,
     (l_on_way_count - v_card_count),
     (l_on_way_face - v_card_face),
     (l_on_way_balance - v_card_amount),
     l_physical_card_count,
     l_physical_card_face,
     l_physical_card_balance,
     (l_electronic_card_count + v_card_count),
     (l_electronic_card_face + v_card_face),
     (l_electronic_card_balance + v_card_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_ORDER_PAY
prompt ====================================
prompt
create or replace function fd_account.sup_f_up_order_pay(v_up_channel_no     varchar2,
                                              v_up_account_id     number,
                                              v_down_channel_no   varchar2,
                                              v_down_account_id   number,
                                              v_company_id        number,
                                              v_system_id         number,
                                              v_sup_order_id      number,
                                              v_trade_order_no    varchar2,
                                              v_trade_delivery_no varchar2,
                                              v_bill_type         number,
                                              v_business_type     number,
                                              v_carrier_no        varchar2,
                                              v_province_no       varchar2,
                                              v_city_no           varchar2,
                                              v_order_unit        number,
                                              v_order_face        number,
                                              v_order_amount      number,
                                              v_up_draw_count     number,
                                              v_up_draw_unit      number,
                                              v_up_draw_face      number,
                                              v_up_draw_amount    number,
                                              v_order_time        varchar2,
                                              v_change_time       varchar2,
                                              v_memo              varchar2)
  return varchar2 is
  -------------------上游订单支付-----------------
  l_down_channel_no        varchar2(32);
  l_business_type          number;
  l_order_face             number;
  l_order_amount           number;
  l_complete_face          number;
  l_complete_amount        number;
  l_up_debit_count         number;
  l_way_count_balance      number;
  l_way_face_balance       number;
  l_way_balance            number;
  l_physical_count_balance number;
  l_physical_face_balance  number;
  l_physical_balance       number;
  l_elec_count             number;
  l_elec_face              number;
  l_elec_balance           number;
  l_down_unit              number;
  l_down_face              number;
  l_down_amount            number;
begin
  ---1.锁订单
  select t.down_channel_no,
         t.business_type,
         t.order_face,
         t.order_amount,
         t.complete_face,
         t.complete_amount
    into l_down_channel_no,
         l_business_type,
         l_order_face,
         l_order_amount,
         l_complete_face,
         l_complete_amount
    from sup_trade_order_main t
   where t.sup_order_id = v_sup_order_id
     for update;

  ---2.检查扣款是否存在
  select count(1)
    into l_up_debit_count
    from sup_trade_up_fund t
   where t.sup_order_id = v_sup_order_id
     and t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.change_type = pkg_up_fund_change_type.debit_amount;

  if l_up_debit_count > 0 then
    return pkg_error_code.success;
  end if;

  ---3.检查订单参数
  if l_down_channel_no != v_down_channel_no or
     l_business_type != v_business_type or l_order_face != v_order_face or
     l_order_amount != v_order_amount or
     (l_order_face - l_complete_face) < v_up_draw_face or
     (l_order_amount - l_complete_amount) < v_up_draw_amount then
  
    return pkg_error_code.param_error;
  end if;

  ---4.修改订单完成数据
  update sup_trade_order_main t
     set t.complete_face  =
         (l_complete_face + v_up_draw_face),
         t.complete_amount =
         (l_complete_amount + v_up_draw_amount)
   where t.sup_order_id = v_sup_order_id;

  ---5.锁账户
  select t.on_way_count,
         t.on_way_face,
         t.on_way_balance,
         t.physical_card_count,
         t.physical_card_face,
         t.physical_card_balance,
         t.electronic_card_count,
         t.electronic_card_face,
         t.electronic_card_balance
    into l_way_count_balance,
         l_way_face_balance,
         l_way_balance,
         l_physical_count_balance,
         l_physical_face_balance,
         l_physical_balance,
         l_elec_count,
         l_elec_face,
         l_elec_balance
    from sup_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  if v_up_draw_count > l_elec_count or v_up_draw_face > l_elec_face or
     v_up_draw_amount > l_elec_balance then
  
    return pkg_error_code.balance_low;
  end if;

  ---6.修改账户余额
  update sup_base_up_account t
     set t.electronic_card_count  =
         (l_elec_count - v_up_draw_count),
         t.electronic_card_face   =
         (l_elec_face - v_up_draw_face),
         t.electronic_card_balance =
         (l_elec_balance - v_up_draw_amount)
   where t.account_id = v_up_account_id;

  ---7.添加上游扣款资金变动
  if v_order_face >= v_up_draw_face then
    l_down_unit   := v_order_unit * v_up_draw_face / v_order_face;
    l_down_face   := v_order_face * v_up_draw_face / v_order_face;
    l_down_amount := v_order_amount * v_up_draw_face / v_order_face;
  end if;

  if l_down_amount != v_up_draw_amount then
    return pkg_error_code.order_own_profit;
  end if;

  insert into sup_trade_up_fund
    (record_id,
     sup_order_id,
     source_system_id,
     trade_order_no,
     trade_delivery_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     change_type,
     change_time,
     trade_order_time,
     trade_change_time,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     city_no,
     down_draw_count,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     up_draw_count,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo)
  values
    (seq_sup_trade_up_fund_id.nextval,
     v_sup_order_id,
     v_system_id,
     v_trade_order_no,
     v_trade_delivery_no,
     v_down_channel_no,
     v_down_account_id,
     v_company_id,
     v_up_channel_no,
     v_up_account_id,
     v_company_id,
     pkg_sup_up_fund_type.debit_amount,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_bill_type,
     v_business_type,
     v_carrier_no,
     v_province_no,
     v_city_no,
     v_up_draw_count,
     l_down_unit,
     l_down_face,
     l_down_amount,
     v_up_draw_count,
     v_up_draw_unit,
     v_up_draw_face,
     v_up_draw_amount,
     l_way_count_balance,
     l_way_face_balance,
     l_way_balance,
     l_physical_count_balance,
     l_physical_face_balance,
     l_physical_balance,
     (l_elec_count - v_up_draw_count),
     (l_elec_face - v_up_draw_face),
     (l_elec_balance - v_up_draw_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_ORDER_REFUND
prompt =======================================
prompt
create or replace function fd_account.sup_f_up_order_refund(v_up_channel_no     varchar2,
                                                 v_up_account_id     number,
                                                 v_down_channel_no   varchar2,
                                                 v_down_account_id   number,
                                                 v_company_id        number,
                                                 v_system_id         number,
                                                 v_bill_type         number,
                                                 v_business_type     number,
                                                 v_trade_order_no    varchar2,
                                                 v_trade_delivery_no varchar2,
                                                 v_trade_refund_no   varchar2,
                                                 v_up_refund_count   number,
                                                 v_up_refund_unit    number,
                                                 v_up_refund_face    number,
                                                 v_up_refund_amount  number,
                                                 v_order_time        varchar2,
                                                 v_change_time       varchar2,
                                                 v_memo              varchar2)
  return varchar2 is
  ----------------上游交易订单退款----------------
  l_down_channel_no        varchar2(32);
  l_business_type          number;
  l_order_unit             number;
  l_order_face             number;
  l_order_amount           number;
  l_complete_face          number;
  l_complete_amount        number;
  l_up_debit_count         number;
  l_up_refund_count        number;
  l_debit_record_id        number;
  l_way_count_balance      number;
  l_way_face_balance       number;
  l_way_balance            number;
  l_physical_count_balance number;
  l_physical_face_balance  number;
  l_physical_balance       number;
  l_elec_count_balance     number;
  l_elec_face_balance      number;
  l_elec_balance           number;
  l_sup_order_id           number;
  l_debit_bill             number;
  l_debit_business         number;
  l_all_draw_count         number;
  l_all_draw_face          number;
  l_all_draw_amount        number;
  l_all_refund_count       number;
  l_all_refund_face        number;
  l_all_refund_amount      number;
  l_down_unit              number;
  l_down_face              number;
  l_down_amount            number;
  l_order_count            number;
begin
  ---1.检查订单
  select count(1)
    into l_order_count
    from sup_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.source_system_id = v_system_id;

  if l_order_count = 0 then
    return pkg_error_code.order_not_exists;
  end if;

  ---2.锁订单
  select t.sup_order_id,
         t.down_channel_no,
         t.business_type,
         t.order_unit,
         t.order_face,
         t.order_amount,
         t.complete_face,
         t.complete_amount
    into l_sup_order_id,
         l_down_channel_no,
         l_business_type,
         l_order_unit,
         l_order_face,
         l_order_amount,
         l_complete_face,
         l_complete_amount
    from sup_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.source_system_id = v_system_id
     for update;

  ---3.检查退款的扣款数据是否存在
  select count(1), max(t.record_id), max(t.bill_type), max(t.business_type)
    into l_up_debit_count,
         l_debit_record_id,
         l_debit_bill,
         l_debit_business
    from sup_trade_up_fund t
   where t.sup_order_id = l_sup_order_id
     and t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.change_type = pkg_sup_up_fund_type.debit_amount
     and rownum <= 1;

  if l_up_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;

  ---4.检查退款信息
  if l_debit_bill != v_bill_type or l_debit_business != v_business_type then
  
    return pkg_error_code.param_error;
  end if;

  ---5.检查重复退款
  select count(1)
    into l_up_refund_count
    from sup_trade_up_fund t
   where t.sup_order_id = l_sup_order_id
     and t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.trade_refund_no = v_trade_refund_no
     and t.change_type = pkg_sup_up_fund_type.refund_amount;

  if l_up_refund_count > 0 then
    return pkg_error_code.success;
  end if;

  ---6.检查退款是否超过扣款
  select nvl(sum(decode(t.change_type,
                        pkg_sup_up_fund_type.debit_amount,
                        1,
                        0) * t.up_draw_count),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_sup_up_fund_type.debit_amount,
                        1,
                        0) * t.up_draw_face),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_sup_up_fund_type.debit_amount,
                        1,
                        0) * t.up_draw_amount),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_sup_up_fund_type.debit_amount,
                        0,
                        1) * t.up_draw_count),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_sup_up_fund_type.debit_amount,
                        0,
                        1) * t.up_draw_face),
             0),
         nvl(sum(decode(t.change_type,
                        pkg_sup_up_fund_type.debit_amount,
                        0,
                        1) * t.up_draw_amount),
             0)
    into l_all_draw_count,
         l_all_draw_face,
         l_all_draw_amount,
         l_all_refund_count,
         l_all_refund_face,
         l_all_refund_amount
    from sup_trade_up_fund t
   where t.sup_order_id = l_sup_order_id
     and t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.change_type in
         (pkg_sup_up_fund_type.debit_amount,
          pkg_sup_up_fund_type.refund_amount);

  if v_up_refund_count > (l_all_draw_count - l_all_refund_count) or
     v_up_refund_face > (l_all_draw_face - l_all_refund_face) or
     v_up_refund_amount > (l_all_draw_amount - l_all_refund_amount) then
  
    return pkg_error_code.amount_error;
  end if;

  ---7.修改订单完成信息
  update sup_trade_order_main t
     set t.complete_face  =
         (l_complete_face - v_up_refund_face),
         t.complete_amount =
         (l_complete_amount - v_up_refund_amount)
   where t.sup_order_id = l_sup_order_id;

  ---8.锁账户
  select t.on_way_count,
         t.on_way_face,
         t.on_way_balance,
         t.physical_card_count,
         t.physical_card_face,
         t.physical_card_balance,
         t.electronic_card_count,
         t.electronic_card_face,
         t.electronic_card_balance
    into l_way_count_balance,
         l_way_face_balance,
         l_way_balance,
         l_physical_count_balance,
         l_physical_face_balance,
         l_physical_balance,
         l_elec_count_balance,
         l_elec_face_balance,
         l_elec_balance
    from sup_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---9.修改账户余额
  update sup_base_up_account t
     set t.electronic_card_count  =
         (l_elec_count_balance + v_up_refund_count),
         t.electronic_card_face   =
         (l_elec_face_balance + v_up_refund_face),
         t.electronic_card_balance =
         (l_elec_balance + v_up_refund_amount)
   where t.account_id = v_up_account_id;

  ---10.添加资金变动
  if v_up_refund_face <= l_order_face then
    l_down_unit   := l_order_unit * v_up_refund_face / l_order_face;
    l_down_face   := l_order_face * v_up_refund_face / l_order_face;
    l_down_amount := l_order_amount * v_up_refund_face / l_order_face;
  end if;

  if l_down_amount != v_up_refund_amount then
    return pkg_error_code.order_own_profit;
  end if;

  insert into sup_trade_up_fund
    (record_id,
     sup_order_id,
     source_system_id,
     trade_order_no,
     trade_delivery_no,
     trade_refund_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     change_type,
     change_time,
     trade_order_time,
     trade_change_time,
     bill_type,
     business_type,
     carrier_no,
     province_no,
     city_no,
     down_draw_count,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     up_draw_count,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo)
    select seq_sup_trade_up_fund_id.nextval,
           t.sup_order_id,
           v_system_id,
           t.trade_order_no,
           t.trade_delivery_no,
           v_trade_refund_no,
           v_down_channel_no,
           v_down_account_id,
           v_company_id,
           v_up_channel_no,
           v_up_account_id,
           v_company_id,
           pkg_sup_up_fund_type.refund_amount,
           sysdate,
           to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
           to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
           v_bill_type,
           v_business_type,
           t.carrier_no,
           t.province_no,
           t.city_no,
           v_up_refund_count,
           l_down_unit,
           l_down_face,
           l_down_amount,
           v_up_refund_count,
           v_up_refund_unit,
           v_up_refund_face,
           v_up_refund_amount,
           l_way_count_balance,
           l_way_face_balance,
           l_way_balance,
           l_physical_count_balance,
           l_physical_face_balance,
           l_physical_balance,
           (l_elec_count_balance + v_up_refund_count),
           (l_elec_face_balance + v_up_refund_face),
           (l_elec_balance + v_up_refund_amount),
           v_memo
      from sup_trade_up_fund t
     where t.record_id = l_debit_record_id;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_PAY_CHECK
prompt ====================================
prompt
create or replace function fd_account.sup_f_up_pay_check(v_up_channel_no       varchar2,
                                              v_down_channel_no     varchar2,
                                              v_business_type       number,
                                              v_order_face          number,
                                              v_order_amount        number,
                                              v_up_draw_count       number,
                                              v_up_draw_face        number,
                                              v_up_draw_amount      number,
                                              v_down_account_id     out number,
                                              v_up_account_id       out number,
                                              v_company_id          out number,
                                              v_system_id           out number,
                                              v_local_business_type out number)
  return varchar2 is
  ------------------上游支付检查----------------
  l_down_company_id number;
  l_down_system_id  number;
  l_up_company_id   number;
  l_up_system_id    number;
  l_elec_count      number;
  l_elec_face       number;
  l_elec_balance    number;
  l_business_count  number;
  l_down_count      number;
  l_up_count        number;
begin
  ---1.检查扣款与订单金额
  if v_order_face <= 0 or v_order_amount <= 0 or v_up_draw_count <= 0 or
     v_up_draw_face <= 0 or v_up_draw_amount <= 0 then
  
    return pkg_error_code.amount_error;
  end if;

  ---2.检查下游渠道信息
  select count(1),
         max(t.company_id),
         max(t.source_system_id),
         max(t.account_id)
    into l_down_count,
         l_down_company_id,
         l_down_system_id,
         v_down_account_id
    from sup_base_down_channel t
   inner join sup_base_down_account a
      on t.account_id = a.account_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   where t.channel_no = v_down_channel_no;

  ---3.检查上游渠道信息
  select count(1),
         max(t.company_id),
         max(t.source_system_id),
         max(t.account_id),
         max(a.electronic_card_count),
         max(a.electronic_card_face),
         max(a.electronic_card_balance)
    into l_up_count,
         l_up_company_id,
         l_up_system_id,
         v_up_account_id,
         l_elec_count,
         l_elec_face,
         l_elec_balance
    from sup_base_up_channel t
   inner join sup_base_up_account a
      on t.account_id = a.account_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   where t.channel_no = v_up_channel_no;

  if l_down_count != 1 or l_up_count != 1 or
     l_down_company_id != l_up_company_id or
     l_down_system_id != l_up_system_id then
  
    return pkg_error_code.channel_error;
  end if;
  v_company_id := l_up_company_id;
  v_system_id  := l_up_system_id;

  ---4.获取本地业务类型
  select count(1), max(t.local_business_type)
    into l_business_count, v_local_business_type
    from fd_system_business_map t
   inner join fd_system_business_statis_map m
      on t.local_business_type = m.local_business_type
   where t.source_system_id = v_system_id
     and t.outer_business_type = v_business_type;

  if l_business_count != 1 then
    return pkg_error_code.business_type_not_exists;
  end if;

  ---5.检查渠道余额
  if v_up_draw_count > l_elec_count or v_up_draw_face > l_elec_face or
     v_up_draw_amount > l_elec_balance then
  
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_PHYSICAL_2_ELECTRONIC
prompt ================================================
prompt
create or replace function fd_account.sup_f_up_physical_2_electronic(v_up_channel_no varchar2,
                                                          v_up_account_id number,
                                                          v_company_id    number,
                                                          v_system_id     number,
                                                          v_card_count    number,
                                                          v_card_face     number,
                                                          v_card_amount   number,
                                                          v_change_time   varchar2,
                                                          v_memo          varchar2,
                                                          v_create_by     varchar2)
  return varchar2 is
  ----------------实体卡转电子卡密-----------------
  l_on_way_count            number;
  l_on_way_face             number;
  l_on_way_balance          number;
  l_physical_card_count     number;
  l_physical_card_face      number;
  l_physical_card_balance   number;
  l_electronic_card_count   number;
  l_electronic_card_face    number;
  l_electronic_card_balance number;
  l_up_fund_id              number;
begin
  ---1.锁上游渠道账户
  select t.on_way_count,
         t.on_way_face,
         t.on_way_balance,
         t.physical_card_count,
         t.physical_card_face,
         t.physical_card_balance,
         t.electronic_card_count,
         t.electronic_card_face,
         t.electronic_card_balance
    into l_on_way_count,
         l_on_way_face,
         l_on_way_balance,
         l_physical_card_count,
         l_physical_card_face,
         l_physical_card_balance,
         l_electronic_card_count,
         l_electronic_card_face,
         l_electronic_card_balance
    from sup_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.检查账户余额
  if v_card_count > l_physical_card_count or
     v_card_face > l_physical_card_face or
     v_card_amount > l_physical_card_balance then
  
    return pkg_error_code.balance_low;
  end if;

  ---3.实体卡转电子卡密，实体卡余额减款、电子卡密余额加款
  update sup_base_up_account t
     set t.physical_card_count    =
         (l_physical_card_count - v_card_count),
         t.physical_card_face     =
         (l_physical_card_face - v_card_face),
         t.physical_card_balance  =
         (l_physical_card_balance - v_card_amount),
         t.electronic_card_count  =
         (l_electronic_card_count + v_card_count),
         t.electronic_card_face   =
         (l_electronic_card_face + v_card_face),
         t.electronic_card_balance =
         (l_electronic_card_balance + v_card_amount)
   where t.account_id = v_up_account_id;

  ---4.实体卡转电子卡密操作记录
  select seq_sup_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into sup_trade_up_manual
    (record_id,
     up_channel_no,
     up_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     physical_change_count,
     physical_change_face,
     physical_change_amount,
     electronic_change_count,
     electronic_change_face,
     electronic_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     trade_change_time,
     memo,
     created_by)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     0,
     0,
     pkg_sup_up_manual_type.physical_2_electronic,
     sysdate,
     0,
     0,
     0,
     -v_card_count,
     -v_card_face,
     -v_card_amount,
     v_card_count,
     v_card_face,
     v_card_amount,
     l_on_way_count,
     l_on_way_face,
     l_on_way_balance,
     (l_physical_card_count - v_card_count),
     (l_physical_card_face - v_card_face),
     (l_physical_card_balance - v_card_amount),
     (l_electronic_card_count + v_card_count),
     (l_electronic_card_face + v_card_face),
     (l_electronic_card_balance + v_card_amount),
     to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_memo,
     v_create_by);

  ---5.实体卡转电子卡密资金变动记录
  insert into sup_trade_up_fund
    (record_id,
     source_system_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     change_type,
     change_time,
     trade_order_time,
     trade_change_time,
     up_draw_count,
     up_draw_face,
     up_draw_amount,
     way_change_count,
     way_change_face,
     way_change_amount,
     physical_change_count,
     physical_change_face,
     physical_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo)
  values
    (l_up_fund_id,
     v_system_id,
     v_up_channel_no,
     v_up_account_id,
     v_company_id,
     pkg_sup_up_fund_type.move_amount,
     sysdate,
     to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_card_count,
     v_card_face,
     v_card_amount,
     0,
     0,
     0,
     -v_card_count,
     -v_card_face,
     -v_card_amount,
     l_on_way_count,
     l_on_way_face,
     l_on_way_balance,
     (l_physical_card_count - v_card_count),
     (l_physical_card_face - v_card_face),
     (l_physical_card_balance - v_card_amount),
     (l_electronic_card_count + v_card_count),
     (l_electronic_card_face + v_card_face),
     (l_electronic_card_balance + v_card_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_PHYSICAL_STORAGE
prompt ===========================================
prompt
create or replace function fd_account.sup_f_up_physical_storage(v_up_channel_no varchar2,
                                                     v_up_account_id number,
                                                     v_company_id    number,
                                                     v_system_id     number,
                                                     v_card_count    number,
                                                     v_card_face     number,
                                                     v_card_amount   number,
                                                     v_change_time   varchar2,
                                                     v_memo          varchar2,
                                                     v_create_by     varchar2)
  return varchar2 is
  ----------------------实体卡入库---------------------
  l_on_way_count            number;
  l_on_way_face             number;
  l_on_way_balance          number;
  l_physical_card_count     number;
  l_physical_card_face      number;
  l_physical_card_balance   number;
  l_electronic_card_count   number;
  l_electronic_card_face    number;
  l_electronic_card_balance number;
  l_up_fund_id              number;
begin
  ---1.锁上游渠道账户
  select t.on_way_count,
         t.on_way_face,
         t.on_way_balance,
         t.physical_card_count,
         t.physical_card_face,
         t.physical_card_balance,
         t.electronic_card_count,
         t.electronic_card_face,
         t.electronic_card_balance
    into l_on_way_count,
         l_on_way_face,
         l_on_way_balance,
         l_physical_card_count,
         l_physical_card_face,
         l_physical_card_balance,
         l_electronic_card_count,
         l_electronic_card_face,
         l_electronic_card_balance
    from sup_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.检查账户余额
  if v_card_count > l_on_way_count or v_card_face > l_on_way_face or
     v_card_amount > l_on_way_balance then
    return pkg_error_code.balance_low;
  end if;

  ---3.实体卡入库，在途减款、实体卡余额加款
  update sup_base_up_account t
     set t.on_way_count         =
         (l_on_way_count - v_card_count),
         t.on_way_face          =
         (l_on_way_face - v_card_face),
         t.on_way_balance       =
         (l_on_way_balance - v_card_amount),
         t.physical_card_count  =
         (l_physical_card_count + v_card_count),
         t.physical_card_face   =
         (l_physical_card_face + v_card_face),
         t.physical_card_balance =
         (l_physical_card_balance + v_card_amount)
   where t.account_id = v_up_account_id;

  ---4.实体卡入库操作记录
  select seq_sup_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into sup_trade_up_manual
    (record_id,
     up_channel_no,
     up_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     way_change_count,
     way_change_face,
     way_change_amount,
     physical_change_count,
     physical_change_face,
     physical_change_amount,
     electronic_change_count,
     electronic_change_face,
     electronic_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     trade_change_time,
     memo,
     created_by)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     0,
     0,
     pkg_sup_up_manual_type.physical_storage,
     sysdate,
     -v_card_count,
     -v_card_face,
     -v_card_amount,
     v_card_count,
     v_card_face,
     v_card_amount,
     0,
     0,
     0,
     (l_on_way_count - v_card_count),
     (l_on_way_face - v_card_face),
     (l_on_way_balance - v_card_amount),
     (l_physical_card_count + v_card_count),
     (l_physical_card_face + v_card_face),
     (l_physical_card_balance + v_card_amount),
     l_electronic_card_count,
     l_electronic_card_face,
     l_electronic_card_balance,
     to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_memo,
     v_create_by);

  ---5.实体卡入库资金变动记录
  insert into sup_trade_up_fund
    (record_id,
     source_system_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     change_type,
     change_time,
     trade_order_time,
     trade_change_time,
     up_draw_count,
     up_draw_face,
     up_draw_amount,
     way_change_count,
     way_change_face,
     way_change_amount,
     physical_change_count,
     physical_change_face,
     physical_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo)
  values
    (l_up_fund_id,
     v_system_id,
     v_up_channel_no,
     v_up_account_id,
     v_company_id,
     pkg_sup_up_fund_type.move_amount,
     sysdate,
     to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     to_date(v_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     0,
     0,
     0,
     -v_card_count,
     -v_card_face,
     -v_card_amount,
     v_card_count,
     v_card_face,
     v_card_amount,
     (l_on_way_count - v_card_count),
     (l_on_way_face - v_card_face),
     (l_on_way_balance - v_card_amount),
     (l_physical_card_count + v_card_count),
     (l_physical_card_face + v_card_face),
     (l_physical_card_balance + v_card_amount),
     l_electronic_card_count,
     l_electronic_card_face,
     l_electronic_card_balance,
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_REFUND_CHECK
prompt =======================================
prompt
create or replace function fd_account.sup_f_up_refund_check(v_up_channel_no       varchar2,
                                                 v_down_channel_no     varchar2,
                                                 v_business_type       number,
                                                 v_up_refund_count     number,
                                                 v_up_refund_face      number,
                                                 v_up_refund_amount    number,
                                                 v_up_account_id       out number,
                                                 v_down_account_id     out number,
                                                 v_company_id          out number,
                                                 v_system_id           out number,
                                                 v_local_business_type out number)
  return varchar2 is
  ---------------上游退款信息检查-----------
  l_down_company_id number;
  l_down_system_id  number;
  l_up_company_id   number;
  l_up_system_id    number;
  l_business_count  number;
  l_down_count      number;
  l_up_count        number;
begin
  ---1.检查上游退款金额信息
  if v_up_refund_count <= 0 or v_up_refund_face <= 0 or
     v_up_refund_amount <= 0 then
  
    return pkg_error_code.amount_error;
  end if;

  ---2.检查下游渠道信息
  select count(1),
         max(t.company_id),
         max(t.source_system_id),
         max(t.account_id)
    into l_down_count,
         l_down_company_id,
         l_down_system_id,
         v_down_account_id
    from sup_base_down_channel t
   inner join sup_base_down_account a
      on t.account_id = a.account_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   where t.channel_no = v_down_channel_no;

  ---3.检查上游渠道信息
  select count(1),
         max(t.company_id),
         max(t.source_system_id),
         max(t.account_id)
    into l_up_count, l_up_company_id, l_up_system_id, v_up_account_id
    from sup_base_up_channel t
   inner join sup_base_up_account a
      on t.account_id = a.account_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   where t.channel_no = v_up_channel_no;

  if l_down_count != 1 or l_up_count != 1 or
     l_down_company_id != l_up_company_id or
     l_down_system_id != l_up_system_id then
  
    return pkg_error_code.channel_error;
  end if;

  v_company_id := l_up_company_id;
  v_system_id  := l_up_system_id;

  ---4.获取本地业务类型
  select count(1), max(t.local_business_type)
    into l_business_count, v_local_business_type
    from fd_system_business_map t
   inner join fd_system_business_statis_map m
      on t.local_business_type = m.local_business_type
   where t.source_system_id = v_system_id
     and t.outer_business_type = v_business_type;

  if l_business_count != 1 then
    return pkg_error_code.business_type_not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_TRADE_RV
prompt ===================================
prompt
create or replace function fd_account.sup_f_up_trade_rv(v_up_channel_no varchar2,
                                             v_rv_count      number,
                                             v_rv_face       number,
                                             v_rv_amount     number,
                                             v_up_account_id number,
                                             v_up_company_id number,
                                             v_system_id     number,
                                             v_bill_type     number,
                                             v_business_type number,
                                             v_memo          varchar2,
                                             v_create_user   varchar2)
  return varchar2 is
  -----------------sup上游渠道账户交易平账----------------
  l_way_count    number;
  l_way_face     number;
  l_way_balance  number;
  l_phy_count    number;
  l_phy_face     number;
  l_phy_balance  number;
  l_elec_count   number;
  l_elec_face    number;
  l_elec_balance number;
  l_up_fund_id   number;

begin
  ---1.锁上游渠道账户
  select t.on_way_count,
         t.on_way_face,
         t.on_way_balance,
         t.physical_card_count,
         t.physical_card_face,
         t.physical_card_balance,
         t.electronic_card_count,
         t.electronic_card_face,
         t.electronic_card_balance
    into l_way_count,
         l_way_face,
         l_way_balance,
         l_phy_count,
         l_phy_face,
         l_phy_balance,
         l_elec_count,
         l_elec_face,
         l_elec_balance
    from sup_base_up_account t
   where t.account_id = v_up_account_id
     for update;

  ---2.检查上游账户余额
  if ((l_elec_balance - v_rv_amount) < 0 or (l_elec_face - v_rv_face) < 0 or
     (l_elec_count - v_rv_count) < 0) then
    return pkg_error_code.balance_low;
  end if;

  ---3.上游渠道交易平账
  update sup_base_up_account t
     set t.electronic_card_count  =
         (l_elec_count - v_rv_count),
         t.electronic_card_face   =
         (l_elec_face - v_rv_face),
         t.electronic_card_balance =
         (l_elec_balance - v_rv_amount)
   where t.account_id = v_up_account_id;

  ---4.添加上游交易平账记录
  select seq_sup_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into sup_trade_up_manual
    (record_id,
     up_channel_no,
     up_account_id,
     has_adjust,
     adjust_record_id,
     change_type,
     change_time,
     electronic_change_count,
     electronic_change_face,
     electronic_change_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo,
     created_by)
  values
    (l_up_fund_id,
     v_up_channel_no,
     v_up_account_id,
     pkg_sys_boolean.istrue,
     0,
     pkg_sup_up_manual_type.trade_revise,
     sysdate,
     v_rv_count,
     v_rv_face,
     v_rv_amount,
     l_way_count,
     l_way_face,
     l_way_balance,
     l_phy_count,
     l_phy_face,
     l_phy_balance,
     (l_elec_count - v_rv_count),
     (l_elec_face - v_rv_face),
     (l_elec_balance - v_rv_amount),
     v_memo,
     v_create_user);

  ---5.添加上游资金变动记录
  insert into sup_trade_up_fund
    (record_id,
     source_system_id,
     trade_order_no,
     up_channel_no,
     up_account_id,
     up_company_id,
     bill_type,
     business_type,
     change_type,
     change_time,
     up_draw_count,
     up_draw_face,
     up_draw_amount,
     way_count_balance,
     way_face_balance,
     way_card_balance,
     physical_count_balance,
     physical_face_balance,
     physical_card_balance,
     electronic_count_balance,
     electronic_face_balance,
     electronic_card_balance,
     memo)
  values
    (l_up_fund_id,
     v_system_id,
     ('SARV' || to_char(sysdate, 'yyyymmddhh24miss')),
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     v_bill_type,
     v_business_type,
     pkg_sup_up_fund_type.debit_amount,
     sysdate,
     v_rv_count,
     v_rv_face,
     v_rv_amount,
     l_way_count,
     l_way_face,
     l_way_balance,
     l_phy_count,
     l_phy_face,
     l_phy_balance,
     (l_elec_count - v_rv_count),
     (l_elec_face - v_rv_face),
     (l_elec_balance - v_rv_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_F_UP_TRADE_RV_CHECK
prompt =========================================
prompt
create or replace function fd_account.sup_f_up_trade_rv_check(v_up_channel_no varchar2,
                                                   v_rv_count      number,
                                                   v_rv_face       number,
                                                   v_rv_amount     number,
                                                   v_business_type number,
                                                   v_up_account_id out number,
                                                   v_up_company_id out number,
                                                   v_system_id     out number)
  return varchar2 is
  -----------------上游交易平账基础信息检查----------------
  l_channel_count  number;
  l_business_count number;
  l_elec_count     number;
  l_elec_face      number;
  l_elec_balance   number;

begin
  ---1.检查平账金额
  if v_rv_amount = 0 or v_rv_count = 0 or v_rv_face = 0 then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查业务类型
  select count(1)
    into l_business_count
    from fd_system_business_statis_map t
   where t.local_business_type = v_business_type;

  if l_business_count != 1 then
    return pkg_error_code.data_error;
  end if;

  ---2.检查上游渠道及账户信息
  select count(1),
         max(t.account_id),
         max(t.company_id),
         max(t.source_system_id),
         max(a.electronic_card_count),
         max(a.electronic_card_face),
         max(a.electronic_card_balance)
    into l_channel_count,
         v_up_account_id,
         v_up_company_id,
         v_system_id,
         l_elec_count,
         l_elec_face,
         l_elec_balance
    from sup_base_up_channel t
   inner join sup_base_up_account a
      on t.account_id = a.account_id
   inner join fd_base_company_info c
      on t.company_id = c.company_id
   inner join fd_base_source_system s
      on t.source_system_id = s.source_system_id
   where t.channel_no = v_up_channel_no;

  if l_channel_count != 1 then
    return pkg_error_code.channel_error;
  end if;

  ---3.检查上游账户余额
  if ((l_elec_balance - v_rv_amount) < 0 or (l_elec_face - v_rv_face) < 0 or
     (l_elec_count - v_rv_count) < 0) then
    return pkg_error_code.balance_low;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function SUP_P_MANUAL_DOWN_BALANCE_RV
prompt ==============================================
prompt
create or replace function fd_account.sup_p_manual_down_balance_rv(v_down_channel_no varchar2,
                                                        v_rv_amount       number,
                                                        v_memo            varchar2,
                                                        v_create_user     varchar2)
  return varchar2 is
  --------------sup下游渠道余额平账--------------
  PRAGMA AUTONOMOUS_TRANSACTION;
  l_result          varchar2(32);
  l_down_account_id number;
  l_down_company_id number;
  l_system_id       number;

begin
  ---1.检查余额平账信息
  l_result := sup_f_down_balance_rv_check(v_down_channel_no,
                                          v_rv_amount,
                                          l_down_account_id,
                                          l_down_company_id,
                                          l_system_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---2.sup下游渠道账户余额平账
  l_result := sup_f_down_balance_rv(v_down_channel_no,
                                    v_rv_amount,
                                    l_down_account_id,
                                    l_down_company_id,
                                    l_system_id,
                                    v_memo,
                                    v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('sup下游渠道余额平账',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        'v_rv_amount=' || v_rv_amount));

  commit;
  return pkg_error_code.success;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_down_balance_rv', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function SUP_P_MANUAL_DOWN_TRADE_RV
prompt ============================================
prompt
create or replace function fd_account.sup_p_manual_down_trade_rv(v_down_channel_no varchar2,
                                                      v_rv_count        number,
                                                      v_rv_face         number,
                                                      v_rv_amount       number,
                                                      v_bill_type       number,
                                                      v_business_type   number,
                                                      v_memo            varchar2,
                                                      v_create_user     varchar2)
  return varchar2 is
  PRAGMA AUTONOMOUS_TRANSACTION;
  --------------sup下游渠道交易平账--------------
  l_result          varchar2(32);
  l_down_account_id number;
  l_down_company_id number;
  l_system_id       number;

begin
  ---1.检查交易平账信息
  l_result := sup_f_down_trade_rv_check(v_down_channel_no,
                                        v_rv_count,
                                        v_rv_face,
                                        v_rv_amount,
                                        v_business_type,
                                        l_down_account_id,
                                        l_down_company_id,
                                        l_system_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---2.sup下游渠道账户交易平账
  l_result := sup_f_down_trade_rv(v_down_channel_no,
                                  v_rv_count,
                                  v_rv_face,
                                  v_rv_amount,
                                  l_down_account_id,
                                  l_down_company_id,
                                  l_system_id,
                                  v_bill_type,
                                  v_business_type,
                                  v_memo,
                                  v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('sup下游渠道交易平账',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        'v_rv_amount=' || v_rv_amount));

  commit;
  return pkg_error_code.success;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_down_trade_rv', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function SUP_P_MANUAL_UP_ADD
prompt =====================================
prompt
create or replace function fd_account.sup_p_manual_up_add(v_up_channel_no   varchar2,
                                               v_bank_account_id number,
                                               v_add_count       number,
                                               v_add_face        number,
                                               v_add_amount      number,
                                               v_service_fee     number,
                                               v_memo            varchar2,
                                               v_create_user     varchar2)
  return varchar2 is
  PRAGMA AUTONOMOUS_TRANSACTION;
  --------------sup上游渠道加款--------------
  l_result              varchar2(32);
  l_up_account_id       number;
  l_up_company_id       number;
  l_system_id           number;
  l_up_channel_name     varchar2(32);
  l_up_account_name     varchar2(32);
  l_sup_down_channel_no varchar2(32);
  l_sup_down_accout_id  number;
  l_18_up_channel_no    varchar2(32);
  l_18_up_accout_id     number;
  l_bank_card_no        varchar2(64);
  l_bank_fund_id        number;
  l_bank_service_id     number;
  l_bank_relate_id      number;
begin
  ---1.检查加款信息
  l_result := sup_f_up_add_check(v_up_channel_no,
                                 v_bank_account_id,
                                 v_add_count,
                                 v_add_face,
                                 v_add_amount,
                                 v_service_fee,
                                 l_up_account_id,
                                 l_up_company_id,
                                 l_system_id,
                                 l_up_channel_name,
                                 l_up_account_name,
                                 l_sup_down_channel_no,
                                 l_sup_down_accout_id,
                                 l_18_up_channel_no,
                                 l_18_up_accout_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---2.银行账户扣款
  l_result := sup_f_up_add_bank_minus(v_bank_account_id,
                                      v_add_amount,
                                      v_service_fee,
                                      l_up_channel_name,
                                      l_up_account_name,
                                      v_memo,
                                      '',
                                      v_create_user,
                                      l_bank_card_no,
                                      l_bank_fund_id,
                                      l_bank_service_id,
                                      l_bank_relate_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---3.sup上游渠道加款
  l_result := sup_f_up_channel_add(v_up_channel_no,
                                   l_up_account_id,
                                   l_up_company_id,
                                   l_system_id,
                                   l_bank_card_no,
                                   l_bank_fund_id,
                                   l_bank_service_id,
                                   l_bank_relate_id,
                                   v_add_count,
                                   v_add_face,
                                   v_add_amount,
                                   v_memo,
                                   v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---4.sup下游渠道加款
  l_result := sup_f_down_channel_add(l_sup_down_channel_no,
                                     l_sup_down_accout_id,
                                     l_up_company_id,
                                     l_system_id,
                                     l_bank_relate_id,
                                     v_add_face,
                                     v_add_amount,
                                     v_memo,
                                     v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---5.用卡生产系统上游渠道加款
  l_result := sup_f_pro_up_channel_add(l_18_up_channel_no,
                                       l_18_up_accout_id,
                                       l_up_company_id,
                                       l_bank_relate_id,
                                       v_add_amount,
                                       v_memo,
                                       v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---6.记录操作日志
  fd_p_write_handle_log('sup上游关联加款',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        'v_bank_account_id=' || v_bank_account_id ||
                        ',v_add_amount=' || v_add_amount));

  commit;
  return pkg_error_code.success;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_up_add', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function SUP_P_MANUAL_UP_ADD_ADJUST
prompt ============================================
prompt
create or replace function fd_account.sup_p_manual_up_add_adjust(v_add_record_id number,
                                                      v_memo          varchar2,
                                                      v_create_user   varchar2)
  return varchar2 is
  PRAGMA AUTONOMOUS_TRANSACTION;
  --------------sup上游渠道加款红冲--------------
  l_result           varchar2(32);
  l_bank_record_id   number;
  l_bank_service_id  number;
  l_bank_relate_id   number;
  l_adjust_relate_id number;
  l_up_channel_no    varchar2(32);
  l_change_time      date;
begin
  ---1.检查上游加款相关记录数据
  l_result := sup_f_up_add_adjust_check(v_add_record_id,
                                        l_up_channel_no,
                                        l_change_time,
                                        l_bank_record_id,
                                        l_bank_service_id,
                                        l_bank_relate_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---2.上游加款银行流水记录红冲
  l_result := sup_f_up_add_bank_adjust(l_bank_record_id,
                                       l_bank_service_id,
                                       l_bank_relate_id,
                                       v_memo,
                                       v_create_user,
                                       l_adjust_relate_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---3.上游加款记录红冲
  l_result := sup_f_up_add_adjust(v_add_record_id,
                                  l_adjust_relate_id,
                                  v_memo,
                                  v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---4.上游加款关联下游红冲
  l_result := sup_f_down_add_adjust(l_up_channel_no,
                                    l_bank_relate_id,
                                    l_change_time,
                                    l_adjust_relate_id,
                                    v_memo,
                                    v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---5.上游加款关联生产系统上游红冲
  l_result := sup_f_pro_up_add_adjust(l_up_channel_no,
                                      l_bank_relate_id,
                                      l_change_time,
                                      l_adjust_relate_id,
                                      v_memo,
                                      v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---6.记录操作日志
  fd_p_write_handle_log('sup上游加款红冲',
                        v_create_user,
                        ('v_add_record_id=' || v_add_record_id));

  commit;
  return pkg_error_code.success;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_up_add_adjust', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function SUP_P_MANUAL_UP_BALANCE_RV
prompt ============================================
prompt
create or replace function fd_account.sup_p_manual_up_balance_rv(v_up_channel_no varchar2,
                                                      v_rv_type       number,
                                                      v_rv_count      number,
                                                      v_rv_face       number,
                                                      v_rv_amount     number,
                                                      v_memo          varchar2,
                                                      v_create_user   varchar2)
  return varchar2 is
  --------------sup上游渠道余额平账--------------
  PRAGMA AUTONOMOUS_TRANSACTION;
  l_result        varchar2(32);
  l_up_account_id number;
  l_up_company_id number;
  l_system_id     number;

begin
  ---1.检查余额平账信息
  l_result := sup_f_up_balance_rv_check(v_up_channel_no,
                                        v_rv_type,
                                        v_rv_count,
                                        v_rv_face,
                                        v_rv_amount,
                                        l_up_account_id,
                                        l_up_company_id,
                                        l_system_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---2.sup上游渠道账户余额平账
  l_result := sup_f_up_balance_rv(v_up_channel_no,
                                  v_rv_type,
                                  v_rv_count,
                                  v_rv_face,
                                  v_rv_amount,
                                  l_up_account_id,
                                  l_up_company_id,
                                  l_system_id,
                                  v_memo,
                                  v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('sup上游渠道余额平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        'v_rv_type=' || v_rv_type || 'v_rv_amount=' ||
                        v_rv_amount));

  commit;
  return pkg_error_code.success;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_up_balance_rv', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function SUP_P_MANUAL_UP_DRAW
prompt ======================================
prompt
create or replace function fd_account.sup_p_manual_up_draw(v_up_channel_no   varchar2,
                                                v_bank_account_id number,
                                                v_draw_type       number,
                                                v_draw_count      number,
                                                v_draw_face       number,
                                                v_draw_amount     number,
                                                v_memo            varchar2,
                                                v_create_user     varchar2)
  return varchar2 is
  --------------sup上游渠道提款--------------
  PRAGMA AUTONOMOUS_TRANSACTION;
  l_result              varchar2(32);
  l_up_account_id       number;
  l_up_company_id       number;
  l_system_id           number;
  l_up_channel_name     varchar2(32);
  l_up_account_name     varchar2(32);
  l_sup_down_channel_no varchar2(32);
  l_sup_down_accout_id  number;
  l_18_up_channel_no    varchar2(32);
  l_18_up_accout_id     number;
  l_bank_card_no        varchar2(64);
  l_bank_fund_id        number;
  l_bank_relate_id      number;

begin
  ---1.检查提款信息
  l_result := sup_f_up_draw_check(v_bank_account_id,
                                  v_up_channel_no,
                                  v_draw_type,
                                  v_draw_count,
                                  v_draw_face,
                                  v_draw_amount,
                                  l_up_account_id,
                                  l_up_company_id,
                                  l_system_id,
                                  l_up_channel_name,
                                  l_up_account_name,
                                  l_sup_down_channel_no,
                                  l_sup_down_accout_id,
                                  l_18_up_channel_no,
                                  l_18_up_accout_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---2.银行账户加款
  l_result := sup_f_up_draw_bank_plus(v_bank_account_id,
                                      v_draw_amount,
                                      l_up_channel_name,
                                      l_up_account_name,
                                      v_create_user,
                                      v_memo,
                                      '',
                                      l_bank_card_no,
                                      l_bank_relate_id,
                                      l_bank_fund_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---3.sup上游渠道减款
  l_result := sup_f_up_channel_draw(v_up_channel_no,
                                    l_up_account_id,
                                    l_up_company_id,
                                    v_draw_type,
                                    v_draw_count,
                                    v_draw_face,
                                    v_draw_amount,
                                    l_bank_card_no,
                                    l_system_id,
                                    l_bank_fund_id,
                                    l_bank_relate_id,
                                    v_memo,
                                    v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---4.sup下游渠道减款
  l_result := sup_f_down_channel_draw(l_sup_down_channel_no,
                                      l_sup_down_accout_id,
                                      l_up_company_id,
                                      l_system_id,
                                      l_bank_relate_id,
                                      v_draw_face,
                                      v_draw_amount,
                                      v_memo,
                                      v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---5.用卡生产系统上游渠道减款
  l_result := sup_f_pro_up_channel_draw(l_18_up_channel_no,
                                        l_18_up_accout_id,
                                        l_up_company_id,
                                        l_bank_relate_id,
                                        v_draw_amount,
                                        v_memo,
                                        v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---6.记录操作日志
  fd_p_write_handle_log('sup上游关联提款',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        'v_bank_account_id=' || v_bank_account_id ||
                        ',v_draw_amount=' || v_draw_amount));

  commit;
  return pkg_error_code.success;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_up_draw', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function SUP_P_MANUAL_UP_DRAW_ADJUST
prompt =============================================
prompt
create or replace function fd_account.sup_p_manual_up_draw_adjust(v_draw_record_id number,
                                                       v_memo           varchar2,
                                                       v_create_user    varchar2)
  return varchar2 is
  --------------sup上游渠道提款红冲--------------
  PRAGMA AUTONOMOUS_TRANSACTION;
  l_result           varchar2(32);
  l_bank_record_id   number;
  l_bank_relate_id   number;
  l_adjust_relate_id number;
  l_up_channel_no    varchar2(32);
  l_change_time      date;

begin
  ---1.检查上游提款相关记录数据
  l_result := sup_f_up_draw_adjust_check(v_draw_record_id,
                                         l_up_channel_no,
                                         l_change_time,
                                         l_bank_record_id,
                                         l_bank_relate_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---2.上游减款银行流水记录红冲
  l_result := sup_f_up_draw_bank_adjust(l_bank_record_id,
                                        l_bank_relate_id,
                                        v_memo,
                                        v_create_user,
                                        l_adjust_relate_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---3.上游减款记录红冲
  l_result := sup_f_up_draw_adjust(v_draw_record_id,
                                   l_adjust_relate_id,
                                   v_memo,
                                   v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---4.上游减款关联下游红冲
  l_result := sup_f_down_draw_adjust(l_up_channel_no,
                                     l_bank_relate_id,
                                     l_change_time,
                                     l_adjust_relate_id,
                                     v_memo,
                                     v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---5.上游减款关联生产系统上游红冲
  l_result := sup_f_pro_up_draw_adjust(l_up_channel_no,
                                       l_bank_relate_id,
                                       l_change_time,
                                       l_adjust_relate_id,
                                       v_memo,
                                       v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---6.记录操作日志
  fd_p_write_handle_log('sup上游提款红冲',
                        v_create_user,
                        ('v_draw_record_id=' || v_draw_record_id));

  commit;
  return pkg_error_code.success;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_up_draw_adjust', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function SUP_P_MANUAL_UP_TRADE_RV
prompt ==========================================
prompt
create or replace function fd_account.sup_p_manual_up_trade_rv(v_up_channel_no varchar2,
                                                    v_rv_count      number,
                                                    v_rv_face       number,
                                                    v_rv_amount     number,
                                                    v_bill_type     number,
                                                    v_business_type number,
                                                    v_memo          varchar2,
                                                    v_create_user   varchar2)
  return varchar2 is
  --------------sup上游渠道交易平账--------------
  PRAGMA AUTONOMOUS_TRANSACTION;
  l_result        varchar2(32);
  l_up_account_id number;
  l_up_company_id number;
  l_system_id     number;

begin
  ---1.检查交易平账信息
  l_result := sup_f_up_trade_rv_check(v_up_channel_no,
                                      v_rv_count,
                                      v_rv_face,
                                      v_rv_amount,
                                      v_business_type,
                                      l_up_account_id,
                                      l_up_company_id,
                                      l_system_id);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---2.sup上游渠道账户交易平账
  l_result := sup_f_up_trade_rv(v_up_channel_no,
                                v_rv_count,
                                v_rv_face,
                                v_rv_amount,
                                l_up_account_id,
                                l_up_company_id,
                                l_system_id,
                                v_bill_type,
                                v_business_type,
                                v_memo,
                                v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    return l_result;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('sup上游渠道交易平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        'v_rv_amount=' || v_rv_amount));

  commit;
  return pkg_error_code.success;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_up_trade_rv', sqlerrm, 1);
    return pkg_error_code.system_busy;
end;
/

prompt
prompt Creating function YX_F_ADJUST_AGENT_DRAW
prompt ========================================
prompt
create or replace function fd_account.yx_f_adjust_agent_draw(v_record_id   in number,
                                                  v_create_user in varchar2,
                                                  v_memo        in varchar2)

 return varchar2 is
  /*
    功能介绍:代理人提款红冲
    创建人:邓孝辉
    创建时间:2019/3/25
  */
  l_agent_id              varchar2(32);
  l_change_amount         number;
  l_change_time           date;
  l_bank_batch_id         number;
  l_bank_account_id       number;
  l_service_count         number;
  l_service_change_amount number;
  l_bank_service_id       number;
  l_bank_balance          number;
  l_handle_batch_id       number;
  l_agent_balance         number;
  l_fund_record_id        number;
  l_bank_fund_id          number;

begin
  ---1. 获取提款数据
  select m.agent_id, m.change_amount, m.change_time, m.bank_fund_id
    into l_agent_id, l_change_amount, l_change_time, l_bank_batch_id
    from yx_trade_agent_manual m
   inner join yx_base_agent a
      on m.agent_id = a.agent_id
   where m.record_id = v_record_id
     and m.add_type = pkg_agent_manual_change_type.draw_amount
     and m.has_adjust = pkg_sys_boolean.isfalse;

  --2. 获取实体卡变动记录
  select t.account_id, t.record_id
    into l_bank_account_id, l_bank_fund_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.use_type = pkg_bank_use_type.down_draw
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  ---3. 获取手续费记录数据
  select count(1), nvl(max(t.change_amount), 0), max(t.record_id)
    into l_service_count, l_service_change_amount, l_bank_service_id
    from fd_bank_cash_fund t
   where t.service_id = l_bank_batch_id
     and t.use_type = pkg_bank_use_type.service_fee
     and t.change_type = pkg_bank_fund_change_type.minus_amount
     and t.change_time > (l_change_time - 1 / 24 / 60)
     and t.change_time < (l_change_time + 1 / 24 / 60)
     and rownum <= 2;

  --=================4.实体卡手续费记录红冲====================
  ---[锁实体卡,更新实体卡余额,红冲实体卡代理人提款,是否有手续费记录,红冲实体卡手续费]---
  ---4.1 锁实体卡账户
  select a.balance
    into l_bank_balance
    from fd_bank_account_info a
   where a.account_id = l_bank_account_id
     for update;

  ---4.2 更新实体卡余额
  update fd_bank_account_info i
     set i.balance = i.balance + l_change_amount + l_service_change_amount
   where i.account_id = l_bank_account_id;

  ---4.3获取数据红冲对应的统一流水编号
  select seq_bank_service_id.nextval into l_handle_batch_id from dual;

  ---4.4 红冲实体卡代理人提款记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0 - t.change_amount),
           (l_bank_balance + l_service_change_amount + l_change_amount),
           sysdate,
           v_create_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id
      from fd_bank_cash_fund t
     where t.record_id = l_bank_fund_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---修改原实体卡提款纪录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_bank_fund_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---4.5 是否有手续费记录,红冲实体卡手续费记录
  if (l_service_count > 0) then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       adjust_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       has_adjust,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
      select seq_bank_cash_fund_id.nextval,
             t.account_id,
             t.record_id,
             t.company_id,
             (0 - t.change_amount),
             (l_bank_balance + l_service_change_amount),
             sysdate,
             v_create_user,
             t.change_type,
             t.use_type,
             pkg_sys_boolean.istrue,
             t.link_channel_name,
             t.link_account_name,
             v_memo,
             l_handle_batch_id
        from fd_bank_cash_fund t
       where t.record_id = l_bank_service_id
         and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  
    --- 修改原手续费记录状态
    update fd_bank_cash_fund t
       set t.has_adjust = pkg_sys_boolean.istrue
     where t.record_id = l_bank_service_id
       and t.has_adjust = pkg_sys_boolean.isfalse;
  
    if sql%rowcount = 0 then
      return pkg_error_code.not_exists;
    end if;
  end if;
  --=================5.代理人记录红冲====================
  ---[锁代理人余额,修改代理人余额,红冲代理人手工提款记录,红冲代理人提款记录]---

  ---5.1. 锁代理人余额
  select a.balance
    into l_agent_balance
    from yx_base_agent a
   where a.agent_id = l_agent_id
     for update;

  ---5.2. 修改代理人余额
  update yx_base_agent a
     set a.balance = a.balance + l_change_amount
   where a.agent_id = l_agent_id;

  --获取红冲记录序号
  select seq_yxtradeagentfund_auto_id.nextval
    into l_fund_record_id
    from dual;
  ---5.3. 红冲代理人手工提款记录
  insert into yx_trade_agent_manual
    (record_id,
     agent_id,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo,
     bank_fund_id)
    select l_fund_record_id,
           t.agent_id,
           t.account_id,
           t.record_id,
           pkg_sys_boolean.istrue,
           pkg_agent_manual_change_type.draw_red,
           0 - t.change_amount,
           sysdate,
           l_agent_balance + l_change_amount,
           v_create_user,
           v_memo,
           l_handle_batch_id
      from yx_trade_agent_manual t
     where t.record_id = v_record_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---修改原代理人手工提款记录
  update yx_trade_agent_manual m
     set m.has_adjust = pkg_sys_boolean.istrue
   where m.record_id = v_record_id
     and m.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;
  ---5.4 红冲代理人提款记录
  insert into yx_trade_agent_fund
    (record_id,
     up_fund_id,
     down_channel_no,
     up_channel_no,
     order_source,
     agent_id,
     change_amount,
     balance,
     change_type,
     change_time)
    select l_fund_record_id,
           f.up_fund_id,
           f.down_channel_no,
           f.up_channel_no,
           f.order_source,
           f.agent_id,
           0 - l_change_amount,
           l_agent_balance + l_change_amount,
           pkg_agent_fund_change_type.draw_amount,
           sysdate
      from yx_trade_agent_fund f
     where f.record_id = v_record_id;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_ADJUST_AGENT_DRAW_CHECK
prompt ==============================================
prompt
create or replace function fd_account.yx_f_adjust_agent_draw_check(v_record_id   in number,
                                                        v_adjust_days in number)

 return varchar2 is
  /*
    功能介绍:代理人检查提款记录,账户,余额,手续费
    创建人:邓孝辉
    创建时间:2019/3/25
  */
  l_record_count number;
  l_change_time  date;
begin
  ---1. 检查代理人提款记录,账户,余额
  select count(1), max(m.change_time)
    into l_record_count, l_change_time
    from yx_trade_agent_manual m
   inner join yx_base_agent a
      on m.agent_id = a.agent_id
   inner join fd_bank_cash_fund f
      on m.bank_fund_id = f.service_id
   inner join fd_bank_account_info b
      on b.account_id = f.account_id
   where m.record_id = v_record_id
     and m.has_adjust = pkg_sys_boolean.isfalse
     and f.has_adjust = pkg_sys_boolean.isfalse
     and m.add_type = pkg_down_manual_change_type.draw_amount
     and m.change_amount = f.change_amount;

  if (l_record_count != 1 and l_record_count != 2) then
    return pkg_error_code.data_error;
  end if;

  if (l_change_time < (sysdate - v_adjust_days)) then
    return pkg_error_code.adjust_timeout;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_ADJUST_DOWN_ADD
prompt ======================================
prompt
create or replace function fd_account.yx_f_adjust_down_add(v_record_id   in number,
                                                v_create_user in varchar2,
                                                v_memo        in varchar2)
  return varchar2 is
  /**
         功能介绍:下游加款红冲
         创建人:邓孝辉
         创建时间:2019/3/25
  */
  l_channel_no         varchar2(32);
  l_account_id         number;
  l_change_amount      number;
  l_change_time        date;
  l_bank_batch_id      number;
  l_bank_balance       number;
  l_bank_account_id    number;
  l_bank_fund_id       number;
  l_handle_batch_id    number;
  l_inner_balance      number;
  l_fund_id            number;

begin

  ---1. 查询下游红冲数据
select m.channel_no,
       m.account_id,
       m.change_amount,
       m.change_time,
       m.bank_fund_id
  into l_channel_no,
       l_account_id,
       l_change_amount,
       l_change_time,
       l_bank_batch_id
  from yx_trade_down_manual m
 where m.record_id = v_record_id;

---2. 获取实体卡变动记录
select f.account_id, f.record_id
  into l_bank_account_id, l_bank_fund_id
  from fd_bank_cash_fund f
 where f.service_id = l_bank_batch_id
   and f.has_adjust = pkg_sys_boolean.isfalse
   and f.use_type = pkg_bank_use_type.down_add
   and f.change_type = pkg_bank_fund_change_type.add_amount
   and f.change_time > (l_change_time - 1 / 24 / 60)
   and f.change_time < (l_change_time + 1 / 24 / 60)
   and rownum <= 2;

--3 =====================银行卡记录红冲=============================
--[锁实体卡,更新实体卡金额,红冲银行卡记录红冲]---

---3.1 锁实体卡
select b.balance
  into l_bank_balance
  from fd_bank_account_info b
 where b.account_id = l_bank_account_id
   for update;

---3.2 修改实体卡金额
update fd_bank_account_info i
   set i.balance = i.balance - l_change_amount
 where i.account_id = l_bank_account_id;

---获取红冲序号
select seq_bank_service_id.nextval into l_handle_batch_id from dual;

---3.3 红冲实体卡下游加款
insert into fd_bank_cash_fund
  (record_id,
   account_id,
   adjust_id,
   company_id,
   change_amount,
   balance,
   change_time,
   created_user,
   change_type,
   use_type,
   has_adjust,
   link_channel_name,
   link_account_name,
   remark,
   service_id)
  select seq_bank_cash_fund_id.nextval,
         t.account_id,
         t.record_id,
         t.company_id,
         (0 - l_change_amount),
         (l_bank_balance - l_change_amount),
         sysdate,
         v_create_user,
         t.change_type,
         t.use_type,
         pkg_sys_boolean.istrue,
         t.link_channel_name,
         t.link_account_name,
         v_memo,
         l_handle_batch_id
    from fd_bank_cash_fund t
   where t.record_id = l_bank_fund_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---3.4 修改原数据

update fd_bank_cash_fund c
   set c.has_adjust = pkg_sys_boolean.istrue
 where c.record_id = l_bank_fund_id
   and c.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;
--4 =====================银行卡记录红冲=============================
--[锁渠道账户,更新渠道账户金额,红冲下游手工加款,红冲下游加款记录]---

---4.1 锁渠道账户
select a.inner_balance
  into l_inner_balance
  from yx_base_down_account a
 where a.account_id = l_account_id
   for update;

---4.2 更新渠道账户金额
update yx_base_down_account a
   set a.inner_balance = a.inner_balance - l_change_amount
 where a.account_id = l_account_id;

---获取红冲序号
select seq_yxtradedownfund_auto_id.nextval into l_fund_id from dual;

---4.3 红冲下游手工加款
insert into yx_trade_down_manual
  (record_id,
   channel_no,
   account_id,
   adjust_id,
   has_adjust,
   add_type,
   change_amount,
   change_time,
   balance,
   create_user,
   bank_fund_id,
   memo)
  select l_fund_id,
         t.channel_no,
         t.account_id,
         t.record_id,
         pkg_sys_boolean.istrue,
         pkg_down_manual_change_type.red_recharge,
         0 - l_change_amount,
         sysdate,
         l_inner_balance - l_change_amount,
         v_create_user,
         l_handle_batch_id,
         v_memo
    from yx_trade_down_manual t
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---修改原纪录
update yx_trade_down_manual t
   set t.has_adjust = pkg_sys_boolean.istrue
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---4.4 红冲下游加款变动记录
insert into yx_trade_down_fund
  (record_id,
   yx_order_id,
   trade_order_no,
   ext_order_no,
   order_source,
   down_channel_no,
   down_account_id,
   change_time,
   order_time,
   change_type,
   pay_amount,
   change_amount,
   balance,
   memo)
  select l_fund_id,
         t.yx_order_id,
         t.trade_order_no,
         t.ext_order_no,
         t.order_source,
         t.down_channel_no,
         t.down_account_id,
         sysdate,
         t.order_time,
         pkg_down_fund_change_type.add_amount,
         0 - l_change_amount,
         0 - l_change_amount,
         l_inner_balance - l_change_amount,
         v_memo
    from yx_trade_down_fund t
   where t.record_id = v_record_id;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_ADJUST_DOWN_ADD_CHECK
prompt ============================================
prompt
create or replace function fd_account.yx_f_adjust_down_add_check(v_record_id   in number,
                                                      v_adjust_days in number)
  return varchar2 is
  /*
         功能介绍:检查加款记录,账户
         创建人:邓孝辉
         创建时间:2019/3/25
  */
  l_record_count  number;
  l_change_time   date;
begin
  ---1. 下游加款检查
select count(1), max(t.change_time)
  into l_record_count, l_change_time
  from yx_trade_down_manual t
 inner join yx_base_down_account a
    on t.account_id = a.account_id
 inner join fd_bank_cash_fund f
    on f.service_id = t.bank_fund_id
 inner join fd_bank_account_info i
    on i.account_id = f.account_id
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse
   and f.has_adjust = pkg_sys_boolean.isfalse
   and t.change_amount = f.change_amount;

if (l_record_count != 1) then
  return pkg_error_code.data_error;
end if;

if (l_change_time < (sysdate - v_adjust_days)) then
  return pkg_error_code.adjust_timeout;
end if;

return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_ADJUST_DOWN_DRAW
prompt =======================================
prompt
create or replace function fd_account.yx_f_adjust_down_draw(v_record_id   in number,
                                                 v_create_user in varchar2,
                                                 v_memo        in varchar2)
  return varchar2 is
/*
  功能介绍:下游提款红冲
  创建人:邓孝辉
  创建时间:2019/3/25
*/
l_manual_record_id                               number;
l_channel_no                                     varchar2(32);
l_pay_account_id                                 number;
l_change_amount                                  number;
l_change_time                                    date;
l_bank_batch_id                                  number;
l_bank_fund_id                                   number;
l_bank_account_id                                number;
l_service_count                                  number;
l_service_amount                                 number;
l_service_bank_id                                number;
l_bank_balance                                   number;
l_handle_batch_id                                number;
l_inner_balance                                  number;
l_fund_id                                        number;

begin

---1. 获取红冲数据
select t.record_id,
       t.channel_no,
       t.account_id,
       t.change_amount,
       t.change_time,
       t.bank_fund_id
  into l_manual_record_id,
       l_channel_no,
       l_pay_account_id,
       l_change_amount,
       l_change_time,
       l_bank_batch_id
  from yx_trade_down_manual t
 where t.record_id = v_record_id
   and t.add_type = pkg_down_manual_change_type.draw_amount
   and t.has_adjust = pkg_sys_boolean.isfalse;

---2. 获取实体卡变动编号
select f.record_id, f.account_id
  into l_bank_fund_id, l_bank_account_id
  from fd_bank_cash_fund f
 where f.service_id = l_bank_batch_id
   and f.has_adjust = pkg_sys_boolean.isfalse
   and f.change_time > (l_change_time - 1 / 24 / 60)
   and f.change_time < (l_change_time + 1 / 24 / 60)
   and f.use_type = pkg_bank_use_type.down_draw
   and f.change_type = pkg_bank_fund_change_type.minus_amount
   and rownum <= 2;

---3.获取手续费条数
select count(1), nvl(max(t.change_amount), 0), max(t.record_id)
  into l_service_count, l_service_amount, l_service_bank_id
  from fd_bank_cash_fund t
 where t.service_id = l_bank_batch_id
   and t.change_type = pkg_bank_fund_change_type.minus_amount
   and t.use_type = pkg_bank_use_type.service_fee
   and t.change_time > (l_change_time - 1 / 24 / 60)
   and t.change_time < (l_change_time + 1 / 24 / 60)
   and rownum <= 2;

--4 ===================实体卡记录红冲====================
--[锁实体卡,修改实体卡账户,手续费红冲,银行变动红冲]--

--4.1 锁实体卡
select t.balance
  into l_bank_balance
  from fd_bank_account_info t
 where t.account_id = l_bank_account_id
   for update;

--4.2 修改实体卡账户余额
update fd_bank_account_info a
   set a.balance = a.balance + l_change_amount + l_service_amount
 where a.account_id = l_bank_account_id;

---获取红冲提款序号
select seq_bank_service_id.nextval into l_handle_batch_id from dual;

if (l_service_count > 0) then
  ---4.3 红冲手续费
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0 - t.change_amount),
           (l_bank_balance + l_service_amount),
           sysdate,
           v_create_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id
      from fd_bank_cash_fund t
     where t.record_id = l_service_bank_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---修改原手续费记录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_service_bank_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;
end if;

---4.4 红冲实体卡下游提款记录
insert into fd_bank_cash_fund
  (record_id,
   account_id,
   adjust_id,
   company_id,
   change_amount,
   balance,
   change_time,
   created_user,
   change_type,
   use_type,
   has_adjust,
   link_channel_name,
   link_account_name,
   remark,
   service_id)
  select seq_bank_cash_fund_id.nextval,
         t.account_id,
         t.record_id,
         t.company_id,
         (0 - t.change_amount),
         (l_bank_balance + l_service_amount + l_change_amount),
         sysdate,
         v_create_user,
         t.change_type,
         t.use_type,
         pkg_sys_boolean.istrue,
         t.link_channel_name,
         t.link_account_name,
         v_memo,
         l_handle_batch_id
    from fd_bank_cash_fund t
   where t.record_id = l_bank_fund_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---修改原记录状态
update fd_bank_cash_fund t
   set t.has_adjust = pkg_sys_boolean.istrue
 where t.record_id = l_bank_fund_id
   and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

--5 =================渠道账户红冲===================
--[锁渠道,更新渠道账户,红冲下游手工扣款,红冲下游扣款变动]--

--5.1 锁渠道
select t.inner_balance
  into l_inner_balance
  from yx_base_down_account t
 where t.account_id = l_pay_account_id
   for update;

---5.2 更新渠道账户
update yx_base_down_account t
   set t.inner_balance = t.inner_balance + l_change_amount
 where t.account_id = l_pay_account_id;

---获取红冲序号
select seq_yxtradedownfund_auto_id.nextval into l_fund_id from dual;

---5.3红冲下游手工提款
insert into yx_trade_down_manual
  (record_id,
   channel_no,
   account_id,
   adjust_id,
   has_adjust,
   add_type,
   change_amount,
   change_time,
   balance,
   create_user,
   bank_fund_id,
   memo)
  select l_fund_id,
         t.channel_no,
         t.account_id,
         t.record_id,
         pkg_sys_boolean.istrue,
         pkg_down_manual_change_type.draw_red,
         0 - t.change_amount,
         sysdate,
         l_inner_balance + l_change_amount,
         v_create_user,
         l_handle_batch_id,
         v_memo
    from yx_trade_down_manual t
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---修改原手工数据
update yx_trade_down_manual t
   set t.has_adjust = pkg_sys_boolean.istrue
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

--5.4 红冲下游提款
insert into yx_trade_down_fund
  (record_id,
   yx_order_id,
   trade_order_no,
   ext_order_no,
   order_source,
   down_channel_no,
   down_account_id,
   change_time,
   order_time,
   change_type,
   pay_amount,
   change_amount,
   balance,
   memo)
select l_fund_id,
       t.yx_order_id,
       t.trade_order_no,
       t.ext_order_no,
       t.order_source,
       t.down_channel_no,
       t.down_account_id,
       sysdate,
       t.order_time,
       pkg_down_fund_change_type.draw_amount,
       0-t.pay_amount,
       0-t.change_amount,
       l_inner_balance+t.change_amount,
       v_memo
   from yx_trade_down_fund t
  where t.record_id=v_record_id;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_ADJUST_DOWN_DRAW_CHECK
prompt =============================================
prompt
create or replace function fd_account.yx_f_adjust_down_draw_check(v_record_id   in number,
                                                       v_adjust_days in number)
  return varchar2 is
/*
  功能介绍:检查提款记录,账户,余额,手续费
  创建人:邓孝辉
  创建时间:2019/3/25
*/
l_record_count    number;
l_change_time     date;
begin
  --1. 检查记录
select count(1), max(t.change_time)
  into l_record_count, l_change_time
  from yx_trade_down_manual t
 inner join yx_base_down_account a
    on a.account_id = t.account_id
 inner join fd_bank_cash_fund f
    on f.service_id = t.bank_fund_id
 inner join fd_bank_account_info i
    on f.account_id = i.account_id
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse
   and f.has_adjust = pkg_sys_boolean.isfalse
   and t.add_type = pkg_down_manual_change_type.draw_amount
   and t.change_amount = f.change_amount;

if (l_record_count != 1 and l_record_count != 2) then
  return pkg_error_code.data_error;
end if;

if (l_change_time < (sysdate - v_adjust_days)) then
  return pkg_error_code.adjust_timeout;
end if;

return pkg_error_code.success;

end;
/

prompt
prompt Creating function YX_F_ADJUST_UP_ADD
prompt ====================================
prompt
create or replace function fd_account.yx_f_adjust_up_add(v_record_id   in number,
                                              v_create_user in varchar2,
                                              v_memo        in varchar2)
  return varchar2 as
/*
  功能介绍:红冲上游加款
  创建人:邓孝辉
  创建人:2019/3/25
*/
l_channel_no                                  varchar2(32);
l_pay_account_id                              number;
l_change_amount                               number;
l_change_time                                 date;
l_bank_batch_id                               number;
l_bank_fund_id                                number;
l_bank_account_id                             number;
l_service_count                               number;
l_service_change_amount                       number;
l_bank_service_id                             number;
l_bank_balance                                number;
l_handle_batch_id                             number;
l_inner_balance                               number;
l_fund_id                                     number;

begin

---1. 红冲查询数据
select t.channel_no,
       t.account_id,
       t.change_amount,
       t.change_time,
       t.bank_fund_id
  into l_channel_no,
       l_pay_account_id,
       l_change_amount,
       l_change_time,
       l_bank_batch_id
  from yx_trade_up_manual t
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse;

---2. 实体卡数据
select c.record_id, c.account_id
  into l_bank_fund_id, l_bank_account_id
  from fd_bank_cash_fund c
 where c.service_id = l_bank_batch_id
   and c.has_adjust = pkg_sys_boolean.isfalse
   and c.use_type = pkg_bank_use_type.up_add
   and c.change_type = pkg_bank_fund_change_type.minus_amount
   and c.change_time > l_change_time - 1 / 24 / 60
   and c.change_time < l_change_time + 1 / 24 / 60
   and rownum <= 2;

---3. 获取手续费记录数据
select count(1), nvl(max(t.change_amount), 0), max(t.record_id)
  into l_service_count, l_service_change_amount, l_bank_service_id
  from fd_bank_cash_fund t
 where t.service_id = l_bank_batch_id
   and t.use_type = pkg_bank_use_type.service_fee
   and t.change_type = pkg_bank_fund_change_type.minus_amount
   and t.change_time > (l_change_time - 1 / 24 / 60)
   and t.change_time < (l_change_time + 1 / 24 / 60)
   and rownum <= 2;

--4. =================实体卡手续费记录红冲====================
--[锁实体卡,更新实体卡余额,红冲手续费,红冲实体卡记录]--

--4.1 锁实体卡
select i.balance
  into l_bank_balance
  from fd_bank_account_info i
 where i.account_id = l_bank_account_id
   for update;

--4.2 更新实体卡余额
update fd_bank_account_info i
   set i.balance = i.balance + l_change_amount + l_service_change_amount
 where i.account_id = l_bank_account_id;

---获取数据红冲对应的统一流水编号
select seq_bank_service_id.nextval into l_handle_batch_id from dual;

if (l_service_count > 0) then
  ---4.3 红冲实体卡手续费记录
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
    select seq_bank_cash_fund_id.nextval,
           t.account_id,
           t.record_id,
           t.company_id,
           (0 - t.change_amount),
           (l_bank_balance + l_service_change_amount),
           sysdate,
           v_create_user,
           t.change_type,
           t.use_type,
           pkg_sys_boolean.istrue,
           t.link_channel_name,
           t.link_account_name,
           v_memo,
           l_handle_batch_id
      from fd_bank_cash_fund t
     where t.record_id = l_bank_service_id
       and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;

  ---修改原手续费记录状态
  update fd_bank_cash_fund t
     set t.has_adjust = pkg_sys_boolean.istrue
   where t.record_id = l_bank_service_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

  if sql%rowcount = 0 then
    return pkg_error_code.not_exists;
  end if;
end if;

---4.4 红冲实体卡加款记录
insert into fd_bank_cash_fund
  (record_id,
   account_id,
   adjust_id,
   company_id,
   change_amount,
   balance,
   change_time,
   created_user,
   change_type,
   use_type,
   has_adjust,
   link_channel_name,
   link_account_name,
   remark,
   service_id)
  select seq_bank_cash_fund_id.nextval,
         t.account_id,
         t.record_id,
         t.company_id,
         (0 - t.change_amount),
         (l_bank_balance + l_service_change_amount + l_change_amount),
         sysdate,
         v_create_user,
         t.change_type,
         pkg_bank_use_type.up_add,
         pkg_sys_boolean.istrue,
         t.link_channel_name,
         t.link_account_name,
         v_memo,
         l_handle_batch_id
    from fd_bank_cash_fund t
   where t.record_id = l_bank_fund_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---修改原实体卡加款纪录状态
update fd_bank_cash_fund t
   set t.has_adjust = pkg_sys_boolean.istrue
 where t.record_id = l_bank_fund_id
   and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

--5 ========================渠道账户记录红冲==============================
--[锁渠道账户,更新渠道余额,红冲上游手工加款,红冲变动记录]--

--5.1 锁渠道
select t.inner_balance
  into l_inner_balance
  from yx_base_up_account t
 where t.account_id = l_pay_account_id
   for update;

---5.2 更新账户渠道余额
update yx_base_up_account t
   set t.inner_balance = t.inner_balance - l_change_amount
 where t.account_id = l_pay_account_id;

---红冲手工加款序号
select seq_yxtradeupfund_auto_id.nextval into l_fund_id from dual;

---5.3 红冲上游手工加款
insert into yx_trade_up_manual
  (record_id,
   channel_no,
   account_id,
   adjust_id,
   has_adjust,
   add_type,
   change_amount,
   real_amount,
   change_time,
   balance,
   create_user,
   bank_fund_id,
   memo)
  select l_fund_id,
         t.channel_no,
         t.account_id,
         t.record_id,
         pkg_sys_boolean.istrue,
         pkg_up_manual_change_type.red_recharge,
         0 - t.change_amount,
         t.real_amount,
         sysdate,
         l_inner_balance - l_change_amount,
         v_create_user,
         l_handle_batch_id,
         v_memo
    from yx_trade_up_manual t
   where t.record_id = v_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---修改手工加款
update yx_trade_up_manual t
   set t.has_adjust = pkg_sys_boolean.istrue
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---5.4 红冲上游变动记录
insert into yx_trade_up_fund
  (record_id,
   yx_order_id,
   trade_order_no,
   trade_delivery_no,
   ext_delivery_no,
   order_source,
   up_channel_no,
   up_account_id,
   up_company_id,
   agent_id,
   up_draw_unit,
   up_draw_face,
   up_draw_amount,
   up_real_amount,
   up_servie_fee,
   change_time,
   change_type,
   balance,
   memo)
  select l_fund_id,
         t.yx_order_id,
         t.trade_order_no,
         t.trade_delivery_no,
         t.ext_delivery_no,
         t.order_source,
         t.up_channel_no,
         t.up_account_id,
         t.up_company_id,
         t.agent_id,
         t.up_draw_unit,
         t.up_draw_face,
         0 - t.up_draw_amount,
         0 - t.up_real_amount,
         t.up_servie_fee,
         sysdate,
         pkg_up_fund_change_type.add_amount,
         l_inner_balance - l_change_amount,
         v_memo
    from yx_trade_up_fund t
   where t.record_id = v_record_id;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_ADJUST_UP_ADD_CHECK
prompt ==========================================
prompt
create or replace function fd_account.yx_f_adjust_up_add_check(v_record_id   in number,
                                                    v_adjust_days in number)
  return varchar2 as
/*
  功能介绍:检查加款记录,账户,余额,手续费
  创建人:邓孝辉
  创建人:2019/3/25
*/
l_record_count    number;
l_change_time     date;
begin
  --1. 检查加款记录
select count(1), max(t.change_time)
  into l_record_count, l_change_time
  from yx_trade_up_manual t
 inner join yx_base_up_account a
    on t.account_id = a.account_id
 inner join fd_bank_cash_fund f
    on f.service_id = t.bank_fund_id
 inner join fd_bank_account_info i
    on i.account_id = f.account_id
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse
   and f.has_adjust = pkg_sys_boolean.isfalse
   and t.change_amount = f.change_amount
   and t.add_type = pkg_up_manual_change_type.add_amount;

if (l_record_count != 1 and l_record_count != 2) then
  return pkg_error_code.data_error;
end if;

if (l_change_time < (sysdate - v_adjust_days)) then
  return pkg_error_code.adjust_timeout;
end if;

return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_ADJUST_UP_DRAW
prompt =====================================
prompt
create or replace function fd_account.yx_f_adjust_up_draw(v_record_id      in  number,
                                               v_create_user    in  varchar2,
                                               v_memo           in  varchar2)
return varchar2 as
/*
       功能介绍:上游红冲扣款
       创建人:邓孝辉
       创建时间:2019/3/25
*/
l_channel_no                                   varchar2(32);
l_pay_account_id                               number;
l_change_amount                                number;
l_change_time                                  date;
l_bank_batch_id                                number;
l_bank_account_id                              number;
l_bank_record_id                               number;
l_bank_balance                                 number;
l_handle_batch_id                              number;
l_inner_balance                                number;
l_fund_id                                      number;

begin
  ---1. 获取红冲渠道数据
select t.channel_no,
       t.account_id,
       t.change_amount,
       t.change_time,
       t.bank_fund_id
  into l_channel_no,
       l_pay_account_id,
       l_change_amount,
       l_change_time,
       l_bank_batch_id
  from yx_trade_up_manual t
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse;

---2. 获取红冲实体卡数据
select c.account_id, c.record_id
  into l_bank_account_id, l_bank_record_id
  from fd_bank_cash_fund c
 where c.service_id = l_bank_batch_id
   and c.change_type = pkg_bank_fund_change_type.add_amount
   and c.use_type = pkg_bank_use_type.up_draw
   and c.change_time > l_change_time - 1 / 24 / 60
   and c.change_time < l_change_time + 1 / 24 / 60
   and rownum <= 2;

--3 =================实体卡记录红冲====================
--[锁实体卡,更新实体卡,红冲实体卡记录]--

--3.1 锁实体卡
select a.balance
  into l_bank_balance
  from fd_bank_account_info a
 where a.account_id = l_bank_account_id
   for update;

---3.2 更新实体卡
update fd_bank_account_info i
   set i.balance = i.balance - l_change_amount
 where i.account_id = l_bank_account_id;

---获取实体卡红冲序号
select seq_bank_service_id.nextval into l_handle_batch_id from dual;
---3.3 红冲实体卡下游提款记录
insert into fd_bank_cash_fund
  (record_id,
   account_id,
   adjust_id,
   company_id,
   change_amount,
   balance,
   change_time,
   created_user,
   change_type,
   use_type,
   has_adjust,
   link_channel_name,
   link_account_name,
   remark,
   service_id)
  select seq_bank_cash_fund_id.nextval,
         t.account_id,
         t.record_id,
         t.company_id,
         (0 - t.change_amount),
         (l_bank_balance - l_change_amount),
         sysdate,
         v_create_user,
         t.change_type,
         pkg_bank_use_type.up_draw,
         pkg_sys_boolean.istrue,
         t.link_channel_name,
         t.link_account_name,
         v_memo,
         l_handle_batch_id
    from fd_bank_cash_fund t
   where t.record_id = l_bank_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---修改原实体卡提款纪录状态
update fd_bank_cash_fund t
   set t.has_adjust = pkg_sys_boolean.istrue
 where t.record_id = l_bank_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

--4 =================渠道账户红冲====================
--[锁渠道账户,更新渠道账户,红冲手工记录,红冲变动记录]--

--4.1 锁渠道账户
select a.inner_balance
  into l_inner_balance
  from yx_base_up_account a
 where a.account_id = l_pay_account_id
   for update;

---4.2 更新渠道账户余额
update yx_base_up_account t
   set t.inner_balance = t.inner_balance + l_change_amount
 where t.account_id = l_pay_account_id;

---获取红冲序号
select seq_yxtradeupfund_auto_id.nextval into l_fund_id from dual;

---4.3 红冲手工记录
insert into yx_trade_up_manual
  (record_id,
   channel_no,
   account_id,
   adjust_id,
   has_adjust,
   add_type,
   change_amount,
   real_amount,
   change_time,
   balance,
   create_user,
   bank_fund_id,
   memo)
  select l_fund_id,
         y.channel_no,
         y.account_id,
         y.record_id,
         pkg_sys_boolean.istrue,
         pkg_up_manual_change_type.red_draw,
         0 - y.change_amount,
         0 - y.real_amount,
         sysdate,
         l_inner_balance + l_change_amount,
         v_create_user,
         l_handle_batch_id,
         v_memo
    from yx_trade_up_manual y
   where y.record_id = v_record_id
     and y.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---更新原手工记录
update yx_trade_up_manual t
   set t.has_adjust = pkg_sys_boolean.istrue
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;


---4.4 红冲变动记录
insert into yx_trade_up_fund
  (record_id,
   up_channel_no,
   up_account_id,
   up_company_id,
   agent_id,
   up_draw_unit,
   up_draw_face,
   up_draw_amount,
   up_real_amount,
   up_servie_fee,
   change_time,
   change_type,
   balance,
   memo)
select l_fund_id,
       t.up_channel_no,
       t.up_account_id,
       t.up_company_id,
       t.agent_id,
       t.up_draw_unit,
       t.up_draw_face,
       0-t.up_draw_amount,
       0-t.up_real_amount,
       t.up_servie_fee,
       sysdate,
       pkg_up_fund_change_type.draw_amount,
       l_inner_balance+l_change_amount,
       t.memo
from yx_trade_up_fund t
where t.record_id=v_record_id;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;


return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_ADJUST_UP_DRAW_CHECK
prompt ===========================================
prompt
create or replace function fd_account.yx_f_adjust_up_draw_check(v_record_id    in  number,v_adjust_days    in  number)
return varchar2 as
/*
       功能介绍:上游红冲扣款账户检查
       创建人:邓孝辉
       创建时间:2019/3/25
*/
  l_record_count           number;
  l_change_time            date;
begin

--1.账户检查
select count(1), max(t.change_time)
  into l_record_count, l_change_time
  from yx_trade_up_manual t
 inner join yx_base_up_account a
    on a.account_id = t.account_id
 inner join fd_bank_cash_fund f
    on f.service_id = t.bank_fund_id
 inner join fd_bank_account_info i
    on i.account_id = f.account_id
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse
   and f.has_adjust = pkg_sys_boolean.isfalse
   and t.change_amount = f.change_amount
   and t.add_type = pkg_up_manual_change_type.draw_amount;

if (l_record_count != 1 and l_record_count != 2) then
  return pkg_error_code.data_error;
end if;

if (l_change_time < (sysdate - v_adjust_days)) then
  return pkg_error_code.adjust_timeout;
end if;

return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_ADJUST_UP_SERVICE_DRAW
prompt =============================================
prompt
create or replace function fd_account.yx_f_adjust_up_service_draw(v_record_id    in    number,
                                                       v_create_user  in    varchar2,
                                                       v_memo         in    varchar2)
    return varchar2 is


l_channel_no                                   varchar2(32);
l_pay_account_id                               number;
l_change_amount                                number;
l_change_time                                  date;
l_bank_batch_id                                number;
l_bank_account_id                              number;
l_bank_record_id                               number;
l_bank_balance                                 number;
l_handle_batch_id                              number;
l_service_fee                                number;
l_fund_id                                      number;

begin
  ---1. 获取红冲渠道数据
select t.channel_no,
       t.account_id,
       t.change_amount,
       t.change_time,
       t.bank_fund_id
  into l_channel_no,
       l_pay_account_id,
       l_change_amount,
       l_change_time,
       l_bank_batch_id
  from yx_trade_up_manual t
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse;

---2. 获取红冲实体卡数据
select c.account_id, c.record_id
  into l_bank_account_id, l_bank_record_id
  from fd_bank_cash_fund c
 where c.service_id = l_bank_batch_id
   and c.change_type = pkg_bank_fund_change_type.add_amount
   and c.use_type = pkg_bank_use_type.up_draw
   and c.change_time > l_change_time - 1 / 24 / 60
   and c.change_time < l_change_time + 1 / 24 / 60
   and rownum <= 2;

--3 =================实体卡记录红冲====================
--[锁实体卡,更新实体卡,红冲实体卡记录]--

--3.1 锁实体卡
select a.balance
  into l_bank_balance
  from fd_bank_account_info a
 where a.account_id = l_bank_account_id
   for update;

---3.2 更新实体卡
update fd_bank_account_info i
   set i.balance = i.balance - l_change_amount
 where i.account_id = l_bank_account_id;

if sql%rowcount = 0 then
  return pkg_error_code.data_error;
end if;

---获取实体卡红冲序号
select seq_bank_service_id.nextval into l_handle_batch_id from dual;
---3.3 红冲实体卡下游提款记录
insert into fd_bank_cash_fund
  (record_id,
   account_id,
   adjust_id,
   company_id,
   change_amount,
   balance,
   change_time,
   created_user,
   change_type,
   use_type,
   has_adjust,
   link_channel_name,
   link_account_name,
   remark,
   service_id)
  select seq_bank_cash_fund_id.nextval,
         t.account_id,
         t.record_id,
         t.company_id,
         (0 - t.change_amount),
         (l_bank_balance - l_change_amount),
         sysdate,
         v_create_user,
         t.change_type,
         pkg_bank_use_type.up_draw,
         pkg_sys_boolean.istrue,
         t.link_channel_name,
         t.link_account_name,
         v_memo,
         l_handle_batch_id
    from fd_bank_cash_fund t
   where t.record_id = l_bank_record_id
     and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---修改原实体卡提款纪录状态
update fd_bank_cash_fund t
   set t.has_adjust = pkg_sys_boolean.istrue
 where t.record_id = l_bank_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

--4 ===========================渠道红冲===================
--4.1 锁渠道
select t.service_balance
  into l_service_fee
  from yx_base_up_channel t
 where t.channel_no = l_channel_no
   for update;

--4.2 更新渠道服务费
update yx_base_up_channel t
   set t.service_balance = t.service_balance + l_change_amount
 where t.channel_no = l_channel_no;

---获取红冲序号
select seq_yxtradeupfund_auto_id.nextval into l_fund_id from dual;

---4.3 红冲手工记录
insert into yx_trade_up_manual
  (record_id,
   channel_no,
   account_id,
   adjust_id,
   has_adjust,
   add_type,
   change_amount,
   real_amount,
   change_time,
   balance,
   create_user,
   bank_fund_id,
   memo)
  select l_fund_id,
         y.channel_no,
         y.account_id,
         y.record_id,
         pkg_sys_boolean.istrue,
         pkg_up_manual_change_type.red_service_draw,
         0 - y.change_amount,
         0 - y.real_amount,
         sysdate,
         l_service_fee + l_change_amount,
         v_create_user,
         l_handle_batch_id,
         v_memo
    from yx_trade_up_manual y
   where y.record_id = v_record_id
     and y.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---更新原手工记录
update yx_trade_up_manual t
   set t.has_adjust = pkg_sys_boolean.istrue
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

---4.4 红冲变动记录
insert into yx_trade_up_fund
  (record_id,
   up_channel_no,
   up_account_id,
   up_company_id,
   agent_id,
   up_draw_unit,
   up_draw_face,
   up_draw_amount,
   up_real_amount,
   up_servie_fee,
   change_time,
   change_type,
   balance,
   memo)
  select l_fund_id,
         t.up_channel_no,
         t.up_account_id,
         t.up_company_id,
         t.agent_id,
         t.up_draw_unit,
         t.up_draw_face,
         0 - t.up_draw_amount,
         0 - t.up_real_amount,
         t.up_servie_fee,
         sysdate,
         pkg_up_fund_change_type.service_draw,
         l_service_fee + l_change_amount,
         t.memo
    from yx_trade_up_fund t
   where t.record_id = v_record_id;

if sql%rowcount = 0 then
  return pkg_error_code.not_exists;
end if;

return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_ADJUST_UP_SERVICE_D_CHECK
prompt ================================================
prompt
create or replace function fd_account.yx_f_adjust_up_service_d_check(v_record_id   in number,
                                                          v_adjust_days in number)
  return varchar2 is

---检查服务费提现记录

l_record_count    number;
l_change_time     date;
begin

---检查服务费提现记录
select count(1), max(t.change_time)
  into l_record_count, l_change_time
  from yx_trade_up_manual t
 inner join fd_bank_cash_fund f
    on f.service_id = t.bank_fund_id
 inner join fd_bank_account_info i
    on i.account_id = f.account_id
 where t.record_id = v_record_id
   and t.has_adjust = pkg_sys_boolean.isfalse
   and f.has_adjust = pkg_sys_boolean.isfalse
   and t.change_amount = f.change_amount
   and t.add_type = pkg_up_manual_change_type.service_draw;

if (l_record_count != 1 and l_record_count != 2) then
  return pkg_error_code.data_error;
end if;

if (l_change_time < (sysdate - v_adjust_days)) then
  return pkg_error_code.adjust_timeout;
end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_GROUP_AGENT
prompt ==================================
prompt
create or replace function fd_account.yx_f_group_agent(v_down_channel_no varchar2, --下游渠道编号
                                            v_agent_count     in number, --含有的代理人数量
                                            l_agent_arr       in t_Array, --代理人编号组
                                            v_out_agent_group in varchar2, --重新组合后的外部系统代理人编号
                                            v_agent_id        out varchar2)
  return varchar2 is
  ----------------------------------------------------
  --主要功能：判断组合代理人
  --创建人：周荣省
  --创建时间;2019-05-22
  ----------------------------------------------------
  l_number    number; --代理人数量
  l_number1 number;
  l_group_agent varchar2(32); --组合代理人外部编号
begin
  --1.判断代理人数量
  select count(1)
    into l_number
    from yx_base_agent t
   where t.down_channel_no = v_down_channel_no
     and t.agent_id in (select * from table(l_agent_arr));

  if l_number <> v_agent_count then
    return pkg_yx_error_code.group_count_error;
  end if;
  --2.判断组合代理人编号是否存在
  l_group_agent := 'ZH' || v_out_agent_group;
  select count(1)
    into l_number
    from yx_base_agent t
   where t.down_channel_no = v_down_channel_no
     and t.group_agent = pkg_yx_agent_type.group_agent
     and t.out_agent_id = l_group_agent;
  if l_number<1 then
    return pkg_yx_error_code.no_group_agent;
  end if;
  select max(t.agent_id)
    into v_agent_id
    from yx_base_agent t
   where t.down_channel_no = v_down_channel_no
     and t.group_agent = pkg_yx_agent_type.group_agent
     and t.out_agent_id = l_group_agent;
  return pkg_yx_error_code.success;
end;
/

prompt
prompt Creating function YX_F_GROUP_AGENT_FEE
prompt ======================================
prompt
create or replace function fd_account.yx_f_group_agent_fee(v_agent_count     in number, --含有的代理人数量
                                                v_agency_fee_list in t_Array, --代理费金额
                                                v_agency_fee      out number --代理费总金额
                                                ) return varchar2 is
  ----------------------------------------------------
  --主要功能：计算代理费总金额
  --创建人：周荣省
  --创建时间;2019-05-22
  ----------------------------------------------------
  l_number number; --代理费数量
  l_j      number := 0;
begin
  --1.判断代理人数量
  select count(1) into l_number from table(v_agency_fee_list);

  if l_number <> v_agent_count then
    return pkg_yx_error_code.group_count_error;
  end if;
  --2.计算总和
  v_agency_fee := 0;
  for item in (select * from table(v_agency_fee_list)) loop
    begin
      l_j          := l_j + 1;
      v_agency_fee := v_agency_fee + to_number(v_agency_fee_list(l_j));
    end;
  end loop;
  return pkg_yx_error_code.success;
end;
/

prompt
prompt Creating function YX_F_GROUP_AGENT_SOLT
prompt =======================================
prompt
create or replace function fd_account.yx_f_group_agent_solt(v_agent_arr       in t_Array, --代理人编号组
                                                 v_out_agent_group out varchar2, -- 代理人编号重新组合 
                                                 v_out_agent_group_name out varchar2--组合代理人名称
                                                 ) return varchar2 is
  ----------------------------------------------------
  --主要功能：代理人编号排序
  --创建人：周荣省
  --创建时间;2019-05-22
  ----------------------------------------------------
begin
  v_out_agent_group := '';
  v_out_agent_group_name:='组合';
  for item in (select t.agent_id,t.agent_name
                 from yx_base_agent t
                where t.agent_id in (SELECT * FROM TABLE(v_agent_arr))
                order by to_number(t.agent_id) asc) loop
    begin
      v_out_agent_group := v_out_agent_group|| '_' || item.agent_id ;
      v_out_agent_group_name:=v_out_agent_group_name||'_'||item.agent_name;
    end;
  end loop;
  return pkg_yx_error_code.success;
end;
/

prompt
prompt Creating function YX_F_MANUAL_AGENT_DRAW
prompt ========================================
prompt
create or replace function fd_account.yx_f_manual_agent_draw(v_agent_id        in varchar2, ---代理人编号
                                                  v_bank_account_id in number, ---实体卡账户编号
                                                  v_amount          in number, ---提款金额
                                                  v_service_fee     in number, ---手续费
                                                  v_memo            in varchar2, ---备注
                                                  v_create_user     in varchar2, ---创建人
                                                  v_agent_name      in varchar2 ---代理人名称
                                                  )

 return varchar2 is

  /*
         功能介绍:代理人提款
         创建人:邓孝辉
         创建时间:2019/3/19
  */
  l_bank_balance   number;
  l_bank_company   number;
  l_fund_record_id number;
  l_bank_batch_id  number;
  l_agent_balance  number;
begin

  ---1. 锁实体卡
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  if (l_bank_balance < v_amount + v_service_fee) then
    return pkg_error_code.balance_low;
  end if;

  ---2.获取部分添加参数
  select seq_yxtradeagentfund_auto_id.nextval
    into l_fund_record_id
    from dual;

  ---获取银行卡资金变动统一流水号(用于红冲时便于查找)
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================3.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡提款的资金变动]===
  ---3.1 更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_amount - v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---3.2 添加实体卡资金变动    
  if (v_service_fee > 0) then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       l_bank_company,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       '-',
       '-',
       v_memo,
       l_bank_batch_id);
  end if;

  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company,
     v_amount,
     (l_bank_balance - v_amount - v_service_fee),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.down_draw,
     v_agent_name,
     v_agent_name,
     v_memo,
     l_bank_batch_id);

  --==============4.更新渠道账户==================================================
  --===[锁代理人账户、更新渠道账户余额、添加代理人手工提款记录、添加代理人资金变动]=====
  ---4.1  锁代理人账户
  select a.balance
    into l_agent_balance
    from yx_base_agent a
   where a.agent_id = v_agent_id
     for update;

  ---4.2  更新代理人账户余额
  update yx_base_agent a
     set a.balance        = a.balance - v_amount,
         a.last_edit_user = v_create_user,
         a.last_edit_time = sysdate
   where a.agent_id = v_agent_id
     and a.balance >= v_amount;

  if (sql%rowcount = 0) then
    return pkg_error_code.balance_low;
  end if;

  --4.3 添加代理人手工提款记录
  insert into yx_trade_agent_manual
    (record_id,
     agent_id,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo,
     bank_fund_id)
  values
    (l_fund_record_id,
     v_agent_id,
     0,
     0,
     1,
     pkg_agent_manual_change_type.draw_amount,
     v_amount,
     sysdate,
     l_agent_balance - v_amount,
     v_create_user,
     v_memo,
     l_bank_batch_id);

  ---4.4  添加代理人资金变动记录
  insert into yx_trade_agent_fund
    (record_id,
     up_fund_id,
     down_channel_no,
     up_channel_no,
     order_source,
     agent_id,
     change_amount,
     balance,
     change_type,
     change_time)
  values
    (l_fund_record_id,
     0,
     '-',
     '-',
     0,
     v_agent_id,
     v_amount,
     l_agent_balance - v_amount,
     pkg_agent_fund_change_type.draw_amount,
     sysdate);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_MANUAL_AGENT_DRAW_CHECK
prompt ==============================================
prompt
create or replace function fd_account.yx_f_manual_agent_draw_check(v_agent_id           in  varchar2,  ---代理人编号
                                                        v_bank_account_id    in  number,  ---实体卡账户编号
                                                        v_service_fee        in  number,  ---手续费
                                                        v_amount             in  number,  ---提现金额
                                                        v_agent_name         out varchar2)
       return varchar2 is
  /*
       功能介绍:代理人提款校验
       创建人:邓孝辉
       创建时间:2019/3/19
  */

l_agent_balance             number;
l_bank_count                number;
l_bank_balance              number;
l_bank_company_id           number;
l_company_id                number;
begin
  --1.校验提款金额是否大于0
  if(v_amount<=0 or v_service_fee<0) then
   return pkg_error_code.amount_error;
  end if;

  ---2. 检查代理人信息
  select a.balance,a.agent_name,a.company_id
    into l_agent_balance,v_agent_name,l_company_id
   from yx_base_agent a
   where a.agent_id=v_agent_id;

    if(l_agent_balance<v_amount) then
     return pkg_error_code.account_balance_error;
    end if;

   ---3. 检查实体卡信息
   select count(1),max(t.balance),max(t.company_id)
     into l_bank_count,l_bank_balance,l_bank_company_id
    from fd_bank_account_info t
  where t.account_id=v_bank_account_id;

  if(l_bank_company_id!=l_company_id) then
   return pkg_error_code.company_error;
  end if;

  if(l_bank_count=0) then
   return pkg_error_code.bank_account_id_error;
  end if;

  if(l_bank_balance<v_amount+v_service_fee) then
   return pkg_error_code.balance_low;
  end if;

return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;

end;
/

prompt
prompt Creating function YX_F_MANUAL_AGENT_RV_CHECK
prompt ============================================
prompt
create or replace function fd_account.yx_f_manual_agent_rv_check(v_agent_id  in varchar2,
                                                      v_agent_fee in varchar2)
  return varchar2 is
  ------------------代理费平账校验--------------------------
  l_number number;
begin
  --1. 代理人渠道校验
  select count(1)
    into l_number
    from yx_base_agent a
   where a.agent_id = v_agent_id
     and (a.balance + v_agent_fee) > 0;
  if l_number < 1 then
    return pkg_error_code.data_error;
  end if;
  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function YX_F_MANUAL_AGENT_RV_FEE
prompt ==========================================
prompt
create or replace function fd_account.yx_f_manual_agent_rv_fee(v_agent_id        in    varchar2,
                                                    v_agent_fee       in    number,
                                                    v_down_channel_no in    varchar2,
                                                    v_down_company_id in    number,
                                                    v_business_type   in    number,
                                                    v_create_user     in    varchar2,
                                                    v_memo            in    varchar2)
          -------------------------代理费平账------------------------------
          return varchar2 is
          l_agent_fund_id                           number;
          l_up_fund_id                              number;
          l_agent_balance                           number;
          begin
            --0.获取序号
select seq_yxtradeagentfund_auto_id.nextval,
       seq_yxtradeupfund_auto_id.nextval
  into l_agent_fund_id,  l_up_fund_id
  from dual;

--1 =============================锁代理人,创建代理人资金变动===================================
--1.1 锁代理人,修改代理人余额
select a.balance
  into l_agent_balance
  from yx_base_agent a
 where a.agent_id = v_agent_id
   for update;

update yx_base_agent t
   set t.balance = t.balance + v_agent_fee
 where t.agent_id = v_agent_id;

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

--1.2 创建代理人工操作

insert into yx_trade_agent_manual
  (record_id,
   agent_id,
   account_id,
   has_adjust,
   add_type,
   change_amount,
   change_time,
   balance,
   create_user,
   memo)
values
  (l_agent_fund_id,
   v_agent_id,
   0,
   0,
   pkg_agent_manual_change_type.agent_revise,
   v_agent_fee,
   sysdate,
   l_agent_balance + v_agent_fee,
   v_create_user,
   v_memo);

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

--1.3 创建资金变动(通过up_fund_id关联上游资金变动)
insert into yx_trade_agent_fund
  (record_id,
   up_fund_id,
   down_channel_no,
   up_channel_no,
   order_source,
   agent_id,
   change_amount,
   balance,
   change_type,
   change_time,
   business_type)
values
  (l_agent_fund_id,
   l_up_fund_id,
   v_down_channel_no,
   0,
   0,
   v_agent_id,
   v_agent_fee,
   l_agent_balance + v_agent_fee,
   pkg_agent_fund_change_type.debit_amount,
   sysdate,
   v_business_type);

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

--2. ===================================创建上游资金变动=======================================
--2.1 上游资金变动（上游下游公司相同避免结算)
insert into yx_trade_up_fund
  (record_id,
   down_channel_no,
   down_account_id,
   down_company_id,
   up_channel_no,
   up_account_id,
   up_company_id,
   down_agency_fee,
   up_draw_unit,
   up_draw_face,
   up_draw_amount,
   up_real_amount,
   up_servie_fee,
   change_time,
   change_type,
   business_type,
   balance,
   memo)
values
  (l_up_fund_id,
   v_down_channel_no,
   0,
   v_down_company_id,
   0,
   0,
   v_down_company_id,
   v_agent_fee,
   0,
   0,
   0,
   0,
   0,
   sysdate,
   pkg_up_fund_change_type.debit_amount,
   v_business_type,
   0,
   v_memo);
if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_MANUAL_DOWN_ADD
prompt ======================================
prompt
create or replace function fd_account.yx_f_manual_down_add(v_down_channel_no in varchar2, --下游渠道编号
                                                v_bank_account_id in number, --实体卡账户号
                                                v_amount          in number, --加款金额
                                                v_create_user     in varchar2, --创建人
                                                v_memo            in varchar2, --备注
                                                v_account_id      in number,   --账号编号
                                                v_account_name    in varchar2, --账号名称
                                                v_channel_name    in varchar2) --渠道名称
        return varchar2 is

/*
    功能介绍:账户手工加款(锁实体银行卡,渠道账户)
    创建人:邓孝辉
    创建时间:2019/3/18
*/

l_bank_company        number;
l_bank_balance        number;
l_fund_record_main_id number;
l_inner_balance       number;
l_bank_batch_id       number;

begin
  --================1.锁账户获取参数======================
  --=========[锁公司手续费账户、锁实体卡账户、检查实体卡余额、获取seq]=======

    --1.1 锁实体卡账户
    select t.balance,t.company_id
      into l_bank_balance,l_bank_company
    from fd_bank_account_info t
    where t.account_id=v_bank_account_id
     for update;

  ---1.2 获取部分添加参数
  select seq_yxtradedownfund_auto_id.nextval
    into l_fund_record_main_id
    from dual;

      ---获取银行卡资金变动统一流水号(为红冲时查询)
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

    --====================2.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡加款的资金变动]===
  ---2.1 更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

     ---2.2 添加实体卡资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company,
     v_amount,
     (l_bank_balance + v_amount),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.add_amount,
     pkg_bank_use_type.down_add,
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id);

     ---==================3.更新渠道账户信息============================
     --===[锁渠道账户,更新渠道账户余额,添加下游、添加下游手工加款记录、添加下游资金变动]=====
     ---3.1 锁下游渠道账户
     select da.inner_balance
       into l_inner_balance
      from yx_base_down_account da
      where da.account_id=v_account_id
       for update;

     ---3.2 更新渠道账户余额
     update yx_base_down_account t
        set t.inner_balance   = (t.inner_balance+v_amount),
            t.last_edit_user  = v_create_user,
            t.last_edit_time  = sysdate
      where t.account_id = v_account_id;

      ---3.3 添加下游人工加款记录
        insert into yx_trade_down_manual
          (record_id,
           channel_no,
           account_id,
           adjust_id,
           has_adjust,
           add_type,
           change_amount,
           change_time,
           balance,
           create_user,
           memo,
           bank_fund_id)
        values
          (l_fund_record_main_id,
           v_down_channel_no,
           v_account_id,
           0,
           1,
           pkg_down_manual_change_type.add_amount,
           v_amount,
           sysdate,
           l_inner_balance+v_amount,
           v_create_user,
           v_memo,
           l_bank_batch_id);

      ---3.4 添加下游资金变动
      insert into yx_trade_down_fund
            (record_id,
             yx_order_id,
             trade_order_no,
             ext_order_no,
             order_source,
             down_channel_no,
             down_account_id,
             change_time,
             change_type,
             pay_amount,
             change_amount,
             balance,
             memo)
          values
            (l_fund_record_main_id,
             0,
             '-',
             '-',
             0,
             v_down_channel_no,
             v_account_id,
             sysdate,
             pkg_down_fund_change_type.add_amount,
             v_amount,
             v_amount,
             (l_inner_balance + v_amount),
             v_memo);

      return pkg_error_code.success;

end;
/

prompt
prompt Creating function YX_F_MANUAL_DOWN_ADD_CHECK
prompt ============================================
prompt
create or replace function fd_account.yx_f_manual_down_add_check(v_down_channel_no in varchar2, --下游渠道编号
                                                      v_bank_account_id in number, --实体卡账户号
                                                      v_amount          in number, --加款金额
                                                      v_account_name    out varchar2, --账户名称
                                                      v_channel_name    out varchar2, --渠道名称
                                                      v_account_id      out number)   --账户编号
      return varchar2 is

/*
      功能介绍:下游加款校验
      创建人:邓孝辉
      创建时间:2019/3/18
*/

      l_bank_account    number;
      l_company_id      number;
      l_bank_company_id number;
begin
      ---1.判断金额是否大于0
      if(v_amount<=0) then
        return pkg_error_code.amount_error;
      end if;

      --2.检查下游渠道
      select  c.channel_name,a.account_name,c.account_id,c.company_id
         into v_channel_name,v_account_name,v_account_id,l_company_id
      from yx_base_down_channel c
      inner join yx_base_down_account a on c.account_id=a.account_id
      where c.channel_no=v_down_channel_no;

      ---3.检查实体卡是否存在
      select count(1),max(t.company_id)
        into l_bank_account,l_bank_company_id
      from fd_bank_account_info t
      where t.account_id=v_bank_account_id;

      if(l_bank_account=0) then
       return pkg_error_code.bank_account_id_error;
      end if;
      
      if(l_bank_company_id!=l_company_id) then
       return pkg_error_code.company_error;
      end if;

      return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function YX_F_MANUAL_DOWN_DRAW
prompt =======================================
prompt
create or replace function fd_account.yx_f_manual_down_draw(v_down_channel_no in varchar2, ---下游渠道编号
                                                 v_account_id      in number, ---下游账户编号
                                                 v_bank_account_id in number, ---实体卡账户编号
                                                 v_service_fee     in number, ---手续费
                                                 v_amount          in number, ---提款金额
                                                 v_create_user     in varchar2, ---创建者
                                                 v_memo            in varchar2, ---备注
                                                 v_account_name    in varchar2, ---账户名称
                                                 v_channel_name    in varchar2) ---渠道名称
 return varchar2 is

  /*
          功能介绍:下游手工提款操作
          创建人:邓孝辉
          创建时间:2018/3/19
  */

  l_bank_balance        number;
  l_fund_record_main_id number;
  l_bank_batch_id       number;
  l_bank_company        number;
  l_inner_balance       number;
  l_credit_money        number;
begin
  ---1.锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  if l_bank_balance < v_amount + v_service_fee then
    return pkg_error_code.balance_low;
  end if;

  ---1.2 获取部分添加参数
  select seq_yxtradedownfund_auto_id.nextval
    into l_fund_record_main_id
    from dual;

  ---获取银行卡资金变动统一流水号
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================2.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡提款的资金变动]===
  --2.1 更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_amount - v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  --2.2 添加实体卡资金变动
  if (v_service_fee > 0) then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       l_bank_company,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       v_channel_name,
       v_account_name,
       v_memo,
       l_bank_batch_id);
  end if;

  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company,
     v_amount,
     (l_bank_balance - v_amount - v_service_fee),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.down_draw,
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id);

  --==============3.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加下游手工提款记录、添加下游资金变动]=====
  ---3.1 锁渠道账户
  select da.inner_balance, da.credit_money
    into l_inner_balance, l_credit_money
    from yx_base_down_account da
   where da.account_id = v_account_id
     for update;

  ---3.2 更新渠道余额
  update yx_base_down_account t
     set t.inner_balance  = (t.inner_balance - v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_account_id;

  ---3.3 添加下游手工提款记录
  insert into yx_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo,
     bank_fund_id)
  values
    (l_fund_record_main_id,
     v_down_channel_no,
     v_account_id,
     0,
     1,
     pkg_down_manual_change_type.draw_amount,
     v_amount,
     sysdate,
     l_inner_balance - v_amount,
     v_create_user,
     v_memo,
     l_bank_batch_id);

  ---3.4 添加下游资金变动
  insert into yx_trade_down_fund
    (record_id,
     yx_order_id,
     trade_order_no,
     ext_order_no,
     order_source,
     down_channel_no,
     down_account_id,
     change_time,
     change_type,
     pay_amount,
     change_amount,
     balance,
     memo)
  values
    (l_fund_record_main_id,
     0,
     '-',
     '-',
     0,
     v_down_channel_no,
     v_account_id,
     sysdate,
     pkg_down_fund_change_type.draw_amount,
     v_amount,
     v_amount,
     (l_inner_balance - v_amount),
     v_memo);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_MANUAL_DOWN_DRAW_CHECK
prompt =============================================
prompt
create or replace function fd_account.yx_f_manual_down_draw_check(v_down_channel_no in  varchar2,  ---下游渠道编号
                                                       v_bank_account_id in  number,    ---实体卡账户号
                                                       v_service_fee     in  number,    ---手续费
                                                       v_amount          in  number,    ---提款金额
                                                       v_account_name    out varchar2, ---账户名称
                                                       v_channel_name    out varchar2, ---渠道名称
                                                       v_account_id      out varchar2)
      return varchar2 is

      /*
             功能介绍:下游渠道提款校验
             创建人:邓孝辉
             创建时间:2019/3/18
      */
      l_bank_account    number;
      l_bank_balance    number;
      l_company_id      number;
      l_bank_company_id number;
begin
      ---1.校验金额
      if(v_amount<=0 or v_service_fee<0 ) then
       return pkg_error_code.amount_error;
      end if;

      ---2.检查下游渠道
      select c.channel_name,c.account_id,a.account_name,c.company_id
        into v_channel_name,v_account_id,v_account_name,l_company_id
      from yx_base_down_channel c
      inner join yx_base_down_account a on c.account_id=a.account_id
      where c.channel_no=v_down_channel_no;

     ---3.检查实体卡是否存在
     select count(1),max(t.balance),max(t.company_id)
      into  l_bank_account,l_bank_balance,l_bank_company_id
     from fd_bank_account_info t
     where t.account_id=v_bank_account_id;

     if(l_company_id!=l_bank_company_id) then
      return pkg_error_code.company_error;
     end if;

     if(l_bank_account=0) then
      return pkg_error_code.bank_account_id_error;
     end if;

     if(l_bank_balance<v_amount+v_service_fee) then
      return pkg_error_code.balance_low;
     end if;
     


  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function YX_F_MANUAL_DOWN_INNER_CHECK
prompt ==============================================
prompt
create or replace function fd_account.yx_f_manual_down_inner_check(v_out_channel_no  in  varchar2, --转出渠道
                                                        v_in_channel_no   in  varchar2, --转入渠道
                                                        v_amount          in  number,
                                                        v_out_account_id  out number,
                                                        v_in_account_id   out number)
       return varchar2 is
    l_out_balance      number;
    l_out_company_id    number;
    l_out_system       number;
    l_in_company_id     number;
    l_in_system        number;
begin

--- 校验转出金额是否正确,公司及系统是否正确
select a.inner_balance, t.company_id, t.source_system_id,t.account_id
  into l_out_balance, l_out_company_id, l_out_system,v_out_account_id
  from yx_base_down_channel t
  left join yx_base_down_account a
    on a.account_id = t.account_id
 where t.channel_no = v_out_channel_no;

select i.company_id, i.source_system_id,i.account_id
  into l_in_company_id, l_in_system,v_in_account_id
  from yx_base_down_channel i
 where i.channel_no = v_in_channel_no;

if (v_amount <= 0 or v_amount > l_out_balance) then
  return pkg_error_code.amount_error;
end if;

if (l_out_company_id != l_in_company_id or l_out_system != l_in_system or
   v_out_channel_no = v_in_channel_no or
   v_out_account_id = v_in_account_id) then
  return pkg_error_code.channel_error;
end if;

return pkg_error_code.success;
exception when others then return pkg_error_code.channel_or_account_error; end;
/

prompt
prompt Creating function YX_F_MANUAL_DOWN_INNER_TSFER
prompt ==============================================
prompt
create or replace function fd_account.yx_f_manual_down_inner_tsfer(v_out_channel_no  in  varchar2,
                                                        v_in_channel_no   in  varchar2,
                                                        v_amount          in  number,
                                                        v_hander_user     in  varchar2,
                                                        v_memo            in  varchar2,
                                                        v_out_account_id  in  number,
                                                        v_in_account_id   in  number)
    return varchar2 is
    -------------------下游渠道内部转账--------------------
    l_out_balance            number;
    l_out_fund_id            number;

    l_in_balance             number;
    l_in_fund_id             number;
begin
  --===========================1.出账渠道操作=============================

--1.1 锁出账渠道账户
select oa.inner_balance
  into l_out_balance
  from yx_base_down_account oa
 where oa.account_id = v_out_account_id
   for update;

--1.2 修改出账渠道余额
update yx_base_down_account oa
   set oa.inner_balance  = oa.inner_balance - v_amount
 where oa.account_id = v_out_account_id
   and oa.inner_balance >= v_amount;

if (sql%rowcount = 0) then
  rollback;
  return pkg_error_code.data_error;
end if;

select seq_yxtradedownfund_auto_id.nextval into l_out_fund_id from dual;

--1.3 添加出账账户提款记录
insert into yx_trade_down_manual
  (record_id,
   channel_no,
   account_id,
   has_adjust,
   add_type,
   change_amount,
   change_time,
   balance,
   create_user,
   memo)
values
  (l_out_fund_id,
   v_out_channel_no,
   v_out_account_id,
   0,
   pkg_down_manual_change_type.draw_amount,
   v_amount,
   sysdate,
   l_out_balance - v_amount,
   v_hander_user,
   v_memo);

if (sql%rowcount = 0) then
  rollback;
  return pkg_error_code.data_error;
end if;

--1.4 添加出账账户资金变动
insert into yx_trade_down_fund
  (record_id,
   yx_order_id,
   order_source,
   down_channel_no,
   down_account_id,
   change_time,
   change_type,
   pay_amount,
   change_amount,
   balance,
   memo)
  select l_out_fund_id,
         0,
         0,
         oc.channel_no,
         v_out_account_id,
         sysdate,
         pkg_down_fund_change_type.draw_amount,
         v_amount,
         v_amount,
         l_out_balance - v_amount,
         v_memo
    from yx_base_down_channel oc
   where oc.channel_no = v_out_channel_no;

if (sql%rowcount = 0) then
  rollback;
  return pkg_error_code.data_error;
end if;

--===========================2.入账渠道操作=============================
--2.1 锁入账渠道账户
select i.inner_balance
  into l_in_balance
  from yx_base_down_account i
 where i.account_id = v_in_account_id;

--2.2 修改入账渠道余额
update yx_base_down_account i
   set i.inner_balance  = i.inner_balance + v_amount
 where i.account_id = v_in_account_id;

if (sql%rowcount = 0) then
  rollback;
  return pkg_error_code.data_error;
end if;

select seq_yxtradedownfund_auto_id.nextval into l_in_fund_id from dual;

--2.3 添加入账账户提款记录
insert into yx_trade_down_manual
  (record_id,
   channel_no,
   account_id,
   has_adjust,
   add_type,
   change_amount,
   change_time,
   balance,
   create_user,
   memo)
values
  (l_in_fund_id,
   v_in_channel_no,
   v_in_account_id,
   0,
   pkg_down_manual_change_type.add_amount,
   v_amount,
   sysdate,
   l_in_balance + v_amount,
   v_hander_user,
   v_memo);

if (sql%rowcount = 0) then
  rollback;
  return pkg_error_code.data_error;
end if;

--2.4 添加入账账户资金变动
insert into yx_trade_down_fund
  (record_id,
   yx_order_id,
   order_source,
   down_channel_no,
   down_account_id,
   change_time,
   change_type,
   pay_amount,
   change_amount,
   balance,
   memo)
values
  (l_in_fund_id,
   0,
   0,
   v_in_channel_no,
   v_in_account_id,
   sysdate,
   pkg_down_fund_change_type.add_amount,
   v_amount,
   v_amount,
   l_in_balance + v_amount,
   v_memo);

if (sql%rowcount = 0) then
  rollback;
  return pkg_error_code.data_error;
end if;

return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_MANUAL_DOWN_ISSUE_ADD
prompt ============================================
prompt
create or replace function fd_account.yx_f_manual_down_issue_add(v_down_channel_no in varchar2, --下游渠道编号
                                                v_bank_account_id in number, --实体卡账户号
                                                v_amount          in number, --加款金额
                                                v_create_user     in varchar2, --创建人
                                                v_memo            in varchar2, --备注
                                                v_account_id      in number,   --账号编号
                                                v_account_name    in varchar2, --账号名称
                                                v_channel_name    in varchar2) --渠道名称
        return varchar2 is

/*
    功能介绍:账户手工发行加款(锁实体银行卡,渠道账户)
    创建人:周荣省
    创建时间:2019/6/4
*/

l_bank_company        number;
l_bank_balance        number;
l_fund_record_main_id number;
l_inner_balance       number;
l_bank_batch_id       number;

begin
  --================1.锁账户获取参数======================
  --=========[锁公司手续费账户、锁实体卡账户、检查实体卡余额、获取seq]=======

    --1.1 锁实体卡账户
    select t.balance,t.company_id
      into l_bank_balance,l_bank_company
    from fd_bank_account_info t
    where t.account_id=v_bank_account_id
     for update;

  ---1.2 获取部分添加参数
  select seq_yxtradedownfund_auto_id.nextval
    into l_fund_record_main_id
    from dual;

      ---获取银行卡资金变动统一流水号(为红冲时查询)
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

    --====================2.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡加款的资金变动]===
  ---2.1 更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

     ---2.2 添加实体卡资金变动
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company,
     v_amount,
     (l_bank_balance + v_amount),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.add_amount,
     pkg_bank_use_type.down_add,
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id);

     ---==================3.更新发行余额============================
     ---3.1 锁下游渠道
     select t.issue_balance
       into l_inner_balance
      from yx_base_down_channel t
      where t.channel_no=v_down_channel_no
       for update;

     ---3.2 更新渠道账户余额
     update yx_base_down_channel t
        set t.issue_balance   = (t.issue_balance+v_amount)
      where t.channel_no = v_down_channel_no;

      ---3.3 添加下游人工发行加款记录
        insert into yx_trade_down_manual
          (record_id,
           channel_no,
           account_id,
           adjust_id,
           has_adjust,
           add_type,
           change_amount,
           change_time,
           balance,
           create_user,
           memo,
           bank_fund_id)
        values
          (l_fund_record_main_id,
           v_down_channel_no,
           v_account_id,
           0,
           1,
           pkg_down_manual_change_type.issue_add,
           v_amount,
           sysdate,
           l_inner_balance+v_amount,
           v_create_user,
           v_memo,
           l_bank_batch_id);

      ---3.4 添加下游资金变动
      insert into yx_trade_down_fund
            (record_id,
             yx_order_id,
             trade_order_no,
             ext_order_no,
             order_source,
             down_channel_no,
             down_account_id,
             change_time,
             change_type,
             pay_amount,
             change_amount,
             balance,
             memo)
          values
            (l_fund_record_main_id,
             0,
             '-',
             '-',
             0,
             v_down_channel_no,
             v_account_id,
             sysdate,
             pkg_down_fund_change_type.add_issue,
             v_amount,
             v_amount,
             (l_inner_balance + v_amount),
             v_memo);

      return pkg_error_code.success;

end;
/

prompt
prompt Creating function YX_F_MANUAL_DOWN_RV_CHANNEL
prompt =============================================
prompt
create or replace function fd_account.yx_f_manual_down_rv_channel(v_down_channel_no varchar2,
                                                       v_down_account_id number,
                                                       v_revise_type     number,
                                                       v_issue           in number, --发行类型，0：普通交易扣款，1：发行卡或优惠券扣款
                                                       v_revise_amount   number,
                                                       v_create_user     varchar2,
                                                       v_memo            varchar2,
                                                       v_trade_fund_id   out number)
  return varchar2 is
  -------------------------------------
  --功能：渠道账户余额平账
  --创建人：周荣省
  --创建时间：2019-07-30
  -------------------------------------
  l_inner_balance         number;
  l_down_manual_type      number;
  l_up_fund_type          number;
  l_down_fund_type        number;
  l_credit_money          number;
  l_balance_change_amount number;
  l_order_source          number;
begin
  ---1.获取变动记录参数
  select seq_yxtradedownfund_auto_id.nextval
    into v_trade_fund_id
    from dual;

  if (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.balance) then
    l_down_manual_type      := pkg_down_manual_change_type.balance_revise_add;
    l_up_fund_type          := 0;
    l_down_fund_type        := pkg_down_fund_change_type.add_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount < 0 and
        v_revise_type = pkg_sys_revise_type.balance) then
    l_down_manual_type      := pkg_down_manual_change_type.balance_revise_minus;
    l_up_fund_type          := 0;
    l_down_fund_type        := pkg_down_fund_change_type.add_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.debit) then
    l_down_manual_type      := pkg_down_manual_change_type.debit_revise_add;
    l_up_fund_type          := pkg_up_fund_change_type.debit_amount;
    l_down_fund_type        := pkg_down_fund_change_type.debit_amount;
    l_balance_change_amount := 0 - v_revise_amount;
  elsif (v_revise_amount < 0 and v_revise_type = pkg_sys_revise_type.debit) then
    l_down_manual_type      := pkg_down_manual_change_type.debit_revise_minus;
    l_up_fund_type          := pkg_up_fund_change_type.debit_amount;
    l_down_fund_type        := pkg_down_fund_change_type.debit_amount;
    l_balance_change_amount := 0 - v_revise_amount;
  elsif (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.refund) then
    l_down_manual_type      := pkg_down_manual_change_type.refund_revise_add;
    l_up_fund_type          := pkg_up_fund_change_type.refund_amount;
    l_down_fund_type        := pkg_down_fund_change_type.refund_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount < 0 and v_revise_type = pkg_sys_revise_type.refund) then
    l_down_manual_type      := pkg_down_manual_change_type.refund_revise_minus;
    l_up_fund_type          := pkg_up_fund_change_type.refund_amount;
    l_down_fund_type        := pkg_down_fund_change_type.refund_amount;
    l_balance_change_amount := v_revise_amount;
  else
    return pkg_error_code.data_error;
  end if;
  select t.source_system_id
    into l_order_source
    from yx_base_down_channel t
   where t.channel_no = v_down_channel_no;
  if v_issue = 0 then
    ---2.锁渠道账户
    select t.inner_balance, t.credit_money
      into l_inner_balance, l_credit_money
      from yx_base_down_account t
     where t.account_id = v_down_account_id
       for update;
  
    ---4修改账户余额添加资金变动
    update yx_base_down_account t
       set t.inner_balance  = (l_inner_balance + l_balance_change_amount),
           t.last_edit_user = v_create_user,
           t.last_edit_time = sysdate
     where t.account_id = v_down_account_id;
  
    ---5下游手工记录添加
    insert into yx_trade_down_manual
      (record_id,
       channel_no,
       account_id,
       adjust_id,
       has_adjust,
       add_type,
       change_amount,
       change_time,
       balance,
       create_user,
       memo)
    values
      (v_trade_fund_id,
       v_down_channel_no,
       v_down_account_id,
       0,
       0,
       l_down_manual_type,
       v_revise_amount,
       sysdate,
       (l_inner_balance + l_balance_change_amount),
       v_create_user,
       nvl2(v_memo, v_memo || ',下游平账', '下游平账'));
  
    ---6.下游资金变动添加
    insert into yx_trade_down_fund
      (record_id,
       yx_order_id,
       order_source,
       trade_order_no,
       down_channel_no,
       down_account_id,
       change_time,
       change_type,
       pay_amount,
       change_amount,
       balance,
       handling_fee,
       coupon_amount,
       memo)
    values
      (v_trade_fund_id,
       0,
       l_order_source,
       'RV' || v_trade_fund_id,
       v_down_channel_no,
       v_down_account_id,
       sysdate,
       l_down_fund_type,
       v_revise_amount,
       v_revise_amount,
       (l_inner_balance + l_balance_change_amount),
       0,
       0,
       v_memo);
  
    ---7.上游资金变动（不存下游公司以免结算)
    if l_up_fund_type != 0 then
      insert into yx_trade_up_fund
        (record_id,
         down_channel_no,
         down_account_id,
         down_company_id,
         up_channel_no,
         up_account_id,
         up_company_id,
         down_draw_unit,
         down_draw_face,
         down_draw_amount,
         down_real_amount,
         up_draw_amount,
         up_real_amount,
         change_time,
         change_type,
         balance,
         memo)
      values
        (seq_trade_up_fund_id.nextval,
         v_down_channel_no,
         v_down_account_id,
         0,
         0,
         0,
         0,
         0,
         0,
         v_revise_amount,
         v_revise_amount,
         0,
         0,
         sysdate,
         l_up_fund_type,
         0,
         v_memo);
    end if;
  else
    --8.锁渠道账户
    select t.issue_balance
      into l_inner_balance
      from yx_base_down_channel t
     where t.channel_no = v_down_channel_no
       for update;
  
    ---9修改账户余额添加资金变动
    update yx_base_down_channel t
       set t.issue_balance  = (l_inner_balance + l_balance_change_amount),
           t.last_edit_user = v_create_user,
           t.last_edit_time = sysdate
     where t.channel_no = v_down_channel_no;
  
    ---10下游手工记录添加
    insert into yx_trade_down_manual
      (record_id,
       channel_no,
       account_id,
       adjust_id,
       has_adjust,
       add_type,
       change_amount,
       change_time,
       balance,
       create_user,
       memo)
    values
      (v_trade_fund_id,
       v_down_channel_no,
       0,
       0,
       0,
       l_down_manual_type,
       v_revise_amount,
       sysdate,
       (l_inner_balance + l_balance_change_amount),
       v_create_user,
       nvl2(v_memo, v_memo || ',下游平账', '下游平账'));
  
    ---11.下游资金变动添加
    insert into yx_trade_down_fund
      (record_id,
       yx_order_id,
       order_source,
       trade_order_no,
       down_channel_no,
       down_account_id,
       change_time,
       change_type,
       pay_amount,
       change_amount,
       balance,
       handling_fee,
       coupon_amount,
       memo)
    values
      (v_trade_fund_id,
       0,
       l_order_source,
       'RV' || v_trade_fund_id,
       v_down_channel_no,
       v_down_account_id,
       sysdate,
       l_down_fund_type,
       v_revise_amount,
       v_revise_amount,
       (l_inner_balance + l_balance_change_amount),
       0,
       0,
       v_memo);
  
    ---12.上游资金变动（不存下游公司以免结算)
    if l_up_fund_type != 0 then
      insert into yx_trade_up_fund
        (record_id,
         down_channel_no,
         down_account_id,
         down_company_id,
         up_channel_no,
         up_account_id,
         up_company_id,
         down_draw_unit,
         down_draw_face,
         down_draw_amount,
         down_real_amount,
         up_draw_amount,
         up_real_amount,
         change_time,
         change_type,
         balance,
         memo)
      values
        (seq_trade_up_fund_id.nextval,
         v_down_channel_no,
         0,
         0,
         0,
         0,
         0,
         0,
         0,
         v_revise_amount,
         v_revise_amount,
         0,
         0,
         sysdate,
         l_up_fund_type,
         0,
         v_memo);
    end if;
  end if;
  return pkg_error_code.success;

end;
/

prompt
prompt Creating function YX_F_MANUAL_DOWN_RV_CHANNEL_CK
prompt ================================================
prompt
create or replace function fd_account.yx_f_manual_down_rv_channel_ck(v_down_channel_no varchar2,
                                                          v_down_account_id number,
                                                          v_revise_amount   number)
  return varchar2 is
  ---------------------------------------
  --功能：检查下游渠道账户手工平账渠道账户、金额是否正确
  --创建人：周荣省
  --创建时间：2019-07-30
  ---------------------------------------
  l_down_account_id number;
begin
  ---1.检查调整金额是否正确
  if (v_revise_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户是否正确
  select t.account_id
    into l_down_account_id
    from yx_base_down_channel t
   inner join yx_base_down_account a on t.account_id = a.account_id
   where t.channel_no = v_down_channel_no
     and t.account_id = v_down_account_id
     and rownum <= 2;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_or_account_error;

end;
/

prompt
prompt Creating function YX_F_MANUAL_DOWN_RV_TRADE
prompt ===========================================
prompt
create or replace function fd_account.yx_f_manual_down_rv_trade(v_channel_no     in    varchar2,
                                                     v_down_account_id  in    number,
                                                     v_down_company_id  in    number,
                                                     v_draw_amount    in    number,
                                                     v_real_amount    in    number,
                                                     v_business_type  in    number,
                                                     v_create_user    in    varchar2,
                                                     v_memo           in    varchar2)
       return varchar2 is
   ------------------下游渠道平账-------------------
   l_up_fund_id        number;
   l_down_fund_id      number;
   l_inner_balance     number;
begin
  --1. ========================获取序列号================================
select seq_yxtradedownfund_auto_id.nextval,
       seq_yxtradeupfund_auto_id.nextval
  into l_down_fund_id, l_up_fund_id
  from dual;
--2 ======================锁账户,创建下游资金变动==========================
--2.1 锁账户,修改余额
if v_draw_amount = 0 then
  select a.inner_balance
    into l_inner_balance
    from yx_base_down_account a
   where a.account_id = v_down_account_id;
else
  select a.inner_balance
    into l_inner_balance
    from yx_base_down_account a
   where a.account_id = v_down_account_id
     for update;

  update yx_base_down_account a
     set a.inner_balance = a.inner_balance - v_draw_amount
   where a.account_id = v_down_account_id;

  if (sql%rowcount = 0) then
    return pkg_error_code.data_error;
  end if;
end if;

--2.2 创建下游手工记录添加
insert into yx_trade_down_manual
  (record_id,
   channel_no,
   account_id,
   has_adjust,
   add_type,
   change_amount,
   real_amount,
   change_time,
   balance,
   create_user,
   memo)
values
  (l_down_fund_id,
   v_channel_no,
   v_down_account_id,
   0,
   pkg_down_manual_change_type.trade_revise,
   v_draw_amount,
   v_real_amount,
   sysdate,
   l_inner_balance - v_draw_amount,
   v_create_user,
   v_memo);

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;
--2.3.下游资金变动添加(通过trade_order_no关联上游资金变动)
insert into yx_trade_down_fund
  (record_id,
   yx_order_id,
   order_source,
   trade_order_no,
   down_channel_no,
   down_account_id,
   change_time,
   change_type,
   pay_amount,
   change_amount,
   balance,
   memo)
values
  (l_down_fund_id,
   0,
   0,
   'SARV' || l_up_fund_id,
   v_channel_no,
   v_down_account_id,
   sysdate,
   pkg_down_fund_change_type.debit_amount,
   0,
   v_draw_amount,
   l_inner_balance - v_draw_amount,
   v_memo);
if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

--3 =========================创建上游资金变动==============================
--3.1 上游资金变动（上游下游公司相同避免结算)
insert into yx_trade_up_fund
  (record_id,
   down_channel_no,
   down_account_id,
   down_company_id,
   up_channel_no,
   up_account_id,
   up_company_id,
   down_draw_amount,
   down_real_amount,
   up_draw_unit,
   up_draw_face,
   up_draw_amount,
   up_real_amount,
   up_servie_fee,
   change_time,
   change_type,
   business_type,
   balance,
   memo)
values
  (l_up_fund_id,
   v_channel_no,
   v_down_account_id,
   v_down_company_id,
   0,
   0,
   v_down_company_id,
   v_draw_amount,
   v_real_amount,
   0,
   0,
   0,
   0,
   0,
   sysdate,
   pkg_up_fund_change_type.debit_amount,
   v_business_type,
   l_inner_balance - v_draw_amount,
   v_memo);
if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_MANUAL_DOWN_RV_TRADE_CK
prompt ==============================================
prompt
create or replace function fd_account.yx_f_manual_down_rv_trade_ck(v_channel_no      in varchar2,
                                                        v_draw_amount     in number,
                                                        v_real_amount     in number,
                                                        v_down_account_id out number,
                                                        v_down_company_id out number)
  return varchar2 is
begin
  --2.检查渠道
  select a.account_id, t.company_id
    into v_down_account_id, v_down_company_id
    from yx_base_down_channel t
   inner join yx_base_down_account a on t.account_id = a.account_id
   where t.channel_no = v_channel_no
     and rownum <= 1;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function YX_F_MANUAL_RV_TRADE
prompt ======================================
prompt
create or replace function fd_account.yx_f_manual_rv_trade(v_order_source     in number, --订单来源系统编号
                                                v_up_channel_no    in varchar2, --上游
                                                v_up_draw_face     in number,
                                                v_up_account_id    in number,
                                                l_up_company_id    in number,
                                                v_up_draw_amount   in number,
                                                v_up_real_amount   in number,
                                                v_up_service_fee   in number,
                                                v_down_channel_no  in varchar2, --下游
                                                v_down_draw_face   in number,
                                                v_down_account_id  in number,
                                                l_down_company_id  in number,
                                                v_down_draw_amount in number,
                                                v_down_real_amount in number,
                                                v_down_hand_fee    in number,
                                                v_down_coupon      in number,
                                                v_agent_id         in varchar2, --代理人
                                                v_agency_fee       in number,
                                                v_business_type    in number,
                                                v_create_user      in varchar2,
                                                v_issue            in number,
                                                v_memo             in varchar2)
  return varchar2 is
  l_inner_balance      number;
  l_down_inner_balance number;
  l_agent_balance      number;
  l_fund_id            number;
  l_down_fund_id       number;
  l_agent_fund_id      number;

  l_service_fee     number;
  l_up_account_id   number;
  l_down_account_id number;

  l_change_type_debit number;
  -------------------------------------------------------
  --功能：交易平账，上游，下游，代理人，服务费，代理费，手续费，推广成本。（发行服务与一般扣款一致）
  --创建人：周荣省
  --创建时间：2019-06-13
  -------------------------------------------------------
begin
  if v_issue = 1 then
    l_change_type_debit := pkg_up_fund_change_type.debit_issue;
  else
    l_change_type_debit := pkg_up_fund_change_type.debit_amount;
  end if;
  --获取上游资金变动序列号
  select seq_yxtradedownfund_auto_id.nextval,
         seq_yxtradeupfund_auto_id.nextval,
         seq_yxtradeagentfund_auto_id.nextval
    into l_down_fund_id, l_fund_id, l_agent_fund_id
    from dual;
  if v_issue = 0 then
    l_up_account_id   := v_up_account_id;
    l_down_account_id := v_down_account_id;
  else
    l_up_account_id   := 0;
    l_down_account_id := 0;
  end if;
  --========================1. 上游。锁账户,修改账户金额===========================
  if (v_up_draw_amount = 0) then
    if v_issue = 0 then
      select a.inner_balance
        into l_inner_balance
        from yx_base_up_account a
       where a.account_id = v_up_account_id;
    else
      select t.issue_balance
        into l_inner_balance
        from yx_base_up_channel t
       where t.channel_no = v_up_channel_no;
    end if;
  else
    if v_issue = 0 then
      --普通平账
      select a.inner_balance
        into l_inner_balance
        from yx_base_up_account a
       where a.account_id = v_up_account_id
         for update;
    
      update yx_base_up_account t
         set t.inner_balance = t.inner_balance - v_up_draw_amount
       where t.account_id = v_up_account_id;
    
      if (sql%rowcount = 0) then
        return pkg_error_code.data_error;
      end if;
    elsif v_issue = 1 then
      --发行平账
      select t.issue_balance
        into l_inner_balance
        from yx_base_up_channel t
       where t.channel_no = v_up_channel_no
         for update;
      update yx_base_up_channel t
         set t.issue_balance = t.issue_balance - v_up_draw_amount
       where t.channel_no = v_up_channel_no;
    else
      return pkg_error_code.data_error;
    end if;
  end if;
  --==================2.锁服务费，修改服务费账户=========================
  if v_up_service_fee != 0 then
    --2.1锁渠道
    select t.service_balance
      into l_service_fee
      from yx_base_up_channel t
     where t.channel_no = v_up_channel_no
       for update;
  
    --2.2 修改渠道数据
    update yx_base_up_channel t
       set t.service_balance = t.service_balance + v_up_service_fee
     where t.channel_no = v_up_channel_no;
  
    if (sql%rowcount = 0) then
      return pkg_error_code.data_error;
    end if;
    insert into yx_trade_up_manual
      (record_id,
       channel_no,
       account_id,
       has_adjust,
       add_type,
       change_amount,
       real_amount,
       change_time,
       balance,
       create_user,
       memo)
    values
      (l_fund_id,
       v_up_channel_no,
       0,
       0,
       pkg_up_manual_change_type.service_revise,
       v_up_service_fee,
       v_up_service_fee,
       sysdate,
       l_service_fee + v_up_service_fee,
       v_create_user,
       v_memo);
  
    if (sql%rowcount = 0) then
      return pkg_error_code.data_error;
    end if;
  end if;
  --===================3.锁下游，修改账户余额(包括手续费和推广成本)============================
  if v_down_draw_amount = 0 and v_down_hand_fee = 0 and v_down_coupon = 0 then
    if v_issue = 0 then
      select a.inner_balance
        into l_down_inner_balance
        from yx_base_down_account a
       where a.account_id = l_down_account_id;
    else
      select t.issue_balance
        into l_down_inner_balance
        from yx_base_down_channel t
       where t.channel_no = v_down_channel_no;
    end if;
  else
    if v_issue = 0 then
      --3.1普通平账
      select a.inner_balance
        into l_down_inner_balance
        from yx_base_down_account a
       where a.account_id = l_down_account_id
         for update;
    
      update yx_base_down_account a
         set a.inner_balance = a.inner_balance - v_down_draw_amount
       where a.account_id = l_down_account_id;
    
      if (sql%rowcount = 0) then
        return pkg_error_code.data_error;
      end if;
    else
      --3.2发行平账
      select t.issue_balance
        into l_down_inner_balance
        from yx_base_down_channel t
       where t.channel_no = v_down_channel_no
         for update;
      update yx_base_down_channel t
         set t.issue_balance = t.issue_balance - v_down_draw_amount
       where t.channel_no = v_down_channel_no;
      if (sql%rowcount = 0) then
        return pkg_error_code.data_error;
      end if;
    end if;
    --3.3添加下游资金变动
    insert into yx_trade_down_fund
      (record_id,
       yx_order_id,
       order_source,
       trade_order_no,
       down_channel_no,
       down_account_id,
       change_time,
       change_type,
       pay_amount,
       change_amount,
       balance,
       handling_fee,
       coupon_amount,
       memo)
    values
      (l_down_fund_id,
       0,
       v_order_source,
       'SARV' || l_fund_id,
       v_down_channel_no,
       l_down_account_id,
       sysdate,
       l_change_type_debit,
       v_down_draw_amount,
       v_down_draw_amount - v_down_hand_fee,
       l_down_inner_balance - v_down_draw_amount,
       v_down_hand_fee,
       v_down_coupon,
       v_memo);
    if (sql%rowcount = 0) then
      return pkg_error_code.data_error;
    end if;
  end if;
  --================4.代理人，锁账户，修改账户余额==================
  if v_agent_id is not null and v_agent_id != '0' and v_agency_fee != 0 then
    --4.1 锁代理人,修改代理人余额
    select a.balance
      into l_agent_balance
      from yx_base_agent a
     where a.agent_id = v_agent_id
       for update;
  
    update yx_base_agent t
       set t.balance = t.balance + v_agency_fee
     where t.agent_id = v_agent_id;
  
    if (sql%rowcount = 0) then
      return pkg_error_code.data_error;
    end if;
    --4.2创建代理人资金变动
    insert into yx_trade_agent_fund
      (record_id,
       up_fund_id,
       down_channel_no,
       up_channel_no,
       order_source,
       agent_id,
       change_amount,
       balance,
       change_type,
       change_time,
       business_type)
    values
      (l_agent_fund_id,
       l_fund_id,
       v_down_channel_no,
       v_up_channel_no,
       v_order_source,
       v_agent_id,
       v_agency_fee,
       l_agent_balance + v_agency_fee,
       pkg_agent_fund_change_type.debit_amount,
       sysdate,
       v_business_type);
  
    if (sql%rowcount = 0) then
      return pkg_error_code.data_error;
    end if;
  end if;

  --==================5.添加上游资金变动=================================
  insert into yx_trade_up_fund
    (record_id,
     yx_order_id,
     order_source,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     agent_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     income_amount,
     dowm_handling_fee,
     down_agency_fee,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     up_servie_fee,
     change_time,
     change_type,
     business_type,
     balance,
     memo,
     coupon_amount)
  values
    (l_fund_id,
     0,
     v_order_source,
     v_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_up_channel_no,
     l_up_account_id,
     l_up_company_id,
     v_agent_id,
     v_down_draw_face,
     v_down_draw_face,
     v_down_draw_amount,
     v_down_real_amount,
     0,
     v_down_hand_fee,
     v_agency_fee,
     v_up_draw_face,
     v_up_draw_face,
     v_up_draw_amount,
     v_up_real_amount,
     v_up_service_fee,
     sysdate,
     l_change_type_debit,
     v_business_type,
     (l_inner_balance - v_up_draw_amount),
     v_memo,
     v_down_coupon);
  if (sql%rowcount = 0) then
    return pkg_error_code.data_error;
  end if;

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_ADD
prompt ====================================
prompt
create or replace function fd_account.yx_f_manual_up_add(v_up_channel_no   in varchar2, ---上有渠道编号
                                              v_up_company_id   in number, ---上游渠道公司编号
                                              v_account_id      in number, ---上游账户编号
                                              v_bank_account_id in number, ---实体账户编号
                                              v_service_fee     in number, ---手续费
                                              v_amount          in number, ---加款金额
                                              v_create_user     in varchar2, ---创建人
                                              v_memo            in varchar2, ---备注
                                              v_account_name    in varchar2, ---账户名称
                                              v_channel_name    in varchar2 ---渠道名称
                                              )

 return varchar2 is
  /*
         功能介绍:上游加款
         创建人:邓孝辉
         创建时间:2019/3/19
  */
  l_bank_balance    number;
  l_bank_company_id number;
  l_fund_id         number;
  l_bank_batch_id   number;
  l_inner_balance   number;
begin
  --===============1.锁实体账户获取参数==========================================
  --=========[锁实体卡账户、检查实体卡余额、获取seq]=======
  ---1.1 锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---1.2 检查相关金额（银行余额需大于加款金额）
  if (l_bank_balance < v_amount + v_service_fee) then
    return pkg_error_code.balance_low;
  end if;

  ---1.3 获取资金变动主键
  ---手续费手费资金变动编号，小于人工加款的资金变动编号
  select seq_yxtradeupfund_auto_id.nextval into l_fund_id from dual;
  ---获取银行卡加款变动统一流水号(用于红冲查询)
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================2.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡加款的资金变动]===
  ---2.1 更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_amount - v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---2.2 添加实体卡加款资金变动 
  if (v_service_fee > 0) then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       l_bank_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       v_channel_name,
       v_account_name,
       v_memo,
       l_bank_batch_id);
  end if;
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company_id,
     v_amount,
     (l_bank_balance - v_amount - v_service_fee),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.up_add,
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id);

  --==============3.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加上游手工加款记录、添加上游资金变动]=====

  ---3.1 锁渠道账户
  select a.inner_balance
    into l_inner_balance
    from yx_base_up_account a
   where a.account_id = v_account_id
     for update;

  ---3.2 更新渠道账户余额
  update yx_base_up_account t
     set t.inner_balance  = t.inner_balance + v_amount,
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_account_id;

  ---3.3 添加上游手工加款记录
  insert into yx_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo,
     bank_fund_id)
  values
    (l_fund_id,
     v_up_channel_no,
     v_account_id,
     0,
     1,
     pkg_up_manual_change_type.add_amount,
     v_amount,
     sysdate,
     l_inner_balance + v_amount,
     v_create_user,
     v_memo,
     l_bank_batch_id);

  ---3.4 添加上游资金变动
  insert into yx_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     up_servie_fee,
     change_time,
     change_type,
     balance,
     memo,
     out_change_time)
  values
    (l_fund_id,
     v_up_channel_no,
     v_account_id,
     v_up_company_id,
     0,
     0,
     v_amount,
     v_amount,
     0,
     sysdate,
     pkg_up_fund_change_type.add_amount,
     (l_inner_balance + v_amount),
     v_memo,
     sysdate);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_ADD_CHECK
prompt ==========================================
prompt
create or replace function fd_account.yx_f_manual_up_add_check(v_up_channel_no    in  varchar2,  ---上游渠道编号
                                                    v_bank_account_id  in  number,    ---实体卡账户编号
                                                    v_service_fee      in  number,    ---手续费
                                                    v_amount           in  number,    ---加款金额
                                                    v_account_id       out number,    ---账户编号
                                                    v_account_name     out varchar2,  ---账户名称
                                                    v_channel_name     out varchar2,  ---渠道名称
                                                    v_up_company_id    out number     ---上游渠道公司编号
                                                    )

       return varchar2 is
       /*
              功能介绍:上游加款校验
              创建人:邓孝辉
              创建时间:2019/3/19
       */
       l_bank_count        number;
       l_bank_balance      number;
       l_company_id        number;
       l_bank_company_id   number;
begin
       --1. 校验金额
       if(v_amount<=0 or v_service_fee<0)then
        return pkg_error_code.amount_error;
       end if;

       --2. 检查上游账户信息
       select c.company_id,c.channel_name,c.account_id,a.account_name,c.company_id
         into v_up_company_id,v_channel_name,v_account_id,v_account_name,l_company_id
        from yx_base_up_channel c
        inner join yx_base_up_account a on c.account_id=a.account_id
        where c.channel_no=v_up_channel_no;

       ---3. 检查实体账户信息
       select count(1),max(t.balance),max(t.company_id)
         into l_bank_count,l_bank_balance,l_bank_company_id
        from fd_bank_account_info t
        where t.account_id=v_bank_account_id;


        if(l_bank_count=0) then
         return pkg_error_code.bank_account_id_error;
        end if;
        
        if(l_bank_company_id!=l_company_id) then
         return pkg_error_code.company_error;
        end if;
        
        if(l_bank_balance<v_amount+v_service_fee) then
         return pkg_error_code.balance_low;
        end if;

        return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_DRAW
prompt =====================================
prompt
create or replace function fd_account.yx_f_manual_up_draw(v_up_channel_no     in varchar2,   ---上有渠道编号
                                               v_up_company_id     in number,     ---上游渠道公司编号
                                               v_account_id        in number,     ---上游账户编号
                                               v_bank_account_id   in number,     ---实体账户编号
                                               v_amount            in number,     ---加款金额
                                               v_create_user       in varchar2,   ---创建人
                                               v_memo              in varchar2,   ---备注
                                               v_account_name      in varchar2,   ---账户名称
                                               v_channel_name      in varchar2    ---渠道名称
                                               )

       return varchar2 is
       /*
              功能介绍:上游人工扣款
              创建人:邓孝辉
              创建时间:2019/3/19
       */
  l_bank_balance       number;
  l_bank_company_id    number;
  l_fund_id            number;
  l_bank_batch_id      number;
  l_inner_balance      number;
begin
  --===============1.锁实体账户获取参数==========================================
    --=========[锁实体卡账户、检查实体卡余额、获取seq]=======
      ---1.1 锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;



  ---1.3 获取资金变动主键
  ---人工扣款的资金变动编号
  select seq_yxtradeupfund_auto_id.nextval into l_fund_id from dual;
  ---获取银行卡加款变动统一流水号
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

    --====================2.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡扣款的资金变动]===
  ---2.1 更新实体卡账户余额
    update fd_bank_account_info t
     set t.balance        = (l_bank_balance + v_amount),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---2.2 添加实体卡扣款资金变动
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       l_bank_company_id,
       v_amount,
       (l_bank_balance + v_amount),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.add_amount,
       pkg_bank_use_type.up_draw,
       v_channel_name,
       v_account_name,
       v_memo,
       l_bank_batch_id);

   --==============3.更新渠道账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加上游手工扣款记录、添加上游资金变动]=====

  ---3.1 锁渠道账户
  select a.inner_balance
    into l_inner_balance
   from yx_base_up_account a
   where a.account_id=v_account_id
   for update;

   ---3.2 更新渠道账户余额
   update yx_base_up_account t
      set t.inner_balance  = t.inner_balance - v_amount,
          t.last_edit_user = v_create_user,
          t.last_edit_time =sysdate
     where t.account_id = v_account_id;

   ---3.3 添加上游手工扣款记录
      insert into yx_trade_up_manual
        (record_id,
         channel_no,
         account_id,
         adjust_id,
         has_adjust,
         add_type,
         change_amount,
         change_time,
         balance,
         create_user,
         memo,
         bank_fund_id)
      values
        (l_fund_id,
         v_up_channel_no,
         v_account_id,
         0,
         1,
         pkg_up_manual_change_type.draw_amount,
         v_amount,
         sysdate,
         l_inner_balance-v_amount,
         v_create_user,
         v_memo,
         l_bank_batch_id);


   ---3.4 添加上游资金变动
      insert into yx_trade_up_fund
        (record_id,
         up_channel_no,
         up_account_id,
         up_company_id,
         up_draw_unit,
         up_draw_face,
         up_draw_amount,
         up_real_amount,
         up_servie_fee,
         change_time,
         change_type,
         balance,
         memo,
         out_change_time)
      values
        (l_fund_id,
         v_up_channel_no,
         v_account_id,
         v_up_company_id,
         0,
         0,
         v_amount,
         v_amount,
         0,
         sysdate,
         pkg_up_fund_change_type.draw_amount,
         (l_inner_balance - v_amount),
         v_memo,
         sysdate);

   return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_DRAW_CHECK
prompt ===========================================
prompt
create or replace function fd_account.yx_f_manual_up_draw_check(v_up_channel_no    in  varchar2,  ---上游渠道编号
                                                    v_bank_account_id  in  number,    ---实体卡账户编号
                                                    v_amount           in  number,    ---加款金额
                                                    v_account_id       out number,    ---账户编号
                                                    v_account_name     out varchar2,  ---账户名称
                                                    v_channel_name     out varchar2,  ---渠道名称
                                                    v_up_company_id    out number     ---上游渠道公司编号
                                                    )

       return varchar2 is
       /*
              功能介绍:上游加款校验
              创建人:邓孝辉
              创建时间:2019/3/19
       */
       l_bank_count       number;
       l_company_id       number;
       l_bank_company_id  number;
begin
       --1. 校验金额
       if(v_amount<=0)then
        return pkg_error_code.amount_error;
       end if;

       --2. 检查上游账户信息
       select c.company_id,c.channel_name,c.account_id,a.account_name,c.company_id
         into v_up_company_id,v_channel_name,v_account_id,v_account_name,l_company_id
        from yx_base_up_channel c
        inner join yx_base_up_account a on c.account_id=a.account_id
        where c.channel_no=v_up_channel_no;

       ---3. 检查实体账户信息
       select count(1),max(t.company_id)
         into l_bank_count,l_bank_company_id
        from fd_bank_account_info t
        where t.account_id=v_bank_account_id;

        if(l_bank_count=0) then
         return pkg_error_code.bank_account_id_error;
        end if;
        
        if(l_company_id!=l_bank_company_id) then
         return pkg_error_code.company_error;
        end if;

        return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_INNER_CHECK
prompt ============================================
prompt
create or replace function fd_account.yx_f_manual_up_inner_check(v_out_channel_no  in  varchar2, --转出渠道
                                                        v_in_channel_no   in  varchar2, --转入渠道
                                                        v_amount          in  number,   --转出金额
                                                        v_out_account_id  out number,
                                                        v_in_account_id   out number)
       return varchar2 is
    l_out_balance      number;
    l_out_company_id    number;
    l_out_system       number;
    l_in_company_id     number;
    l_in_system        number;
begin

--- 校验转出金额是否正确,公司及系统是否正确
select a.inner_balance, t.company_id, t.source_system_id,t.account_id
  into l_out_balance, l_out_company_id, l_out_system,v_out_account_id
  from yx_base_up_channel t
  left join yx_base_up_account a
    on a.account_id = t.account_id
 where t.channel_no = v_out_channel_no;

select i.company_id, i.source_system_id,i.account_id
  into l_in_company_id, l_in_system,v_in_account_id
  from yx_base_up_channel i
 where i.channel_no = v_in_channel_no;

if (v_amount <= 0 or v_amount > l_out_balance) then
  return pkg_error_code.amount_error;
end if;

if (l_out_company_id != l_in_company_id or l_out_system != l_in_system or
   v_out_channel_no = v_in_channel_no or
   v_out_account_id = v_in_account_id) then
  return pkg_error_code.channel_error;
end if;

return pkg_error_code.success;
exception when others then return pkg_error_code.channel_or_account_error; end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_INNER_TSFER
prompt ============================================
prompt
create or replace function fd_account.yx_f_manual_up_inner_tsfer(v_out_channel_no  in  varchar2,
                                                        v_in_channel_no   in  varchar2,
                                                        v_amount          in  number,
                                                        v_hander_user     in  varchar2,
                                                        v_memo            in  varchar2,
                                                        v_out_account_id  in  number,
                                                        v_in_account_id   in  number)
    return varchar2 is
    -------------------上游渠道内部转账--------------------
    l_out_balance            number;
    l_out_fund_id            number;

    l_in_balance             number;
    l_in_fund_id             number;
begin
  --===========================1.出账渠道操作=============================

--1.1 锁出账渠道账户
 select oa.inner_balance
   into l_out_balance
  from yx_base_up_account oa
  where oa.account_id=v_out_account_id;


--1.2 修改出账渠道余额
 update yx_base_up_account oa
    set oa.inner_balance=oa.inner_balance-v_amount
   where oa.account_id=v_out_account_id
    and oa.inner_balance>=v_amount;

if (sql%rowcount = 0) then
  rollback;
  return pkg_error_code.data_error;
end if;

select seq_yxtradeupfund_auto_id.nextval into l_out_fund_id from dual;

--1.3 添加出账账户提款记录
insert into yx_trade_up_manual
  (record_id,
   channel_no,
   account_id,
   has_adjust,
   add_type,
   change_amount,
   change_time,
   balance,
   create_user,
   memo)
values
  (l_out_fund_id,
   v_out_channel_no,
   v_out_account_id,
   0,
   pkg_up_manual_change_type.draw_amount,
   v_amount,
   sysdate,
   l_out_balance-v_amount,
   v_hander_user,
   v_memo);


if (sql%rowcount = 0) then
  rollback;
  return pkg_error_code.data_error;
end if;

--1.4 添加出账账户资金变动
insert into yx_trade_up_fund
  (record_id,
   up_channel_no,
   up_account_id,
   up_company_id,
   up_draw_unit,
   up_draw_face,
   up_draw_amount,
   up_real_amount,
   up_servie_fee,
   change_time,
   change_type,
   balance,
   memo)
select l_out_fund_id,
       v_out_channel_no,
       v_out_account_id,
       oc.company_id,
       0,
       0,
       v_amount,
       v_amount,
       0,
       sysdate,
       pkg_up_fund_change_type.draw_amount,
       l_out_balance-v_amount,
       v_memo
   from yx_base_up_channel oc
   where oc.channel_no=v_out_channel_no;

if (sql%rowcount = 0) then
  rollback;
  return pkg_error_code.data_error;
end if;

--===========================2.入账渠道操作=============================
--2.1 锁入账渠道账户
select ia.inner_balance
  into l_in_balance
  from yx_base_up_account ia
  where ia.account_id=v_in_account_id;

--2.2 修改入账渠道余额
update yx_base_up_account ia
   set ia.inner_balance=ia.inner_balance+v_amount
   where ia.account_id=v_in_account_id;

if (sql%rowcount = 0) then
  rollback;
  return pkg_error_code.data_error;
end if;

select seq_yxtradeupfund_auto_id.nextval into l_in_fund_id from dual;

--2.3 添加入账账户提款记录
insert into yx_trade_up_manual
  (record_id,
   channel_no,
   account_id,
   has_adjust,
   add_type,
   change_amount,
   change_time,
   balance,
   create_user,
   memo)
values
  (l_in_fund_id,
   v_in_channel_no,
   v_in_account_id,
   0,
   pkg_up_manual_change_type.add_amount,
   v_amount,
   sysdate,
   l_in_balance+v_amount,
   v_hander_user,
   v_memo);

if (sql%rowcount = 0) then
  rollback;
  return pkg_error_code.data_error;
end if;

--2.4 添加入账账户资金变动
insert into yx_trade_up_fund
  (record_id,
   up_channel_no,
   up_account_id,
   up_company_id,
   up_draw_unit,
   up_draw_face,
   up_draw_amount,
   up_real_amount,
   up_servie_fee,
   change_time,
   change_type,
   balance,
   memo)
select l_in_fund_id,
       v_in_channel_no,
       v_in_account_id,
       oc.company_id,
       0,
       0,
       v_amount,
       v_amount,
       0,
       sysdate,
       pkg_up_fund_change_type.add_amount,
       l_in_balance+v_amount,
       v_memo
   from yx_base_up_channel oc
   where oc.channel_no=v_in_channel_no;

if (sql%rowcount = 0) then
  rollback;
  return pkg_error_code.data_error;
end if;

return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_ISSUE_ADD
prompt ==========================================
prompt
create or replace function fd_account.yx_f_manual_up_issue_add(v_up_channel_no   in varchar2, ---上有渠道编号
                                                    v_up_company_id   in number, ---上游渠道公司编号
                                                    v_account_id      in number, ---上游账户编号
                                                    v_bank_account_id in number, ---实体账户编号
                                                    v_service_fee     in number, ---手续费
                                                    v_amount          in number, ---加款金额
                                                    v_create_user     in varchar2, ---创建人
                                                    v_memo            in varchar2, ---备注
                                                    v_account_name    in varchar2, ---账户名称
                                                    v_channel_name    in varchar2 ---渠道名称
                                                    )

 return varchar2 is
  ----------------------------------------------------
  --功能介绍:上游发行加款
  --创建人:周荣省
  --创建时间:2019-06-18
  ----------------------------------------------------
  l_bank_balance    number;
  l_bank_company_id number;
  l_fund_id         number;
  l_bank_batch_id   number;
  l_inner_balance   number;
begin
  --===============1.锁实体账户获取参数==========================================
  --=========[锁实体卡账户、检查实体卡余额、获取seq]=======
  ---1.1 锁实体卡账户
  select t.balance, t.company_id
    into l_bank_balance, l_bank_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---1.2 检查相关金额（银行余额需大于加款金额）
  if (l_bank_balance < v_amount + v_service_fee) then
    return pkg_error_code.balance_low;
  end if;

  ---1.3 获取资金变动主键
  ---手续费手费资金变动编号，小于人工加款的资金变动编号
  select seq_yxtradeupfund_auto_id.nextval into l_fund_id from dual;
  ---获取银行卡加款变动统一流水号(用于红冲查询)
  select seq_bank_service_id.nextval into l_bank_batch_id from dual;

  --====================2.实体卡账户=====================================
  --==[更新实体卡账户余额、添加实体卡加款的资金变动]===
  ---2.1 更新实体卡账户余额
  update fd_bank_account_info t
     set t.balance        = (l_bank_balance - v_amount - v_service_fee),
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.account_id = v_bank_account_id;

  ---2.2 添加实体卡加款资金变动
  if (v_service_fee > 0) then
    insert into fd_bank_cash_fund
      (record_id,
       account_id,
       company_id,
       change_amount,
       balance,
       change_time,
       created_user,
       change_type,
       use_type,
       link_channel_name,
       link_account_name,
       remark,
       service_id)
    values
      (seq_bank_cash_fund_id.nextval,
       v_bank_account_id,
       l_bank_company_id,
       v_service_fee,
       (l_bank_balance - v_service_fee),
       sysdate,
       v_create_user,
       pkg_bank_fund_change_type.minus_amount,
       pkg_bank_use_type.service_fee,
       v_channel_name,
       v_account_name,
       v_memo,
       l_bank_batch_id);
  end if;
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     link_channel_name,
     link_account_name,
     remark,
     service_id)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     l_bank_company_id,
     v_amount,
     (l_bank_balance - v_amount - v_service_fee),
     sysdate,
     v_create_user,
     pkg_bank_fund_change_type.minus_amount,
     pkg_bank_use_type.up_add,
     v_channel_name,
     v_account_name,
     v_memo,
     l_bank_batch_id);

  --==============3.更新渠道发行账户==================================================
  --===[锁渠道账户、更新渠道账户余额、添加上游手工加款记录、添加上游资金变动]=====

  ---3.1 锁渠道账户
  select a.issue_balance
    into l_inner_balance
    from yx_base_up_channel a
   where a.channel_no = v_up_channel_no
     for update;

  ---3.2 更新渠道账户余额
  update yx_base_up_channel t
     set t.issue_balance  = t.issue_balance + v_amount,
         t.last_edit_user = v_create_user,
         t.last_edit_time = sysdate
   where t.channel_no = v_up_channel_no;

  ---3.3 添加上游手工加款记录
  insert into yx_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo,
     bank_fund_id)
  values
    (l_fund_id,
     v_up_channel_no,
     v_account_id,
     0,
     1,
     pkg_up_manual_change_type.issue_add,
     v_amount,
     sysdate,
     l_inner_balance + v_amount,
     v_create_user,
     v_memo,
     l_bank_batch_id);

  ---3.4 添加上游资金变动
  insert into yx_trade_up_fund
    (record_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     up_servie_fee,
     change_time,
     change_type,
     balance,
     memo,
     out_change_time)
  values
    (l_fund_id,
     v_up_channel_no,
     v_account_id,
     v_up_company_id,
     0,
     0,
     v_amount,
     v_amount,
     0,
     sysdate,
     pkg_up_fund_change_type.add_issue,
     (l_inner_balance + v_amount),
     v_memo,
     sysdate);

  return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_REV_SERVICE
prompt ============================================
prompt
create or replace function fd_account.yx_f_manual_up_rev_service(v_channel_no    in    varchar2,
                                                      v_company_id    in    number,
                                                      v_business_type in    number,
                                                      v_service_fee   in    number,
                                                      v_create_user   in    varchar2,
                                                      v_memo          in    varchar2)
          return varchar2 is
          ----------------------服务费平账-------------------------
 l_service_fee   number;
 l_fund_id       number;
begin

--1. 锁渠道
 select t.service_balance
   into l_service_fee
   from yx_base_up_channel t
  where t.channel_no=v_channel_no
  for update;

--2. 修改渠道数据
update yx_base_up_channel t
   set t.service_balance=t.service_balance+v_service_fee
 where t.channel_no=v_channel_no;

 if(sql%rowcount=0) then
  return pkg_error_code.data_error;
 end if;
--3. 创建上游人工
select seq_yxtradeupfund_auto_id.nextval into l_fund_id from dual;

insert into yx_trade_up_manual
  (record_id,
   channel_no,
   account_id,
   has_adjust,
   add_type,
   change_amount,
   real_amount,
   change_time,
   balance,
   create_user,
   memo)
values
  (l_fund_id,
   v_channel_no,
   0,
   0,
   pkg_up_manual_change_type.service_revise,
   v_service_fee,
   v_service_fee,
   sysdate,
   l_service_fee+v_service_fee,
   v_create_user,
   v_memo);

 if(sql%rowcount=0) then
  return pkg_error_code.data_error;
 end if;

--4. 创建资金变动
insert into yx_trade_up_fund
  (record_id,
   up_channel_no,
   up_account_id,
   up_company_id,
   up_draw_unit,
   up_draw_face,
   up_draw_amount,
   up_real_amount,
   up_servie_fee,
   change_time,
   change_type,
   business_type,
   balance,
   memo)
values
  (l_fund_id,
   v_channel_no,
   0,
   v_company_id,
   0,
   0,
   0,
   0,
   v_service_fee,
   sysdate,
   pkg_up_fund_change_type.debit_amount,
   v_business_type,
   0,
   v_memo);

if(sql%rowcount=0) then
 return pkg_error_code.data_error;
end if;
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_REV_SERV_CK
prompt ============================================
prompt
create or replace function fd_account.yx_f_manual_up_rev_serv_ck(v_channel_no    in    varchar2,
                                                      v_service_fee   in    number,
                                                      v_company_id    out   number)
          return varchar2 is
          ----------------------服务平账检查-------------------------

begin
 --1. 金额检测
 if(v_service_fee=0)   then
  return pkg_error_code.amount_error;
 end if;

 --2. 检测渠道信息
 select t.company_id
   into v_company_id
   from yx_base_up_channel t
  where t.channel_no=v_channel_no;

  return pkg_error_code.success;
  exception
    when others then
      return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_RV_CHANNEL
prompt ===========================================
prompt
create or replace function fd_account.yx_f_manual_up_rv_channel(v_up_channel_no varchar2,
                                                     v_up_account_id number,
                                                     v_revise_type   number,
                                                     v_revise_amount number,
                                                     v_issue         in number, --发行类型，0：普通交易扣款，1：发行卡或优惠券扣款
                                                     v_create_user   varchar2,
                                                     v_memo          varchar2,
                                                     v_trade_fund_id out number)
  return varchar2 is
  -------------------------------------
  --功能：上游渠道账户平账
  --创建人：周荣省
  --创建时间：2019-07-31
  -------------------------------------
  l_inner_balance         number;
  l_up_manual_type        number;
  l_fund_type             number;
  l_balance_change_amount number;
begin
  ---1.获取渠道资金变动参数
  select seq_yxtradeupfund_auto_id.nextval into v_trade_fund_id from dual;

  if (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.balance) then
    l_up_manual_type        := pkg_up_manual_change_type.balance_revise_add;
    l_fund_type             := pkg_up_fund_change_type.add_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount < 0 and
        v_revise_type = pkg_sys_revise_type.balance) then
    l_up_manual_type        := pkg_up_manual_change_type.balance_revise_minus;
    l_fund_type             := pkg_up_fund_change_type.add_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.debit) then
    l_up_manual_type        := pkg_up_manual_change_type.debit_revise_add;
    l_fund_type             := pkg_up_fund_change_type.debit_amount;
    l_balance_change_amount := 0 - v_revise_amount;
  elsif (v_revise_amount < 0 and v_revise_type = pkg_sys_revise_type.debit) then
    l_up_manual_type        := pkg_up_manual_change_type.debit_revise_minus;
    l_fund_type             := pkg_up_fund_change_type.debit_amount;
    l_balance_change_amount := 0 - v_revise_amount;
  elsif (v_revise_amount > 0 and v_revise_type = pkg_sys_revise_type.refund) then
    l_up_manual_type        := pkg_up_manual_change_type.refund_revise_add;
    l_fund_type             := pkg_up_fund_change_type.refund_amount;
    l_balance_change_amount := v_revise_amount;
  elsif (v_revise_amount < 0 and v_revise_type = pkg_sys_revise_type.refund) then
    l_up_manual_type        := pkg_up_manual_change_type.refund_revise_minus;
    l_fund_type             := pkg_up_fund_change_type.refund_amount;
    l_balance_change_amount := v_revise_amount;
  else
    return pkg_error_code.data_error;
  end if;
  if v_issue = 0 then
    ---2.锁渠道账户
    select t.inner_balance
      into l_inner_balance
      from yx_base_up_account t
     where t.account_id = v_up_account_id
       for update;
  
    ---3.修改账户余额添加资金变动
    update yx_base_up_account t
       set t.inner_balance  = (l_inner_balance + l_balance_change_amount),
           t.last_edit_user = v_create_user,
           t.last_edit_time = sysdate
     where t.account_id = v_up_account_id;
  
    insert into yx_trade_up_manual
      (record_id,
       channel_no,
       account_id,
       adjust_id,
       add_type,
       change_amount,
       change_time,
       balance,
       memo,
       create_user,
       has_adjust)
    values
      (v_trade_fund_id,
       v_up_channel_no,
       v_up_account_id,
       0,
       l_up_manual_type,
       v_revise_amount,
       sysdate,
       (l_inner_balance + l_balance_change_amount),
       nvl2(v_memo, v_memo || ',上游平账', '上游平账'),
       v_create_user,
       0);
  
    insert into yx_trade_up_fund
      (record_id,
       up_channel_no,
       up_account_id,
       up_company_id,
       up_draw_amount,
       up_real_amount,
       change_time,
       change_type,
       balance,
       memo)
    values
      (v_trade_fund_id,
       v_up_channel_no,
       v_up_account_id,
       0,
       v_revise_amount,
       v_revise_amount,
       sysdate,
       l_fund_type,
       (l_inner_balance + l_balance_change_amount),
       v_memo);
  else
    return pkg_error_code.failure;
  end if;

  return pkg_error_code.success;

end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_RV_CHANNEL_CK
prompt ==============================================
prompt
create or replace function fd_account.yx_f_manual_up_rv_channel_ck(v_up_channel_no  varchar2,
                                                        v_up_account_id  number,
                                                        v_account_amount number)
  return varchar2 is
  ---------------------------------------
  --功能：检查手工平账渠道账户、金额是否正确
  --创建人：周荣省
  --创建时间：2019-07-31
  ---------------------------------------
  l_company_id number;
begin

  ---1.检查金额是否正确
  if (v_account_amount = 0) then
    return pkg_error_code.amount_error;
  end if;

  ---2.检查渠道账户是否正确
  select t.company_id
    into l_company_id
    from yx_base_up_channel t
   inner join yx_base_up_account a on t.account_id = a.account_id
   where t.channel_no = v_up_channel_no
     and t.account_id = v_up_account_id
     and rownum <= 2;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_or_account_error;
end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_RV_TRADE
prompt =========================================
prompt
create or replace function fd_account.yx_f_manual_up_rv_trade(v_up_channel_no in varchar2,
                                                   v_up_account_id in number,
                                                   l_up_company_id in number,
                                                   v_draw_amount   in number,
                                                   v_real_amount   in number,
                                                   v_business_type in number,
                                                   v_create_user  in varchar2,
                                                   v_memo          in varchar2)
  return varchar2 is
  l_inner_balance     number;
  l_fund_id           number;
  -------------------------上游交易平账-----------------------
begin

--========================1. 锁账户,修改账户金额===========================
if(v_draw_amount=0) then
  select a.inner_balance
    into l_inner_balance
    from yx_base_up_account a
   where a.account_id = v_up_account_id;
else
  select a.inner_balance
    into l_inner_balance
    from yx_base_up_account a
   where a.account_id = v_up_account_id
   for update;

  update yx_base_up_account t
     set t.inner_balance = t.inner_balance - v_draw_amount
   where t.account_id = v_up_account_id;

   if (sql%rowcount = 0) then
      return pkg_error_code.data_error;
  end if;
end if;

--=======================2. 创建资金变动=========================================
--2.1  获取序列号
select seq_yxtradeupfund_auto_id.nextval into l_fund_id from dual;

--2.2 创建手工资金变动
insert into yx_trade_up_manual
  (record_id,
   channel_no,
   account_id,
   has_adjust,
   add_type,
   change_amount,
   real_amount,
   change_time,
   balance,
   create_user,
   memo)
values
  (l_fund_id,
   v_up_channel_no,
   v_up_account_id,
   0,
   pkg_up_manual_change_type.trade_revise,
   v_draw_amount,
   v_real_amount,
   sysdate,
   l_inner_balance-v_draw_amount,
   v_create_user,
   v_memo);

 if(sql%rowcount=0) then
   return pkg_error_code.data_error;
 end if;

insert into yx_trade_up_fund
  (record_id,
   down_company_id,
   up_channel_no,
   up_account_id,
   up_company_id,
   up_draw_unit,
   up_draw_face,
   up_draw_amount,
   up_real_amount,
   up_servie_fee,
   change_time,
   change_type,
   business_type,
   balance,
   memo)
values
  (l_fund_id,
   l_up_company_id,
   v_up_channel_no,
   v_up_account_id,
   l_up_company_id,
   0,
   0,
   v_draw_amount,
   v_real_amount,
   0,
   sysdate,
   pkg_up_fund_change_type.debit_amount,
   v_business_type,
   l_inner_balance-v_draw_amount,
   v_memo);



 if(sql%rowcount=0) then
   return pkg_error_code.data_error;
 end if;

return pkg_error_code.success; end;
/

prompt
prompt Creating function YX_F_MANUAL_UP_RV_TRADE_CK
prompt ============================================
prompt
create or replace function fd_account.yx_f_manual_up_rv_trade_ck(v_up_channel_no  in   varchar2,
                                                      v_up_draw_amount in   number,
                                                      v_up_real_amount in   number,
                                                      v_up_account_id  out  number,
                                                      v_up_company_id  out  number)

 return varchar2 is
begin
  ---1.检查渠道账户是否正确
  select t.account_id,t.company_id
    into v_up_account_id,v_up_company_id
    from yx_base_up_channel t
   where t.channel_no = v_up_channel_no
     and rownum <= 1;

  return pkg_error_code.success;

exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function YX_F_SPLIT
prompt ============================
prompt
CREATE OR REPLACE FUNCTION FD_ACCOUNT.yx_f_Split(AS_STR   VARCHAR2,

                                          AS_SPLIT VARCHAR2)  

  RETURN t_Array IS  
  V_OUT     t_Array;  

  V_TMP     VARCHAR2(4000);  

  V_ELEMENT VARCHAR2(4000);  

BEGIN  

  V_TMP := AS_STR;  

  V_OUT := t_Array();  

  --如果存在匹配的分割符  

  WHILE INSTR(V_TMP, AS_SPLIT) > 0 LOOP  

    V_ELEMENT := SUBSTR(V_TMP, 1, INSTR(V_TMP, AS_SPLIT) - 1);  

    V_TMP     := SUBSTR(V_TMP,  

                        INSTR(V_TMP, AS_SPLIT) + LENGTH(AS_SPLIT),  

                        LENGTH(V_TMP));  

    V_OUT.EXTEND(1);  

    V_OUT(V_OUT.COUNT) := V_ELEMENT;  

  END LOOP;  

  IF V_TMP IS NOT NULL THEN  

    V_OUT.EXTEND(1);  

    V_OUT(V_OUT.COUNT) := V_TMP;  

  END IF;  

  RETURN V_OUT;  

END yx_f_Split;
/

prompt
prompt Creating function YX_F_TRADE_BUSINESS_TYPE_GET
prompt ==============================================
prompt
create or replace function fd_account.yx_f_trade_business_type_get(v_order_source  number, --外部系统编号
                                                        v_business_type number --外部类型编号
                                                        ) return varchar2 is
  ---------------------------------------------------------------------------
  --主要功能：获取外部业务类型对应的记账系统业务类型
  --创建人：周荣省
  --创建时间：2019-03-18
  ---------------------------------------------------------------------------
  l_yx_business_type number; --记账系统类型编号
begin

  select t.local_business_type
    into l_yx_business_type
    from yx_base_business_map t
   where t.outer_business_type = v_business_type
     and t.outer_system_no = v_order_source;

  return l_yx_business_type;
end;
/

prompt
prompt Creating function YX_F_TRADE_DOWN_AMOUNT_CHECK
prompt ==============================================
prompt
create or replace function fd_account.yx_f_trade_down_amount_check(v_order_source    in number, --订单来源系统编号
                                                        v_down_channel_no varchar2, --下游订单号
                                                        v_pay_amount      number, --支付金额
                                                        v_agent_id        varchar2, --代理人
                                                        v_agency_fee      number --代理费
                                                        ) return varchar2 is
  ------------------------------------------------
  --主要功能：检查下游账户余额，余额+授信>=订单金额时允许扣款，否则提示余额不足
  --创建人：周荣省
  --创建时间：2019-03-18
  -------------------------------------------------
  l_account_id       number;
begin
  
  --1、粗捡下游账户余额
  select t.account_id
    into l_account_id
    from yx_base_down_channel t
   inner join yx_base_down_account a on a.account_id = t.account_id
   where t.channel_no = v_down_channel_no
     and t.source_system_id = v_order_source
     and (a.inner_balance + a.credit_money) >= v_pay_amount
     and rownum <= 1;
  --2、检查代理费
  if ((v_agent_id is null) or (v_agent_id = '0')) then
    if (v_agency_fee > 0) then
      return pkg_error_code.amount_error;
    end if;
  end if;
  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.balance_low;
  
end;
/

prompt
prompt Creating function YX_F_TRADE_DOWN_DRAW_CHECK
prompt ============================================
prompt
create or replace function fd_account.yx_f_trade_down_draw_check(v_order_source   number, --外部系统编号
                                                      v_trade_order_no varchar2, --外部系统订单编号
                                                      v_issue_type     in number default null --发行类型，0：普通交易扣款，1：发行卡或优惠券扣款
                                                      ) return varchar2 is
  --------------------------------------------
  --主要功能：检查下游扣款
  --创建人：周荣省
  --创建时间：2019-03-18
  --------------------------------------------
  l_pay_count          number;
  l_issue_type         number;
  l_change_type_refund number;
  l_change_type_debit  number;
begin
  if v_issue_type is null then
    l_issue_type := 0;
  else
    l_issue_type := v_issue_type;
  end if;
  if l_issue_type = 1 then
    l_change_type_refund := pkg_down_fund_change_type.refund_issue;
    l_change_type_debit  := pkg_down_fund_change_type.debit_issue;
  else
    l_change_type_refund := pkg_down_fund_change_type.refund_amount;
    l_change_type_debit  := pkg_down_fund_change_type.debit_amount;
  end if;
  select count(1)
    into l_pay_count
    from yx_trade_down_fund t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and t.change_type = l_change_type_debit;
  if (l_pay_count > 0) then
    return pkg_error_code.data_repeat;
  end if;
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_TRADE_FUND_DIFFER_ADD
prompt ============================================
prompt
create or replace function fd_account.yx_f_trade_fund_differ_add(v_yx_order_id   number, --订单编号
                                                      v_trade_type    number, --交易类型（1.下游扣款2.上游扣款3.上游退款4.下游退款5.转账退款）
                                                      v_channel_no    varchar2, --渠道编号
                                                      v_account_id    number, --账户编号
                                                      v_business_type number, --业务类型                        
                                                      v_order_face    number, --订单面值
                                                      v_order_amount  number, --订单扣款金额
                                                      v_down_face     number, --下游扣款或上游中的下游扣款面值
                                                      v_down_amount   number, --下游扣款或上游中的下游扣款金额
                                                      v_income_amount number, --下游扣款或上游中的收入金额
                                                      v_up_face       number --上游扣款面值
                                                      ) return varchar2 is
  -------------------------------------------
  --主要功能：记录资金变动相关统计差异数据
  --创建人：周荣省
  --创建时间：2019-04-08
  -------------------------------------------
  l_today_date   date := trunc(sysdate); --今天
  l_differ_count number;

  l_down_first_face   number := 0; ---订单差异表中下游扣款比上游资金变动中下游扣款多的面值
  l_down_first_amount number := 0; ---同上金额
  l_down_first_income number := 0; --订单差异表中下游收入比上游资金变动中收入多的面值
  l_up_many_face      number := 0; ---资金变动差异表中记录的上游多冲的面值
  l_up_many_amount    number := 0; ---同上的金额
  l_up_many_income    number := 0; --资金变动差异表中上游多充的收入
  l_total_many_face   number; ---当天单笔订单总多冲面值
  l_total_many_amount number; ---同上金额

  l_main_differ_count number; --订单差异表中今天的数据

  l_refund_many_face number; --多充退款面值
  l_down_refund_face number; --下游退款的面值
  l_real_order_face  number; --真实订单面值
  l_all_up_face      number; --上游总扣款
  l_down_up_differ   number; --实际上游扣款比下游扣款多的值

  l_down_draw_unit     number; --下游扣款规格
  l_down_draw_face     number; --下游扣款面值
  l_down_draw_amount   number; --下游扣款金额
  l_down_real_amount   number; --下游真实扣款
  l_down_income        number; --下游扣款收入
  l_down_adjust_face   number := 0; ---资金变动差异表中，下游退款造成多冲时，需要用来抵消上游资金变动中的下游扣款面值
  l_down_adjust_unit   number := 0; ---同上的规格
  l_down_adjust_amount number := 0; ---同上的金额
  l_down_adjust_real   number := 0; ---同上的真实金额
  l_down_adjust_income number := 0; --下游退款时，需要用来抵消上游资金变动表中的下游收入值

  l_many_face_now number; ---退款红冲后多冲值
  l_many_face_red number; ---退款红冲前多冲值
begin
  --1、计算差异报表需要的数据（分为下游扣款、上游扣款、上游退款、下游退款、下游转账退款）
  if v_trade_type = pkg_trade_type.down_debit then
    --1.1下游扣款
    l_down_first_face   := v_down_face;
    l_down_first_amount := v_down_amount;
    l_down_first_income := v_income_amount;
  elsif v_trade_type = pkg_trade_type.up_debit then
    --1.2上游扣款
    l_down_first_face   := -1 * v_down_face;
    l_down_first_amount := -1 * v_down_amount;
    l_down_first_income := -1 * v_income_amount;
    l_up_many_face      := v_up_face - v_down_face;
    l_up_many_amount    := v_order_amount * l_up_many_face / v_order_face;
  elsif v_trade_type = pkg_trade_type.up_refund then
    --1.3上游退款
    l_down_first_face   := v_down_face;
    l_down_first_amount := v_down_amount;
    l_down_first_income := v_income_amount;
    --1.3.1计算当前多充的总面值
    select nvl(sum(t.up_many_face), 0), nvl(sum(t.up_many_amount), 0)
      into l_total_many_face, l_total_many_amount
      from yx_trade_up_fund_differ t
     where t.yx_order_id = v_yx_order_id;
    --1.3.2
    l_refund_many_face := v_up_face - v_down_face;
    if l_refund_many_face > l_total_many_face then
      --多充退款面值比多充扣款面值多，数据不正确
      return pkg_error_code.debit_not_exists;
    end if;
    --1.3.2多充调整数据计算
    l_up_many_face   := -1 * l_refund_many_face;
    l_up_many_amount := v_order_amount * l_up_many_face / v_order_face;
  elsif v_trade_type = pkg_trade_type.down_refund or
        v_trade_type = pkg_trade_type.transfer_refund then
    --1.4下游退款、转账退款
    --1.4.1计算扣除下游退款的实际订单面值
    select nvl(sum(t.order_face), 0)
      into l_down_refund_face
      from yx_trade_down_fund t
     where t.yx_order_id = v_yx_order_id
       and t.change_type = pkg_down_fund_change_type.refund_amount;
  
    l_real_order_face := v_order_face - l_down_refund_face;
    --1.4.2计算当前上游总扣款
    select nvl(sum(decode(t.change_type,
                          pkg_up_fund_change_type.debit_amount,
                          1,
                          -1) * t.up_draw_face),
               0)
      into l_all_up_face
      from yx_trade_up_fund t
     where t.yx_order_id = v_yx_order_id
       and t.change_type in (pkg_up_fund_change_type.debit_amount,
            pkg_up_fund_change_type.refund_amount);
    --1.4.3计算实际上游扣款比下游扣款多的值
    l_down_up_differ := l_all_up_face - l_real_order_face;
    --订单真实面值已包含本次退款
    --差>=退款   多冲 退款
    --退款>差>0  多冲 差
    --差<=0    无多冲
    if l_down_up_differ >= v_down_face then
      l_up_many_face   := v_down_face;
      l_up_many_amount := v_order_amount * l_up_many_face / v_order_face;
      l_up_many_income := v_income_amount * l_up_many_face / v_order_face;
    elsif l_down_up_differ > 0 and v_down_face > l_down_up_differ then
      l_up_many_face   := l_down_up_differ;
      l_up_many_amount := v_order_amount * l_up_many_face / v_order_face;
      l_up_many_income := v_income_amount * l_up_many_face / v_order_face;
    end if;
    --差异小于等于退款部分无多充，直接不计算
    --1.4.4有多充需要计算多充造成的差异
    if l_up_many_face > 0 then
      select t.down_draw_unit,
             t.down_draw_face,
             t.down_draw_amount,
             t.down_real_amount,
             t.income_amount
        into l_down_draw_unit,
             l_down_draw_face,
             l_down_draw_amount,
             l_down_real_amount,
             l_down_income
        from yx_trade_up_fund t
       where t.yx_order_id = v_yx_order_id
         and t.change_type = pkg_up_fund_change_type.debit_amount
         and t.down_draw_face > 0
         and rownum <= 1;
    
      l_down_adjust_face   := -1 * l_up_many_face;
      l_down_adjust_unit   := l_down_draw_unit * l_down_adjust_face /
                              l_down_draw_face;
      l_down_adjust_amount := l_down_draw_amount * l_down_adjust_face /
                              l_down_draw_face;
      l_down_adjust_real   := l_down_real_amount * l_down_adjust_face /
                              l_down_draw_face;
      l_down_adjust_income := l_down_income * l_down_adjust_face /
                              l_down_draw_face;
    end if;
    --1.4.5上下游扣款时间差异
    l_down_first_face   := l_up_many_face - v_down_face;
    l_down_first_amount := l_up_many_amount - v_down_amount;
    l_down_first_income   := l_up_many_income - v_income_amount;
  elsif v_trade_type = pkg_trade_type.refund_red then
    --1.5下游退款红冲
    --1.5.1计算扣除下游退款的实际订单面值
    select nvl(sum(t.order_face), 0)
      into l_down_refund_face
      from yx_trade_down_fund t
     where t.yx_order_id = v_yx_order_id
       and t.change_type = pkg_down_fund_change_type.refund_amount;
  
    l_real_order_face := v_order_face - l_down_refund_face;
    --1.5.2计算当前总上游扣款
    select nvl(sum(decode(t.change_type,
                          pkg_up_fund_change_type.debit_amount,
                          1,
                          -1) * t.up_draw_face),
               0)
      into l_all_up_face
      from yx_trade_up_fund t
     where t.yx_order_id = v_yx_order_id
       and t.change_type in (pkg_up_fund_change_type.debit_amount,
            pkg_up_fund_change_type.refund_amount);
    --1.5.3计算当前多充值与红冲前多充值
    l_many_face_now := l_all_up_face - l_real_order_face;
    l_many_face_red := l_all_up_face - (l_real_order_face + v_down_face);
  
    if l_many_face_now >= 0 and l_many_face_red > 0 then
      ---红冲退款的值为多冲值(负值)，对订单的上下游时间差异无影响
      l_up_many_face   := v_down_face;
      l_up_many_amount := v_order_amount * l_up_many_face / v_order_face;
    elsif l_many_face_now < 0 and l_many_face_red > 0 then
      ---红冲前的多冲值的反值为多冲值(负值)，上下游时间差异为红冲后多冲值的反值
      l_up_many_face      := -1 * l_many_face_red;
      l_up_many_amount    := v_order_amount * l_up_many_face / v_order_face;
      l_down_first_face   := -1 * l_many_face_now;
      l_down_first_amount := v_order_amount * l_down_first_face /
                             v_order_face;
      l_down_first_income := v_income_amount * l_down_first_face /
                             v_order_face;
    else
      ---无多冲，红冲退款的值的反值为上下游时间差异的值
      l_down_first_face   := -1 * v_down_face;
      l_down_first_amount := v_order_amount * l_down_first_face /
                             v_order_face;
      l_down_first_income := v_order_amount * l_down_first_face /
                             v_order_face;
    end if;
    if l_up_many_face != 0 then
      select t.down_draw_unit,
             t.down_draw_face,
             t.down_draw_amount,
             t.down_real_amount,
             t.income_amount
        into l_down_draw_unit,
             l_down_draw_face,
             l_down_draw_amount,
             l_down_real_amount,
             l_down_income
        from yx_trade_up_fund t
       where t.yx_order_id = v_yx_order_id
         and t.change_type = pkg_up_fund_change_type.debit_amount
         and t.down_draw_face > 0
         and rownum <= 1;
    
      l_down_adjust_face   := -1 * l_up_many_face;
      l_down_adjust_unit   := l_down_draw_unit * l_down_adjust_face /
                              l_down_draw_face;
      l_down_adjust_amount := l_down_draw_amount * l_down_adjust_face /
                              l_down_draw_face;
      l_down_adjust_real   := l_down_real_amount * l_down_adjust_face /
                              l_down_draw_face;
      l_down_adjust_income := l_down_income * l_down_adjust_face /
                              l_down_draw_face;
    end if;
  else
    --1.6错误数据
    return pkg_error_code.success;
  end if;
  --=============数据收集============
  if l_up_many_face != 0 then
    select count(1)
      into l_differ_count
      from yx_trade_up_fund_differ t
     where t.record_date = l_today_date
       and t.yx_order_id = v_yx_order_id
       and t.channel_no = v_channel_no
       and t.account_id = v_account_id
       and t.business_type = v_business_type;
    --3、添加差异数据
    if l_differ_count = 0 then
      insert into yx_trade_up_fund_differ
        (differ_id,
         record_date,
         yx_order_id,
         channel_no,
         account_id,
         business_type,
         down_adjust_face,
         down_adjust_unit,
         down_adjust_amount,
         down_adjust_real,
         down_adjust_income,
         up_many_face,
         up_many_amount)
      values
        (seq_yxtradeupfunddiffer_id.nextval,
         l_today_date,
         v_yx_order_id,
         v_channel_no,
         v_account_id,
         v_business_type,
         l_down_adjust_face,
         l_down_adjust_unit,
         l_down_adjust_amount,
         l_down_adjust_real,
         l_down_adjust_income,
         l_up_many_face,
         l_up_many_amount);
    else
      update yx_trade_up_fund_differ t
         set t.down_adjust_face   = t.down_adjust_face + l_down_adjust_face,
             t.down_adjust_unit   = t.down_adjust_unit + l_down_adjust_unit,
             t.down_adjust_amount = t.down_adjust_amount +
                                    l_down_adjust_amount,
             t.down_adjust_real   = t.down_adjust_real + l_down_adjust_real,
             t.down_adjust_income = t.down_adjust_income +
                                    l_down_adjust_income,
             t.up_many_face       = t.up_many_face + l_up_many_face,
             t.up_many_amount     = t.up_many_amount + l_up_many_amount
       where t.record_date = l_today_date
         and t.yx_order_id = v_yx_order_id
         and t.channel_no = v_channel_no
         and t.account_id = v_account_id
         and t.business_type = v_business_type;
    end if;
    if sql%rowcount = 0 then
      return pkg_error_code.data_error;
    end if;
  end if;
  --4、记录上下游扣款时间产生的差异(当天的数据不存在时间差异，隔天的需要插入新的数据)
  select count(1)
    into l_main_differ_count
    from yx_trade_order_main_differ t
   where t.record_date = l_today_date
     and t.yx_order_id = v_yx_order_id
     and t.channel_no = v_channel_no
     and t.account_id = v_account_id
     and t.business_type = v_business_type;
  if l_main_differ_count = 0 then
    --插入订单差异表
    insert into yx_trade_order_main_differ
      (differ_id,
       record_date,
       yx_order_id,
       channel_no,
       account_id,
       business_type,
       down_first_face,
       down_first_amount,
       down_first_income)
    values
      (seq_yxtradeordermaindiffer_id.nextval,
       l_today_date,
       v_yx_order_id,
       v_channel_no,
       v_account_id,
       v_business_type,
       l_down_first_face,
       l_down_first_amount,
       l_down_first_income);
  else
    --修改订单差异表数据
    update yx_trade_order_main_differ t
       set t.down_first_face   = (t.down_first_face + l_down_first_face),
           t.down_first_amount = (t.down_first_amount + l_down_first_amount),
           t.down_first_income = (t.down_first_income + l_down_first_income)
     where t.record_date = l_today_date
       and t.yx_order_id = v_yx_order_id
       and t.channel_no = v_channel_no
       and t.account_id = v_account_id
       and t.business_type = v_business_type;
  end if;
  if sql%rowcount = 0 then
    return pkg_error_code.data_error;
  end if;
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_TRADE_DOWN_FEE_REFUND
prompt ============================================
prompt
create or replace function fd_account.yx_f_trade_down_fee_refund(v_order_source    in number, --订单来源系统编号
                                                      v_down_channel_no in varchar2, --下游渠道编号
                                                      v_trade_order_no  in varchar2, --交易系统订单号
                                                      v_trade_refund_no varchar2, --交易系统退款编号
                                                      v_refund_unit     number, --退款单位
                                                      --v_order_amount    number, --订单金额
                                                      v_refund_face   number, --退款面值
                                                      v_refund_amount number, --退款金额（用户支付金额）
                                                      --v_real_refund     number, --真实退款
                                                      v_order_date varchar2, --订单时间
                                                      --v_agency_fee      in number, --代理费
                                                      v_handling_fee  in number, --手续费
                                                      v_refund_income in number, --退收入
                                                      v_memo          in varchar2, --备注
                                                      v_coupon_amount in number default null, --优惠券金额
                                                      v_issue_type    in number default null --发行类型，0：普通交易退款，1：发行卡或优惠券退款
                                                      ) return varchar2 is
  --------------------------------------
  --主要功能：下游订单退款
  --创建人：周荣省
  --创建时间：2019-03-19
  --------------------------------------
  l_yx_order_id         number; --记账系统订单编号
  l_order_source        number; --订单来源系统编号
  l_down_channel_no     varchar2(32); --下游渠道编号
  l_ext_order_no        varchar2(32); --交易系统下游订单号
  l_trade_order_no      varchar2(32); --交易系统订单编号
  l_down_account_id     number; --下游账号id
  l_order_face          number; --订单面值
  l_pay_amount          number; --订单扣款金额（用户支付金额）
  l_business_type       number; --业务类型
  l_refund_count        number; --退款订单数
  l_debit_count         number; --扣款数量
  l_total_refund        number; --退款金额
  l_total_refund_income number; --退款收入
  l_inner_balance       number; --账户余额
  l_down_fund_id        number; --下游资金变动id
  l_total_refund_face   number; --总退款面值
  l_total_pay_face      number; --总扣款面值
  l_total_draw_amount   number; --总扣款金额
  l_total_income        number; --总收入金额

  l_total_agence_fee number; --上游扣款添加的代理费总额
  l_agent_id         varchar2(32); --代理人编号
  l_agent_balance    number; --代理人代理费余额
  l_up_channel_no    varchar2(32); --上游渠道编号

  l_result             varchar2(32);
  l_group_agent        number; --组合代理人
  l_group_agent_id     number;
  l_number             number;
  l_coupon_amount      number;
  l_issue_type         number;
  l_change_type_refund number;
  l_change_type_debit  number;
begin
  if v_coupon_amount is null then
    l_coupon_amount := 0;
  else
    l_coupon_amount := v_coupon_amount;
  end if;
  if v_issue_type is null then
    l_issue_type := 0;
  else
    l_issue_type := v_issue_type;
  end if;
  if l_issue_type = 1 then
    l_change_type_refund := pkg_down_fund_change_type.refund_issue;
    l_change_type_debit  := pkg_down_fund_change_type.debit_issue;
  else
    l_change_type_refund := pkg_down_fund_change_type.refund_amount;
    l_change_type_debit  := pkg_down_fund_change_type.debit_amount;
  end if;

  --===============检查订单重复退款、金额错误=================
  --1、锁下游订单
  select t.yx_order_id,
         t.order_source,
         t.down_channel_no,
         t.down_account_id,
         t.ext_order_no,
         t.trade_order_no,
         t.order_face,
         t.order_amount,
         t.business_type
    into l_yx_order_id,
         l_order_source,
         l_down_channel_no,
         l_down_account_id,
         l_ext_order_no,
         l_trade_order_no,
         l_order_face,
         l_pay_amount,
         l_business_type
    from yx_trade_order_main t
   where t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and t.trade_order_no = v_trade_order_no
     and rownum <= 1
     for update;
  --2、检测订单重复退款
  select count(1)
    into l_refund_count
    from yx_trade_down_fund t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and t.refund_order_id = v_trade_refund_no
     and t.change_type = l_change_type_refund
     and rownum <= 1;
  if (l_refund_count > 0) then
    return pkg_error_code.success;
  end if;
  --2.1检查退款时是否有扣款记录
  select count(1),
         nvl(sum(t.change_face), 0),
         nvl(sum(t.change_amount), 0),
         nvl(sum(t.income_amount), 0)
    into l_debit_count,
         l_total_pay_face,
         l_total_draw_amount,
         l_total_income
    from yx_trade_down_fund t
   where t.yx_order_id = l_yx_order_id
     and t.change_type = l_change_type_debit
     and t.order_source = l_order_source
     and rownum <= 1;
  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;
  --3、获取订单已退款金额
  select nvl(sum(t.change_amount), 0),
         nvl(sum(t.change_face), 0),
         nvl(sum(t.income_amount), 0)
    into l_total_refund, l_total_refund_face, l_total_refund_income
    from yx_trade_down_fund t
   where t.yx_order_id = l_yx_order_id
     and t.change_type = l_change_type_refund
     and t.order_source = l_order_source;
  --4、检查退款金额是否超过订单总面值(扣款金额=用户支付金额-手续费-收入）
  if ((v_refund_amount - v_handling_fee - v_refund_income) >
     (l_total_draw_amount - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;
  if (v_refund_face > (l_total_pay_face - l_total_refund_face)) then
    return pkg_error_code.amount_error;
  end if;
  --=====================修改账户余额=====================
  --5、获取并修改账户余额,退款总金额为扣款金额+收入，即用户支付金额-手续费
  if l_issue_type = 0 then
    select t.inner_balance
      into l_inner_balance
      from yx_base_down_account t
     where t.account_id = l_down_account_id
       for update;
  
    update yx_base_down_account t
       set t.inner_balance = (l_inner_balance + v_refund_amount)
     where t.account_id = l_down_account_id;
  else
    select t.issue_balance
      into l_inner_balance
      from yx_base_down_channel t
     where t.channel_no = l_down_channel_no
       for update;
    update yx_base_down_channel t
       set t.issue_balance = (l_inner_balance + v_refund_amount)
     where t.channel_no = l_down_channel_no;
    l_down_account_id := 0;
  end if;
  --=================添加资金变动==================
  --6、添加下游资金变动
  select seq_yxtradedownfund_auto_id.nextval into l_down_fund_id from dual;
  insert into yx_trade_down_fund
    (record_id,
     yx_order_id,
     trade_order_no,
     ext_order_no,
     refund_order_id,
     order_source,
     down_channel_no,
     down_account_id,
     change_time,
     order_time,
     change_type,
     pay_amount,
     change_amount,
     income_amount,
     order_face,
     change_face,
     balance,
     handling_fee,
     memo,
     coupon_amount)
  values
    (l_down_fund_id,
     l_yx_order_id,
     l_trade_order_no,
     l_ext_order_no,
     v_trade_refund_no,
     l_order_source,
     l_down_channel_no,
     l_down_account_id,
     sysdate,
     to_date(v_order_date, 'yyyy-mm-dd hh24:mi:ss'),
     l_change_type_refund,
     v_refund_amount,
     (v_refund_amount - v_handling_fee - v_refund_income),
     v_refund_income,
     l_order_face,
     v_refund_face,
     (l_inner_balance + v_refund_amount),
     v_handling_fee,
     v_memo,
     v_coupon_amount);

  --==================退回代理费=================
  --7、计算上游扣款代理费总额
  select sum(t.down_agency_fee)
    into l_total_agence_fee
    from yx_trade_up_fund t
   where t.yx_order_id = l_yx_order_id
     and t.change_type = l_change_type_debit;
  if l_total_agence_fee > 0 then
    select max(t.agent_id), max(t.up_channel_no)
      into l_agent_id, l_up_channel_no
      from yx_trade_up_fund t
     where t.yx_order_id = l_yx_order_id
       and t.change_type = l_change_type_debit;
    --9、锁并修改代理费
    select t.balance
      into l_agent_balance
      from yx_base_agent t
     where t.agent_id = l_agent_id
       for update;
  
    update yx_base_agent t
       set t.balance = (l_agent_balance - l_total_agence_fee)
     where t.agent_id = l_agent_id;
    if (sql%rowcount = 0) then
      return pkg_error_code.data_error;
    end if;
    --10、添加代理人资金变动
    insert into yx_trade_agent_fund
      (record_id,
       up_fund_id,
       down_channel_no,
       up_channel_no,
       order_source,
       agent_id,
       change_amount,
       balance,
       change_type,
       change_time,
       business_type)
    values
      (seq_yxtradeagentfund_auto_id.nextval,
       l_down_fund_id,
       v_down_channel_no,
       l_up_channel_no,
       v_order_source,
       l_agent_id,
       l_total_agence_fee,
       (l_agent_balance - l_total_agence_fee),
       l_change_type_refund,
       sysdate,
       l_business_type);
  end if;

  --===========订单差异信息记录================
  l_result := yx_f_trade_fund_differ_add(l_yx_order_id,
                                         pkg_trade_type.down_refund,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         l_order_face,
                                         (v_refund_amount - v_refund_income),
                                         v_refund_face,
                                         (v_refund_amount - v_refund_income),
                                         v_refund_income,
                                         0);
  return l_result;
end;
/

prompt
prompt Creating function YX_F_TRADE_DOWN_ORDER_FEE_MUS
prompt ===============================================
prompt
create or replace function fd_account.yx_f_trade_down_order_fee_mus(v_order_source    number, --订单来源系统编号
                                                         v_down_channel_no varchar2, --下游渠道编号
                                                         v_trade_order_no  varchar2, --交易系统订单编号
                                                         v_ext_order_no    varchar2, --交易系统下游订单编号
                                                         v_order_time      varchar2, --交易系统下单时间
                                                         v_order_face      number, --订单面值
                                                         v_pay_amount      number, --订单扣款金额(用户支付金额)
                                                         v_change_amount   in number, --变动金额
                                                         v_income_amount   in number, --收入金额
                                                         --v_agency_fee      number, --代理费
                                                         v_handling_fee  number, --手续费
                                                         v_memo          varchar2, --备注
                                                         v_coupon_amount in number default null, --优惠券金额
                                                         v_issue_type    in number default null --发行类型，0：普通交易扣款，1：发行卡或优惠券扣款
                                                         ) return varchar2 is
  -----------------------------------------------
  --主要功能：处理下游扣款
  --创建人：周荣省
  --创建时间：2019-03-19
  -----------------------------------------------
  l_yx_order_id        number; --记账系统订单编号
  l_down_account_id    number; --下游渠道账户编号
  l_pay_amount         number; --订单扣款金额
  l_order_face         number; --成交面值
  l_business_type      number; --业务类型
  l_pay_count          number; --扣款数量
  l_inner_balance      number; --理论月 
  l_credit_money       number; --授信余额
  l_handling_fee       number; --手续费
  l_result             varchar2(32);
  l_coupon_amount      number := 0; --优惠券金额
  l_issue_type         number;
  l_change_type_refund number;
  l_change_type_debit  number;
begin
  if v_coupon_amount is null then
    l_coupon_amount := 0;
  else
    l_coupon_amount := v_coupon_amount;
  end if;
  if v_issue_type is null then
    l_issue_type := 0;
  else
    l_issue_type := v_issue_type;
  end if;
  if l_issue_type = 1 then
    l_change_type_refund := pkg_down_fund_change_type.refund_issue;
    l_change_type_debit  := pkg_down_fund_change_type.debit_issue;
  else
    l_change_type_refund := pkg_down_fund_change_type.refund_amount;
    l_change_type_debit  := pkg_down_fund_change_type.debit_amount;
  end if;
  --======================锁订单，检查是否重复扣款====================
  --1、锁订单，检查扣款是否存在
  select t.yx_order_id,
         t.down_account_id,
         t.order_amount,
         t.order_face,
         t.business_type,
         t.handling_fee
    into l_yx_order_id,
         l_down_account_id,
         l_pay_amount,
         l_order_face,
         l_business_type,
         l_handling_fee
    from yx_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;
  --2、检查是否存在扣款记录
  select count(1)
    into l_pay_count
    from yx_trade_down_fund t
   where t.yx_order_id = l_yx_order_id
     and t.change_type = l_change_type_debit
     and rownum <= 1;
  if (l_pay_count > 0) then
    return pkg_error_code.success;
  end if;
  --3、检查从订单查询的扣款与本次扣款是否一致
  if l_pay_amount != v_pay_amount then
    return pkg_error_code.amount_error;
  end if;
  if (l_handling_fee != v_handling_fee) then
    return pkg_error_code.amount_error;
  end if;
  --==================锁账户，检查余额并扣款==========================
  if l_issue_type = 0 then
    --4、获取下游账户信息
    select t.inner_balance, t.credit_money
      into l_inner_balance, l_credit_money
      from yx_base_down_account t
     where t.account_id = l_down_account_id
       for update;
    --5、检查账户余额，余额不足则不能扣款，扣款金额直接使用用户支付金额
    if (v_pay_amount > (l_inner_balance + l_credit_money)) then
      return pkg_error_code.balance_low;
    end if;
    --6、下游扣款（扣款金额扣除了手续费）
    update yx_base_down_account t
       set t.inner_balance = (l_inner_balance - (v_pay_amount))
     where t.account_id = l_down_account_id;
  else
    --4.1获取发行收入余额
    select t.issue_balance
      into l_inner_balance
      from yx_base_down_channel t
     where t.channel_no = v_down_channel_no
       for update;
    --5.1检查余额
    if (v_pay_amount > l_inner_balance) then
      return pkg_error_code.balance_low;
    end if;
    --6.1发行下游扣款
    update yx_base_down_channel t
       set t.issue_balance = (l_inner_balance - (v_pay_amount))
     where t.channel_no = v_down_channel_no;
    l_down_account_id := 0;
  end if;
  --7、扣款完成，添加下游资金变动
  insert into yx_trade_down_fund
    (record_id,
     yx_order_id,
     trade_order_no,
     ext_order_no,
     order_source,
     down_channel_no,
     down_account_id,
     change_time,
     order_time,
     change_type,
     pay_amount,
     change_amount, --订单金额-手续费-收入
     income_amount, --收入金额
     order_face,
     change_face,
     balance,
     handling_fee,
     memo,
     coupon_amount)
  values
    (seq_yxtradedownfund_auto_id.nextval,
     l_yx_order_id,
     v_trade_order_no,
     v_ext_order_no,
     v_order_source,
     v_down_channel_no,
     l_down_account_id,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     l_change_type_debit,
     v_pay_amount,
     v_change_amount,
     v_income_amount,
     v_order_face,
     v_order_face,
     (l_inner_balance - v_pay_amount),
     v_handling_fee,
     v_memo,
     l_coupon_amount);
  --8、扣款成功记录订单差异
  l_result := yx_f_trade_fund_differ_add(l_yx_order_id,
                                         pkg_trade_type.down_debit,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         l_order_face,
                                         v_pay_amount,
                                         l_order_face,
                                         v_pay_amount,
                                         v_income_amount,
                                         0);
  return l_result;

end;
/

prompt
prompt Creating function YX_F_TRADE_ORDER_EXIST_CHECK
prompt ==============================================
prompt
create or replace function fd_account.yx_f_trade_order_exist_check(v_order_source    number, --订单来源系统编号
                                                        v_down_channel_no varchar2, --下游渠道编号
                                                        v_trade_order_no  varchar2, --交易系统订单编号
                                                        v_yx_order_id     out number --记账系统订单编号
                                                        ) return varchar2 is
  ------------------------------------------------------------
  --主要功能：检查订单是否已经存在
  --创建人：周荣省
  --创建时间：2019-03-18
  ------------------------------------------------------------
begin
  --1、检查订单是否存在,存在则将记账系统订单号返回
  select t.yx_order_id
    into v_yx_order_id
    from yx_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and t.down_channel_no = v_down_channel_no
     and rownum <= 1;
  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.order_or_account_not_exists;
end;
/

prompt
prompt Creating function YX_F_TRADE_ORDER_CREATE
prompt =========================================
prompt
create or replace function fd_account.yx_f_trade_order_create(v_order_source        number, --订单来源系统编号
                                                   v_down_channel_no     varchar2, --下游渠道编号
                                                   v_agent_id            varchar2, --代理人编号
                                                   v_trade_order_no      varchar2, --交易系统订单编号
                                                   v_ext_order_no        varchar2, --交易系统下游订单编号
                                                   v_recharge_account_no varchar2, --充值号码
                                                   v_business_type       number, --业务类型
                                                   v_carrier_no          varchar2, --运营商
                                                   v_province_no         varchar2, --省份
                                                   v_city_no             varchar2, --市
                                                   v_total_face          number, --订单总面值
                                                   v_recharge_unit       number, --单位
                                                   v_order_amount        number, --订单扣款金额（用户支付金额）
                                                   v_change_amount       in number, --变动金额
                                                   v_income_amount       in number, --收入金额
                                                   v_agency_fee          number, --代理费
                                                   v_handling_fee        number, --三方手续费
                                                   v_order_time          varchar2, --交易系统订单时间
                                                   v_coupon_amount       in number default null, --优惠券金额
                                                   v_issue_type          in number default null --发行类型，0：普通交易扣款，1：发行卡或优惠券扣款
                                                   ) return varchar2 is
  ----------------------------------------------------
  --主要功能：检查订单是否存在，不存则创建订单
  --创建人：周荣省
  --创建时间;2019-03-18
  ----------------------------------------------------
  l_result          varchar2(32); --返回值
  l_yx_order_id     number; --记账系统订单id
  l_down_account_id number; --下游账户id
  l_down_company_id number; --公司id
  l_agent_type      number := 0; --代理人类型
  l_coupon_amount   number := 0; --优惠券金额
  l_issue_type      number;
begin
  if v_coupon_amount is null then
    l_coupon_amount := 0;
  else
    l_coupon_amount := v_coupon_amount;
  end if;
  if v_issue_type is null then
    l_issue_type := 0;
  else
    l_issue_type := v_issue_type;
  end if;
  --1、检查订单是否存在
  l_result := yx_f_trade_order_exist_check(v_order_source,
                                           v_down_channel_no,
                                           v_trade_order_no,
                                           l_yx_order_id);
  if (l_result = pkg_error_code.success) then
    return pkg_error_code.success;
  end if;
  --2、获取下游账户和公司
  select t.account_id, t.company_id
    into l_down_account_id, l_down_company_id
    from yx_base_down_channel t
   where t.channel_no = v_down_channel_no;
  if l_issue_type = 1 then
    l_down_account_id := 0;
  end if;
  --3、获取代理人类型
  if (v_agent_id > 0) then
    select t.agent_type
      into l_agent_type
      from yx_base_agent t
     where t.agent_id = v_agent_id;
  end if;
  --4、添加订单
  select seq_yxtradeordermain_auto_id.nextval into l_yx_order_id from dual;
  insert into yx_trade_order_main
    (yx_order_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     agent_id,
     agent_type,
     trade_order_no,
     ext_order_no,
     order_source,
     create_time,
     order_time,
     business_type,
     order_face,
     order_amount,
     income_amount,
     real_amount,
     agency_fee,
     handling_fee,
     success_face,
     last_edit_time,
     coupon_amount)
  values
    (l_yx_order_id,
     v_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_agent_id,
     l_agent_type,
     v_trade_order_no,
     v_ext_order_no,
     v_order_source,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_business_type,
     v_total_face,
     v_order_amount,
     v_income_amount,
     v_change_amount,
     v_agency_fee,
     v_handling_fee,
     0,
     sysdate,
     l_coupon_amount);
  return pkg_error_code.success;
exception
  when others then
    --5、订单添加失败，检查是否并发添加
    fd_p_write_log('yx_p_trade_down_order_fee_pay' || v_trade_order_no,
                   sqlerrm,
                   1);
    l_result := yx_f_trade_order_exist_check(v_order_source,
                                             v_down_channel_no,
                                             v_trade_order_no,
                                             l_yx_order_id);
    if l_result != pkg_error_code.success then
      return pkg_error_code.order_insert_fail;
    end if;
    return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_TRADE_ORDER_FACE_CHECK
prompt =============================================
prompt
create or replace function fd_account.yx_f_trade_order_face_check(v_trade_order_no  in number, --交易系统订单号
                                                       v_down_order_face in number, --下游订单面值
                                                       v_down_draw_face  in number --下游扣款面值
                                                       ) return varchar2 is
  -----------------------------------
  --主要功能：上游扣款订单面值检查
  --创建人：周荣省
  --创建时间：2019-03-19
  -----------------------------------
  l_order_face number; --订单面值
begin
  select t.order_face
    into l_order_face
    from yx_trade_order_main t
   where t.trade_order_no = v_trade_order_no;
  if ((v_down_order_face > l_order_face) or
     (v_down_draw_face > l_order_face)) then
    return pkg_error_code.order_face_too_max;
  end if;
  return pkg_error_code.success;
end;
/

prompt
prompt Creating function YX_F_TRADE_PAY_ACCOUNT_GET
prompt ============================================
prompt
create or replace function fd_account.yx_f_trade_pay_account_get(v_order_source  number, --外部系统编号
                                                      v_up_channel_no varchar2, --上游渠道编号
                                                      v_up_account_id out number --上游账户编号
                                                      ) return varchar2 is
  ----------------------------------------
  --主要功能：获取上游账户
  --创建人：周荣省
  --创建时间：2019-03-19
  ----------------------------------------
begin
  --1、获取上游渠道账户
  select t.account_id
    into v_up_account_id
    from yx_base_up_channel t
   inner join yx_base_up_account d on d.account_id = t.account_id
   where t.channel_no = v_up_channel_no
     and t.source_system_id = v_order_source
     and rownum <= 1;
  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function YX_F_TRADE_UP_ORDER_MINUS
prompt ===========================================
prompt
create or replace function fd_account.yx_f_trade_up_order_minus(v_order_source       number, --外部系统编号
                                                     v_trade_order_no     varchar2, --交易系统订单号
                                                     v_trade_delivery_no  varchar2, --交易系统发货号
                                                     v_ext_delivery_no    varchar2, --交易系统下游订单号
                                                     v_up_channel_no      varchar2, --上游渠道编号
                                                     v_up_account_id      number, --上游账户编号
                                                     v_up_draw_unit       number, --上游扣款规格
                                                     v_up_draw_face       number, --上游扣款面值
                                                     v_up_draw_amount     number, --上游扣款金额
                                                     v_up_real_amount     number, --上游实际扣款金额
                                                     v_down_draw_unit     number, --下游订单规格
                                                     v_down_draw_face     number, --下游扣款面值
                                                     v_down_draw_amount   number, --下游扣款金额(用户支付金额)
                                                     v_down_real_amount   number, --下游真实扣款金额
                                                     v_down_income_amount number, --下游收入金额
                                                     v_agent_id           varchar2, --代理人编号
                                                     v_down_handling_fee  number, --手续费
                                                     v_down_agency_fee    number, --代理费
                                                     v_up_servie_fee      number, --服务费
                                                     v_order_time         varchar2, --交易系统订单时间
                                                     v_out_change_time    varchar2, --交易系统上游扣款时间
                                                     v_carrier_no         varchar2, --运营商
                                                     v_province_no        varchar2, --省份
                                                     v_memo               varchar2, --备注
                                                     v_coupon_amount      in number default null, --优惠券金额
                                                     v_issue_type         in number default null --发行类型，0：普通交易扣款，1：发行卡或优惠券扣款
                                                     ) return varchar2 is
  ---------------------------------------------
  --主要功能：上游扣款
  --创建人：周荣省
  --创建时间：2019-03-19
  ---------------------------------------------
  l_yx_order_id       number; --记账系统订单编号
  l_down_channel_no   varchar2(32); --下游渠道编号
  l_down_account_id   number; --下游账户编号
  l_down_company_id   number; --下游所属公司编号
  l_order_face        number; --下游订单面值
  l_business_type     number; --业务类型
  l_order_amount      number; --下游订单扣款金额（用户支付金额）
  l_down_agency_fee   number; --下游代理费
  l_down_handling_fee number; --下游手续费
  l_down_income       number; --下游收入

  l_pay_count           number; --支付订单数量
  l_down_debit_now_unit number; --已经扣款的下游规格
  l_down_debit_now_face number; --已经扣款的下游面值
  l_refund_face         number; --退款面值
  l_refund_unit         number; --退款规格

  l_down_order_all_face number; --订单实际总面值
  l_down_order_all_unit number; --订单实际总规格

  l_down_draw_unit   number; --下游应扣规格
  l_down_draw_face   number; --下游应扣面值
  l_down_draw_amount number; --下游应扣金额
  l_down_real_amount number; --下游应扣真实金额

  l_query_balance number; --查询余额
  l_inner_balance number; --理论余额
  l_agent_balance number; --代理人余额

  l_up_company_id      number; --上游公司编号
  l_up_fund_id         number; --上游资金变动编号
  l_result             varchar2(32);
  l_service_balance    number; --上游渠道服务费
  l_number             number;
  l_index              number := 0;
  l_sysdate            date := sysdate;
  l_issue_type         number;
  l_change_type_refund number;
  l_change_type_debit  number;
begin
  if v_issue_type is null then
    l_issue_type := 0;
  else
    l_issue_type := v_issue_type;
  end if;
  if l_issue_type = 1 then
    l_change_type_refund := pkg_up_fund_change_type.refund_issue;
    l_change_type_debit  := pkg_up_fund_change_type.debit_issue;
  else
    l_change_type_refund := pkg_up_fund_change_type.refund_amount;
    l_change_type_debit  := pkg_up_fund_change_type.debit_amount;
  end if;
  --=====================检查订单支付情况=====================
  --1、锁支付订单
  select t.yx_order_id,
         t.down_channel_no,
         t.down_account_id,
         t.down_company_id,
         t.order_face,
         t.business_type,
         t.order_amount
    into l_yx_order_id,
         l_down_channel_no,
         l_down_account_id,
         l_down_company_id,
         l_order_face,
         l_business_type,
         l_order_amount
    from yx_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;
  --2、检查订单是否已经付款
  select count(1)
    into l_pay_count
    from yx_trade_up_fund t
   where t.trade_delivery_no = v_trade_delivery_no
     and t.yx_order_id = l_yx_order_id
     and t.order_source = v_order_source
     and t.change_type = l_change_type_debit
     and rownum <= 1;
  if (l_pay_count > 0) then
    return pkg_error_code.success;
  end if;
  --3、计算下游已经扣款的规格、订单金额
  select nvl(sum(decode(t.change_type, l_change_type_debit, 1, -1) *
                 t.down_draw_unit),
             0),
         nvl(sum(decode(t.change_type, l_change_type_debit, 1, -1) *
                 t.down_draw_face),
             0)
    into l_down_debit_now_unit, l_down_debit_now_face
    from yx_trade_up_fund t
   where t.yx_order_id = l_yx_order_id
     and t.change_type in (l_change_type_debit, l_change_type_refund);
  --4、计算出下游退款金额
  select nvl(sum(t.change_face), 0)
    into l_refund_face
    from yx_trade_down_fund t
   where t.change_type = l_change_type_refund
     and t.yx_order_id = l_yx_order_id;
  --5、计算扣款金额
  l_down_order_all_face := l_order_face - l_refund_face; --订单实际总面值
  l_down_order_all_unit := (l_down_order_all_face / l_order_face) *
                           v_down_draw_unit; --订单实际总规格
  if ((l_down_order_all_face <= l_down_debit_now_face)) then
    --已经扣完，下游不能继续扣款，处理重复充值
    l_down_draw_unit    := 0;
    l_down_draw_face    := 0;
    l_down_draw_amount  := 0;
    l_down_real_amount  := 0;
    l_down_agency_fee   := 0;
    l_down_handling_fee := 0;
    l_down_income       := 0;
  elsif ((l_down_order_all_face - l_down_debit_now_face) < v_up_draw_face) then
    --已经扣款一部分，下游继续扣除，处理多充
    l_down_draw_face    := l_down_order_all_face - l_down_debit_now_face;
    l_down_draw_unit    := (l_down_draw_face / v_down_draw_face) *
                           v_down_draw_unit;
    l_down_draw_amount  := (l_down_draw_face / v_down_draw_face) *
                           v_down_draw_amount;
    l_down_real_amount  := (l_down_draw_face / v_down_draw_face) *
                           v_down_real_amount;
    l_down_agency_fee   := (l_down_draw_face / v_down_draw_face) *
                           v_down_agency_fee;
    l_down_handling_fee := (l_down_draw_face / v_down_draw_face) *
                           v_down_handling_fee;
    l_down_income       := (l_down_draw_face / v_down_draw_face) *
                           v_down_income_amount;
  else
    --正常扣款，上下游相等
    l_down_draw_unit    := v_up_draw_unit;
    l_down_draw_face    := v_up_draw_face;
    l_down_draw_amount  := v_down_draw_amount *
                           (v_up_draw_face / v_down_draw_face);
    l_down_real_amount  := v_down_real_amount *
                           (v_up_draw_face / v_down_draw_face);
    l_down_agency_fee   := v_down_agency_fee *
                           (v_up_draw_face / v_down_draw_face);
    l_down_handling_fee := v_down_handling_fee *
                           (v_up_draw_face / v_down_draw_face);
    l_down_income       := v_down_income_amount *
                           (v_up_draw_face / v_down_draw_face);
  
  end if;
  --6、获取上游公司编号
  select t.company_id, t.service_balance, t.issue_balance
    into l_up_company_id, l_service_balance, l_inner_balance
    from yx_base_up_channel t
   where t.channel_no = v_up_channel_no
     for update;
  --6.1修改上游渠道服务费余额
  update yx_base_up_channel t
     set t.service_balance = l_service_balance + v_up_servie_fee
   where t.channel_no = v_up_channel_no;
  --6.2发行成本扣款
  if l_issue_type = 1 then
    update yx_base_up_channel t
       set t.issue_balance = (l_inner_balance - v_up_draw_amount)
     where t.channel_no = v_up_channel_no;
  end if;
  --7、锁并修改账户余额
  if l_issue_type = 0 then
    select t.query_balance, t.inner_balance
      into l_query_balance, l_inner_balance
      from yx_base_up_account t
     where t.account_id = v_up_account_id
       for update;
    update yx_base_up_account t
       set t.inner_balance = (l_inner_balance - v_up_draw_amount)
     where t.account_id = v_up_account_id;
  end if;

  if (sql%rowcount = 0) then
    return pkg_error_code.data_error;
  end if;

  --8、添加上游资金变动
  select seq_yxtradeupfund_auto_id.nextval into l_up_fund_id from dual;
  insert into yx_trade_up_fund
    (record_id,
     yx_order_id,
     trade_order_no,
     trade_delivery_no,
     ext_delivery_no,
     order_source,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     agent_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     income_amount,
     dowm_handling_fee,
     down_agency_fee,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     up_servie_fee,
     change_time,
     change_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     memo,
     order_time,
     out_change_time,
     coupon_amount)
  values
    (l_up_fund_id,
     l_yx_order_id,
     v_trade_order_no,
     v_trade_delivery_no,
     v_ext_delivery_no,
     v_order_source,
     l_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_up_channel_no,
     v_up_account_id,
     l_up_company_id,
     v_agent_id,
     l_down_draw_unit,
     l_down_draw_face,
     l_down_draw_amount,
     l_down_real_amount,
     l_down_income,
     l_down_handling_fee,
     l_down_agency_fee,
     v_up_draw_unit,
     v_up_draw_face,
     v_up_draw_amount,
     v_up_real_amount,
     v_up_servie_fee,
     l_sysdate,
     l_change_type_debit,
     l_business_type,
     v_carrier_no,
     v_province_no,
     (l_inner_balance - v_up_draw_amount),
     v_memo,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     to_date(v_out_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     v_coupon_amount);
  if (sql%rowcount = 0) then
    return pkg_error_code.data_error;
  end if;
  --9、锁并修改代理人余额
  select count(1)
    into l_number
    from yx_base_agent t
   where t.agent_id = v_agent_id;
  if l_number >= 1 then
    select t.balance
      into l_agent_balance
      from yx_base_agent t
     where t.agent_id = v_agent_id
       for update;
    update yx_base_agent t
       set t.balance = (l_agent_balance + l_down_agency_fee)
     where t.agent_id = v_agent_id;
    if (sql%rowcount = 0) then
      return pkg_error_code.data_error;
    end if;
    --10、添加代理人资金变动
    insert into yx_trade_agent_fund
      (record_id,
       up_fund_id,
       down_channel_no,
       up_channel_no,
       order_source,
       agent_id,
       change_amount,
       balance,
       change_type,
       change_time,
       business_type)
    values
      (seq_yxtradeagentfund_auto_id.nextval,
       l_up_fund_id,
       l_down_channel_no,
       v_up_channel_no,
       v_order_source,
       v_agent_id,
       l_down_agency_fee,
       (l_agent_balance + l_down_agency_fee),
       l_change_type_debit,
       sysdate,
       l_business_type);
  end if;

  --12、添加订单差异数据
  l_result := yx_f_trade_fund_differ_add(l_yx_order_id,
                                         pkg_trade_type.up_debit,
                                         l_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         l_order_face,
                                         v_up_draw_amount,
                                         l_down_draw_face,
                                         l_down_real_amount,
                                         l_down_income,
                                         v_up_draw_face);
  return l_result;
end;
/

prompt
prompt Creating function YX_F_TRADE_UP_ORDER_REFUND
prompt ============================================
prompt
create or replace function fd_account.yx_f_trade_up_order_refund(v_order_source    number, --订单来源系统编号
                                                      v_down_channel_no varchar2, --下游渠道编号
                                                      v_up_channel_no   varchar2, --上游渠道编号
                                                      --v_agent_id              varchar2, --代理人编号
                                                      v_trade_order_no        varchar2, --交易系统订单编号
                                                      v_trade_delivery_no     varchar2, --发货编号
                                                      v_ext_delivery_no       varchar2, --扩张发货编号
                                                      v_trade_refund_no       varchar2, --退款单号
                                                      v_business_type         number, --业务类型
                                                      v_carrier_no            varchar2, --运营商
                                                      v_province_no           varchar2, --省份
                                                      v_up_refund_unit        number, --上游退款规格
                                                      v_up_refund_face        number, --上游退款面值
                                                      v_up_refund_amount      number, --上游退款金额
                                                      v_up_refund_real_amount number, --上游真实退款
                                                      v_order_time            varchar2, --交易系统订单时间
                                                      v_service_fee           in number, --上游服务费
                                                      v_memo                  varchar2, --备注
                                                      v_out_change_time       varchar2, --外部上游退款发生时间（yyyy-mm-dd hh24:mi:ss）
                                                      v_coupon_amount         in number default null, --优惠券金额
                                                      v_issue_type            in number default null --发行类型，0：普通交易退款，1：发行卡或优惠券退款
                                                      ) return varchar2 is
  ---------------------------------------------------
  --主要功能：上游订单退款
  --创建人：周荣省
  --创建时间：2019-03-21
  ---------------------------------------------------
  l_yx_order_id     number; --记账系统订单编号
  l_down_account_id number; --下游账号
  l_down_company_id number; --下游所属公司
  l_order_face      number; --订单总面值
  l_order_amount    number; --扣款金额（用户支付金额）
  l_real_amount     number; --订单真实扣款金额
  l_business_type   number; --业务类型

  yx_refund_count number; --退款订单数量
  l_debit_count   number; --扣款订单数量

  l_up_draw_amount number; --上游扣款金额
  l_up_account_id  number; --上游账户编号
  l_up_company_id  number; --上游所属公司
  l_up_draw_face   number; --上游扣款面值
  l_total_refund   number; --上游退款总额
  l_up_refund_face number; --上游退款总金额

  l_down_refund_face number; --下游退款总面值

  l_up_all_face          number; --上游扣款总面值
  l_up_all_down_unit     number; --上游资金变动下游扣款总规格
  l_up_all_down_face     number; --上游资金变动下游扣款总面值
  l_up_all_down_amount   number; --上游资金变动下游扣款总金额
  l_up_all_down_real     number; --上游资金变动下游真实扣款总金额
  l_up_all_down_handling number; --上游资金变动下游手续费总金额
  l_up_all_down_agency   number; --上游资金变动下游代理费总金额
  l_up_all_service       number; --服务费总额
  l_up_all_income        number; --收入总额

  l_face_differ number; --已扣款与应扣款差

  l_up_down_face   number; --上游资金变动下游扣款面值
  l_up_down_unit   number; --上游资金变动下游扣款规格
  l_up_down_amount number; --上游资金变动下游扣款金额
  l_up_down_real   number; --上游资金变动下游真实扣款金额
  l_handling_fee   number; --手续费
  l_agency_fee     number; --代理费
  l_income_amount  number; --收入

  l_query_balance number; --查询余额
  l_inner_balance number; --理论余额
  l_up_fund_id    number; --上游资金变动编号

  l_agent_balance   number; --代理费余额
  l_result          varchar2(32);
  l_service_balance number; --上游渠道服务费
  l_agent_id        varchar2(32); --代理人编号

  l_coupon_amount      number := 0; --优惠券金额
  l_issue_type         number;
  l_change_type_refund number;
  l_change_type_debit  number;

begin
  if v_coupon_amount is null then
    l_coupon_amount := 0;
  else
    l_coupon_amount := v_coupon_amount;
  end if;
  if v_issue_type is null then
    l_issue_type := 0;
  else
    l_issue_type := v_issue_type;
  end if;
  if l_issue_type = 1 then
    l_change_type_refund := pkg_up_fund_change_type.refund_issue;
    l_change_type_debit  := pkg_up_fund_change_type.debit_issue;
  else
    l_change_type_refund := pkg_up_fund_change_type.refund_amount;
    l_change_type_debit  := pkg_up_fund_change_type.debit_amount;
  end if;
  --===========================检查订单重复退款、金额错误===================
  --1、锁下游订单
  select t.yx_order_id,
         t.down_account_id,
         t.down_company_id,
         t.order_face,
         t.order_amount,
         t.business_type,
         t.real_amount,
         t.agent_id
    into l_yx_order_id,
         l_down_account_id,
         l_down_company_id,
         l_order_face,
         l_order_amount,
         l_business_type,
         l_real_amount,
         l_agent_id
    from yx_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and rownum <= 1
     for update;
  --2、检查重复退款
  select count(1)
    into yx_refund_count
    from yx_trade_up_fund t
   where t.trade_delivery_no = v_trade_delivery_no
     and t.change_type = l_change_type_refund
     and t.refund_order_no = v_trade_refund_no
     and t.order_source = v_order_source
     and rownum <= 1;
  if (yx_refund_count > 0) then
    return pkg_error_code.success;
  end if;
  --3、检查退款时是否有扣款，没扣款不能退款
  select count(1)
    into l_debit_count
    from yx_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.change_type = l_change_type_debit
     and rownum <= 1;
  if l_debit_count = 0 then
    return pkg_error_code.debit_not_exists;
  end if;
  --4、获取上游支付扣款、已退款金额
  select t.up_draw_amount, t.up_account_id, t.up_company_id, t.up_draw_face
    into l_up_draw_amount, l_up_account_id, l_up_company_id, l_up_draw_face
    from yx_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = l_change_type_debit
     and rownum <= 1;

  select nvl(sum(t.up_draw_amount), 0), nvl(sum(t.up_draw_face), 0)
    into l_total_refund, l_up_refund_face
    from yx_trade_up_fund t
   where t.trade_order_no = v_trade_order_no
     and t.trade_delivery_no = v_trade_delivery_no
     and t.order_source = v_order_source
     and t.change_type = l_change_type_refund;
  --5、检查退款金额是否超过上游支付总金额
  if (v_up_refund_amount > (l_up_draw_amount - l_total_refund)) then
    return pkg_error_code.amount_error;
  end if;
  --6、计算上游资金变动的下游信息
  select nvl(sum(t.order_face), 0)
    into l_down_refund_face
    from yx_trade_down_fund t
   where t.yx_order_id = l_yx_order_id
     and t.change_type = l_change_type_refund;

  select nvl(sum(decode(t.change_type, l_change_type_debit, 1, -1) *
                 t.up_draw_face),
             0),
         nvl(sum(decode(t.change_type, l_change_type_debit, 1, -1) *
                 t.down_draw_unit),
             0),
         nvl(sum(decode(t.change_type, l_change_type_debit, 1, -1) *
                 t.down_draw_face),
             0),
         nvl(sum(decode(t.change_type, l_change_type_debit, 1, -1) *
                 t.down_draw_amount),
             0),
         nvl(sum(decode(t.change_type, l_change_type_debit, 1, -1) *
                 t.down_real_amount),
             0),
         nvl(sum(decode(t.change_type, l_change_type_debit, 1, -1) *
                 t.dowm_handling_fee),
             0),
         nvl(sum(decode(t.change_type, l_change_type_debit, 1, -1) *
                 t.down_agency_fee),
             0),
         nvl(sum(decode(t.change_type, l_change_type_debit, 1, -1) *
                 t.up_servie_fee),
             0),
         nvl(sum(decode(t.change_type, l_change_type_debit, 1, -1) *
                 t.income_amount),
             0)
    into l_up_all_face,
         l_up_all_down_unit,
         l_up_all_down_face,
         l_up_all_down_amount,
         l_up_all_down_real,
         l_up_all_down_handling,
         l_up_all_down_agency,
         l_up_all_service,
         l_up_all_income
    from yx_trade_up_fund t
   where t.yx_order_id = l_yx_order_id
     and t.change_type in (l_change_type_debit, l_change_type_refund);

  l_face_differ := l_up_all_face - (l_order_face - l_down_refund_face);
  if (l_face_differ >= v_up_refund_face) then
    --多充或重复充值退款
    l_up_down_face   := 0;
    l_up_down_unit   := 0;
    l_up_down_amount := 0;
    l_up_down_real   := 0;
    l_handling_fee   := 0;
    l_agency_fee     := 0;
    l_income_amount  := 0;
  elsif l_face_differ > 0 then
    --多充多退
    l_up_down_face   := v_up_refund_face - l_face_differ;
    l_up_down_unit   := l_up_all_down_unit *
                        (v_up_refund_face / l_up_all_down_face) *
                        (1 - (l_face_differ / v_up_refund_face));
    l_up_down_amount := l_up_all_down_amount *
                        (v_up_refund_face / l_up_all_down_face) *
                        (1 - (l_face_differ / v_up_refund_face));
    l_up_down_real   := l_up_all_down_real *
                        (v_up_refund_face / l_up_all_down_face) *
                        (1 - (l_face_differ / v_up_refund_face));
    l_handling_fee   := l_up_all_down_handling *
                        (v_up_refund_face / l_up_all_down_face) *
                        (1 - (l_face_differ / v_up_refund_face));
    l_agency_fee     := l_up_all_down_agency *
                        (v_up_refund_face / l_up_all_down_face) *
                        (1 - (l_face_differ / v_up_refund_face));
    l_income_amount  := l_up_all_income *
                        (v_up_refund_face / l_up_all_down_face) *
                        (1 - (l_face_differ / v_up_refund_face));
  else
    l_up_down_face   := v_up_refund_face;
    l_up_down_unit   := l_up_all_down_unit *
                        (v_up_refund_face / l_up_all_down_face);
    l_up_down_amount := l_up_all_down_amount *
                        (v_up_refund_face / l_up_all_down_face);
    l_up_down_real   := l_up_all_down_real *
                        (v_up_refund_face / l_up_all_down_face);
    l_handling_fee   := l_up_all_down_handling *
                        (v_up_refund_face / l_up_all_down_face);
    l_agency_fee     := l_up_all_down_agency *
                        (v_up_refund_face / l_up_all_down_face);
    l_income_amount  := l_up_all_income *
                        (v_up_refund_face / l_up_all_down_face);
  end if;
  --================上游退款===================
  --修改上游渠道服务费余额
  select t.service_balance, t.issue_balance
    into l_service_balance, l_inner_balance
    from yx_base_up_channel t
   where t.channel_no = v_up_channel_no
     for update;

  update yx_base_up_channel t
     set t.service_balance = l_service_balance - v_service_fee
   where t.channel_no = v_up_channel_no;
  --修改发行成本余额
  if l_issue_type = 1 then
    update yx_base_up_channel t
       set t.issue_balance = (l_inner_balance + v_up_refund_amount)
     where t.channel_no = v_up_channel_no;
  end if;
  --7、锁并修改上游账户余额
  if l_issue_type = 0 then
    select t.query_balance, t.inner_balance
      into l_query_balance, l_inner_balance
      from yx_base_up_account t
     where t.account_id = l_up_account_id
       for update;
  
    update yx_base_up_account t
       set t.inner_balance = (l_inner_balance + v_up_refund_amount)
     where t.account_id = l_up_account_id;
    if (sql%rowcount = 0) then
      return pkg_error_code.data_error;
    end if;
  end if;
  --8、添加上游资金变动
  select seq_yxtradeupfund_auto_id.nextval into l_up_fund_id from dual;
  insert into yx_trade_up_fund
    (record_id,
     yx_order_id,
     trade_order_no,
     trade_delivery_no,
     ext_delivery_no,
     refund_order_no,
     order_source,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     agent_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     dowm_handling_fee,
     down_agency_fee,
     income_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     up_servie_fee,
     change_time,
     change_type,
     business_type,
     carrier_no,
     province_no,
     balance,
     memo,
     order_time,
     out_change_time,
     coupon_amount)
  values
    (l_up_fund_id,
     l_yx_order_id,
     v_trade_order_no,
     v_trade_delivery_no,
     v_ext_delivery_no,
     v_trade_refund_no,
     v_order_source,
     v_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_up_channel_no,
     l_up_account_id,
     l_up_company_id,
     l_agent_id,
     l_up_down_unit,
     l_up_down_face,
     l_up_down_amount,
     l_up_down_real,
     l_handling_fee,
     l_agency_fee,
     l_income_amount,
     v_up_refund_unit,
     v_up_refund_face,
     v_up_refund_amount,
     v_up_refund_real_amount,
     v_service_fee,
     sysdate,
     l_change_type_refund,
     l_business_type,
     v_carrier_no,
     v_province_no,
     (l_inner_balance + v_up_refund_amount),
     v_memo,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     to_date(v_out_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     l_coupon_amount);
  if (sql%rowcount = 0) then
    return pkg_error_code.data_error;
  end if;
  /*--9、锁并修改代理费
  select t.balance
    into l_agent_balance
    from yx_base_agent t
   where t.agent_id = v_agent_id
     for update;
  update yx_base_agent t
     set t.balance = (l_agent_balance - l_agency_fee)
   where t.agent_id = v_agent_id;
  if (sql%rowcount = 0) then
    return pkg_error_code.data_error;
  end if;
  --10、添加代理人资金变动
  insert into yx_trade_agent_fund
    (record_id,
     up_fund_id,
     down_channel_no,
     up_channel_no,
     order_source,
     agent_id,
     change_amount,
     balance,
     change_type,
     change_time)
  values
    (seq_yxtradeagentfund_auto_id.nextval,
     l_up_fund_id,
     v_down_channel_no,
     v_up_channel_no,
     v_order_source,
     v_agent_id,
     l_agency_fee,
     (l_agent_balance - l_agency_fee),
     pkg_up_fund_change_type.refund_amount,
     sysdate);*/
  --11、记录差异信息
  l_result := yx_f_trade_fund_differ_add(l_yx_order_id,
                                         pkg_trade_type.up_refund,
                                         v_down_channel_no,
                                         l_down_account_id,
                                         l_business_type,
                                         l_order_face,
                                         l_real_amount,
                                         l_up_down_face,
                                         l_up_down_real,
                                         l_income_amount,
                                         v_up_refund_face);
  return l_result;
end;
/

prompt
prompt Creating function YX_F_UP_DRAW_SERVICE
prompt ======================================
prompt
create or replace function fd_account.yx_f_up_draw_service(v_channel_no          in    varchar2, --渠道编号
                                                v_bank_account_id     in    number,   --银行账户
                                                v_amount              in    number,   --服务提现金额
                                                v_channel_name        in    varchar2, --渠道名称
                                                v_account_name        in    varchar2, --账户名称
                                                v_handler_user        in    varchar2, --操作人
                                                v_memo                in    varchar2)
        return varchar2 is
    ---服务费提现
    l_bank_batch_id                 number;
    l_bank_balance                  number;
    l_bank_company_id               number;
    l_service_fee                   number;
    l_fund_id                       number;
    l_up_company_id                 number;
begin

  --======================1.锁银行账户,创建资金变动=========================
  --1.1 锁实体卡账户
select t.balance, t.company_id
  into l_bank_balance, l_bank_company_id
  from fd_bank_account_info t
 where t.account_id = v_bank_account_id
   for update;

---1.2 获取资金变动主键
---获取银行卡加款变动统一流水号
select seq_bank_service_id.nextval into l_bank_batch_id from dual;

---1.3 更新实体卡账户余额
update fd_bank_account_info t
   set t.balance        = l_bank_balance + v_amount,
       t.last_edit_user = v_handler_user,
       t.last_edit_time = sysdate
 where t.account_id = v_bank_account_id;

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

---1.4 添加实体卡扣款资金变动
insert into fd_bank_cash_fund
  (record_id,
   account_id,
   company_id,
   change_amount,
   balance,
   change_time,
   created_user,
   change_type,
   use_type,
   link_channel_name,
   link_account_name,
   remark,
   service_id)
values
  (seq_bank_cash_fund_id.nextval,
   v_bank_account_id,
   l_bank_company_id,
   v_amount,
   (l_bank_balance + v_amount),
   sysdate,
   v_handler_user,
   pkg_bank_fund_change_type.add_amount,
   pkg_bank_use_type.up_draw,
   v_channel_name,
   v_account_name,
   v_memo,
   l_bank_batch_id);

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

--=====================2. 锁渠道,创建资金变动=============================
--2.1 锁渠道
select t.service_balance, t.company_id
  into l_service_fee, l_up_company_id
  from yx_base_up_channel t
 where t.channel_no = v_channel_no
   for update;

--2.2 修改
update yx_base_up_channel t
   set t.service_balance = t.service_balance - v_amount
 where t.channel_no = v_channel_no;

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

---资金变动编号
select seq_yxtradeupfund_auto_id.nextval into l_fund_id from dual;

---2.3 添加上游服务费提现记录
insert into yx_trade_up_manual
  (record_id,
   channel_no,
   account_id,
   has_adjust,
   add_type,
   change_amount,
   change_time,
   balance,
   create_user,
   memo,
   bank_fund_id)
values
  (l_fund_id,
   v_channel_no,
   0,
   1,
   pkg_up_manual_change_type.service_draw,
   v_amount,
   sysdate,
   l_service_fee - v_amount,
   v_handler_user,
   v_memo,
   l_bank_batch_id);

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

---2.4 添加上游资金变动
insert into yx_trade_up_fund
  (record_id,
   up_channel_no,
   up_account_id,
   up_company_id,
   up_draw_unit,
   up_draw_face,
   up_draw_amount,
   up_real_amount,
   up_servie_fee,
   change_time,
   change_type,
   balance,
   memo,
   out_change_time)
values
  (l_fund_id,
   v_channel_no,
   0,
   l_up_company_id,
   0,
   0,
   v_amount,
   v_amount,
   0,
   sysdate,
   pkg_up_fund_change_type.service_draw,
   (l_service_fee - v_amount),
   v_memo,
   sysdate);

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;
return pkg_error_code.success;

end;
/

prompt
prompt Creating function YX_F_UP_DRAW_SERVICE_CHECK
prompt ============================================
prompt
create or replace function fd_account.yx_f_up_draw_service_check(v_channel_no      in varchar2,
                                                      v_bank_account_id in number,
                                                      v_amount          in number,
                                                      v_channel_name    out varchar2,
                                                      v_account_name    out varchar2)
  return varchar2 is

  ---检查渠道,银行账户,金额
  l_up_company_id number;
  l_service_fee   number;
  l_bank_count    number;
begin

  select c.company_id, c.service_balance, c.channel_name, a.account_name
    into l_up_company_id, l_service_fee, v_channel_name, v_account_name
    from yx_base_up_channel c
    left join yx_base_up_account a
      on a.account_id = c.account_id
   where c.channel_no = v_channel_no;

  select count(1)
    into l_bank_count
    from fd_bank_account_info b
   where b.account_id = v_bank_account_id
     and b.company_id = l_up_company_id;

  /*if (v_amount <= 0 or v_amount > l_service_fee) then
    return pkg_error_code.amount_error;
  end if;*/

  if (l_bank_count = 0) then
    return pkg_error_code.bank_account_id_error;
  end if;

  return pkg_error_code.success;
exception
  when others then
    return pkg_error_code.channel_error;
end;
/

prompt
prompt Creating function YX_F_UP_SERVICE_TSFER_BALANCE
prompt ===============================================
prompt
create or replace function fd_account.yx_f_up_service_tsfer_balance(v_channel_no   in  varchar2,
                                                         v_account_id   in  number,
                                                         v_amount       in  number,
                                                         v_handler_user in  varchar2,
                                                         v_memo         in  varchar2)
       return varchar2 is
       -------服务费转余额
       l_up_company_id         number;
       l_service_fee           number;
       l_inner_balance         number;
       l_channel_fund_id       number;
       l_account_fund_id       number;
begin
   --====================1.锁渠道,修改金额,创建资金变动===============
   --1.1 锁渠道
select uc.company_id, uc.service_balance
  into l_up_company_id, l_service_fee
  from yx_base_up_channel uc
 where uc.channel_no = v_channel_no
   for update;

--1.2 修改服务费
update yx_base_up_channel uc
   set uc.service_balance = uc.service_balance - v_amount
 where uc.channel_no = v_channel_no
   and uc.service_balance >= v_amount;

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

--1.3 获取账户,渠道资金变动编号
select seq_yxtradeupfund_auto_id.nextval into l_channel_fund_id from dual;
select seq_yxtradeupfund_auto_id.nextval into l_account_fund_id from dual;
--1.4 创建资金变动

insert into yx_trade_up_manual
  (record_id,
   channel_no,
   account_id,
   has_adjust,
   add_type,
   change_amount,
   change_time,
   balance,
   create_user,
   bank_fund_id,
   memo)
values
  (l_channel_fund_id,
   v_channel_no,
   0,
   1,
   pkg_up_manual_change_type.service_tsfer_balance,
   v_amount,
   sysdate,
   l_service_fee - v_amount,
   v_handler_user,
   l_account_fund_id,
   v_memo);

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

insert into yx_trade_up_fund
  (record_id,
   up_channel_no,
   up_account_id,
   up_company_id,
   up_draw_unit,
   up_draw_face,
   up_draw_amount,
   up_real_amount,
   up_servie_fee,
   change_time,
   change_type,
   balance,
   memo)
values
  (l_channel_fund_id,
   v_channel_no,
   v_account_id,
   l_up_company_id,
   0,
   0,
   v_amount,
   v_amount,
   0,
   sysdate,
   pkg_up_fund_change_type.service_tran_balance,
   l_service_fee - v_amount,
   v_memo);

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

--===================2.锁账户,修改余额,创建资金变动======================
--2.1 锁账户
select t.inner_balance
  into l_inner_balance
  from yx_base_up_account t
 where t.account_id = v_account_id
   for update;

--2.2 修改账户余额
update yx_base_up_account t
   set t.inner_balance = t.inner_balance + v_amount
 where t.account_id = v_account_id;

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

--2.3 创建资金变动


insert into yx_trade_up_manual
  (record_id,
   channel_no,
   account_id,
   has_adjust,
   add_type,
   change_amount,
   change_time,
   balance,
   create_user,
   bank_fund_id,
   memo)
values
  (l_account_fund_id,
   v_channel_no,
   v_account_id,
   1,
   pkg_up_manual_change_type.service_add_balance,
   v_amount,
   sysdate,
   l_inner_balance + v_amount,
   v_handler_user,
   l_channel_fund_id,
   v_memo);

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

insert into yx_trade_up_fund
  (record_id,
   up_channel_no,
   up_account_id,
   up_company_id,
   up_draw_unit,
   up_draw_face,
   up_draw_amount,
   up_real_amount,
   up_servie_fee,
   change_time,
   change_type,
   balance,
   memo)
values
  (l_account_fund_id,
   v_channel_no,
   v_account_id,
   l_up_company_id,
   0,
   0,
   v_amount,
   v_amount,
   0,
   sysdate,
   pkg_up_fund_change_type.add_amount,
   l_inner_balance + v_amount,
   v_memo);

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;

return pkg_error_code.success;

if (sql%rowcount = 0) then
  return pkg_error_code.data_error;
end if;
end;
/

prompt
prompt Creating function YX_F_UP_SERVICE_TSFER_CHECK
prompt =============================================
prompt
create or replace function fd_account.yx_f_up_service_tsfer_check(v_channel_no   in    varchar2,
                                                       v_amount       in    varchar2,
                                                       v_account_id   out   number)
         return varchar2 is
 ------检查渠道信息,金额
 l_service_amount        number;
begin

select t.service_balance, t.account_id
  into l_service_amount, v_account_id
  from yx_base_up_channel t
 where t.channel_no = v_channel_no;

if (v_amount <= 0 or v_amount > l_service_amount) then
  return pkg_error_code.amount_error;
end if;

return pkg_error_code.success;
exception when others then return pkg_error_code.channel_error; end;
/

prompt
prompt Creating procedure CZTH_P_AUTO_TRADE_GET
prompt ========================================
prompt
create or replace procedure fd_account.czth_p_auto_trade_get(v_collect_date in varchar2 default null) as
  ---------------充值特惠交易信息收集--------------
  l_collect_date    date := to_date(v_collect_date, 'yyyymmddhh24miss');
  l_statistics_type number;
begin
  ---1.设置获取日期
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---2.获取充值特惠上游交易信息
  for item in (select o.company_id,
                      o.order_source,
                      o.down_channel_no,
                      o.down_account_id,
                      o.up_channel_no,
                      o.up_account_id,
                      o.bill_type,
                      o.business_type,
                      o.service_rate,
                      sum(decode(o.change_type, 2, 1, 0) * o.draw_unit) draw_unit,
                      sum(decode(o.change_type, 2, 1, 0) * o.draw_face) draw_face,
                      sum(decode(o.change_type, 2, 1, 0) * o.draw_amount) draw_amount,
                      sum(decode(o.change_type, 2, 1, 0) * o.subsidy) subsidy,
                      sum(decode(o.change_type, 2, 0, 1) * o.draw_unit) refund_unit,
                      sum(decode(o.change_type, 2, 0, 1) * o.draw_face) refund_face,
                      sum(decode(o.change_type, 2, 0, 1) * o.draw_amount) refund_amount,
                      sum(decode(o.change_type, 2, 0, 1) * o.subsidy) refund_subsidy
                 from czth_trade_order o
                where o.change_time >= l_collect_date
                  and o.change_time < (l_collect_date + 1)
                  and o.change_type in (2, 3)
                group by o.company_id,
                         o.order_source,
                         o.down_channel_no,
                         o.down_account_id,
                         o.up_channel_no,
                         o.up_account_id,
                         o.bill_type,
                         o.business_type,
                         o.service_rate) loop
    begin
    
      ---3.获取业务类型的财务分类
      select t.statistics_type
        into l_statistics_type
        from fd_system_business_statis_map t
       where t.local_business_type = item.business_type;
    
      ---4.添加交易数据
      insert into czth_trade_report
        (record_id,
         snap_time,
         source_system,
         down_company_id,
         down_channel_no,
         down_account_id,
         up_company_id,
         up_channel_no,
         up_account_id,
         statistics_type,
         business_type,
         bill_type,
         service_rate,
         total_unit,
         total_face,
         total_draw_amount,
         refund_unit,
         refund_face,
         refund_draw_amount,
         total_subsidy,
         refund_subsidy)
      values
        (seq_czth_trade_reportrecord_id.nextval,
         l_collect_date,
         item.order_source,
         item.company_id,
         item.down_channel_no,
         item.down_account_id,
         item.company_id,
         item.up_channel_no,
         item.up_account_id,
         l_statistics_type,
         item.business_type,
         item.bill_type,
         item.service_rate,
         item.draw_unit,
         item.draw_face,
         item.draw_amount,
         item.refund_unit,
         item.refund_face,
         item.refund_amount,
         item.subsidy,
         item.refund_subsidy);
    
    end;
  end loop;

  commit;

exception
  when others then
    rollback;
    fd_p_write_log('czth_p_auto_up_trade_get', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure CZTH_P_TRADE_DRAW
prompt ====================================
prompt
create or replace procedure fd_account.czth_p_trade_draw(v_order_source        in number, ---订单来源系统编号
                                              v_down_channel_no     in varchar2, ---下游渠道编号
                                              v_up_channel_no       in varchar2, ---上游渠道编号
                                              v_trade_order_no      in varchar2, ---生成系统交易订单号
                                              v_trade_delivery_no   in varchar2, ---生成系统发货订单号
                                              v_ext_order_no        in varchar2, ---外部系统订单号
                                              v_recharge_account_no in varchar2, ---充值号码
                                              v_business_type       in number, ---业务类型
                                              v_bill_type           in number, ---前后项信息
                                              v_carrier_no          in varchar2, ---运营商信息
                                              v_province_no         in varchar2, ---省份编号
                                              v_city_no             in varchar2, ---城市编号
                                              v_draw_unit           in number, ---上游扣款规格
                                              v_draw_face           in number, ---上游扣款面值
                                              v_draw_amount         in number, ---上游扣款金额
                                              v_service_rate        in number, ---上游服务费率
                                              v_subsidy             in number, ---上游补贴金额
                                              v_order_time          in varchar2, --外部订单生成时间（yyyy-mm-dd hh24:mi:ss）
                                              v_out_change_time     in varchar2, --上游资金变动时间（yyyy-mm-dd hh24:mi:ss）
                                              v_memo                in varchar2, ---备注信息
                                              v_result              out varchar2) as
  ---------------充值特惠扣款------------
  l_fd_business_type number;
  l_up_account_id    number;
begin
  ---1.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---2.充值特惠扣款参数检查
  v_result := czth_f_trade_info_check(v_order_source,
                                      v_trade_order_no,
                                      v_down_channel_no,
                                      v_up_channel_no,
                                      (v_draw_amount-v_subsidy),
                                      l_up_account_id);
  if v_result != pkg_error_code.success then
    if (v_result = pkg_error_code.data_repeat) then
      v_result := pkg_error_code.success;
    end if;
  
    rollback;
    return;
  end if;

  ---3.历史库获取订单
  v_result := czth_f_trade_hs_move(v_order_source,
                                   v_trade_order_no,
                                   v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---4.检查订单是否存在，不存在则创建订单
  v_result := fd_f_trade_order_create_ii(v_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_ext_order_no,
                                         v_recharge_account_no,
                                         l_fd_business_type,
                                         v_carrier_no,
                                         v_province_no,
                                         v_city_no,
                                         v_draw_face,
                                         v_draw_unit,
                                         (v_draw_amount-v_subsidy),
                                         v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---5.下游扣款
  v_result := fd_f_trade_down_order_fee_mus(v_order_source,
                                            v_down_channel_no,
                                            v_trade_order_no,
                                            v_ext_order_no,
                                            v_order_time,
                                            (v_draw_amount - v_subsidy),
                                            0,
                                            v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---6.上游扣款
  v_result := fd_f_trade_up_order_minus2(v_order_source,
                                         v_trade_order_no,
                                         v_trade_delivery_no,
                                         v_up_channel_no,
                                         l_up_account_id,
                                         v_draw_unit,
                                         v_draw_face,
                                         v_draw_amount,
                                         v_draw_amount,
                                         v_draw_unit,
                                         v_draw_face,
                                         (v_draw_amount-v_subsidy),
                                         (v_draw_amount-v_subsidy),
                                         v_bill_type,
                                         v_order_time,
                                         0,
                                         v_memo,
                                         v_out_change_time);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---7.添加充值特惠记录
  v_result := czth_f_trade_order_add(v_trade_order_no,
                                     v_trade_delivery_no,
                                     v_order_source,
                                     v_up_channel_no,
                                     l_up_account_id,
                                     v_draw_unit,
                                     v_draw_face,
                                     v_draw_amount,
                                     v_service_rate,
                                     v_subsidy,
                                     pkg_up_fund_change_type.debit_amount,
                                     v_bill_type,
                                     v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('czth_p_trade_draw', sqlerrm, 1);
  
end;
/

prompt
prompt Creating procedure DK_P_ADJUST_DOWN_MANUAL_SETTLE
prompt =================================================
prompt
create or replace procedure fd_account.dk_p_adjust_down_manual_settle(v_record_id   in number, ---红冲的结算编号
                                                           v_create_user in varchar2, ---操作人
                                                           v_adjust_days in number, ---红冲天数
                                                           v_memo        in varchar2, ---备注
                                                           v_result      out varchar2) as
  --------------代扣业务:下游结算红冲----------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游结算红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---2. 检查加款记录、账户、余额、手续费
  v_result := dk_f_adjust_down_settle_check(v_record_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3. 红冲下游手工加款记录
  v_result := dk_f_adjust_down_settle_handle(v_record_id,
                                             v_create_user,
                                             v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_adjust_down_manual_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_ADJUST_UP_MANUAL_SETTLE
prompt ===============================================
prompt
create or replace procedure fd_account.dk_p_adjust_up_manual_settle(v_record_id   in number, ---红冲的结算编号
                                                      v_create_user in varchar2, ---操作人
                                                      v_adjust_days in number, ---红冲天数
                                                      v_memo        in varchar2, ---备注
                                                      v_result      out varchar2) as
  --------------代扣业务:上游结算红冲----------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('上游结算红冲',
                        v_create_user,
                        'record_id=' || v_record_id);

  ---2. 检查加款记录、账户、余额、手续费
  v_result := dk_f_adjust_up_settle_check(v_record_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3. 红冲上游手工加款记录
  v_result := dk_f_adjust_up_settle_handle(v_record_id, v_create_user, v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_adjust_up_manual_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_AUTO_BALANCE_WARN_DOWN
prompt ==============================================
prompt
create or replace procedure fd_account.dk_p_auto_balance_warn_down as
  -----------------------下游渠道余额报警--------------------------
  l_warn_balance  number;
  l_warn_type     number;
  l_inner_balance number;

  l_date_now  number := to_number(to_char(sysdate, 'dd')); ---当前日期是几号
  l_date_last number := to_number(to_char(last_day(sysdate), 'dd')); ---本月最后一天是几号
begin

  ---1.下游渠道告警检查
  for item in (select d.channel_no, d.channel_name
                 from dk_base_down_channel d
                where d.status = pkg_sys_boolean.istrue
                  and d.warn_balance > 0) loop
    begin

      ---2.获取告警配置
      select t.warn_balance, t.warn_type
        into l_warn_balance, l_warn_type
        from dk_base_down_channel t
       where t.channel_no = item.channel_no;

      ---3.月初月末报警额翻倍
      if l_date_now > 4 and l_date_now < l_date_last then
        l_warn_balance := l_warn_balance;
      else
        l_warn_balance := 2 * l_warn_balance;
      end if;

      ---4.单独支付账户报警
      if l_warn_type = pkg_balance_warn_type.single_warn then
        insert into fd_system_warn
          (warn_id,
           uniq_id,
           warn_level,
           warn_type,
           title,
           warn_date,
           content,
           sync_status,
           key_word)
          select seq_system_warn_id.nextval,
                 'CHAC' || t.account_id,
                 5,
                 pkg_warn_into_type.balance_warn,
                 '收卡或SP下游渠道:' || item.channel_name || ' 余额过低.',
                 sysdate,
                 '收卡或SP下游渠道:' || item.channel_name || ' 余额过低.剩余余额:' ||
                 t.inner_balance || ',预警余额:' || l_warn_balance || ',支付账户:' ||
                 t.account_name,
                 pkg_balance_sync_status.wait,
                 '下游渠道余额不足'
            from dk_base_down_account t
           inner join dk_base_down_account_map m on t.account_id =
                                                    m.account_id
           where m.channel_no = item.channel_no
             and t.inner_balance < l_warn_balance
             and t.status = pkg_sys_boolean.istrue;
      end if;

      ---5.合并支付账户报警
      if l_warn_type = pkg_balance_warn_type.all_warn then
        select sum(t.inner_balance)
          into l_inner_balance
          from dk_base_down_account t
         inner join dk_base_down_account_map m on t.account_id =
                                                  m.account_id
         where m.channel_no = item.channel_no
           and t.status = pkg_sys_boolean.istrue;

        if l_warn_balance > l_inner_balance then
          insert into fd_system_warn
            (warn_id,
             uniq_id,
             warn_level,
             warn_type,
             title,
             warn_date,
             content,
             sync_status,
             key_word)
          values
            (seq_system_warn_id.nextval,
             'CH' || item.channel_no,
             5,
             pkg_warn_into_type.balance_warn,
             '收卡或SP下游渠道:' || item.channel_name || ' 余额过低.',
             sysdate,
             '收卡或SP下游渠道:' || item.channel_name || ' 余额过低.剩余余额:' ||
             l_inner_balance || ',预警余额:' || l_warn_balance,
             pkg_balance_sync_status.wait,
             '下游渠道余额不足');
        end if;

      end if;

      commit;

    exception
      when others then
        rollback;
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('dk_p_auto_balance_warn_down', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_AUTO_BALANCE_WARN_UP
prompt ============================================
prompt
create or replace procedure fd_account.dk_p_auto_balance_warn_up as
  -----------------------上游渠道余额报警--------------------------
  l_warn_balance  number;
  l_warn_type     number;
  l_inner_balance number;
begin
  ---1.上游渠道告警检查
  for item in (select c.channel_no, c.channel_name
                 from dk_base_up_channel c
                where c.status = pkg_sys_boolean.istrue
                  and c.warn_balance > 0) loop
    begin
      ---2.获取告警配置
      select t.warn_balance, t.warn_type
        into l_warn_balance, l_warn_type
        from dk_base_up_channel t
       where t.channel_no = item.channel_no
         and t.warn_balance > pkg_sys_boolean.istrue;
    
      ---3.单独支付账户报警
      if l_warn_type = pkg_balance_warn_type.single_warn then
        insert into fd_system_warn
          (warn_id,
           uniq_id,
           warn_level,
           warn_type,
           title,
           warn_date,
           content,
           sync_status,
           key_word)
          select seq_system_warn_id.nextval,
                 'CHAC' || t.account_id,
                 5,
                 pkg_warn_into_type.balance_warn,
                 '收卡或SP上游渠道:' || item.channel_name || ' 余额过低.',
                 sysdate,
                 '收卡或SP上游渠道:' || item.channel_name || ' 余额过低.剩余余额:' ||
                 t.inner_balance || ',预警余额:' || l_warn_balance || ',支付账户:' ||
                 t.account_name,
                 pkg_balance_sync_status.wait,
                 '上游渠道余额不足'
            from dk_base_up_account t
           inner join dk_base_up_account_map m on t.account_id =
                                                  m.account_id
           where m.channel_no = item.channel_no
             and t.inner_balance < l_warn_balance
             and t.status = pkg_sys_boolean.istrue;
      end if;
    
      ---4.合并支付账户报警
      if l_warn_type = pkg_balance_warn_type.all_warn then
        select sum(t.inner_balance)
          into l_inner_balance
          from dk_base_up_account t
         inner join dk_base_up_account_map m on t.account_id = m.account_id
         where m.channel_no = item.channel_no
           and t.status = pkg_sys_boolean.istrue;
      
        if l_warn_balance > l_inner_balance then
          insert into fd_system_warn
            (warn_id,
             uniq_id,
             warn_level,
             warn_type,
             title,
             warn_date,
             content,
             sync_status,
             key_word)
          values
            (seq_system_warn_id.nextval,
             'CH' || item.channel_no,
             5,
             pkg_warn_into_type.balance_warn,
             '收卡或SP上游渠道:' || item.channel_name || ' 余额过低.',
             sysdate,
             '收卡或SP上游渠道:' || item.channel_name || ' 余额过低.剩余余额:' ||
             l_inner_balance || ',预警余额:' || l_warn_balance,
             pkg_balance_sync_status.wait,
             '上游渠道余额不足');
        end if;
      
      end if;
    
      commit;
    exception
      when others then
        rollback;
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('dk_p_auto_balance_warn_up', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_AUTO_COMMI_PROFIT_ADD
prompt =============================================
prompt
create or replace procedure fd_account.dk_p_auto_commi_profit_add(v_add_date in varchar2 default null) as
  -----------------------利润账户加款-------------------------
  l_record_id      number;
  l_add_date       date := to_date(v_add_date, 'yyyymmddhh24miss');
  l_profit_balance number;
  l_cap_account_id number;
  l_profit_amount  number;
  l_commi_amount   number;
  l_commi_balance  number;
begin

  if l_add_date is null then
    l_add_date := trunc(sysdate) - 1;
  end if;

  for item in (select d.record_id,
                      d.company_id,
                      d.channel_no,
                      d.channel_type,
                      d.commission,
                      d.profits,
                      d.refund_commission,
                      d.refund_profits,
                      d.sys_cost
                 from dk_report_commi_profit_daily d
                where d.add_status = pkg_commi_profit_add_status.wait
                  and d.snap_time >= l_add_date
                  and d.snap_time < l_add_date + 1) loop
    begin
      ---1.修改数据状态(正在)
      select t.record_id
        into l_record_id
        from dk_report_commi_profit_daily t
       where t.record_id = item.record_id
         and t.add_status = pkg_commi_profit_add_status.wait
         for update;
    
      ---2.佣金账户加款
      l_commi_amount := item.commission - item.refund_commission;
      if (item.channel_type = pkg_channel_type.down_channel and
         l_commi_amount != 0) then
        select t.commi_balance
          into l_commi_balance
          from dk_base_down_channel t
         where t.channel_no = item.channel_no
           for update;
      
        update dk_base_down_channel t
           set t.commi_balance = (l_commi_balance + l_commi_amount)
         where t.channel_no = item.channel_no;
      elsif (item.channel_type = pkg_channel_type.up_channel and
            l_commi_amount != 0) then
        select t.commi_balance
          into l_commi_balance
          from dk_base_up_channel t
         where t.channel_no = item.channel_no
           for update;
      
        update dk_base_up_channel t
           set t.commi_balance = (l_commi_balance + l_commi_amount)
         where t.channel_no = item.channel_no;
      end if;
    
      ---3.添加佣金加款记录
      if (sql%rowcount > 0 and l_commi_amount != 0) then
        insert into dk_trade_commission_settle
          (report_id,
           channel_no,
           channel_type,
           commission,
           settle_month,
           settle_status,
           settle_user,
           settle_time,
           has_adjust,
           adjust_id,
           bank_batch_id,
           settle_type,
           commi_balance,
           memo)
        values
          (seq_trade_commission_settle_id.nextval,
           item.channel_no,
           item.channel_type,
           l_commi_amount,
           trunc(sysdate, 'mm'),
           0,
           'sys',
           sysdate,
           pkg_sys_boolean.isfalse,
           0,
           0,
           pkg_commi_settle_type.add_commi,
           (l_commi_balance + l_commi_amount),
           '-');
      end if;
    
      ---4.利润账户加款
      l_profit_amount := item.profits - item.refund_profits - item.sys_cost;
      if (sql%rowcount > 0 and l_profit_amount != 0) then
        select t.balance, t.account_id
          into l_profit_balance, l_cap_account_id
          from fd_base_company_account_cap t
         where t.company_id = item.company_id
           and t.account_type = pkg_co_cap_account_type.profit
           for update;
      
        update fd_base_company_account_cap t
           set t.balance = (l_profit_balance + l_profit_amount)
         where t.company_id = item.company_id
           and t.account_type = pkg_co_cap_account_type.profit;
      
        insert into fd_trade_co_cap_fund
          (change_id,
           account_id,
           change_amount,
           change_type,
           balance,
           change_time,
           adjust_id,
           has_adjust,
           bank_batch_id,
           memo,
           record_no,
           create_user)
        values
          (seq_trade_co_cap_fund_id.nextval,
           l_cap_account_id,
           l_profit_amount,
           pkg_co_cap_fund_type.add_amount,
           (l_profit_balance + l_profit_amount),
           sysdate,
           0,
           pkg_sys_boolean.isfalse,
           0,
           '-',
           0,
           'sys');
      end if;
    
      if sql%rowcount > 0 then
        ---5.修改数据状态(完成)
        update dk_report_commi_profit_daily t
           set t.add_status = pkg_commi_profit_add_status.complate
         where t.record_id = item.record_id;
      end if;
    
      if sql%rowcount > 0 then
        commit;
      else
        rollback;
      end if;
    
    exception
      when others then
        rollback;
        fd_p_write_log('dk_p_auto_commi_profit_add', sqlerrm, 1);
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('dk_p_auto_commi_profit_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_PROC_LOG
prompt ================================
prompt
create or replace procedure fd_account.fd_p_proc_log(p_proc_name  in varchar2,
                                          p_start_time in date,
                                          p_status     in varchar2,
                                          p_user_mark  in varchar2) is
  pragma autonomous_transaction; --自治事务
  v_error_code  varchar2(20) := sqlcode;
  v_error_desc  varchar2(200) := SUBSTR(SQLERRM, 1, 160);
  v_error_trace varchar2(200) := substrb(nvl(dbms_utility.format_error_backtrace,
                                             dbms_utility.format_call_stack),
                                         0,
                                         160);

begin
  insert into TBL_PROC_LOG
    (proc_name,
     log_time,
     start_time,
     status,
     user_mark,
     err_code,
     err_desc,
     err_trace)
  values
    (p_proc_name,
     sysdate,
     p_start_time,
     p_status,
     substr(p_user_mark, 1, 199),
     v_error_code,
     v_error_desc,
     v_error_trace);
  commit;
exception
  when others then
    rollback;
end fd_p_proc_log;
/

prompt
prompt Creating procedure DK_P_AUTO_COMMI_PROFIT_DOWN
prompt ==============================================
prompt
create or replace procedure fd_account.dk_p_auto_commi_profit_down(v_collect_date in varchar2 default null) as
  --------------------收集下游资金变动佣金利润信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160721000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type number := 0; --数据出现错误，统计类型为0
  l_wait_count      number := 0;
  l_start_time      date := sysdate;
  l_channel_name    varchar2(100);
  l_account_name    varchar2(100);
  l_channel_system  number;
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from dk_trade_up_fund t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then
  
    ---1.收集上游资金变动信息
    ---1.收集上游资金变动信息
    for item in (select m.down_company_id,
                        m.down_channel_no,
                        m.down_account_id,
                        m.business_type,
                        m.bill_type,
                        m.order_source,
                        m.down_draw_unit,
                        m.down_draw_face,
                        m.down_draw_amount,
                        m.down_real_amount,
                        m.settle_amount,
                        m.down_draw_unit_ref,
                        m.down_draw_face_ref,
                        m.down_draw_amount_ref,
                        m.down_real_amount_ref,
                        m.settle_amount_ref,
                        0 up_many_face,
                        0 up_many_amount,
                        f.sys_paid_money
                   from (select u.down_company_id,
                                u.down_channel_no,
                                u.down_account_id,
                                u.business_type,
                                u.bill_type,
                                max(u.order_source) order_source,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_unit) down_draw_unit,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_face) down_draw_face,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_amount) down_draw_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_real_amount) down_real_amount, -------- 扣款中：下游实际扣款
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           decode(u.down_company_id,
                                                  u.up_company_id,
                                                  u.up_real_amount,
                                                  decode(u.settle_amount,
                                                         0,
                                                         u.up_real_amount,
                                                         u.settle_amount)),
                                           0)) settle_amount, ------------- 扣款中：上游实际扣款
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_unit) down_draw_unit_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_face) down_draw_face_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_amount) down_draw_amount_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_real_amount) down_real_amount_ref, ---- 退款中：下游实际扣款
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           decode(u.down_company_id,
                                                  u.up_company_id,
                                                  u.up_real_amount,
                                                  decode(u.settle_amount,
                                                         0,
                                                         u.up_real_amount,
                                                         u.settle_amount)))) settle_amount_ref ---- 退款中：上游实际扣款
                         
                           from dk_trade_up_fund u
                          where u.change_time >= l_collect_date
                            and u.change_time < (l_collect_date + 1)
                            and (u.change_type =
                                pkg_up_fund_change_type.debit_amount or
                                u.change_type =
                                pkg_up_fund_change_type.refund_amount)
                          group by u.down_company_id,
                                   u.down_channel_no,
                                   u.down_account_id,
                                   u.business_type,
                                   u.bill_type) m
                   left join (select d.channel_no,
                                    d.account_id,
                                    d.business_type,
                                    d.bill_type,
                                    sum(d.sys_cost) sys_paid_money
                               from dk_trade_refund_sys_cost d
                              where trunc(d.record_date, 'dd') =
                                    l_collect_date
                              group by d.channel_no,
                                       d.account_id,
                                       d.business_type,
                                       d.bill_type) f on m.down_channel_no =
                                                         f.channel_no
                                                     and m.down_account_id =
                                                         f.account_id
                                                     and m.business_type =
                                                         f.business_type
                                                     and m.bill_type =
                                                         f.bill_type) loop
      begin
        ---2.添加下游佣金利润数据
        if item.down_channel_no != '0' and item.down_account_id != 0 then
        
          --***从业务类型与分类表中获取分类***
          select t.statistics_type
            into l_statistics_type
            from fd_system_business_statis_map t
           where t.local_business_type = item.business_type
             and rownum <= 1;
        
          ---3.获取渠道账户名称
          select t.channel_name
            into l_channel_name
            from dk_base_down_channel t
           where t.channel_no = item.down_channel_no;
        
          select t.account_name
            into l_account_name
            from dk_base_down_account t
           where t.account_id = item.down_account_id;
        
          --4.获取渠道系统编号，包括平账
          l_channel_system := item.order_source;
          if l_channel_system = 0 then
          
            select max(t.source_system_id)
              into l_channel_system
              from dk_base_down_system_map t
             where t.channel_no = item.down_channel_no;
          end if;
        
          --5.添加数据
          insert into dk_report_commi_profit_daily
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_unit,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits, -- 13
             service_fee,
             refund_total_unit,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             refund_profits,
             refund_service_fee,
             snap_time,
             statistics_type,
             sys_cost,
             channel_name,
             account_name,
             channel_source_system)
          values
            (seq_report_commi_profit_id.nextval,
             item.down_company_id,
             item.down_channel_no,
             item.down_account_id,
             pkg_channel_type.down_channel,
             item.business_type,
             item.bill_type,
             item.down_draw_unit,
             item.down_draw_face,
             item.down_draw_amount,
             item.down_real_amount,
             (trunc(item.down_draw_amount, 2) -
             trunc(item.down_real_amount, 2)),
             (item.settle_amount - item.down_real_amount), -- 13  ---->>>>>>>>>>>>(这里利润可能为负) 利润 = 上游的结算金额-下游的结算金额 （扣款时记的正,因此反过来减）
             0,
             item.down_draw_unit_ref,
             item.down_draw_face_ref,
             item.down_draw_amount_ref,
             item.down_real_amount_ref,
             (trunc(item.down_draw_amount_ref, 2) -
             trunc(item.down_real_amount_ref, 2)),
             (item.settle_amount_ref - item.down_real_amount_ref), ------>>>>>> 利润退回 = 上游退款 - 下游退款(事实上,不算利润退回)
             0,
             l_collect_date,
             l_statistics_type,
             item.sys_paid_money,
             l_channel_name,
             l_account_name,
             l_channel_system);
        end if;
      
        commit;
      
      exception
        when others then
          rollback;
          fd_p_write_log('dk_p_auto_commi_profit_down', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');
  
    commit;
  end if;
  fd_p_proc_log('dk_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('dk_p_auto_commi_profit_down', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_AUTO_COMMI_PROFIT_UP
prompt ============================================
prompt
create or replace procedure fd_account.dk_p_auto_commi_profit_up(v_collect_date in varchar2 default null) as
  --------------------收集上游资金变动佣金利润信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160721000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type number := 0; --数据出现错误，统计类型为0
  l_wait_count      number := 0;
  l_start_time      date := sysdate;
  l_channel_name    varchar2(100);
  l_account_name    varchar2(100);
  l_channel_system  number;
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from dk_trade_up_fund t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then
  
    ---1.收集上游资金变动信息
    for item in (select u.up_company_id,
                        u.up_channel_no,
                        u.up_account_id,
                        u.business_type,
                        u.bill_type,
                        max(u.order_source) order_source,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.down_draw_unit) up_draw_unit, ---》保证上下游面值规格报表一致，取下游的值
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.down_draw_face) up_draw_face, ---》保证上下游面值规格报表一致，取下游的值
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_amount) up_draw_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_real_amount) up_real_amount, --- 上游实际扣款金额
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.down_company_id,
                                          u.up_company_id,
                                          decode(u.down_channel_no,
                                                 '0',
                                                 0,
                                                 u.up_real_amount),
                                          decode(u.settle_amount,
                                                 0,
                                                 u.up_real_amount,
                                                 u.settle_amount)),
                                   0)) settle_amount, ----- 下游实际扣款金额
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.down_draw_unit) up_draw_unit_ref, ---》保证上下游面值规格报表一致，取下游的值
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.down_draw_face) up_draw_face_ref, ---》保证上下游面值规格报表一致，取下游的值
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_amount) up_draw_amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_real_amount) up_real_amount_ref, --- 上游实际退款金额
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.down_company_id,
                                          u.up_company_id,
                                          u.up_real_amount,
                                          decode(u.settle_amount,
                                                 0,
                                                 u.up_real_amount,
                                                 u.settle_amount)))) settle_amount_ref --- 也是上游实际退款金额??
                   from dk_trade_up_fund u
                  where u.change_time >= l_collect_date
                    and u.change_time < (l_collect_date + 1)
                    and (u.change_type =
                        pkg_up_fund_change_type.debit_amount or
                        u.change_type =
                        pkg_up_fund_change_type.refund_amount)
                  group by u.up_company_id,
                           u.up_channel_no,
                           u.up_account_id,
                           u.business_type,
                           u.bill_type) loop
      begin
        ---2.添加下游佣金利润数据
        if item.up_channel_no != '0' and item.up_account_id != 0 then
        
          --***从业务类型与分类表中获取分类***
          select t.statistics_type
            into l_statistics_type
            from fd_system_business_statis_map t
           where t.local_business_type = item.business_type
             and rownum <= 1;
        
          ---3.获取渠道账户名称
          select t.channel_name
            into l_channel_name
            from dk_base_up_channel t
           where t.channel_no = item.up_channel_no;
        
          select t.account_name
            into l_account_name
            from dk_base_up_account t
           where t.account_id = item.up_account_id;
        
          --4.获取渠道系统编号，包括平账
          l_channel_system := item.order_source;
          if l_channel_system = 0 then
          
            select max(t.source_system_id)
              into l_channel_system
              from dk_base_up_system_map t
             where t.channel_no = item.up_channel_no;
          end if;
        
          ---5.添加数据
          insert into dk_report_commi_profit_daily
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_unit,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits, -- 13
             service_fee,
             refund_total_unit,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             refund_profits, -- 20
             refund_service_fee,
             snap_time,
             statistics_type,
             channel_name,
             account_name,
             channel_source_system)
          values
            (seq_report_commi_profit_id.nextval,
             item.up_company_id,
             item.up_channel_no,
             item.up_account_id,
             pkg_channel_type.up_channel,
             item.business_type,
             item.bill_type,
             item.up_draw_unit,
             item.up_draw_face,
             item.up_draw_amount,
             item.up_real_amount,
             (trunc(item.up_draw_amount, 2) - trunc(item.up_real_amount, 2)),
             (item.up_real_amount - item.settle_amount), -- 13
             0,
             item.up_draw_unit_ref,
             item.up_draw_face_ref,
             item.up_draw_amount_ref,
             item.up_real_amount_ref,
             (trunc(item.up_draw_amount_ref, 2) -
             trunc(item.up_real_amount_ref, 2)),
             (item.up_real_amount_ref - item.settle_amount_ref), -- 20
             0,
             l_collect_date,
             l_statistics_type,
             l_channel_name,
             l_account_name,
             l_channel_system);
        end if;
      
        commit;
      
      exception
        when others then
          rollback;
          fd_p_write_log('dk_p_auto_commi_profit_up', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');
  
    commit;
  end if;
  fd_p_proc_log('dk_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('dk_p_auto_commi_profit_up', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_AUTO_REPORT_MERGE
prompt =========================================
prompt
create or replace procedure fd_account.dk_p_auto_report_merge(v_merge_date in varchar2 default null) as
  -------------------合并sp相关报表到记账系统------------------
  l_merge_date             date := to_date(v_merge_date, 'yyyymmddhh24miss');
  l_commi_profit_err_count number;
  l_result                 varchar2(32);
begin
  ---=================同步零点余额报表====================================
  ---1.计算出合并数据的日期
  if l_merge_date is null then
    l_merge_date := trunc(sysdate) - 1;
  end if;

  ---2.零点余额报表数据同步
  l_result := dk_f_auto_zero_balance_sync(l_merge_date);
  if l_result = pkg_error_code.success then
    commit;
  else
    rollback;
    fd_p_b2e_warn_info_set('rpmg' || to_char(sysdate, 'yyyymmddhh24miss'),
                           pkg_warn_into_type.report_merge_warn,
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           ' sp报表合并失败.',
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           '零点余额报表合并过程中发生错误,' || l_result,
                           'sp报表合并失败');
  end if;

  ---==================同步佣金利润报表====================================

  ---3.检查指定日期未同步的数据是否有未完成利润加款的数据
  select count(1)
    into l_commi_profit_err_count
    from dk_report_commi_profit_daily t
   where t.snap_time = l_merge_date
     and t.add_status != pkg_commi_profit_add_status.complate
     and t.sync_status = pkg_report_sync_status.wait;

  l_result := pkg_error_code.failure;
  if l_commi_profit_err_count = 0 then
    ---4.利润佣金报表数据同步
    l_result := dk_f_auto_commi_profit_sync(l_merge_date);
    if l_result = pkg_error_code.success then
      commit;
      return;
    end if;
  end if;

  rollback;
  fd_p_b2e_warn_info_set('rpmg' || to_char(sysdate, 'yyyymmddhh24miss'),
                         pkg_warn_into_type.report_merge_warn,
                         '时间:' || to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                         ' sp报表合并失败.',
                         '时间:' || to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                         '佣金利润报表合并过程中发生错误,' || l_result,
                         'sp报表合并失败');

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_report_merge', sqlerrm, 1);
    fd_p_b2e_warn_info_set('rpmg' || to_char(sysdate, 'yyyymmddhh24miss'),
                           pkg_warn_into_type.report_merge_warn,
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           ' sp报表合并失败.',
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           '报表合并发生未知错误.',
                           'sp报表合并失败');
end;
/

prompt
prompt Creating procedure DK_P_AUTO_T
prompt ==============================
prompt
create or replace procedure fd_account.dk_p_auto_t(v_up_add_amount in out number) as
  -----------------------利润账户加款-------------------------
  l_len number;
begin
  l_len           := length(trunc(v_up_add_amount)) - 1; ---取整数位个数
  v_up_add_amount := round(v_up_add_amount, -1 * l_len); ---对整数位四舍五入
  v_up_add_amount := trunc(trunc(v_up_add_amount), -1 * l_len); --对非最高位取0

exception
  when others then
    rollback;
  
end;
/

prompt
prompt Creating procedure DK_P_AUTO_ZERO_DOWN_COMMI_GET
prompt ================================================
prompt
create or replace procedure fd_account.dk_p_auto_zero_down_commi_get(v_report_date in varchar2 default null) as
  --------------------获取代扣下游佣金账户的零点余额-------------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number;
  l_count           number;
  l_max_change_id   number;
  l_max_change_time date;
  l_before_commi    number;
  l_system_id       number;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  ---2.循环需要后返佣金的下游渠道
  for item in (select c.channel_no,
                      c.channel_name,
                      c.commi_balance,
                      c.company_id,
                      c.status,
                      c.classification
                 from dk_base_down_channel c
                where c.need_commi = pkg_sys_boolean.istrue) loop
    begin
      ---3.检查下游佣金零点余额是否存在
      select count(1)
        into l_report_count
        from dk_report_zero_balance t
       where t.record_date = l_report_date
         and t.account_type = pkg_report_zero_acc_type.down_commi_account
         and t.channel_no = item.channel_no;
    
      if l_report_count = 0 then
        ---4.检查是否有佣金账户变动记录
        select count(1), max(t.settle_time)
          into l_count, l_max_change_time
          from dk_trade_commission_settle t
         where t.settle_time >= l_report_date
           and t.settle_time < (l_report_date + 1 + 3 / 24)
           and t.channel_no = item.channel_no
           and t.channel_type = pkg_channel_type.down_channel;
      
        select min(t.source_system_id)
          into l_system_id
          from dk_base_down_system_map t
         where t.channel_no = item.channel_no;
      
        if l_count > 0 then
          ---5.获取渠道佣金最后的变动记录
          select max(t.report_id)
            into l_max_change_id
            from dk_trade_commission_settle t
           where t.settle_time = l_max_change_time
             and t.channel_no = item.channel_no
             and t.channel_type = pkg_channel_type.down_channel;
        
          ---6.添加下游佣金零点余额记录
          insert into dk_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             channel_name,
             channel_status,
             company_id,
             channel_source_system,
             channel_classif)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.down_commi_account,
                   0,
                   item.channel_no,
                   t.commi_balance,
                   item.channel_name,
                   item.status,
                   item.company_id,
                   l_system_id,
                   item.classification
              from dk_trade_commission_settle t
             where t.report_id = l_max_change_id;
        else
          ---7.获取前一天零点余额
          select nvl(max(t.balance), item.commi_balance)
            into l_before_commi
            from dk_report_zero_balance t
           where t.record_date = (l_report_date - 1)
             and t.account_type =
                 pkg_report_zero_acc_type.down_commi_account
             and t.channel_no = item.channel_no;
        
          ---8.没有变动记录，添加前一天零点余额
          insert into dk_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             channel_name,
             channel_status,
             company_id,
             channel_source_system,
             channel_classif)
          values
            (seq_report_zero_balance_id.nextval,
             l_report_date,
             sysdate,
             pkg_report_zero_acc_type.down_commi_account,
             0,
             item.channel_no,
             l_before_commi,
             item.channel_name,
             item.status,
             item.company_id,
             l_system_id,
             item.classification);
        end if;
      
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('dk_p_auto_zero_up_commi_get', sqlerrm, 1);
    end;
  end loop;

end;
/

prompt
prompt Creating procedure DK_P_AUTO_ZERO_DOWN_GET
prompt ==========================================
prompt
create or replace procedure fd_account.dk_p_auto_zero_down_get(v_report_date in varchar2 default null) as
  -----------------获取下游零点余额--------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_count           number;
  l_max_record      number;
  l_report_count    number;
  l_max_change_time date;
  l_system_id       number;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select tb.channel_no,
                      tb.account_id,
                      a.account_name,
                      c.channel_name,
                      a.status account_status,
                      c.status channel_status,
                      a.inner_balance,
                      c.company_id,
                      0 down_first_face, -------->>>>>>>>>>>>>>> 目前没有多充,也暂不考虑跨天交易的差异
                      0 down_first_amount, -------->>>>>>>>>>>>>>> yangdj 20161020
                      c.classification
                 from dk_base_down_account_map tb
                inner join dk_base_down_account a on tb.account_id =
                                                     a.account_id
                inner join dk_base_down_channel c on tb.channel_no =
                                                     c.channel_no) loop
    begin
      ---0.检查记录是否存在
      select count(1)
        into l_report_count
        from dk_report_zero_balance t
       where t.record_date = l_report_date
         and t.account_type = pkg_report_zero_acc_type.down_channel
         and t.channel_no = item.channel_no
         and t.account_id = item.account_id
         and rownum <= 1;
    
      if l_report_count = 0 then
      
        ---1.检查渠道资金变动是否存在
        select count(1), max(t.create_time)
          into l_count, l_max_change_time
          from dk_trade_down_fund t
         where t.create_time >= l_report_date
           and t.create_time < l_report_date + 1
           and t.account_id = item.account_id;
      
        select min(t.source_system_id)
          into l_system_id
          from dk_base_down_system_map t
         where t.channel_no = item.channel_no;
      
        if l_count > 0 then
          ---2.有资金变动，添加最后一笔资金变动的余额
          select max(t.record_id)
            into l_max_record
            from dk_trade_down_fund t
           where t.create_time = l_max_change_time
             and t.account_id = item.account_id;
        
          insert into dk_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             down_first_face,
             down_first_amount,
             channel_source_system,
             channel_classif)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.down_channel,
                   item.account_id,
                   item.channel_no,
                   t.balance,
                   item.account_name,
                   item.channel_name,
                   item.channel_status,
                   item.account_status,
                   item.company_id,
                   item.down_first_face,
                   item.down_first_amount,
                   l_system_id,
                   item.classification
              from dk_trade_down_fund t
             where t.record_id = l_max_record;
        
        else
          ---3.没有资金变动，取昨天零点余额的值
          insert into dk_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             down_first_face,
             down_first_amount,
             channel_source_system,
             channel_classif)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.down_channel,
                   item.account_id,
                   item.channel_no,
                   tab.zero_balance,
                   item.account_name,
                   item.channel_name,
                   item.channel_status,
                   item.account_status,
                   item.company_id,
                   0,
                   0,
                   l_system_id,
                   item.classification
              from (select nvl(max(t.balance), item.inner_balance) zero_balance
                      from dk_report_zero_balance t
                     where t.record_date = (l_report_date - 1)
                       and t.account_type =
                           pkg_report_zero_acc_type.down_channel
                       and t.channel_no = item.channel_no
                       and t.account_id = item.account_id
                       and rownum <= 1) tab;
        end if;
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('dk_p_auto_zero_down_get', sqlerrm, 1);
    end;
  end loop;

end;
/

prompt
prompt Creating procedure DK_P_AUTO_ZERO_UP_COMMI_GET
prompt ==============================================
prompt
create or replace procedure fd_account.dk_p_auto_zero_up_commi_get(v_report_date in varchar2 default null) as
  --------------------获取代扣上游佣金账户的零点余额-------------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number;
  l_count           number;
  l_max_change_id   number;
  l_max_change_time date;
  l_before_commi    number;
  l_system_id       number;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  ---2.循环需要后返佣金的上游渠道
  for item in (select c.channel_no,
                      c.channel_name,
                      c.commi_balance,
                      c.company_id,
                      c.status,
                      c.classification
                 from dk_base_up_channel c
                where c.need_commi = pkg_sys_boolean.istrue) loop
    begin
      ---3.检查下游佣金零点余额是否存在
      select count(1)
        into l_report_count
        from dk_report_zero_balance t
       where t.record_date = l_report_date
         and t.account_type = pkg_report_zero_acc_type.up_commi_account
         and t.channel_no = item.channel_no;
    
      if l_report_count = 0 then
        ---4.检查是否有佣金账户变动记录
        select count(1), max(t.settle_time)
          into l_count, l_max_change_time
          from dk_trade_commission_settle t
         where t.settle_time >= l_report_date
           and t.settle_time < (l_report_date + 1 + 3 / 24)
           and t.channel_no = item.channel_no
           and t.channel_type = pkg_channel_type.up_channel;
      
        select min(t.source_system_id)
          into l_system_id
          from dk_base_up_system_map t
         where t.channel_no = item.channel_no;
      
        if l_count > 0 then
          ---5.获取渠道佣金最后的变动记录
          select max(t.report_id)
            into l_max_change_id
            from dk_trade_commission_settle t
           where t.settle_time = l_max_change_time
             and t.channel_no = item.channel_no
             and t.channel_type = pkg_channel_type.up_channel;
        
          ---6.添加下游佣金零点余额记录
          insert into dk_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             channel_name,
             channel_status,
             company_id,
             channel_source_system,
             channel_classif)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.up_commi_account,
                   0,
                   item.channel_no,
                   t.commi_balance,
                   item.channel_name,
                   item.status,
                   item.company_id,
                   l_system_id,
                   item.classification
              from dk_trade_commission_settle t
             where t.report_id = l_max_change_id;
        else
          ---7.获取前一天零点余额
          select nvl(max(t.balance), item.commi_balance)
            into l_before_commi
            from dk_report_zero_balance t
           where t.record_date = (l_report_date - 1)
             and t.account_type = pkg_report_zero_acc_type.up_commi_account
             and t.channel_no = item.channel_no;
        
          ---8.没有变动记录，添加前一天零点余额
          insert into dk_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             channel_name,
             channel_status,
             company_id,
             channel_source_system,
             channel_classif)
          values
            (seq_report_zero_balance_id.nextval,
             l_report_date,
             sysdate,
             pkg_report_zero_acc_type.up_commi_account,
             0,
             item.channel_no,
             l_before_commi,
             item.channel_name,
             item.status,
             item.company_id,
             l_system_id,
             item.classification);
        end if;
      
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('dk_p_auto_zero_up_commi_get', sqlerrm, 1);
    end;
  end loop;

end;
/

prompt
prompt Creating procedure DK_P_AUTO_ZERO_UP_GET
prompt ========================================
prompt
create or replace procedure fd_account.dk_p_auto_zero_up_get(v_report_date in varchar2 default null) as
  -----------------获取上游零点余额--------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_count           number;
  l_max_record      number;
  l_report_count    number;
  l_max_change_time date;
  l_system_id       number;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select tb.channel_no,
                      tb.account_id,
                      a.account_name,
                      c.channel_name,
                      a.status account_status,
                      c.status channel_status,
                      a.inner_balance,
                      c.company_id,
                      c.classification
                 from dk_base_up_account_map tb
                inner join dk_base_up_account a on tb.account_id =
                                                   a.account_id
                inner join dk_base_up_channel c on tb.channel_no =
                                                   c.channel_no) loop
    begin
      ---0.检查记录是否存在
      select count(1)
        into l_report_count
        from dk_report_zero_balance t
       where t.record_date = l_report_date
         and t.account_type = pkg_report_zero_acc_type.up_channel
         and t.channel_no = item.channel_no
         and t.account_id = item.account_id
         and rownum <= 1;
    
      if l_report_count = 0 then
      
        ---1.检查渠道资金变动是否存在
        select count(1), max(t.change_time)
          into l_count, l_max_change_time
          from dk_trade_up_fund t
         where t.change_time >= l_report_date
           and t.change_time < l_report_date + 1
           and t.up_account_id = item.account_id;
      
        select min(t.source_system_id)
          into l_system_id
          from dk_base_up_system_map t
         where t.channel_no = item.channel_no;
      
        if l_count > 0 then
          ---2.有资金变动，添加最后一笔资金变动的余额
          select max(t.record_id)
            into l_max_record
            from dk_trade_up_fund t
           where t.change_time = l_max_change_time
             and t.up_account_id = item.account_id;
        
          insert into dk_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             channel_source_system,
             channel_classif)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.up_channel,
                   item.account_id,
                   item.channel_no,
                   t.balance,
                   item.account_name,
                   item.channel_name,
                   item.channel_status,
                   item.account_status,
                   item.company_id,
                   l_system_id,
                   item.classification
              from dk_trade_up_fund t
             where t.record_id = l_max_record;
        
        else
          ---3.没有资金变动，取昨天零点余额的值
          insert into dk_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             channel_source_system,
             channel_classif)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.up_channel,
                   item.account_id,
                   item.channel_no,
                   tab.zero_balance,
                   item.account_name,
                   item.channel_name,
                   item.channel_status,
                   item.account_status,
                   item.company_id,
                   l_system_id,
                   item.classification
              from (select nvl(max(t.balance), item.inner_balance) zero_balance
                      from dk_report_zero_balance t
                     where t.record_date = (l_report_date - 1)
                       and t.account_type =
                           pkg_report_zero_acc_type.up_channel
                       and t.channel_no = item.channel_no
                       and t.account_id = item.account_id
                       and rownum <= 1) tab;
        end if;
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('dk_p_auto_zero_up_get', sqlerrm, 1);
    end;
  end loop;

end;
/

prompt
prompt Creating procedure DK_P_BANK_COMMISION_SETTLE
prompt =============================================
prompt
create or replace procedure fd_account.dk_p_bank_commision_settle(v_channel_no      varchar2, ---渠道编号
                                                       v_channel_type    number, ---渠道类型
                                                       v_bank_account_id number, ---结算实体卡编号 
                                                       v_commission      number, ---结算佣金
                                                       v_commi_month     varchar2, ---结算月份(yyyymmddhh24miss)
                                                       v_service_fee     number, ---结算公司支付的手续费                                                      
                                                       v_settle_user     varchar2, ---结算人
                                                       v_memo            varchar2, ---备注
                                                       v_result          out varchar2) as
  --------------------代扣佣金结算-------------------
begin
  ---0.记录操作日志
  fd_p_write_handle_log('代扣渠道佣金结算',
                        v_settle_user,
                        ('v_channel_no=' || v_channel_no ||
                        ',v_channel_type=' || v_channel_type ||
                        ',v_commission=' || v_commission));

  ---1.获取并检查结算参数
  v_result := dk_f_bank_commision_check(v_channel_no,
                                        v_channel_type,
                                        v_bank_account_id,
                                        v_commission,
                                        v_service_fee);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.渠道佣金结算
  v_result := dk_f_bank_commision_settle(v_channel_no,
                                         v_channel_type,
                                         v_bank_account_id,
                                         v_commission,
                                         v_commi_month,
                                         v_service_fee,
                                         v_settle_user,
                                         v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_bank_commision_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_MANUAL_DOWN_COMMI_ADD
prompt =============================================
prompt
create or replace procedure fd_account.dk_p_manual_down_commi_add(v_down_channel_no in varchar2, ---下游渠道
                                                       v_down_account_id in number, ---下游支付账户
                                                       v_commi_month     in varchar2, ---结算月份（yyyymmddhh24miss）
                                                       v_amount          in number, ------渠道到账金额
                                                       v_create_user     in varchar2, ---加款人
                                                       v_memo            in varchar2, ---备注
                                                       v_result          out varchar2) as
  --------------代扣下游渠道佣金转渠道余额---------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('代扣下游佣金转渠道余额',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_amount=' || v_amount));

  ---2.检查下游渠道、账户及其关联情况
  v_result := dk_f_manual_down_commi_add_ck(v_down_channel_no,
                                            v_down_account_id,
                                            v_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.渠道佣金转渠道余额
  v_result := dk_f_manual_down_commi_add(v_down_channel_no,
                                         v_down_account_id,
                                         v_amount,
                                         v_commi_month,
                                         v_create_user,
                                         v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_manual_down_commi_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_MANUAL_DOWN_DRAW
prompt ========================================
prompt
create or replace procedure fd_account.dk_p_manual_down_draw(v_down_channel_no in varchar2, ---下游渠道
                                                  v_down_account_id in number, ---下游支付账户
                                                  v_bank_account_id in number, ---实体卡账户号
                                                  v_amount          in number, ------退款金额
                                                  v_service_fee     in number, ------公司承担手续费
                                                  v_create_user     in varchar2, ---退款人
                                                  v_partner_account in varchar2, ---可空，合作方银行账户
                                                  v_memo            in varchar2, ---备注
                                                  v_remark_name     in varchar2, --收付款账户名称
                                                  v_result          out varchar2) as
  ---------------------------------------------------
  --功能：下游退款
  --创建人：周荣省
  --创建时间：2019-05-24
  --修改人：周荣省
  --修改时间：2019-08-27
  --修改内容：添加收付款账户名称
  ---------------------------------------------------
  l_account_name varchar2(32);
  l_channel_name varchar2(32);
  l_number       number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游渠道提款',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_amount=' || v_amount));

  ---2.检查下游渠道、账户及其关联情况
  v_result := dk_f_manual_down_draw_check(v_down_channel_no,
                                          v_down_account_id,
                                          v_bank_account_id,
                                          v_amount,
                                          v_service_fee,
                                          l_account_name,
                                          l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款(锁实体卡账户、渠道账户、手续费账户)
  v_result := dk_f_manual_down_draw(v_down_channel_no,
                                    v_down_account_id,
                                    v_bank_account_id,
                                    v_amount,
                                    v_service_fee,
                                    v_create_user,
                                    v_partner_account,
                                    v_memo,
                                    v_remark_name,
                                    l_account_name,
                                    l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --4.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_down_account_id
     and t.co_account_type = 8
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(v_down_account_id,
                                         8,
                                         v_remark_name,
                                         v_create_user);
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_down_draw', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_MANUAL_DOWN_RV_CHANNEL
prompt ==============================================
prompt
create or replace procedure fd_account.dk_p_manual_down_rv_channel(v_down_channel_no in varchar2, ---下游渠道编号
                                                        v_down_account_id in number, ---下游支付账户
                                                        v_revise_type     in number, ---平账类型（1.余额平账）
                                                        v_revise_amount   in number, ---账户调整金额（可正、可负） TODO:??
                                                        v_create_user     in varchar2, ---操作人
                                                        v_memo            in varchar2, ---备注
                                                        v_result          out varchar2) as
  --------------代扣业务:平账、下游手工渠道账户平账---------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游渠道平账',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_revise_amount=' || v_revise_amount));

  ---2.检查渠道与金额是否正确
  v_result := dk_f_manual_down_rv_channel_ck(v_down_channel_no,
                                             v_down_account_id,
                                             v_revise_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.渠道账户平账
  v_result := dk_f_manual_down_rv_channel(v_down_channel_no,
                                          v_down_account_id,
                                          v_revise_type,
                                          v_revise_amount,
                                          v_create_user,
                                          v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_manual_down_rv_channel', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_MANUAL_DOWN_RV_TRADE
prompt ============================================
prompt
create or replace procedure fd_account.dk_p_manual_down_rv_trade(v_down_channel_no  in varchar2, ---下游渠道编号
                                                      v_down_account_id  in number, ---下游支付账户
                                                      v_down_draw_amount in number, ---下游扣款金额
                                                      v_down_real_amount in number, ---下游真实金额
                                                      v_business_type    in number, ---业务类型
                                                      v_bill_type        in number, ---交易类型，1前向，2后向
                                                      v_create_user      in varchar2, ---操作人
                                                      v_memo             in varchar2, ---备注
                                                      v_result           out varchar2) as
  --------------------代扣业务:下游渠道交易平账-----------------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游渠道交易平账',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id));

  ---2.检查下游渠道及账户
  v_result := dk_f_manual_down_rv_trade_ck(v_down_channel_no,
                                           v_down_account_id,
                                           v_down_draw_amount,
                                           v_down_real_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.下游渠道交易平账
  v_result := dk_f_manual_down_rv_trade(v_down_channel_no,
                                        v_down_account_id,
                                        v_down_draw_amount,
                                        v_down_real_amount,
                                        v_business_type,
                                        v_bill_type,
                                        v_create_user,
                                        v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_manual_down_rv_trade', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_MANUAL_DOWN_SETTLE
prompt ==========================================
prompt
create or replace procedure fd_account.dk_p_manual_down_settle(v_down_channel_no in varchar2, --- 下游渠道
                                                    v_down_account_id in number, --- 下游收款账户
                                                    v_bank_account_id in number, --- 实体卡账户号
                                                    v_settle_amount   in number, ------ 结算给下游的金额
                                                    v_service_fee     in number, ------ 公司承担手续费?? 不明确谁承担,传0
                                                    v_create_user     in varchar2, --- 操作人
                                                    v_partner_account in varchar2, --- 可空，合作方银行账户
                                                    v_memo            in varchar2, --- 备注
                                                    v_remark_name     in varchar2, --收付款账户名称
                                                    v_result          out varchar2) as
  --------------代扣业务:下游结算---------------
  l_bank_batch_id number;
  l_account_name  varchar2(100);
  l_channel_name  varchar2(100);
  l_number        number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游代扣结算',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_settle_amount=' || v_settle_amount));

  ---2.检查下游渠道、账户及其关联情况
  v_result := dk_f_manual_down_settle_check(v_down_channel_no,
                                            v_down_account_id,
                                            v_bank_account_id,
                                            v_settle_amount,
                                            v_service_fee,
                                            l_account_name,
                                            l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款(锁实体卡账户、渠道账户、手续费账户)
  v_result := dk_f_manual_down_settle(v_down_channel_no,
                                      v_down_account_id,
                                      v_bank_account_id,
                                      v_settle_amount,
                                      v_service_fee,
                                      v_create_user,
                                      v_partner_account,
                                      v_memo,
                                      v_remark_name,
                                      l_account_name,
                                      l_channel_name,
                                      l_bank_batch_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --4.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_down_account_id
     and t.co_account_type = 8
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(v_down_account_id,
                                         8,
                                         v_remark_name,
                                         v_create_user);
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_manual_down_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_MANUAL_UP_COMMI_ADD
prompt ===========================================
prompt
create or replace procedure fd_account.dk_p_manual_up_commi_add(v_up_channel_no in varchar2, ---上游渠道
                                                     v_up_account_id in number, ---上游支付账户
                                                     v_commi_month   in varchar2, ---结算月份（yyyymmddhh24miss）
                                                     v_amount        in number, ------渠道到账金额
                                                     v_create_user   in varchar2, ---加款人
                                                     v_memo          in varchar2, ---备注
                                                     v_result        out varchar2) as
  --------------代扣上游渠道佣金转渠道余额---------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('代扣上游佣金转渠道余额',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_amount=' || v_amount));

  ---2.检查下游渠道、账户及其关联情况
  v_result := dk_f_manual_up_commi_add_ck(v_up_channel_no,
                                          v_up_account_id,
                                          v_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.渠道佣金转渠道余额
  v_result := dk_f_manual_up_commi_add(v_up_channel_no,
                                       v_up_account_id,
                                       v_amount,
                                       v_commi_month,
                                       v_create_user,
                                       v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_manual_up_commi_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_MANUAL_UP_DRAW
prompt ======================================
prompt
create or replace procedure fd_account.dk_p_manual_up_draw(v_up_channel_no   in varchar2, ---上游渠道编号
                                                v_up_account_id   in number, ---上游账户号
                                                v_bank_account_id in number, ---实体卡账户号
                                                v_amount          in number, ---渠道提款金额
                                                v_service_fee     in number, ---公司承担的手续费
                                                v_create_user     in varchar2, ---提款人
                                                v_partner_account in varchar2, ---可空，上游商户银行账户
                                                v_memo            in varchar2, ---备注
                                                v_remark_name     in varchar2, --收付款账户名称
                                                v_result          out varchar2) as
  ----------------------------------------------------
  --功能：sp上游渠道提款
  --创建人：周荣省
  --创建时间：2019-05-24
  --修改人：周荣省
  --修改时间：2019-08-27
  --修改内容：添加收付款账户名称
  ----------------------------------------------------
  l_company_id   number;
  l_account_name varchar2(32);
  l_channel_name varchar2(32);
  l_number       number;
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

begin
  ---1.记录操作日志
  fd_p_write_handle_log('上游渠道提款',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_amount=' || v_amount));

  ---2.上游提款检查
  v_result := dk_f_manual_up_draw_check(v_up_channel_no,
                                        v_up_account_id,
                                        v_bank_account_id,
                                        v_amount,
                                        v_service_fee,
                                        l_company_id,
                                        l_account_name,
                                        l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款
  v_result := dk_f_manual_up_draw(v_up_channel_no,
                                  l_company_id,
                                  v_up_account_id,
                                  v_bank_account_id,
                                  v_amount,
                                  v_service_fee,
                                  v_create_user,
                                  v_partner_account,
                                  v_memo,
                                  v_remark_name,
                                  l_account_name,
                                  l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --4.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_up_account_id
     and t.co_account_type = 8
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(v_up_account_id,
                                         8,
                                         v_remark_name,
                                         v_create_user);
  end if;

  ---4.空充系统对应下游和关联的18上游关联提款
  /* v_result := fd_f_manual_up_bind_draw(v_up_channel_no,
                                       l_company_id,
                                       v_amount,
                                       v_create_user,
                                       v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;*/

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_up_draw', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_MANUAL_UP_RV_CHANNEL
prompt ============================================
prompt
create or replace procedure fd_account.dk_p_manual_up_rv_channel(v_up_channel_no in varchar2, ---上游游渠道编号
                                                      v_up_account_id in number, ---上游支付账户编号
                                                      v_revise_type in number,---平账类型（1.余额平账）
                                                      v_revise_amount in number, ---账户调整金额（可正、可负）
                                                      v_create_user   in varchar2, ---操作人
                                                      v_memo          in varchar2, ---备注
                                                      v_result        out varchar2) as
  --------------代扣业务:平账、上游手工渠道账户平账---------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('上游渠道平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_revise_amount=' || v_revise_amount));

  ---2.检查渠道与金额是否正确
  v_result := dk_f_manual_up_rv_channel_ck(v_up_channel_no,
                                           v_up_account_id,
                                           v_revise_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.渠道账户平账
  v_result := dk_f_manual_up_rv_channel(v_up_channel_no,
                                        v_up_account_id,
                                        v_revise_type,
                                        v_revise_amount,
                                        v_create_user,
                                        v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_manual_up_rv_channel', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_MANUAL_UP_RV_TRADE
prompt ==========================================
prompt
create or replace procedure fd_account.dk_p_manual_up_rv_trade(v_up_channel_no  in varchar2, ---上游渠道编号
                                                    v_up_account_id  in number, ---上游支付账户
                                                    v_up_draw_amount in number, ---上游扣款金额(从余额中扣减)
                                                    v_up_real_amount in number, ---上游实际扣款 
                                                    v_business_type  in number, ---业务类型
                                                    v_bill_type      in number, ---交易类型，1前向，2后向
                                                    v_create_user    in varchar2, ---操作人
                                                    v_memo           in varchar2, ---备注
                                                    v_result         out varchar2) as
  --------------------代扣业务:上游渠道交易平账-----------------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('上游渠道交易平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id));

  ---2.检查下游渠道及账户
  v_result := dk_f_manual_up_rv_trade_ck(v_up_channel_no,
                                         v_up_account_id,
                                         v_up_draw_amount,
                                         v_up_real_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.下游渠道交易平账
  v_result := dk_f_manual_up_rv_trade(v_up_channel_no,
                                      v_up_account_id,
                                      v_up_draw_amount,
                                      v_up_real_amount,
                                      v_business_type,
                                      v_bill_type,
                                      v_create_user,
                                      v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_manual_up_rv_trade', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_MANUAL_UP_SETTLE
prompt ========================================
prompt
create or replace procedure fd_account.dk_p_manual_up_settle(v_up_channel_no   in varchar2, --- 上游渠道编号
                                                  v_up_account_id   in number, --- 上游账户号
                                                  v_bank_account_id in number, --- 上游结算给我们(收款银行账户)
                                                  v_settle_amount   in number, --- 结算金额
                                                  v_service_fee     in number, --- 手续费?? 目前收取方向不明,传0
                                                  v_create_user     in varchar2, --- 操作员
                                                  v_partner_account in varchar2, --- 可空，上游商户银行账户
                                                  v_memo            in varchar2, --- 备注
                                                  v_remark_name     in varchar2, --收付款账户名称
                                                  v_result          out varchar2) as
  ------------------------------
  --功能：代扣业务:上游结算
  --修改人：周荣省
  --修改时间：2019-08-27
  --修改内容：添加收付款账户名称
  ------------------------------
  l_company_id   number;
  l_account_name varchar2(100);
  l_channel_name varchar2(100);
  l_number       number;

begin
  ---1.记录操作日志
  fd_p_write_handle_log('上游代扣结算',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_settle_amount=' || v_settle_amount));

  ---2.上游加款检查
  v_result := dk_f_manual_up_settle_check(v_up_channel_no,
                                          v_up_account_id,
                                          v_bank_account_id,
                                          v_settle_amount,
                                          v_service_fee,
                                          l_company_id,
                                          l_account_name,
                                          l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款
  v_result := dk_f_manual_up_settle(v_up_channel_no,
                                    l_company_id,
                                    v_up_account_id,
                                    v_bank_account_id,
                                    v_settle_amount,
                                    v_service_fee,
                                    v_create_user,
                                    v_partner_account,
                                    v_memo,
                                    v_remark_name,
                                    l_account_name,
                                    l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --4.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_up_account_id
     and t.co_account_type = 8
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(v_up_account_id,
                                         8,
                                         v_remark_name,
                                         v_create_user);
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_manual_up_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_TRADE_DOWN_ORDER_FEE_PAY
prompt ================================================
prompt
create or replace procedure fd_account.dk_p_trade_down_order_fee_pay(v_source_name     in varchar2, ---系统名称
                                                          v_down_channel_no in varchar2,
                                                          v_trade_order_no  in varchar2, ---外部系统交易订单号
                                                          v_ext_order_no    in varchar2, ---下游商户的订单号
                                                          v_deduct_account  in varchar2, --- 代扣账号
                                                          v_business_type   in number, --- 代扣业务: 点播-17,包月-18,sdk-19
                                                          v_carrier_no      in varchar2,
                                                          v_province_no     in varchar2,
                                                          v_city_no         in varchar2,
                                                          v_total_face      in number, --面值
                                                          v_deduct_unit     in number, --扣款总量（目前和面值相同）
                                                          v_order_time      in varchar2,
                                                          v_settle_amount   in number, --结算给商户的金额
                                                          v_service_pay     in number, --下游收取手续费
                                                          v_memo            in varchar2,
                                                          v_deduct_times    in number, -- 缴费次数(第一次就是1)
                                                          v_result          out varchar2,
                                                          v_msg             out varchar2) as
  pragma autonomous_transaction; --自治事务
  ----------------------代扣业务:下游扣款----------------------
  --- yangdejian 20161019
  v_order_source     number;
  l_fd_business_type number;
begin

  v_result := dk_f_system_id_get(v_source_name, v_order_source);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---0.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---1.历史库获取订单
  v_result := dk_f_trade_pay_hs_move(v_order_source,
                                     v_down_channel_no,
                                     v_trade_order_no,
                                     v_order_time,
                                     v_deduct_times,
                                     v_settle_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.检查订单是否存在，不存在则创建订单
  v_result := dk_f_trade_order_create(v_order_source,
                                      v_down_channel_no,
                                      v_trade_order_no,
                                      v_ext_order_no,
                                      v_deduct_account,
                                      l_fd_business_type,
                                      v_carrier_no,
                                      v_province_no,
                                      v_city_no,
                                      v_total_face,
                                      v_deduct_unit,
                                      v_settle_amount,
                                      v_order_time,
                                      v_deduct_times);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.下游资金变动扣款(锁订单，检查扣款记录是否存在，锁定账户，添加资金变动)
  v_result := dk_f_trade_down_order_fee_mus(v_order_source,
                                            v_down_channel_no,
                                            v_trade_order_no,
                                            v_ext_order_no,
                                            v_order_time,
                                            v_settle_amount,
                                            v_service_pay,
                                            v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('dk_p_trade_down_order_fee_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_TRADE_DOWN_ORDER_FEE_REF
prompt ================================================
prompt
create or replace procedure fd_account.dk_p_trade_down_order_fee_ref(v_source_name     in varchar2, ---系统名称
                                                          v_down_channel_no in varchar2,
                                                          v_trade_order_no  in varchar2,
                                                          v_trade_refund_no in varchar2, --- 同trade_order_no订单的多次退款,应不相同
                                                          v_refund_unit     in number, --- 退款规格（对于没有拆单的订单,必须等于订单面值）
                                                          v_refund_face     in number, --- 退款面值（同上）
                                                          v_refund_amount   in number, --- 退款金额,不能大于面值
                                                          v_real_refund     in number, --- 实际退款金额(无佣金时和退款金额一致)
                                                          v_order_date      in varchar2,
                                                          v_service_fee     in number, --- 手续费
                                                          v_memo            in varchar2,
                                                          v_sys_paid_amount in number, -- 由系统垫付的退款金额(将作为系统成本的一部分)
                                                          v_result          out varchar2) as
  pragma autonomous_transaction; --自治事务
  ----------------代扣业务：下游退款------------------
  ---- 规则：退款金额可以超过扣款金额，但不能超过面值
  v_order_source number;
begin

  v_result := dk_f_system_id_get(v_source_name, v_order_source);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.获取历史库中的数据
  v_result := dk_f_trade_hs_move(v_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.下游订单退款
  v_result := dk_f_trade_down_fee_refund(v_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_trade_refund_no,
                                         v_refund_unit,
                                         v_refund_face,
                                         v_refund_amount,
                                         v_real_refund,
                                         v_order_date,
                                         v_service_fee,
                                         v_memo,
                                         v_sys_paid_amount);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_trade_down_order_fee_ref', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_TRADE_DOWN_ORDER_LOSS_REF
prompt =================================================
prompt
create or replace procedure fd_account.dk_p_trade_down_order_loss_ref(v_source_name     in varchar2, ---系统名称
                                                           v_down_channel_no in varchar2,
                                                           v_trade_order_no  in varchar2,
                                                           v_trade_refund_no in varchar2, --- 同trade_order_no订单的多次退款,应不相同
                                                           v_refund_unit     in number, --- 退款规格（对于没有拆单的订单,必须等于订单面值）
                                                           v_refund_face     in number, --- 退款面值（同上）
                                                           v_refund_amount   in number, --- 退款金额,不能大于面值
                                                           v_real_refund     in number, --- 实际退款金额(无佣金时和退款金额一致)
                                                           v_order_date      in varchar2,
                                                           v_service_fee     in number, --- 手续费
                                                           v_memo            in varchar2,
                                                           v_sys_paid_amount in number, -- 由系统垫付的退款金额(将作为系统成本的一部分)
                                                           v_calc_profit     in number, --是否计算利润,0.是，1.不是
                                                           v_result          out varchar2) as
  pragma autonomous_transaction; --自治事务
  ----------------代扣业务：下游退款,考虑退款记入利润统计------------------
  ---- 规则：退款金额可以超过扣款金额，但不能超过面值
  v_order_source number;
begin

  v_result := dk_f_system_id_get(v_source_name, v_order_source);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.获取历史库中的数据
  v_result := dk_f_trade_hs_move(v_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.下游订单退款
  v_result := dk_f_trade_down_loss_refund(v_order_source,
                                          v_down_channel_no,
                                          v_trade_order_no,
                                          v_trade_refund_no,
                                          v_refund_unit,
                                          v_refund_face,
                                          v_refund_amount,
                                          v_real_refund,
                                          v_order_date,
                                          v_service_fee,
                                          v_memo,
                                          v_sys_paid_amount,
                                          v_calc_profit);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_trade_down_order_loss_ref', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_TRADE_TIME_DIFFER_ADJUST
prompt ================================================
prompt
create or replace procedure fd_account.dk_p_trade_time_differ_adjust(v_down_channel_no  varchar2,
                                                           v_add_debit_amount number,
                                                           v_bill_type        number,
                                                           v_business_type    number,
                                                           v_memo             varchar2,
                                                           v_result           out varchar2) as
 /*
  创建人:邓孝辉
  创建时间:2019-05-07
  简介:交易时间差平账，使交易时间差为0
 */

  l_down_account_id number;
  l_down_company_id number;

begin

  ---  JYSJC   作为查找记录标志
  ---公式：期初+加款-扣款-期末=交易时间差
  ---    :期初+加款-(扣款+交易时间差）-期末=0
  ---所以需要在上游资金变动中补上金额为“交易时间差”的扣款记录

  ---下游扣款不退款情况，需要在上游资金变动补上“下游扣款金额”的扣款记录

  ---1.获取渠道账户公司信息
  select t.account_id, c.company_id
    into l_down_account_id, l_down_company_id
    from dk_base_down_account_map t
   inner join dk_base_down_channel c
      on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and rownum <= 1;

  ---2.添加消除时间差人工操作记录
  insert into dk_trade_down_settle
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo,
     real_amount)
  values
    (seq_trade_up_fund_id.nextval,
     v_down_channel_no,
     l_down_account_id,
     0,
     0,
     pkg_up_manual_change_type.trade_revise,
     v_add_debit_amount,
     sysdate,
     0,
     '-',
     '消除时间差记录,不影响余额:' || v_memo,
     v_add_debit_amount);

  ---3.添加消除时间差扣款记录
  insert into dk_trade_up_fund
    (record_id,
     trade_order_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_amount,
     down_real_amount,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     balance,
     memo)
  values
    (seq_trade_up_fund_id.nextval,
     'JYSJC' || to_char(sysdate, 'yyyymmddhh24miss'),
     v_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     '0',
     0,
     l_down_company_id,
     v_add_debit_amount,
     v_add_debit_amount,
     0,
     0,
     sysdate,
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     v_business_type,
     0,
     v_memo);

  if sql%rowcount != 1 then
    rollback;
    v_result := pkg_error_code.data_error;
    return;
  end if;

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure DK_P_TRADE_UP_ORDER_PAY
prompt ==========================================
prompt
create or replace procedure fd_account.dk_p_trade_up_order_pay(v_source_name       in varchar2, ---系统名称
                                                    v_down_channel_no   in varchar2,
                                                    v_up_channel_no     in varchar2,
                                                    v_trade_order_no    in varchar2,
                                                    v_trade_delivery_no in varchar2,
                                                    v_ext_order_no      in varchar2,
                                                    v_deduct_account    in varchar2, -- 代扣账户
                                                    v_bill_type         in number, -- 代扣业务传2-后向
                                                    v_business_type     in number, -- 代扣业务: 点播-17,包月-18,sdk-19
                                                    v_carrier_no        in varchar2,
                                                    v_province_no       in varchar2,
                                                    v_city_no           in varchar2,
                                                    v_down_order_unit   in number, -- 订单代扣规格
                                                    v_down_order_face   in number, -- 订单代扣面值
                                                    v_down_draw_unit    in number, -- 下游代扣规格
                                                    v_down_draw_face    in number, -- 下游代扣面值
                                                    v_down_draw_amount  in number, -- 下游结算金额
                                                    v_down_real_amount  in number, -- 下游实际结算金额
                                                    v_up_draw_unit      in number, -- 上游代扣规格
                                                    v_up_draw_face      in number, -- 上游代扣面值
                                                    v_up_draw_amount    in number, -- 上游结算金额（结算给我方）
                                                    v_up_real_amount    in number, -- 上游实际结算金额
                                                    v_order_time        in varchar2,
                                                    v_service_fee       in number, --手续费
                                                    v_memo              in varchar2,
                                                    v_deduct_times      in number, -- 缴费次数(第一次就是1)
                                                    v_result            out varchar2) as
  pragma autonomous_transaction; --自治事务
  --------------代扣业务：上游扣款--------------
  --- yangdj 20161019
  l_up_account_id    number;
  v_order_source     number;
  l_fd_business_type number;
begin
  ----检查渠道公司是否相同
  v_result := dk_f_channel_company_check(v_down_channel_no, v_up_channel_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  v_result := dk_f_system_id_get(v_source_name, v_order_source);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---0.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---1.检查上游渠道、账户及其关联情况
  v_result := dk_f_trade_pay_account_get(v_order_source,
                                         v_up_channel_no,
                                         l_up_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.1历史库获取订单
  v_result := dk_f_trade_pay_hs_move(v_order_source,
                                     v_down_channel_no,
                                     v_trade_order_no,
                                     v_order_time,
                                     v_deduct_times,
                                     v_down_draw_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.检查订单是否存在，不存在则创建订单
  v_result := dk_f_trade_order_create(v_order_source,
                                      v_down_channel_no,
                                      v_trade_order_no,
                                      v_ext_order_no,
                                      v_deduct_account,
                                      l_fd_business_type,
                                      v_carrier_no,
                                      v_province_no,
                                      v_city_no,
                                      v_down_order_face,
                                      v_down_order_unit,
                                      v_down_draw_amount,
                                      v_order_time,
                                      v_deduct_times);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.上游支付扣款
  v_result := dk_f_trade_up_order_minus(v_order_source,
                                        v_trade_order_no,
                                        v_trade_delivery_no,
                                        v_up_channel_no,
                                        l_up_account_id,
                                        v_up_draw_unit,
                                        v_up_draw_face,
                                        v_up_draw_amount,
                                        v_up_real_amount,
                                        v_down_draw_unit,
                                        v_down_draw_face,
                                        v_down_draw_amount,
                                        v_down_real_amount,
                                        v_bill_type,
                                        v_order_time,
                                        v_service_fee,
                                        v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_trade_up_order_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DK_P_TRADE_UP_ORDER_REFUND
prompt =============================================
prompt
create or replace procedure fd_account.dk_p_trade_up_order_refund(v_source_name             in varchar2, ---系统名称
                                                       v_down_channel_no         in varchar2, ---下游渠道编号
                                                       v_up_channel_no           in varchar2, ---上游渠道编号
                                                       v_trade_order_no          in varchar2, ---交易系统订单号
                                                       v_trade_delivery_no       in varchar2, ---交易系统发货编号
                                                       v_trade_refund_no         in varchar2, -- 交易系统退款编号（相同的退款编号被认为是同一笔退款的重复请求）
                                                       v_bill_type               in number, -- 代扣业务 1前向，2-后向
                                                       v_business_type           in number, -- 代扣业务: 点播-17,包月-18,sdk-19
                                                       v_carrier_no              in varchar2, --运营商
                                                       v_province_no             in varchar2, --省份
                                                       v_up_refund_unit          in number, -- 退款总规格
                                                       v_up_refund_face          in number, -- 退款总面值
                                                       v_up_refund_amount        in number, -- 退款金额
                                                       v_up_refund_real_amount   in number, -- 退款实际金额
                                                       v_down_refund_unit        in number, -- 下游退款总规格
                                                       v_down_refund_face        in number, -- 下游退款总面值
                                                       v_down_refund_amount      in number, -- 下游退款金额
                                                       v_down_refund_real_amount in number, -- 下游实际退款金额
                                                       v_order_time              in varchar2, --交易系统订单时间
                                                       v_service_fee             in number, ---手续费
                                                       v_memo                    in varchar2,
                                                       v_result                  out varchar2) as
  pragma autonomous_transaction; --自治事务
  --------------代扣业务：上游退款--------------
  v_order_source     number;
  l_fd_business_type number;
begin
  ----检查渠道公司是否相同
  v_result := dk_f_channel_company_check(v_down_channel_no, v_up_channel_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  v_result := dk_f_system_id_get(v_source_name, v_order_source);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---0.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---1.获取历史库中的数据
  v_result := dk_f_trade_hs_move(v_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;
  ---2.上游支付退款
  v_result := dk_f_trade_up_order_refund(v_order_source,
                                         v_down_channel_no,
                                         v_up_channel_no,
                                         v_trade_order_no,
                                         v_trade_delivery_no,
                                         v_trade_refund_no,
                                         v_bill_type,
                                         l_fd_business_type,
                                         v_carrier_no,
                                         v_province_no,
                                         v_up_refund_unit,
                                         v_up_refund_face,
                                         v_up_refund_amount,
                                         v_up_refund_real_amount,
                                         v_order_time,
                                         v_service_fee,
                                         v_memo,
                                         v_down_refund_unit, -- 下游退款总规格
                                         v_down_refund_face, -- 下游退款总面值
                                         v_down_refund_amount, -- 下游退款金额
                                         v_down_refund_real_amount -- 下游实际退款金额
                                         );

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_trade_up_order_refund', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_ADJUST_DOWN_AFTER
prompt ===========================================
prompt
create or replace procedure fd_account.dsup_p_adjust_down_after(v_down_report_id number,
                                                     v_adjust_days    number,
                                                     v_adjust_user    varchar2,
                                                     v_adjust_memo    varchar2,
                                                     v_result         out varchar2) as
  ------------收卡系统下游后付红冲------------
  l_fund_batch_id  number;
  l_down_settle_id number;
  l_change_amount  number;
  l_change_time    date;
  l_sup_record_id  number;
  l_jz_record_id   number;
begin
  ---1.检查下游结算记录及银行相关记录
  v_result := dk_f_sup_adjust_down_after_ck(v_down_report_id,
                                            v_adjust_days,
                                            l_fund_batch_id,
                                            l_down_settle_id,
                                            l_change_amount,
                                            l_change_time);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.检查收卡系统的18渠道和记账系统的收卡渠道相关记录信息
  v_result := dk_f_sup_adjust_bind_up_check(l_fund_batch_id,
                                            l_change_amount,
                                            l_change_time,
                                            pkg_up_manual_change_type.add_amount,
                                            l_sup_record_id,
                                            l_jz_record_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.红冲相关记录
  v_result := dk_f_sup_adjust_down_after(v_down_report_id,
                                         l_down_settle_id,
                                         l_fund_batch_id,
                                         l_sup_record_id,
                                         l_jz_record_id,
                                         v_adjust_user,
                                         v_adjust_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.人工操作记录
  fd_p_write_handle_log('收卡下游后付红冲',
                        v_adjust_user,
                        ('v_down_report_id=' || v_down_report_id));

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_sup_adjust_down_after', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_ADJUST_DOWN_PRE
prompt =========================================
prompt
create or replace procedure fd_account.dsup_p_adjust_down_pre(v_down_settle_id number,
                                                   v_adjust_days    number,
                                                   v_adjust_user    varchar2,
                                                   v_adjust_memo    varchar2,
                                                   v_result         out varchar2) as
  --------------收卡系统下游预付结算红冲-------------
  l_fund_batch_id number;
  l_change_amount number;
  l_change_time   date;
  l_sup_record_id number;
  l_jz_record_id  number;
begin
  ---1.检查下游结算记录及银行相关记录
  v_result := dk_f_sup_adjust_down_pre_check(v_down_settle_id,
                                             v_adjust_days,
                                             l_fund_batch_id,
                                             l_change_amount,
                                             l_change_time);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.检查收卡系统的18渠道和记账系统的收卡渠道相关记录信息
  v_result := dk_f_sup_adjust_bind_up_check(l_fund_batch_id,
                                            l_change_amount,
                                            l_change_time,
                                            pkg_up_manual_change_type.add_amount,
                                            l_sup_record_id,
                                            l_jz_record_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.红冲相关记录
  v_result := dk_f_sup_adjust_down_pre(v_down_settle_id,
                                       l_sup_record_id,
                                       l_jz_record_id,
                                       v_adjust_user,
                                       v_adjust_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.人工操作记录
  fd_p_write_handle_log('收卡下游预付红冲',
                        v_adjust_user,
                        ('v_down_settle_id=' || v_down_settle_id));

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_sup_adjust_down_pre', sqlerrm, 1);
  
end;
/

prompt
prompt Creating procedure DSUP_P_ADJUST_UP_AFTER
prompt =========================================
prompt
create or replace procedure fd_account.dsup_p_adjust_up_after(v_up_report_id number,
                                                   v_adjust_days  number,
                                                   v_adjust_user  varchar2,
                                                   v_adjust_memo  varchar2,
                                                   v_result       out varchar2) as
  ------------收卡上游后付结算红冲------------
  l_fund_batch_id number;
  l_up_settle_id  number;
  l_change_amount number;
  l_change_time   date;
  l_sup_record_id number;
  l_jz_record_id  number;
begin
  ---1.检查下游结算记录及银行相关记录
  v_result := dk_f_sup_adjust_up_after_ck(v_up_report_id,
                                          v_adjust_days,
                                          l_fund_batch_id,
                                          l_up_settle_id,
                                          l_change_amount,
                                          l_change_time);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.检查收卡系统的18渠道和记账系统的收卡渠道相关记录信息
  v_result := dk_f_sup_adjust_bind_up_check(l_fund_batch_id,
                                            l_change_amount,
                                            l_change_time,
                                            pkg_up_manual_change_type.draw_amount,
                                            l_sup_record_id,
                                            l_jz_record_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.红冲相关记录
  v_result := dk_f_sup_adjust_up_after(v_up_report_id,
                                       l_up_settle_id,
                                       l_fund_batch_id,
                                       l_sup_record_id,
                                       l_jz_record_id,
                                       v_adjust_user,
                                       v_adjust_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.人工操作记录
  fd_p_write_handle_log('收卡上游后付红冲',
                        v_adjust_user,
                        ('v_up_report_id=' || v_up_report_id));

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_sup_adjust_up_after', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_ADJUST_UP_PRE
prompt =======================================
prompt
create or replace procedure fd_account.dsup_p_adjust_up_pre(v_up_settle_id number,
                                                 v_adjust_days  number,
                                                 v_adjust_user  varchar2,
                                                 v_adjust_memo  varchar2,
                                                 v_result       out varchar2) as
  --------------收卡系统上游预付红冲-------------
  l_fund_batch_id number;
  l_change_amount number;
  l_change_time   date;
  l_sup_record_id number;
  l_jz_record_id  number;
begin
  ---1.检查下游结算记录及银行相关记录
  v_result := dk_f_sup_adjust_up_pre_check(v_up_settle_id,
                                           v_adjust_days,
                                           l_fund_batch_id,
                                           l_change_amount,
                                           l_change_time);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.检查收卡系统的18渠道和记账系统的收卡渠道相关记录信息
  v_result := dk_f_sup_adjust_bind_up_check(l_fund_batch_id,
                                            l_change_amount,
                                            l_change_time,
                                            pkg_up_manual_change_type.draw_amount,
                                            l_sup_record_id,
                                            l_jz_record_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.红冲相关记录
  v_result := dk_f_sup_adjust_up_pre(v_up_settle_id,
                                     l_sup_record_id,
                                     l_jz_record_id,
                                     v_adjust_user,
                                     v_adjust_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.人工操作记录
  fd_p_write_handle_log('收卡上游预付红冲',
                        v_adjust_user,
                        ('v_up_settle_id=' || v_up_settle_id));

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_sup_adjust_up_pre', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_AUTO_CHANNEL_SETTLE
prompt =============================================
prompt
create or replace procedure fd_account.dsup_p_auto_channel_settle as
  -----------------自动渠道结算金额生成-----------------
  l_result            varchar2(32);
  l_change_start_time date := trunc(sysdate - 10);
  l_change_end_time   date := sysdate;
  l_settle_batch_id   number;
begin
  ---1.按订单时间获取结算时间零点以前等待结算的数据
  ---*******************************************
  ---@订单时间以天为单位分批次生成结算记录
  ---@由于订单时间不确定及时性，所以建立状态索引
  ---@分批次更新等待结算的数据
  ---*******************************************
  for item in (select trunc(d.order_time) settle_data_time
                 from dk_trade_up_fund d
                 left join dk_base_down_channel dc on dc.channel_no =
                                                      d.down_channel_no
                 left join dk_base_up_channel uc on uc.channel_no =
                                                    d.up_channel_no
                where d.change_time > l_change_start_time
                  and d.change_time < l_change_end_time
                  and d.channel_settle_status =
                      pkg_dk_channel_settle_status.wait
                  and d.order_time < trunc(sysdate)
                  and d.change_type in
                      (pkg_up_fund_change_type.debit_amount,
                       pkg_up_fund_change_type.refund_amount)
                group by trunc(d.order_time)) loop
    begin
      ---2.将该批次的数据更新为正在进行结算记录创建并赋值批次号(状态锁)
      select seq_dk_channel_settle_batch_id.nextval
        into l_settle_batch_id
        from dual;
    
      update dk_trade_up_fund t
         set t.channel_settle_status   = pkg_dk_channel_settle_status.doing,
             t.channel_settle_batch_id = l_settle_batch_id
       where t.change_time > l_change_start_time
         and t.change_time < l_change_end_time
         and t.order_time >= item.settle_data_time
         and t.order_time < item.settle_data_time + 1
         and t.channel_settle_status = pkg_dk_channel_settle_status.wait
         and t.change_type in (pkg_up_fund_change_type.debit_amount,
              pkg_up_fund_change_type.refund_amount);
    end;
  end loop;

  if sql%rowcount = 0 or sql%rowcount is null then
    rollback;
    return;
  end if;

  ---3.添加渠道结算记录
  l_result := dk_f_channel_settle_add(l_change_start_time,
                                      l_change_end_time);

  if l_result != pkg_error_code.success then
    rollback;
    fd_p_b2e_warn_info_set('auto_err' ||
                           to_char(sysdate, 'yyyymmddhh24miss'),
                           pkg_warn_into_type.auto_error,
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           ' 自动生成收卡结算记录失败.',
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           '自动生成收卡结算记录失败,' || l_result,
                           '存储过程自动脚本执行错误');
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    l_result := pkg_error_code.system_busy;
  
    fd_p_write_log('dk_p_auto_channel_settle', sqlerrm, 1);
    fd_p_b2e_warn_info_set('auto_err' ||
                           to_char(sysdate, 'yyyymmddhh24miss'),
                           pkg_warn_into_type.auto_error,
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           ' 自动生成收卡结算记录失败.',
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           '自动生成收卡结算记录失败,' || l_result,
                           '存储过程自动脚本执行错误');
end;
/

prompt
prompt Creating procedure DSUP_P_MANU_DOWN_SETTLE_AFTER
prompt ================================================
prompt
create or replace procedure fd_account.dsup_p_manu_down_settle_after(v_down_channel_no  varchar2,
                                                          v_down_account_id  number,
                                                          v_bank_account_id  number,
                                                          v_settle_record_id number,
                                                          v_service_fee      number,
                                                          v_partner_account  varchar2, --对方的银行账户,没有传'-'
                                                          v_settle_user      varchar2,
                                                          v_settle_memo      varchar2,
                                                          v_remark_name      varchar2,--添加收付款账户名称
                                                          v_result           out varchar2) as
  ---------------------------------
  --功能：收卡系统下游后付结算
  --修改人：周荣省
  --修改时间：2019-08-27
  --修改内容：添加收付款账户名称
  ---------------------------------
  l_sup_up_channel_no varchar2(32) := '101';
  l_jz_up_channel_no  varchar2(32) := '18dc_gw';
  l_sup_up_account_id number;
  l_jz_up_account_id  number;
  l_sup_up_company_id number;
  l_jz_up_company_id  number;
  l_channel_name      varchar2(100);
  l_account_name      varchar2(100);
  v_settle_amount     number;
begin
  ---1.检查收卡中关联18的上游、直充系统中18关联收卡的上游相关数据是否正确
  v_result := dk_f_sup_bind_up_check(l_sup_up_channel_no,
                                     l_jz_up_channel_no,
                                     l_sup_up_account_id,
                                     l_jz_up_account_id,
                                     l_sup_up_company_id,
                                     l_jz_up_company_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.检查结算记录、收卡下游相关数据是否正确
  v_result := dk_f_sup_down_settle_after_ck(v_settle_record_id,
                                            v_down_channel_no,
                                            v_down_account_id,
                                            v_bank_account_id,
                                            v_service_fee,
                                            l_channel_name,
                                            l_account_name,
                                            v_settle_amount);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.进行收卡下游渠道后付结算
  v_result := dk_f_sup_down_settle_after(v_down_channel_no,
                                         v_down_account_id,
                                         v_bank_account_id,
                                         v_settle_record_id,
                                         l_channel_name,
                                         l_account_name,
                                         l_sup_up_channel_no,
                                         l_sup_up_account_id,
                                         l_sup_up_company_id,
                                         l_jz_up_channel_no,
                                         l_jz_up_account_id,
                                         l_jz_up_company_id,
                                         v_settle_amount,
                                         v_service_fee,
                                         v_partner_account,
                                         v_settle_user,
                                         v_remark_name,
                                         v_settle_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.人工操作记录
  fd_p_write_handle_log('收卡下游后付结算',
                        v_settle_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_settle_record_id=' || v_settle_record_id));

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_sup_down_settle_after', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_MANU_DOWN_SETTLE_PRE
prompt ==============================================
prompt
create or replace procedure fd_account.dsup_p_manu_down_settle_pre(v_down_channel_no varchar2, ---结算下游渠道编号
                                                        v_down_account_id number, ---结算下游账户
                                                        v_bank_account_id number, ---结算使用的银行账户
                                                        v_settle_amount   number, ---结算金额
                                                        v_service_fee     number, ---结算支付的手续费
                                                        v_partner_account varchar2, ---对方银行账户，为空传'-'
                                                        v_settle_user     varchar2, ---结算操作人
                                                        v_settle_memo     varchar2, ---结算备注
                                                        v_remark_name     varchar2, --添加收付款账户名称
                                                        v_result          out varchar2) as
  -----------------------------
  --功能：收卡系统下游预付结算
  --修改人：周荣省
  --修改时间：2019-08-26
  --修改内容：添加收付款账户名称
  -----------------------------
  l_sup_up_channel_no varchar2(32) := '101';
  l_jz_up_channel_no  varchar2(32) := '18dc_gw';
  l_sup_up_account_id number;
  l_jz_up_account_id  number;
  l_sup_up_company_id number;
  l_jz_up_company_id  number;
  l_channel_name      varchar2(100);
  l_account_name      varchar2(100);
  l_number            number;
begin
  ---1.检查收卡中关联18的上游、直充系统中18关联收卡的上游相关数据是否正确
  v_result := dk_f_sup_bind_up_check(l_sup_up_channel_no,
                                     l_jz_up_channel_no,
                                     l_sup_up_account_id,
                                     l_jz_up_account_id,
                                     l_sup_up_company_id,
                                     l_jz_up_company_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.检查金额、收卡下游是否正确
  v_result := dk_f_sup_down_settle_pre_check(v_down_channel_no,
                                             v_down_account_id,
                                             v_bank_account_id,
                                             v_settle_amount,
                                             v_service_fee,
                                             l_channel_name,
                                             l_account_name);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.进行收卡下游渠道预付结算
  v_result := dk_f_sup_down_settle_pre(v_down_channel_no,
                                       v_down_account_id,
                                       v_bank_account_id,
                                       l_channel_name,
                                       l_account_name,
                                       l_sup_up_channel_no,
                                       l_sup_up_account_id,
                                       l_sup_up_company_id,
                                       l_jz_up_channel_no,
                                       l_jz_up_account_id,
                                       l_jz_up_company_id,
                                       v_settle_amount,
                                       v_service_fee,
                                       v_partner_account,
                                       v_settle_user,
                                       v_remark_name,
                                       v_settle_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.人工操作记录
  fd_p_write_handle_log('收卡下游预付结算',
                        v_settle_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_settle_amount=' || v_settle_amount));
  --5.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_down_account_id
     and t.co_account_type = 8
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(v_down_account_id,
                                         8,
                                         v_remark_name,
                                         v_settle_user);
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_sup_down_settle_pre', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_MANU_DOWN_SETTLE_PRE_T
prompt ================================================
prompt
create or replace procedure fd_account.dsup_p_manu_down_settle_pre_t(v_down_channel_no varchar2, ---结算下游渠道编号
                                                          v_down_account_id number, ---结算下游账户
                                                          v_record_no       varchar2, ---外部加款编号
                                                          v_settle_amount   number, ---结算金额
                                                          v_service_fee     number, ---结算支付的手续费
                                                          v_partner_account varchar2, ---对方银行账户，为空传'-'
                                                          v_settle_user     varchar2, ---结算操作人
                                                          v_settle_memo     varchar2, ---结算备注
                                                          v_result          out varchar2) as
  ---------------收卡系统下游预付结算--------------
  l_channel_name varchar2(100);
  l_account_name varchar2(100);
begin
  ---1.检查金额、收卡下游是否正确
  v_result := dk_f_sup_down_settle_pre_ck_t(v_down_channel_no,
                                            v_down_account_id,
                                            v_record_no,
                                            v_settle_amount,
                                            v_service_fee,
                                            l_channel_name,
                                            l_account_name);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.下游渠道加款
  v_result := dk_f_sup_down_settle_t(v_down_channel_no,
                                     v_down_account_id,
                                     v_record_no,
                                     pkg_down_fund_change_type.add_amount,
                                     v_settle_amount,
                                     0,
                                     v_partner_account,
                                     v_settle_user,
                                     v_settle_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dsup_p_manu_down_settle_pre_t', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_MANU_UP_SETTLE_AFTER
prompt ==============================================
prompt
create or replace procedure fd_account.dsup_p_manu_up_settle_after(v_up_channel_no    varchar2,
                                                        v_up_account_id    number,
                                                        v_bank_account_id  number,
                                                        v_settle_record_id number,
                                                        v_partner_account  varchar2,
                                                        v_settle_user      varchar2,
                                                        v_settle_memo      varchar2,
                                                        v_remark_name      varchar2,   
                                                        v_result           out varchar2) as
  --------------收卡上游后付结算-------------

  l_sup_up_channel_no varchar2(32) := '101';
  l_jz_up_channel_no  varchar2(32) := '18dc_gw';
  l_sup_up_account_id number;
  l_jz_up_account_id  number;
  l_sup_up_company_id number;
  l_jz_up_company_id  number;
  l_up_company_id     number;
  l_channel_name      varchar2(100);
  l_account_name      varchar2(100);
  l_settle_amount     number;
begin
  ---1.检查收卡中关联18的上游、直充系统中18关联收卡的上游相关数据是否正确
  v_result := dk_f_sup_bind_up_check(l_sup_up_channel_no,
                                     l_jz_up_channel_no,
                                     l_sup_up_account_id,
                                     l_jz_up_account_id,
                                     l_sup_up_company_id,
                                     l_jz_up_company_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.检查结算记录、收卡下游相关数据是否正确
  v_result := dk_f_sup_up_settle_after_ck(v_up_channel_no,
                                          v_up_account_id,
                                          v_bank_account_id,
                                          v_settle_record_id,
                                          l_sup_up_channel_no,
                                          l_up_company_id,
                                          l_channel_name,
                                          l_account_name,
                                          l_settle_amount);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.进行收卡下游渠道后付结算
  v_result := dk_f_sup_up_settle_after(v_up_channel_no,

                                       v_up_account_id,
                                       l_up_company_id,
                                       v_bank_account_id,
                                       v_settle_record_id,
                                       l_channel_name,
                                       l_account_name,
                                       l_sup_up_channel_no,
                                       l_sup_up_account_id,
                                       l_sup_up_company_id,
                                       l_jz_up_channel_no,
                                       l_jz_up_account_id,
                                       l_jz_up_company_id,
                                       l_settle_amount,
                                       v_partner_account,
                                       v_settle_user,
                                       v_remark_name,
                                       v_settle_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.人工操作记录
  fd_p_write_handle_log('收卡上游后付结算',
                        v_settle_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_settle_record_id=' || v_settle_record_id));

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_sup_up_settle_after', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_MANU_UP_SETTLE_PRE
prompt ============================================
prompt
create or replace procedure fd_account.dsup_p_manu_up_settle_pre(v_up_channel_no   varchar2,
                                                      v_up_account_id   number,
                                                      v_bank_account_id number,
                                                      v_settle_amount   number,
                                                      v_partner_account varchar2,
                                                      v_settle_user     varchar2,
                                                      v_settle_memo     varchar2,
                                                      v_remark_name     varchar2, --收付款账户名称
                                                      v_result          out varchar2) as
  ----------------------------
  --功能：收卡上游预付结算
  --修改人：周荣省
  --修改时间：2019-08-26
  --修改内容：添加收付款账户名称
  ----------------------------
  l_sup_up_channel_no varchar2(32) := '101';
  l_jz_up_channel_no  varchar2(32) := '18dc_gw';
  l_sup_up_account_id number;
  l_jz_up_account_id  number;
  l_sup_up_company_id number;
  l_jz_up_company_id  number;
  l_up_company_id     number;
  l_account_name      varchar2(100);
  l_channel_name      varchar2(100);
  l_number            number;
begin
  ---1.检查收卡中关联18的上游、直充系统中18关联收卡的上游相关数据是否正确
  v_result := dk_f_sup_bind_up_check(l_sup_up_channel_no,
                                     l_jz_up_channel_no,
                                     l_sup_up_account_id,
                                     l_jz_up_account_id,
                                     l_sup_up_company_id,
                                     l_jz_up_company_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.检查金额、收卡结算上游是否正确
  v_result := dk_f_sup_up_settle_pre_check(v_up_channel_no,
                                           v_up_account_id,
                                           v_bank_account_id,
                                           l_sup_up_channel_no,
                                           v_settle_amount,
                                           l_up_company_id,
                                           l_channel_name,
                                           l_account_name);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.进行收卡上游渠道预付结算
  v_result := dk_f_sup_up_settle_pre(v_up_channel_no,
                                     v_up_account_id,
                                     l_up_company_id,
                                     v_bank_account_id,
                                     l_channel_name,
                                     l_account_name,
                                     l_sup_up_channel_no,
                                     l_sup_up_account_id,
                                     l_sup_up_company_id,
                                     l_jz_up_channel_no,
                                     l_jz_up_account_id,
                                     l_jz_up_company_id,
                                     v_settle_amount,
                                     v_partner_account,
                                     v_settle_user,
                                     v_remark_name,
                                     v_settle_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.人工操作记录
  fd_p_write_handle_log('收卡上游预付结算',
                        v_settle_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_settle_amount=' || v_settle_amount));
  --5.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_up_account_id
     and t.co_account_type = 8
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(v_up_account_id,
                                         8,
                                         v_remark_name,
                                         v_settle_user);
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_sup_up_settle_pre', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_MANU_UP_SETTLE_PRE_T
prompt ==============================================
prompt
create or replace procedure fd_account.dsup_p_manu_up_settle_pre_t(v_up_channel_no   varchar2, ---上游渠道
                                                        v_up_account_id   number, ---上游渠道账户
                                                        v_record_no       varchar2, ---外部加款编号
                                                        v_settle_amount   number, ---结算金额
                                                        v_partner_account varchar2, ---对方银行账户，没有传‘-’
                                                        v_settle_user     varchar2, ---结算人
                                                        v_settle_memo     varchar2, ---结算备注
                                                        v_result          out varchar2) as
  --------------收卡上游预付结算-------------

  l_up_company_id number;
  l_account_name  varchar2(100);
  l_channel_name  varchar2(100);
begin
  ---1.检查金额、收卡结算上游是否正确
  v_result := dk_f_sup_up_settle_pre_ck_t(v_up_channel_no,
                                          v_up_account_id,
                                          v_record_no,
                                          v_settle_amount,
                                          l_up_company_id,
                                          l_channel_name,
                                          l_account_name);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.上游渠道结算(上游加款)
  v_result := dk_f_sup_up_settle_t(v_up_channel_no,
                                   v_up_account_id,
                                   l_up_company_id,
                                   v_record_no,
                                   0,
                                   pkg_up_fund_change_type.add_amount,
                                   v_settle_amount,
                                   v_partner_account,
                                   v_settle_user,
                                   v_settle_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dsup_p_manu_up_settle_pre_t', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_TRADE_DOWN_ORDER_PAY
prompt ==============================================
prompt
create or replace procedure fd_account.dsup_p_trade_down_order_pay(v_source_name     in varchar2, ---系统名称
                                                        v_down_channel_no in varchar2, --下游渠道
                                                        v_trade_order_no  in varchar2, ---外部系统交易订单号
                                                        v_trade_fund_no   in varchar2, --收卡下游资金变动编号
                                                        v_is_adjust       in varchar2, --是否为二次结算
                                                        v_ext_order_no    in varchar2, ---下游商户的订单号
                                                        v_deduct_account  in varchar2, --- 代扣账号
                                                        v_business_type   in number, --- 代扣业务: 点播-17,包月-18,sdk-19
                                                        v_carrier_no      in varchar2, ---运营商
                                                        v_province_no     in varchar2, ---省份
                                                        v_city_no         in varchar2, ---城市
                                                        v_total_face      in number, --面值
                                                        v_deduct_unit     in number, --扣款总量（目前和面值相同）
                                                        v_order_time      in varchar2, --订单时间
                                                        v_trade_time      in varchar2, --交易系统变动时间
                                                        v_settle_amount   in number, --结算给商户的金额
                                                        v_service_pay     in number, --下游收取手续费
                                                        v_memo            in varchar2, --备注
                                                        v_result          out varchar2,
                                                        v_msg             out varchar2) as
  pragma autonomous_transaction; --自治事务
  ----------------------收卡系统下游扣款----------------------
  v_order_source     number;
  l_fd_business_type number;
begin

  v_result := dk_f_system_id_get(v_source_name, v_order_source);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---0.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---1.历史库获取订单
  v_result := dk_f_trade_pay_hs_move(v_order_source,
                                     v_down_channel_no,
                                     v_trade_order_no,
                                     v_order_time,
                                     1,
                                     v_settle_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.检查订单是否存在，不存在则创建订单
  v_result := dk_f_trade_order_create(v_order_source,
                                      v_down_channel_no,
                                      v_trade_order_no,
                                      v_ext_order_no,
                                      v_deduct_account,
                                      l_fd_business_type,
                                      v_carrier_no,
                                      v_province_no,
                                      v_city_no,
                                      v_total_face,
                                      v_deduct_unit,
                                      v_settle_amount,
                                      v_order_time,
                                      1);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.下游资金变动扣款(锁订单，检查扣款记录是否存在，锁定账户，添加资金变动)
  v_result := dk_f_sup_down_order_fee_mus(v_order_source,
                                          v_down_channel_no,
                                          v_trade_order_no,
                                          v_trade_fund_no,
                                          v_is_adjust,
                                          v_ext_order_no,
                                          v_order_time,
                                          v_trade_time,
                                          v_settle_amount,
                                          v_service_pay,
                                          v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('dk_p_trade_down_order_fee_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_TRADE_DOWN_ORDER_REF
prompt ==============================================
prompt
create or replace procedure fd_account.dsup_p_trade_down_order_ref(v_source_name     in varchar2, ---系统名称
                                                        v_down_channel_no in varchar2, ---下游渠道
                                                        v_trade_order_no  in varchar2, ---交易系统订单号
                                                        v_trade_refund_no in varchar2, --- 交易系统退款编号,同trade_order_no订单的多次退款,应不相同
                                                        v_refund_unit     in number, --- 退款规格（对于没有拆单的订单,必须等于订单面值）
                                                        v_refund_face     in number, --- 退款面值（同上）
                                                        v_refund_amount   in number, --- 退款金额,不能大于面值
                                                        v_real_refund     in number, --- 实际退款金额(无佣金时和退款金额一致)
                                                        v_order_date      in varchar2, ---订单时间
                                                        v_trade_time      in varchar2, ---交易系统退款时间
                                                        v_service_fee     in number, --- 手续费
                                                        v_memo            in varchar2, ---备注
                                                        v_result          out varchar2) as
  pragma autonomous_transaction; --自治事务
  ----------------收卡系统下游退款------------------
  ---- 规则：退款金额可以超过扣款金额，但不能超过面值
  v_order_source number;
begin

  v_result := dk_f_system_id_get(v_source_name, v_order_source);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.获取历史库中的数据
  v_result := dk_f_trade_hs_move(v_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.下游订单退款
  v_result := dk_f_sup_down_fee_refund(v_order_source,
                                       v_down_channel_no,
                                       v_trade_order_no,
                                       v_trade_refund_no,
                                       v_refund_unit,
                                       v_refund_face,
                                       v_refund_amount,
                                       v_real_refund,
                                       v_order_date,
                                       v_trade_time,
                                       v_service_fee,
                                       v_memo);

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_trade_down_order_fee_ref', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_TRADE_UP_ORDER_PAY
prompt ============================================
prompt
create or replace procedure fd_account.dsup_p_trade_up_order_pay(v_source_name       in varchar2, ---系统名称
                                                      v_down_channel_no   in varchar2, ---下游渠道
                                                      v_up_channel_no     in varchar2, ---上游渠道
                                                      v_trade_order_no    in varchar2, ---交易系统订单号
                                                      v_trade_delivery_no in varchar2, ---交易系统发货编号
                                                      v_ext_order_no      in varchar2, ---交易系统上游订单号
                                                      v_deduct_account    in varchar2, -- 代扣账户
                                                      v_bill_type         in number, -- 代扣业务传2-后向
                                                      v_business_type     in number, -- 代扣业务: 点播-17,包月-18,sdk-19
                                                      v_carrier_no        in varchar2, ---运营商
                                                      v_province_no       in varchar2, ---省份
                                                      v_city_no           in varchar2, ---城市
                                                      v_down_order_unit   in number, -- 订单代扣规格
                                                      v_down_order_face   in number, -- 订单代扣面值
                                                      v_down_draw_unit    in number, -- 下游代扣规格
                                                      v_down_draw_face    in number, -- 下游代扣面值
                                                      v_down_draw_amount  in number, -- 下游结算金额
                                                      v_down_real_amount  in number, -- 下游实际结算金额
                                                      v_up_draw_unit      in number, -- 上游代扣规格
                                                      v_up_draw_face      in number, -- 上游代扣面值
                                                      v_up_draw_amount    in number, -- 上游结算金额（结算给我方）
                                                      v_up_real_amount    in number, -- 上游实际结算金额
                                                      v_order_time        in varchar2, --订单时间
                                                      v_trade_time        in varchar2, --上游资金变动时间
                                                      v_service_fee       in number, --手续费
                                                      v_memo              in varchar2, --备注
                                                      v_result            out varchar2) as
  pragma autonomous_transaction; --自治事务
  --------------代扣业务：上游扣款--------------
  --- yangdj 20161019
  l_up_account_id    number;
  v_order_source     number;
  l_fd_business_type number;
begin

  v_result := dk_f_system_id_get(v_source_name, v_order_source);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---0.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---1.检查上游渠道、账户及其关联情况
  v_result := dk_f_trade_pay_account_get(v_order_source,
                                         v_up_channel_no,
                                         l_up_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.1历史库获取订单
  v_result := dk_f_trade_pay_hs_move(v_order_source,
                                     v_down_channel_no,
                                     v_trade_order_no,
                                     v_order_time,
                                     1,
                                     v_down_draw_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.检查订单是否存在，不存在则创建订单
  v_result := dk_f_trade_order_create(v_order_source,
                                      v_down_channel_no,
                                      v_trade_order_no,
                                      v_ext_order_no,
                                      v_deduct_account,
                                      l_fd_business_type,
                                      v_carrier_no,
                                      v_province_no,
                                      v_city_no,
                                      v_down_order_face,
                                      v_down_order_unit,
                                      v_down_draw_amount,
                                      v_order_time,
                                      1);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.上游支付扣款
  v_result := dk_f_sup_up_order_minus(v_order_source,
                                      v_trade_order_no,
                                      v_trade_delivery_no,
                                      v_up_channel_no,
                                      l_up_account_id,
                                      v_up_draw_unit,
                                      v_up_draw_face,
                                      v_up_draw_amount,
                                      v_up_real_amount,
                                      v_down_draw_unit,
                                      v_down_draw_face,
                                      v_down_draw_amount,
                                      v_down_real_amount,
                                      v_bill_type,
                                      v_order_time,
                                      v_trade_time,
                                      v_service_fee,
                                      v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_trade_up_order_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure DSUP_P_TRADE_UP_ORDER_REFUND
prompt ===============================================
prompt
create or replace procedure fd_account.dsup_p_trade_up_order_refund(v_source_name             in varchar2, ---系统名称
                                                         v_down_channel_no         in varchar2, ---下游渠道
                                                         v_up_channel_no           in varchar2, ---上游渠道
                                                         v_trade_order_no          in varchar2, ---交易系统订单号
                                                         v_trade_delivery_no       in varchar2, ---交易系统发货编号
                                                         v_trade_refund_no         in varchar2, -- 退款编号（相同的退款编号被认为是同一笔退款的重复请求）
                                                         v_bill_type               in number, -- 是否开票，1不开，2要开
                                                         v_business_type           in number, -- 业务类型
                                                         v_carrier_no              in varchar2, --运营商
                                                         v_province_no             in varchar2, --省份
                                                         v_up_refund_unit          in number, -- 退款总规格
                                                         v_up_refund_face          in number, -- 退款总面值
                                                         v_up_refund_amount        in number, -- 退款金额
                                                         v_up_refund_real_amount   in number, -- 退款实际金额
                                                         v_down_refund_unit        in number, -- 下游退款总规格
                                                         v_down_refund_face        in number, -- 下游退款总面值
                                                         v_down_refund_amount      in number, -- 下游退款金额
                                                         v_down_refund_real_amount in number, -- 下游实际退款金额
                                                         v_order_time              in varchar2, --订单时间
                                                         v_trade_time              in varchar2, --交易系统退款时间
                                                         v_service_fee             in number, ---手续费
                                                         v_memo                    in varchar2, --备注
                                                         v_result                  out varchar2) as
  pragma autonomous_transaction; --自治事务
  --------------代扣业务：上游退款--------------
  v_order_source     number;
  l_fd_business_type number;
begin

  v_result := dk_f_system_id_get(v_source_name, v_order_source);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---0.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---1.获取历史库中的数据
  v_result := dk_f_trade_hs_move(v_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;
  ---2.上游支付退款
  v_result := dk_f_sup_up_order_refund(v_order_source,
                                       v_down_channel_no,
                                       v_up_channel_no,
                                       v_trade_order_no,
                                       v_trade_delivery_no,
                                       v_trade_refund_no,
                                       v_bill_type,
                                       l_fd_business_type,
                                       v_carrier_no,
                                       v_province_no,
                                       v_up_refund_unit,
                                       v_up_refund_face,
                                       v_up_refund_amount,
                                       v_up_refund_real_amount,
                                       v_order_time,
                                       v_trade_time,
                                       v_service_fee,
                                       v_memo,
                                       v_down_refund_unit, -- 下游退款总规格
                                       v_down_refund_face, -- 下游退款总面值
                                       v_down_refund_amount, -- 下游退款金额
                                       v_down_refund_real_amount -- 下游实际退款金额
                                       );

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('dk_p_trade_up_order_refund', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ACTIVITY_PREPAY
prompt =======================================
prompt
create or replace procedure fd_account.fd_p_activity_prepay(v_activity_id     number, ---记账系统的活动编号
                                                 v_bank_account_id number, ---银行账户编号
                                                 v_trade_record_no varchar2, ---外部操作的记录编号
                                                 v_prepay_amount   number, ---预付的金额
                                                 v_service_fee     number, ---预付费手续费
                                                 v_handle_user     varchar2, ---操作人
                                                 v_memo            varchar2, ---备注信息
                                                 v_result          out varchar2) as
  ----------------活动预支付（从公司利润中拿出一部分作为活动预付费用）--------------

  l_down_channel_no varchar2(32);
  l_down_account_id number;
  l_down_company_id number;
  l_trade_record_no varchar2(32) := 'ACT' || v_trade_record_no;
  l_account_name    varchar2(32);
  l_channel_name    varchar2(32);
begin
  ---1.检查活动信息
  v_result := fd_f_activity_info_check(v_activity_id,
                                       l_trade_record_no,
                                       v_prepay_amount,
                                       l_down_channel_no,
                                       l_down_account_id,
                                       l_down_company_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.检查下游渠道、账户及其关联情况
  v_result := fd_f_manual_down_draw_check(l_down_channel_no,
                                          l_down_account_id,
                                          v_bank_account_id,
                                          v_prepay_amount,
                                          v_service_fee,
                                          l_account_name,
                                          l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.添加预付费详情记录
  v_result := fd_f_activity_details_add(v_activity_id,
                                        l_trade_record_no,
                                        pkg_activity_change_type.prepay,
                                        0,
                                        1,
                                        v_prepay_amount,
                                        v_handle_user,
                                        '活动预付款:' || v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  ---4.账户手工加款(锁实体卡账户、渠道账户、手续费账户)
  v_result := fd_f_manual_down_draw(l_down_channel_no,
                                    l_down_account_id,
                                    v_bank_account_id,
                                    v_prepay_amount,
                                    v_service_fee,
                                    v_handle_user,
                                    '-',
                                    l_trade_record_no || '|' || '活动预付款:' ||
                                    v_memo,
                                    l_account_name,
                                    '',
                                    l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_activity_prepay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ACTIVITY_PROFIT_ADD
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_activity_profit_add(v_order_source      number, ---来源系统编号
                                                     v_activity_id       number,
                                                     v_trade_record_no   varchar2,
                                                     v_business_type     number,
                                                     v_bill_type         number,
                                                     v_add_profit_amount number,
                                                     v_handle_user       varchar2,
                                                     v_memo              varchar2,
                                                     v_result            out varchar2) as
  -------------------增加搞活动产生的利润------------------
  l_down_channel_no  varchar2(32);
  l_down_account_id  number;
  l_down_company_id  number;
  l_fd_business_type number;
  l_trade_record_no  varchar2(32) := 'ACT' || v_trade_record_no;
begin
  ---1.检查活动信息
  v_result := fd_f_activity_info_check(v_activity_id,
                                       l_trade_record_no,
                                       v_add_profit_amount,
                                       l_down_channel_no,
                                       l_down_account_id,
                                       l_down_company_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.获取外部系统业务类型对应的记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---3.添加活动利润变动记录
  v_result := fd_f_activity_details_add(v_activity_id,
                                        l_trade_record_no,
                                        pkg_activity_change_type.add_profit,
                                        l_fd_business_type,
                                        v_bill_type,
                                        v_add_profit_amount,
                                        v_handle_user,
                                        '投入资金:' || v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---4.下游渠道交易平账
  v_result := fd_f_activity_down_rv_trade(v_order_source,
                                          l_down_channel_no,
                                          l_down_account_id,
                                          l_down_company_id,
                                          l_trade_record_no,
                                          v_add_profit_amount, ---平账为正数，下游扣款增加，毛利增加
                                          v_add_profit_amount,
                                          l_fd_business_type,
                                          v_bill_type,
                                          v_handle_user,
                                          '投入资金:' || v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_activity_profit_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ACTIVITY_PROFIT_MINUS
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_activity_profit_minus(v_order_source        number, ---来源系统编号
                                                       v_activity_id         number,
                                                       v_trade_record_no     varchar2,
                                                       v_business_type       number,
                                                       v_bill_type           number,
                                                       v_minus_profit_amount number,
                                                       v_handle_user         varchar2,
                                                       v_memo                varchar2,
                                                       v_result              out varchar2) as
  -------------------增加搞活动产生的利润------------------
  l_down_channel_no  varchar2(32);
  l_down_account_id  number;
  l_down_company_id  number;
  l_fd_business_type number;
  l_trade_record_no  varchar2(32) := 'ACT' || v_trade_record_no;
begin
  ---1.检查活动信息
  v_result := fd_f_activity_info_check(v_activity_id,
                                       l_trade_record_no,
                                       v_minus_profit_amount,
                                       l_down_channel_no,
                                       l_down_account_id,
                                       l_down_company_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.获取外部系统业务类型对应的记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---3.添加活动利润变动记录
  v_result := fd_f_activity_details_add(v_activity_id,
                                        l_trade_record_no,
                                        pkg_activity_change_type.minus_profit,
                                        l_fd_business_type,
                                        v_bill_type,
                                        v_minus_profit_amount,
                                        v_handle_user,
                                        '回笼资金:' || v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---4.下游渠道交易平账
  v_result := fd_f_activity_down_rv_trade(v_order_source,
                                          l_down_channel_no,
                                          l_down_account_id,
                                          l_down_company_id,
                                          l_trade_record_no,
                                          -1 * v_minus_profit_amount, ---平账为负数，下游扣款减少，毛利减少
                                          -1 * v_minus_profit_amount,
                                          l_fd_business_type,
                                          v_bill_type,
                                          v_handle_user,
                                          '回笼资金:' || v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_activity_profit_minus', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_CAPITAL_HANDER
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_adjust_capital_hander(v_record_id   in number, ---红冲的借支、押金、保证金编号
                                                       v_hander_user in varchar2, ---操作人  
                                                       v_adjust_days in number, ---红冲天数                                                      
                                                       v_memo        in varchar2, ---备注
                                                       v_result      out varchar2) as
  -----------------红冲 借支、押金、保证金、短期借贷、转账退款相关记录-----------------
  l_bank_record_id number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('资产账户账务记录红冲',
                        v_hander_user,
                        ('v_record_id=' || v_record_id));

  ---2.检查相关数据
  v_result := fd_f_adjust_capital_check(v_record_id,
                                        v_adjust_days,
                                        l_bank_record_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.红冲借支、押金、保证金
  v_result := fd_f_adjust_capital_record(v_record_id,
                                         l_bank_record_id,
                                         v_hander_user,
                                         v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_capital_hander', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_COMMISION_SETTLE
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_adjust_commision_settle(v_record_id   in number, ---红冲的加款编号
                                                         v_create_user in varchar2, ---操作人
                                                         v_memo        in varchar2, ---备注
                                                         v_result      out varchar2) as
  ---------------------------------------
  --功能：佣金结算红冲
  --创建人：周荣省
  --创建时间：2019-08-21
  ---------------------------------------
begin
  ---0.记录操作日志
  fd_p_write_handle_log('渠道佣金结算红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---1.检查佣金结算记录
  v_result := fd_f_commision_settle_check(v_record_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.渠道佣金结算红冲
  v_result := fd_f_adjust_commision_settle(v_record_id,v_create_user,v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_commision_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_COMPANY_SETTLE
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_adjust_company_settle(v_co_settle_fund_id in number, ---公司间结算加款资金变动编号
                                                       v_adjust_user       in varchar2, ---操作人
                                                       v_adjust_days       in number, ---红冲天数
                                                       v_memo              in varchar2, ---备注
                                                       v_result            out varchar2) as

  --------------------红冲公司间结算加款---------------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('公司间结算红冲',
                        v_adjust_user,
                        ('v_co_settle_fund_id=' || v_co_settle_fund_id));

  ---2.检查记录及相关账户余额
  v_result := fd_f_adjust_co_settle_check(v_co_settle_fund_id,
                                          v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.红冲公司间结算记录
  v_result := fd_f_adjust_co_settle_record(v_co_settle_fund_id,
                                           v_adjust_user,
                                           v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_company_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_DOWN_BORROW_ADD
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_adjust_down_borrow_add(v_record_id   in number, ---红冲的借支账户流水号
                                                        v_create_user in varchar2, ---操作人
                                                        v_adjust_days in number, ---红冲天数
                                                        v_memo        in varchar2, ---备注
                                                        v_result      out varchar2) as
  --------------下游借支账户加款红冲----------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游借支账户加款红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---2. 检查借支账户、渠道账户
  v_result := fd_f_adjust_down_borrow_check(v_record_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3. 红冲借支加款、渠道加款及下游手续费记录
  v_result := fd_f_adjust_down_borrow_add(v_record_id,
                                          v_create_user,
                                          v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_down_borrow_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_DOWN_DEPOSIT_ADD
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_adjust_down_deposit_add(v_record_id   in number, ---红冲的加款编号
                                                         v_create_user in varchar2, ---操作人
                                                         v_adjust_days in number, ---红冲天数
                                                         v_memo        in varchar2, ---备注
                                                         v_result      out varchar2) as
  --------------押金类 资产账户转下游加款红冲----------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('押金类下游加款红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---2. 检查加款记录、账户、余额、手续费
  v_result := fd_f_adjust_down_dep_add_ck(v_record_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3. 红冲下游手工加款记录
  v_result := fd_f_adjust_down_dep_add(v_record_id, v_create_user, v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_down_deposit_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_DOWN_MANUAL_ADD
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_adjust_down_manual_add(v_record_id   in number, ---红冲的加款编号
                                                        v_create_user in varchar2, ---操作人
                                                        v_adjust_days in number, ---红冲天数
                                                        v_memo        in varchar2, ---备注
                                                        v_result      out varchar2) as
  --------------下游手工加款红冲----------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游人工加款红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---2. 检查加款记录、账户、余额、手续费
  v_result := fd_f_adjust_down_add_check(v_record_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3. 红冲下游手工加款记录
  v_result := fd_f_adjust_down_add_handle(v_record_id,
                                          v_create_user,
                                          v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_down_manual_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_DOWN_MANUAL_DRAW
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_adjust_down_manual_draw(v_record_id   in number, ---红冲的加款编号
                                                         v_create_user in varchar2, ---操作人
                                                         v_adjust_days in number, ---红冲天数
                                                         v_memo        in varchar2, ---备注
                                                         v_result      out varchar2) as
  --------------下游手工加款红冲----------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游人工提款红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---2. 检查加款记录、账户、余额、手续费
  v_result := fd_f_adjust_down_draw_check(v_record_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3. 红冲下游手工加款记录
  v_result := fd_f_adjust_down_draw_handle(v_record_id,
                                           v_create_user,
                                           v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_down_manual_draw', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_DOWN_REFUND
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_adjust_down_refund(v_order_source    number, ---外部系统编号
                                                    v_down_channel_no varchar2, ---下游渠道编号
                                                    v_trade_order_no  varchar2, ---外部系统交易订单号
                                                    v_adjust_no       varchar2, ---外部系统红冲编号
                                                    v_adjust_unit     number, ---红冲退款规格
                                                    v_adjust_face     number, ---红冲退款面值
                                                    v_adjust_amount   number, ---红冲交易退款
                                                    v_adjust_refund   number, ---红冲真实退款
                                                    v_adjust_time     varchar2, ---可空，红冲时间
                                                    v_memo            varchar2, ---备注
                                                    v_result          out varchar2,
                                                    v_msg             out varchar2) as
  ----------------------下游退款的红冲-----------------------
begin
  ---1.获取历史库中的数据
  v_result := fd_f_trade_hs_move(v_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;
  ---2.红冲下游退款
  v_result := fd_f_adjust_down_refund_hander(v_order_source,
                                             v_down_channel_no,
                                             v_trade_order_no,
                                             v_adjust_no,
                                             v_adjust_unit,
                                             v_adjust_face,
                                             v_adjust_amount,
                                             v_adjust_refund,
                                             v_adjust_time,
                                             v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_adjust_down_refund', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_PROFIT_DRAW
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_adjust_profit_draw(v_draw_record_id in number, ---毛利提取任务编号
                                                    v_adjust_user    in varchar2, ---操作人
                                                    v_adjust_days    in number, ---红冲天数                                                        
                                                    v_memo           in varchar2, ---备注
                                                    v_result         out varchar2) as
  ------------------------红冲毛利润提现------------------------
begin
  ---1.检查记录是否正确
  v_result := fd_f_adjust_prof_draw_check(v_draw_record_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.红冲利润提取记录
  v_result := fd_f_adjust_prof_draw_record(v_draw_record_id,
                                           v_adjust_user,
                                           v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_profit_draw', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_SERVICE_HANDER
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_adjust_service_hander(v_record_id   in number, ---红冲的手续费编号
                                                       v_hander_user in varchar2, ---操作人  
                                                       v_adjust_days in number, ---红冲天数                                                      
                                                       v_memo        in varchar2, ---备注
                                                       v_result      out varchar2) as
  -----------------红冲 手续费-----------------
  l_bank_record_id number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('单独手续费红冲',
                        v_hander_user,
                        ('v_record_id=' || v_record_id));

  ---2.检查相关数据
  v_result := fd_f_adjust_service_check(v_record_id,
                                        v_adjust_days,
                                        l_bank_record_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.红冲手续费
  v_result := fd_f_adjust_service_record(v_record_id,
                                         l_bank_record_id,
                                         v_hander_user,
                                         v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_service_hander', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_TRANSFER_HANDER
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_adjust_transfer_hander(v_record_id   in number, ---红冲的转账实体卡资金变动编号
                                                        v_hander_user in varchar2, ---操作人
                                                        v_adjust_days in number, ---红冲天数
                                                        v_memo        in varchar2, ---备注
                                                        v_result      out varchar2) as
  ------------------红冲银行卡转账-----------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('银行卡转账红冲',
                        v_hander_user,
                        ('v_record_id=' || v_record_id));

  ---2.检查相关数据信息
  v_result := fd_f_adjust_transfer_check(v_record_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.红冲转账记录(锁实体卡变动、锁实体卡)
  v_result := fd_f_adjust_transfer_record(v_record_id,
                                          v_hander_user,
                                          v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_transfer_hander', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_UP_BORROW_ADD
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_adjust_up_borrow_add(v_record_id   in number, ---红冲的加款编号
                                                      v_create_user in varchar2, ---操作人
                                                      v_adjust_days in number, ---红冲天数
                                                      v_memo        in varchar2, ---备注
                                                      v_result      out varchar2) as
  --------------借支类 上游加款红冲----------------
begin
  ---1.记录操作日志 
  fd_p_write_handle_log('借支类上游加款红冲',
                        v_create_user,
                        'record_id=' || v_record_id);

  ---2. 检查加款记录、账户、余额、手续费
  v_result := fd_f_adjust_up_borrow_add_ck(v_record_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3. 红冲上游手工加款记录
  v_result := fd_f_adjust_up_borrow_add(v_record_id, v_create_user, v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_up_borrow_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_UP_DEPOSIT_ADD
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_adjust_up_deposit_add(v_record_id   in number, ---红冲的加款编号
                                                       v_create_user in varchar2, ---操作人
                                                       v_adjust_days in number, ---红冲天数
                                                       v_memo        in varchar2, ---备注
                                                       v_result      out varchar2) as
  --------------押金类 上游加款红冲----------------
begin
  ---1.记录操作日志 
  fd_p_write_handle_log('押金类上游加款红冲',
                        v_create_user,
                        'record_id=' || v_record_id);

  ---2. 检查加款记录、账户、余额
  v_result := fd_f_adjust_up_dep_add_ck(v_record_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3. 红冲上游手工加款记录
  v_result := fd_f_adjust_up_dep_add(v_record_id, v_create_user, v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_up_deposit_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_UP_MANUAL_ADD
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_adjust_up_manual_add(v_record_id   in number, ---红冲的加款编号
                                                      v_create_user in varchar2, ---操作人
                                                      v_adjust_days in number, ---红冲天数
                                                      v_memo        in varchar2, ---备注
                                                      v_result      out varchar2) as
  --------------上游手工加款红冲----------------
begin
  ---1.记录操作日志 
  fd_p_write_handle_log('上游人工加款红充',
                        v_create_user,
                        'record_id=' || v_record_id);

  ---2. 检查加款记录、账户、余额、手续费
  v_result := fd_f_adjust_up_add_check(v_record_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3. 红冲上游手工加款记录
  v_result := fd_f_adjust_up_add_handle(v_record_id, v_create_user, v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_up_manual_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_ADJUST_UP_MANUAL_DRAW
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_adjust_up_manual_draw(v_record_id   in number, ---红冲的加款编号
                                                       v_create_user in varchar2, ---操作人
                                                       v_adjust_days in number, ---红冲天数
                                                       v_memo        in varchar2, ---备注
                                                       v_result      out varchar2) as
  --------------上游手工提款红冲----------------
begin
  ---1.记录操作日志 
  fd_p_write_handle_log('上游人工提款红充',
                        v_create_user,
                        'record_id=' || v_record_id);

  ---2. 检查提款记录、账户、余额、手续费
  v_result := fd_f_adjust_up_draw_check(v_record_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3. 红冲上游手工提款记录
  v_result := fd_f_adjust_up_draw_handle(v_record_id, v_create_user, v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_adjust_up_manual_draw', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_APPLY_RV_COMPLETE
prompt =========================================
prompt
create or replace procedure fd_account.fd_p_apply_rv_complete(v_apply_id           number,--申请id
                                                   v_channel_no         varchar2,--渠道编号
                                                   v_account_id         number,--账户编号
                                                   v_deal_rv_type       number,--平账类型1：交易平账，2：余额平账
                                                   v_deal_business_type number,--处理业务类型
                                                   v_deal_bill_type     number,--处理前后向1：前向，2后向
                                                   v_deal_trade_amount  number,--处理平账金额
                                                   v_deal_real_amount   number,--处理平账真实金额
                                                   v_deal_user          varchar2,--处理人
                                                   v_deal_flow_id       number,--关联平账流水号
                                                   v_deal_memo          varchar2,--备注
                                                   v_result             out varchar2) as
  -----------------------------
  --功能：完成平账申请
  --创建人：周荣省
  --创建时间：2019-07-09
  -----------------------------
begin
  update fd_trade_rv_apply t
     set t.apply_status     = pkg_apply_rv_status.apply_complete,
         deal_rv_type       = v_deal_rv_type,
         deal_business_type = v_deal_business_type,
         deal_bill_type     = v_deal_bill_type,
         deal_trade_amount  = v_deal_trade_amount,
         deal_real_amount   = v_deal_real_amount,
         deal_time          = sysdate,
         deal_user          = v_deal_user,
         deal_flow_id       = v_deal_flow_id,
         deal_memo          = v_deal_memo
   where t.apply_id = v_apply_id
     and t.channel_no = v_channel_no
     and t.account_id = v_account_id
     and t.apply_status = pkg_apply_rv_status.apply_submit;

  if sql%rowcount != 1 then
    v_result := pkg_error_code.data_error;
    return;
  end if;
  v_result := pkg_error_code.success;
  commit;
end;
/

prompt
prompt Creating procedure FD_P_APPLY_RV_DEL
prompt ====================================
prompt
create or replace procedure fd_account.fd_p_apply_rv_del(v_apply_id           number, --申请id
                                              v_channel_no         varchar2, --渠道编号
                                              v_account_id         number, --账户编号
                                              v_deal_user          varchar2, --处理人
                                              v_deal_memo          varchar2, --备注
                                              v_result             out varchar2) as
  -----------------------------
  --功能：作废平账申请
  --创建人：周荣省
  --创建时间：2019-07-09
  -----------------------------
begin
  update fd_trade_rv_apply t
     set t.apply_status     = pkg_apply_rv_status.apply_invalid,
         deal_time          = sysdate,
         deal_user          = v_deal_user,
         deal_memo          = v_deal_memo
   where t.apply_id = v_apply_id
     and t.channel_no = v_channel_no
     and t.account_id = v_account_id
     and t.apply_status = pkg_apply_rv_status.apply_submit;

  if sql%rowcount != 1 then
    v_result := pkg_error_code.data_error;
    return;
  end if;
  v_result := pkg_error_code.success;
  commit;
end;
/

prompt
prompt Creating procedure FD_P_AUTO_AL_DOWN_UP_ADD
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_auto_al_down_up_add(v_add_date in varchar2 default null) as
  -----------------天猫上游 阿里云店铺 下游千行通信店 联合加款-------------------
  l_add_date        date := to_date(v_add_date, 'yyyymmddhh24miss');
  l_down_channel_no varchar2(32) := '2555813200'; ---千行通信店
  l_down_account_id number := 296; ---千行通信店账户
  l_up_channel_no   varchar2(32) := 'aliyun'; ---阿里云店铺
  l_up_account_id   number := 13843; ---阿里云店铺账户
  l_result          varchar2(32);
begin
  ---1.获取需加款交易量日期
  if l_add_date is null then
    l_add_date := trunc(sysdate) - 1;
  end if;

  ---2.上下游渠道关联加款
  l_result := fd_f_auto_down_up_add(l_add_date,
                                    l_down_channel_no,
                                    l_down_account_id,
                                    l_up_channel_no,
                                    l_up_account_id);
  if (l_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    l_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_auto_al_down_up_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_DOWN_ADD
prompt ====================================
prompt
create or replace procedure fd_account.fd_p_b2e_down_add(v_apply_id         in number, --加款申请编号
                                              v_down_channel_no  varchar2, ---下游渠道编号
                                              v_down_account_id  number,
                                              v_pay_time         in date, --付款时间
                                              v_apply_account_no in varchar2, --客户银行账号
                                              v_add_amount       in number, --加款金额
                                              v_create_user      varchar2, ---加款人
                                              v_memo             varchar2,
                                              v_user_id          varchar2, --操作人
                                              v_auto_add_on_time in date, --自动加款开启时间
                                              v_result           out varchar2) as
  --pragma autonomous_transaction; --自治事务
  --------------------------------
  --功能：银企直连下游渠道加款
  --创建人：周荣省
  --创建时间：2019-09-16
  --------------------------------
  l_bank_account_id number;
  l_receive_amount  number;
  l_bank_batch_id   number;
  l_account_name    varchar2(32);
  l_channel_name    varchar2(32);
  l_down_card_no    varchar2(64);

  l_recv_record_id      number;
  l_apply_id            number;
  l_tran_no             varchar2(32);
  l_receive_time        date;
  l_apply_account_name  varchar2(128);
  l_bank_account_tittle varchar2(128);
  l_status              number;
  l_number              number;
  l_bank_holder_name    varchar2(32);
begin
  --锁申请记录
  select d.apply_id, d.apply_account_name, d.status, d.bank_account_id
    into l_apply_id, l_apply_account_name, l_status, l_bank_account_id
    from fd_trade_down_add_apply d
   where d.apply_id = v_apply_id
     and d.flow_status = pkg_b2e_add_apply_status.status_wait
     for update;
  if (l_status <> pkg_b2e_add_apply_status.status_wait) then
    rollback;
    v_result := pkg_error_code.failure;
    return;
  end if;
  --自动加款
  --查找银行流水
  select t.record_id, t.bank_svr_seq, trunc(t.receive_time)
    into l_recv_record_id, l_tran_no, l_receive_time
    from fd_b2e_bank_receive_record t
   where t.receive_time >= v_pay_time - 1
     and t.receive_time < v_pay_time + 1
     and t.client_card_no = v_apply_account_no
     and t.receive_amount = v_add_amount
     and t.trade_type = 2
     and t.bank_account_id = l_bank_account_id
     and t.deal_status = Pkg_b2e_deal_status.Wait
     and t.receive_time > v_auto_add_on_time
     and rownum <= 1;

  ---1.获取收款记录信息
  v_result := fd_f_b2e_down_add_get(l_recv_record_id,
                                    v_down_channel_no,
                                    v_down_account_id,
                                    l_number,
                                    l_receive_amount,
                                    l_down_card_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.检查下游渠道、账户及其关联情况
  v_result := fd_f_manual_down_add_check(v_down_channel_no,
                                         v_down_account_id,
                                         l_bank_account_id,
                                         l_receive_amount,
                                         0,
                                         l_account_name,
                                         l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款(锁实体卡账户、渠道账户、手续费账户)
  select t.bank_holder_name
    into l_bank_holder_name
    from fd_b2e_down_white_list t
   where t.down_holder_card_no = v_apply_account_no
     and t.audit_status = pkg_audit_status.Complete
     and t.down_channel_no = v_down_channel_no
     and t.channel_account_id = v_down_account_id;
  v_result := fd_f_manual_down_add(v_down_channel_no,
                                   v_down_account_id,
                                   l_bank_account_id,
                                   l_receive_amount,
                                   0,
                                   v_create_user,
                                   l_down_card_no,
                                   (l_recv_record_id || '|' || v_memo),
                                   l_account_name,
                                   l_channel_name,
                                   l_bank_holder_name,
                                   l_bank_batch_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  ---4.修改任务状态
  v_result := fd_f_b2e_down_add_complate(l_recv_record_id,
                                         v_down_channel_no,
                                         v_down_account_id,
                                         l_bank_batch_id,
                                         v_create_user,
                                         v_apply_id,
                                         v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --5、申请记录添加银行流水
  update fd_trade_down_add_apply d
     set d.flow_status = pkg_b2e_add_apply_status.status_success,
         d.tran_no     = l_tran_no,
         d.status      = pkg_b2e_add_apply_status.status_success,
         d.audit_memo  = substr(v_memo, 1, 100),
         d.handle_time = sysdate,
         d.audit_user  = v_user_id,
         d.recive_time = l_receive_time
   where d.apply_id = v_apply_id
     and d.flow_status = pkg_b2e_add_apply_status.status_wait;
  ---6.记录操作日志
  fd_p_write_handle_log('银企直连下游加款',
                        v_create_user,
                        ('l_recv_record_id=' || l_recv_record_id));
  --7、添加通知
  select t.title
    into l_bank_account_tittle
    from fd_bank_account_info t
   where t.account_id = l_bank_account_id;
  insert into fd_system_warn
    (warn_id,
     uniq_id,
     warn_level,
     warn_type,
     title,
     warn_date,
     content,
     sync_status,
     key_word)
  values
    (seq_system_warn_id.nextval,
     'ZDJK' || v_down_channel_no,
     5,
     pkg_warn_into_type.b2e_down_auto_add,
     '下游渠道:' || l_channel_name || ' 银企直联自动加款',
     sysdate,
     '下游渠道:' || l_channel_name || ' 自动加款:' || v_add_amount || ',付款行号:' ||
     l_down_card_no || '(' || l_apply_account_name || ')' || ',收款账号:' ||
     l_bank_account_tittle || '申请编号:' || v_apply_id,
     pkg_balance_sync_status.wait,
     '下游自动加款提示');
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_down_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_B2E_DOWN_ADD
prompt =========================================
prompt
create or replace procedure fd_account.fd_p_auto_b2e_down_add(v_add_date in varchar2 default null) as
  -------------------------------------
  --功能：银企直连下游渠道自动加款
  --创建人：周荣省
  --创建时间：2019-09-12
  -------------------------------------
  l_add_date         date := to_date(v_add_date, 'yyyymmddhh24miss'); --输入时间转换成年月日时分秒格式
  l_result           varchar2(100);
  l_white_count      number;
  l_auto_amount      number;
  l_status           number;
  l_amount_total     number; --当前加款总金额
  l_auto_add_on_time date; --自动加款开启时间
begin
  if l_add_date is null then
    l_add_date := sysdate - 1;
  end if;
  --1、找到未修改银行流水的申请
  for item in (select t.apply_id,
                      t.channel_no,
                      t.account_id,
                      t.add_amount,
                      t.apply_account_no,
                      t.bank_type,
                      t.status, --处理状态
                      t.create_time,
                      t.pay_time,
                      t.tran_no,
                      t.flow_status, --银行流水状态
                      t.bank_account_id
                 from fd_trade_down_add_apply t
                where t.flow_status = pkg_b2e_add_apply_status.status_wait
                  and t.create_time >= l_add_date) loop
    begin
      begin
        select d.status
          into l_status
          from fd_trade_down_add_apply d
         where d.apply_id = item.apply_id
           and d.flow_status = pkg_b2e_add_apply_status.status_wait
           for update nowait;
      exception
        when others then
          continue;
      end;
    
      --2、判断申请的银行账户在白名单内
      select count(1)
        into l_white_count
        from fd_b2e_down_white_list d
       where d.down_holder_card_no = item.apply_account_no
         and d.audit_status = pkg_audit_status.Complete
         and d.down_channel_no = item.channel_no
         and d.channel_account_id = item.account_id;
    
      if l_white_count = 0 then
        update fd_trade_down_add_apply t
           set t.error_msg   = '银行账号不在白名单中',
               t.flow_status = pkg_b2e_add_apply_status.status_fail,
               t.status      = pkg_b2e_add_apply_status.status_fail,
               t.handle_time = sysdate
         where t.apply_id = item.apply_id;
        commit;
        continue;
      end if;
    
      select nvl(sum(t.add_amount), 0)
        into l_amount_total
        from fd_trade_down_add_apply t
       where t.account_id = item.account_id
         and t.handle_time >= trunc(sysdate)
         and t.status = pkg_b2e_add_apply_status.status_success;
    
      --3、判断下游渠道开启自动加款
      l_result := fd_f_b2e_down_check(item.channel_no,
                                      l_auto_amount,
                                      l_auto_add_on_time);
      if (l_result != pkg_error_code.success) then
        update fd_trade_down_add_apply t
           set t.error_msg   = '渠道未开启自动加款',
               t.flow_status = pkg_b2e_add_apply_status.status_fail,
               t.status      = pkg_b2e_add_apply_status.status_fail，
                               t.handle_time = sysdate
         where t.apply_id = item.apply_id;
        commit;
        continue;
      end if;
      --4、已经手工加款，直接找到银行流水，修改状态,未手工加款，自动加款
      if (l_status = pkg_b2e_add_apply_status.status_success) then
        --已手工加款
        --4.1处理银行流水
        l_result := fd_f_bank_rcv_record_update(item.apply_id,
                                                item.pay_time,
                                                item.apply_account_no,
                                                item.add_amount,
                                                item.tran_no,
                                                item.bank_account_id,
                                                l_auto_add_on_time);
        --4.2银行流水处理成功，修改申请状态
        if l_result = pkg_error_code.success then
          update fd_trade_down_add_apply d
             set d.flow_status = pkg_b2e_add_apply_status.status_success
           where d.apply_id = item.apply_id;
          commit;
        else
          rollback;
          continue;
        end if;
      elsif (item.status = pkg_b2e_add_apply_status.status_wait) then
        if (l_auto_amount < item.add_amount + l_amount_total) then
          update fd_trade_down_add_apply t
             set t.error_msg   = '超过当天加款阈值：' || l_auto_amount || ',请手动处理',
                 t.flow_status = pkg_b2e_add_apply_status.status_fail,
                 --t.status      = pkg_b2e_add_apply_status.status_fail,
                 t.handle_time = sysdate
           where t.apply_id = item.apply_id;
          commit;
          continue;
        end if;
        --累计
        --未手工加款，自动加款
        fd_p_b2e_down_add(item.apply_id,
                          item.channel_no,
                          item.account_id,
                          item.pay_time,
                          item.apply_account_no,
                          item.add_amount,
                          'auto add',
                          '自动上账成功',
                          '_system',
                          l_auto_add_on_time,
                          l_result);
      end if;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_b2e_down_add',
                       item.apply_id || ',' || sqlerrm,
                       1);
    end;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_b2e_down_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_B2E_WARN
prompt =====================================
prompt
create or replace procedure fd_account.fd_p_auto_b2e_warn as
  ------------------------------------------------
  --功能：银企直联下游自动加款告警
  --创建人：周荣省
  --创建时间：2019-09-20
  ------------------------------------------------
  l_bank_account_tittle varchar2(128);
begin
  --1、申请处理超时告警
  for item in (select t.channel_no,
                      t.apply_id,
                      t.add_amount,
                      t.bank_account_id
                 from fd_trade_down_add_apply t
                where t.status = pkg_b2e_add_apply_status.status_wait
                  and t.create_time < sysdate - 2 / 24) loop
    begin
      --2、插入告警
      select t.title
        into l_bank_account_tittle
        from fd_bank_account_info t
       where t.account_id = item.bank_account_id;
      insert into fd_system_warn
        (warn_id,
         uniq_id,
         warn_level,
         warn_type,
         title,
         warn_date,
         content,
         sync_status,
         key_word)
      values
        (seq_system_warn_id.nextval,
         'ZDJK' || item.channel_no,
         5,
         pkg_warn_into_type.b2e_down_apply_warn,
         '下游渠道:' || item.channel_no || ' 加款申请超2小时未处理',
         sysdate,
         '下游加款申请超2小时未处理,下游渠道:' || item.channel_no || ' 申请编号:' || item.apply_id ||
         ',加款金额:' || item.add_amount || ',收款账号:' || l_bank_account_tittle,
         pkg_balance_sync_status.wait,
         '下游加款申请告警');
      commit;
    exception
      when others then
        rollback;
    end;
  end loop;
  commit;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_b2e_warn', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_BALANCE_ADD_WARN
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_auto_balance_add_warn as
  -----------------上游渠道加款过多报警----------------
  l_ratio number;
begin
  ---每日八点运行
  ---1号不统计8点余额
  if to_char(sysdate, 'dd') != '01' then
    for item in (select t.channel_no,
                        t.channel_name,
                        a.inner_balance,
                        nvl(ad.add_amount, 0) add_amount
                   from fd_base_up_channel t
                  inner join fd_base_up_account_map m on t.channel_no =
                                                         m.channel_no
                  inner join fd_base_up_account a on m.account_id =
                                                     a.account_id
                   left join (select um.channel_no,
                                    um.account_id,
                                    sum(decode(um.manual_change_type,
                                               11,
                                               1,
                                               -1) * um.change_amount) add_amount
                               from fd_trade_up_manual um
                              where um.change_time >= sysdate - 1
                                and um.change_time < sysdate
                                and um.manual_change_type in (11, 12)
                              group by um.channel_no, um.account_id) ad on t.channel_no =
                                                                           ad.channel_no
                                                                       and a.account_id =
                                                                           ad.account_id
                  where --t.classification = pkg_business_type.huafei
                 --and 
                  a.inner_balance > 0) loop
      begin
        ---加款8点到8点加款小于0或余额与加款比大于0.5则报警
        if item.add_amount <= 0 or
           (item.inner_balance / item.add_amount) > 0.5 then
        
          l_ratio := 0;
          if item.add_amount > 0 then
            l_ratio := trunc(item.inner_balance / item.add_amount, 2);
          end if;
        
          insert into fd_system_warn
            (warn_id,
             uniq_id,
             warn_level,
             warn_type,
             title,
             warn_date,
             content,
             sync_status,
             key_word)
          values
            (seq_system_warn_id.nextval,
             'BA' || item.channel_no,
             5,
             pkg_warn_into_type.add_much_warn,
             '上游渠道:' || item.channel_name || ' 8点余额报警.',
             sysdate,
             '上游渠道:' || item.channel_name || ' 8点余额:' || item.inner_balance ||
             ',昨日8点至今日8点加款:' || item.add_amount || ' 余额占加款比例:' ||
             to_char(l_ratio, 'fm9999999990.00'),
             pkg_balance_sync_status.wait,
             '上游渠道八点余额报警');
        
          insert into fd_report_add_warn
            (id,
             warn_date,
             channel_name,
             eight_balance,
             yesterday_add,
             balance_ratio)
          values
            (seq_system_warn_id.nextval,
             sysdate,
             item.channel_name,
             item.inner_balance,
             item.add_amount,
             to_char(l_ratio, 'fm9999999990.00'));
        end if;
      
        commit;
      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_balance_add_warn', sqlerrm, 1);
      end;
    end loop;
  end if;
end;
/

prompt
prompt Creating procedure FD_P_AUTO_BALANCE_WARN_DOWN
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_auto_balance_warn_down as
  -----------------------下游渠道余额报警--------------------------
  l_warn_balance  number;
  l_warn_type     number;
  l_inner_balance number;
  l_credit_money  number;

begin

  ---1.下游渠道告警检查
  for item in (select d.channel_no,
                      d.channel_name,
                      b.text
                 from fd_base_down_channel d
                 left join fd_base_down_system_map a on a.channel_no =
                                                        d.channel_no
                 left join fd_base_source_system b on b.source_system_id =
                                                      a.source_system_id
                where d.status = pkg_sys_boolean.istrue
                  and d.warn_balance != 0) loop
    begin
      ---2.获取告警配置
      select t.warn_balance, t.warn_type
        into l_warn_balance, l_warn_type
        from fd_base_down_channel t
       where t.channel_no = item.channel_no;

      ---3.单独支付账户报警
      if l_warn_type = pkg_balance_warn_type.single_warn then
        insert into fd_system_warn
          (warn_id,
           uniq_id,
           warn_level,
           warn_type,
           title,
           warn_date,
           content,
           sync_status,
           key_word)
          select seq_system_warn_id.nextval,
                 'CHAC' || t.account_id,
                 5,
                 pkg_warn_into_type.balance_warn,
                 '下游渠道:' || item.channel_name || ' 余额过低.',
                 sysdate,
                 '下游渠道:' || item.channel_name || ' 余额过低.剩余余额:' ||
                 t.inner_balance || ',预警余额:' || l_warn_balance || ',支付账户:' ||
                 t.account_name||',系统:'||item.text,
                 pkg_balance_sync_status.wait,
                 '下游渠道余额不足'
            from fd_base_down_account t
           inner join fd_base_down_account_map m on t.account_id =
                                                    m.account_id
           where m.channel_no = item.channel_no
             and (t.inner_balance) < l_warn_balance
             and t.status = pkg_sys_boolean.istrue;
        --余额不足或者授信达限
        --Edit by:lancy
        --2019-01-22
      end if;

      ---4.合并支付账户报警
      if l_warn_type = pkg_balance_warn_type.all_warn then
        select sum(t.inner_balance)
          into l_inner_balance
          from fd_base_down_account t
         inner join fd_base_down_account_map m on t.account_id =
                                                  m.account_id
         where m.channel_no = item.channel_no
           and t.status = pkg_sys_boolean.istrue;
        --余额不足或者授信达限
        --Edit by:lancy
        --2019-01-22
        if (l_warn_balance > l_inner_balance or
           l_inner_balance + l_credit_money < 0) then
          insert into fd_system_warn
            (warn_id,
             uniq_id,
             warn_level,
             warn_type,
             title,
             warn_date,
             content,
             sync_status,
             key_word)
          values
            (seq_system_warn_id.nextval,
             'CH' || item.channel_no,
             5,
             pkg_warn_into_type.balance_warn,
             '下游渠道:' || item.channel_name || ' 余额过低.',
             sysdate,
             '下游渠道:' || item.channel_name || ' 余额过低.剩余余额:' ||
             l_inner_balance || ',预警余额:' || l_warn_balance,
             pkg_balance_sync_status.wait,
             '下游渠道余额不足');
        end if;

      end if;

      commit;

    exception
      when others then
        rollback;
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_balance_warn_down', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_BALANCE_WARN_DOWN_MS
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_auto_balance_warn_down_ms as
  -------------------------------------------------
  --功能：下游渠道余额报警（短信）
  --创建人：周荣省
  --创建时间：2019-09-02
  -------------------------------------------------
  l_warn_balance  number;
  l_warn_type     number;
  l_inner_balance number;
  l_credit_money  number;

begin

  ---1.下游渠道告警检查
  for item in (select d.channel_no,
                      d.channel_name,
                      b.text
                 from fd_base_down_channel d
                 left join fd_base_down_system_map a on a.channel_no =
                                                        d.channel_no
                 left join fd_base_source_system b on b.source_system_id =
                                                      a.source_system_id
                where d.status = pkg_sys_boolean.istrue
                  --and d.warn_balance != 0
                  and b.source_system_id=71
                  and d.channel_no in('D10022','D10079')) loop
    begin
      ---2.获取告警配置
      select t.warn_balance, t.warn_type,e.credit_money
        into l_warn_balance, l_warn_type,l_credit_money
        from fd_base_down_channel t
        left join fd_base_down_account_map c on c.channel_no=t.channel_no
        left join fd_base_down_account e on e.account_id=c.account_id
       where t.channel_no = item.channel_no;

      ---3.单独支付账户报警
      if l_warn_type = pkg_balance_warn_type.single_warn then
        insert into fd_system_warn
          (warn_id,
           uniq_id,
           warn_level,
           warn_type,
           title,
           warn_date,
           content,
           sync_status,
           key_word,system_no)
          select seq_system_warn_id.nextval,
                 'CHAC' || t.account_id,
                 5,
                 pkg_warn_into_type.balance_warn,
                 '下游渠道:' || item.channel_name || ' 余额过低.',
                 sysdate,
                 '下游渠道:' || item.channel_name || ' 余额过低.剩余余额:' ||
                 t.inner_balance || ',预警余额:' || l_warn_balance || ',支付账户:' ||
                 t.account_name||',系统:'||item.text||',授信:'||l_warn_balance,
                 pkg_balance_sync_status.wait,
                 '下游渠道余额不足',
                 'LX_IM'
            from fd_base_down_account t
           inner join fd_base_down_account_map m on t.account_id =
                                                    m.account_id
           where m.channel_no = item.channel_no
             and (t.inner_balance+l_credit_money) < l_warn_balance+1000
             and t.status = pkg_sys_boolean.istrue;
        --余额不足或者授信达限
        --Edit by:lancy
        --2019-01-22
      end if;
      commit;

    exception
      when others then
        rollback;
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_balance_warn_down_ms', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_BALANCE_WARN_UP
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_auto_balance_warn_up as
  -----------------------上游渠道余额报警--------------------------
  l_warn_balance      number;
  l_warn_type         number;
  l_inner_balance     number;
  l_trade_amount      number;
  l_time_number       number;
  l_trade_hour        number; ---报警交易量，半小时、两小时
  l_up_classification number;

  l_date_now  number := to_number(to_char(sysdate, 'dd')); ---当前日期是几号
  l_date_last number := to_number(to_char(last_day(sysdate), 'dd')); ---本月最后一天是几号
begin
  ---1.上游渠道告警检查
  for item in (select c.channel_no, c.channel_name, c.classification,b.text
                 from fd_base_up_channel c
                 left join fd_base_up_system_map a on a.channel_no =
                                                      c.channel_no
                 left join fd_base_source_system b on b.source_system_id =
                                                      a.source_system_id
                where c.status = pkg_sys_boolean.istrue
                  and c.warn_balance != 0
                  and c.can_add = 0) loop
    begin
      ---2.获取告警配置
      select t.warn_balance,
             t.warn_type,
             to_number(to_char(sysdate, 'hh24miss')),
             t.classification
        into l_warn_balance,
             l_warn_type,
             l_time_number,
             l_up_classification
        from fd_base_up_channel t
       where t.channel_no = item.channel_no;

      if l_warn_balance > 0 then
        ---3.月初月末报警额翻倍
        if (l_date_now > 4 and l_date_now < l_date_last) or
           (l_up_classification != pkg_business_type.huafei) then
          l_warn_balance := l_warn_balance;
        else
          l_warn_balance := 2 * l_warn_balance;
        end if;

        ---4.比较报警额与前半小时交易量(19:50-20:10分以前两小时交易量报警)
        l_trade_hour := 1;
        if (l_time_number >= 195000 and l_time_number <= 201000 and
           (item.classification = 5 or item.classification = 6)) then
          l_trade_hour := 4;
        end if;

        select sum(tab.trade_amount)
          into l_trade_amount
          from (select *
                  from (select *
                          from fd_report_channel_halfhour t
                         where t.collect_time >= sysdate - 4 / 24
                           and t.channel_no = item.channel_no
                           and t.channel_type = 1
                         order by t.collect_time desc) r
                 where rownum <= l_trade_hour) tab;

        if l_trade_amount > l_warn_balance then
          l_warn_balance := l_trade_amount;
        end if;
      end if;

      ---5.单独支付账户报警
      if l_warn_type = pkg_balance_warn_type.single_warn then
        insert into fd_system_warn
          (warn_id,
           uniq_id,
           warn_level,
           warn_type,
           title,
           warn_date,
           content,
           sync_status,
           key_word)
          select seq_system_warn_id.nextval,
                 'CHAC' || t.account_id,
                 5,
                 pkg_warn_into_type.balance_warn,
                 '上游渠道:' || item.channel_name || ' 余额过低.',
                 sysdate,
                 '上游渠道:' || item.channel_name || ' 余额过低.剩余余额:' ||
                 t.inner_balance || ',预警余额:' || l_warn_balance || ',支付账户:' ||
                 t.account_name||',系统:'||item.text,
                 pkg_balance_sync_status.wait,
                 '上游渠道余额不足'
            from fd_base_up_account t
           inner join fd_base_up_account_map m on t.account_id =
                                                  m.account_id
           where m.channel_no = item.channel_no
             and t.inner_balance < l_warn_balance
             and t.status = pkg_sys_boolean.istrue;

      end if;

      ---6.合并支付账户报警
      if l_warn_type = pkg_balance_warn_type.all_warn then
        select sum(t.inner_balance)
          into l_inner_balance
          from fd_base_up_account t
         inner join fd_base_up_account_map m on t.account_id = m.account_id
         where m.channel_no = item.channel_no
           and t.status = pkg_sys_boolean.istrue;

        if l_warn_balance > l_inner_balance then
          insert into fd_system_warn
            (warn_id,
             uniq_id,
             warn_level,
             warn_type,
             title,
             warn_date,
             content,
             sync_status,
             key_word)
          values
            (seq_system_warn_id.nextval,
             'CH' || item.channel_no,
             5,
             pkg_warn_into_type.balance_warn,
             '上游渠道:' || item.channel_name || ' 余额过低.',
             sysdate,
             '上游渠道:' || item.channel_name || ' 余额过低.剩余余额:' ||
             l_inner_balance || ',预警余额:' || l_warn_balance,
             pkg_balance_sync_status.wait,
             '上游渠道余额不足');
        end if;

      end if;

      commit;
    exception
      when others then
        rollback;
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_balance_warn_up', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_BANK_DAILY_COLLECT
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_auto_bank_daily_collect as
  ------------------实体卡日报表信息收集-----------------
  l_result varchar2(32);
begin
  ---1.每天第一个小时收集昨日数据
  if sysdate < (trunc(sysdate, 'dd') + 1 / 24) then
    l_result := fd_f_auto_bank_daily_collect(trunc(sysdate, 'dd') - 1);
    if l_result != pkg_error_code.success then
      rollback;
      return;
    end if;
  end if;

  ---2.收集实体卡日报表信息
  l_result := fd_f_auto_bank_daily_collect(trunc(sysdate, 'dd'));
  if l_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_bank_daily_collect', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_CAPITAL_USE_RATE
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_auto_capital_use_rate as
  ---------------定时收集渠道资金利用率，无法后补----------------
  l_snap_time           date := trunc(sysdate);
  l_yesterday_draw      number;
  l_bef_yesterday_draw  number;
  l_three_days_ago_draw number;
  l_average_draw        number;
  l_no_draw_days        number;
  l_record_count        number;
  --fd_f_capital_use_rate_check 是否显示红色方法
begin

  ---1.检查数据是否已创建
  select count(1)
    into l_record_count
    from fd_report_capital_use_rate t
   where t.snap_time = l_snap_time;

  if l_record_count = 0 then
    for item in (select c.channel_no,
                        c.channel_name,
                        c.status,
                        c.company_id,
                        c.capital_class,
                        a.account_id,
                        a.account_name,
                        a.inner_balance
                   from fd_base_up_channel c
                  inner join fd_base_up_account_map m on c.channel_no =
                                                         m.channel_no
                  inner join fd_base_up_account a on m.account_id =
                                                     a.account_id) loop
      begin
        ---2.获取近三天交易量，计算平均交易量
        l_yesterday_draw      := fd_f_auto_channel_draw_get(l_snap_time - 1, --昨天交易量
                                                            item.account_id,
                                                            item.company_id);
        l_bef_yesterday_draw  := fd_f_auto_channel_draw_get(l_snap_time - 2, --前天交易量
                                                            item.account_id,
                                                            item.company_id);
        l_three_days_ago_draw := fd_f_auto_channel_draw_get(l_snap_time - 3, --大前天交易量
                                                            item.account_id,
                                                            item.company_id);
        l_average_draw        := (l_yesterday_draw + l_bef_yesterday_draw +
                                 l_three_days_ago_draw) / 3;

        ---3.计算渠道累计无交易天数
        select (nvl(sum(t.no_draw_days), 0) + 1)
          into l_no_draw_days
          from fd_report_capital_use_rate t
         where t.snap_time = (l_snap_time - 1)
           and t.channel_no = item.channel_no
           and t.account_id = item.account_id
           and t.company_id = item.company_id;

        if (l_yesterday_draw != 0 or item.inner_balance < 1000) then
          l_no_draw_days := 0;
        end if;

        ---4.收集资金利用率基础信息
        insert into fd_report_capital_use_rate
          (record_id,
           snap_time,
           create_time,
           company_id,
           channel_no,
           account_id,
           channel_name,
           account_name,
           channel_status,
           capital_class,
           account_balance,
           yesterday_draw,
           bef_yesterday_draw,
           three_days_ago_draw,
           average_draw,
           no_draw_days)
        values
          (seq_report_capital_use_rate_id.nextval,
           l_snap_time,
           sysdate,
           item.company_id,
           item.channel_no,
           item.account_id,
           item.channel_name,
           item.account_name,
           item.status,
           item.capital_class,
           item.inner_balance,
           l_yesterday_draw,
           l_bef_yesterday_draw,
           l_three_days_ago_draw,
           l_average_draw,
           l_no_draw_days);

        ---5.连续五天无交易的告警到主管
        if l_no_draw_days >= 5 then
          fd_p_b2e_warn_info_set('capital_use_rate_err' ||
                                 to_char(sysdate, 'yyyymmddhh24miss'),
                                 pkg_warn_into_type.capital_use_rate_err,
                                 '时间:' ||
                                 to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                                 ' 渠道连续五天无交易.' || item.channel_name,
                                 '时间:' ||
                                 to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                                 '渠道连续五天无交易,' || item.channel_name,
                                 '资金利用不合理报警');
        end if;

        commit;
      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_capital_use_rate', sqlerrm, 1);
          fd_p_b2e_warn_info_set('auto_err' ||
                                 to_char(sysdate, 'yyyymmddhh24miss'),
                                 pkg_warn_into_type.auto_error,
                                 '时间:' ||
                                 to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                                 ' 自动生成资金利用率基础数据错误.' || item.channel_no,
                                 '时间:' ||
                                 to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                                 '自动生成资金利用率基础数据错误',
                                 '存储过程自动脚本执行错误');
      end;
    end loop;
  end if;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_capital_use_rate', sqlerrm, 1);
    fd_p_b2e_warn_info_set('auto_err' ||
                           to_char(sysdate, 'yyyymmddhh24miss'),
                           pkg_warn_into_type.auto_error,
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           ' 自动生成资金利用率基础数据错误.',
                           '时间:' ||
                           to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                           '自动生成资金利用率基础数据错误',
                           '存储过程自动脚本执行错误');
end;
/

prompt
prompt Creating procedure FD_P_AUTO_COMMI_PROFIT_ADD
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_auto_commi_profit_add(v_add_date in varchar2 default null) as
  -----------------------佣金、利润账户加款-------------------------
  l_record_id      number;
  l_add_date       date := to_date(v_add_date, 'yyyymmddhh24miss');
  l_commi_balance  number;
  l_profit_balance number;
  l_cap_account_id number;
  l_commi_amount   number;
  l_profit_amount  number;
begin

  if l_add_date is null then
    l_add_date := trunc(sysdate) - 1;
  end if;

  for item in (select d.record_id,
                      d.company_id,
                      d.channel_no,
                      d.channel_type,
                      d.commission,
                      d.profits,
                      d.refund_commission,
                      d.refund_profits
                 from fd_report_commi_profit_daily d
                where d.add_status = pkg_commi_profit_add_status.wait
                  and d.snap_time >= l_add_date
                  and d.snap_time < l_add_date + 1) loop
    begin
      ---0.修改数据状态(正在)
      select t.record_id
        into l_record_id
        from fd_report_commi_profit_daily t
       where t.record_id = item.record_id
         and t.add_status = pkg_commi_profit_add_status.wait
         for update;

      ---1.佣金账户加款
      l_commi_amount := item.commission - item.refund_commission;
      if (item.channel_type = pkg_channel_type.down_channel and
         l_commi_amount != 0) then
        select t.commi_balance
          into l_commi_balance
          from fd_base_down_channel t
         where t.channel_no = item.channel_no
           for update;

        update fd_base_down_channel t
           set t.commi_balance = (l_commi_balance + l_commi_amount)
         where t.channel_no = item.channel_no;
      elsif (item.channel_type = pkg_channel_type.up_channel and
            l_commi_amount != 0) then
        select t.commi_balance
          into l_commi_balance
          from fd_base_up_channel t
         where t.channel_no = item.channel_no
           for update;

        update fd_base_up_channel t
           set t.commi_balance = (l_commi_balance + l_commi_amount)
         where t.channel_no = item.channel_no;
      end if;

      ---1.1添加佣金加款记录
      if (sql%rowcount > 0 and l_commi_amount != 0) then
        insert into fd_trade_commission_settle
          (report_id,
           channel_no,
           channel_type,
           commission,
           settle_month,
           settle_status,
           settle_user,
           settle_time,
           has_adjust,
           adjust_id,
           bank_batch_id,
           settle_type,
           commi_balance,
           memo)
        values
          (seq_trade_commission_settle_id.nextval,
           item.channel_no,
           item.channel_type,
           l_commi_amount,
           trunc(sysdate, 'mm'),
           0,
           'sys',
           sysdate,
           pkg_sys_boolean.isfalse,
           0,
           0,
           pkg_commi_settle_type.add_commi,
           (l_commi_balance + l_commi_amount),
           '-');
      end if;

      ---2.利润账户加款
      l_profit_amount := item.profits - item.refund_profits;
      if (sql%rowcount > 0 and l_profit_amount != 0) then
        select t.balance, t.account_id
          into l_profit_balance, l_cap_account_id
          from fd_base_company_account_cap t
         where t.company_id = item.company_id
           and t.account_type = pkg_co_cap_account_type.profit
           for update;

        update fd_base_company_account_cap t
           set t.balance = (l_profit_balance + l_profit_amount)
         where t.company_id = item.company_id
           and t.account_type = pkg_co_cap_account_type.profit;

        insert into fd_trade_co_cap_fund
          (change_id,
           account_id,
           change_amount,
           change_type,
           balance,
           change_time,
           adjust_id,
           has_adjust,
           bank_batch_id,
           memo,
           record_no,
           create_user)
        values
          (seq_trade_co_cap_fund_id.nextval,
           l_cap_account_id,
           l_profit_amount,
           pkg_co_cap_fund_type.add_amount,
           (l_profit_balance + l_profit_amount),
           sysdate,
           0,
           pkg_sys_boolean.isfalse,
           0,
           '-',
           0,
           'sys');
      end if;

      if sql%rowcount > 0 then
        ---3.修改数据状态(完成)
        update fd_report_commi_profit_daily t
           set t.add_status = pkg_commi_profit_add_status.complate
         where t.record_id = item.record_id;
      end if;

      if sql%rowcount > 0 then
        commit;
      else
        rollback;
      end if;

    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_commi_profit_add', sqlerrm, 1);
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_COMMI_PROFIT_COLLECT
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_auto_commi_profit_collect as
  --------------------收集上游资金变动佣金利润信息---------------------
  l_collect_date date := trunc(sysdate) - 1;
  --l_collect_date   date := trunc(to_date('20160615000000',
  --                                       'yyyymmddhh24miss')) - 1;
  l_down_count     number;
  l_up_count       number;
  l_down_record_id number;
  l_up_record_id   number;
begin
  ---1.收集上游资金变动信息
  for item in (select u.down_channel_no,
                      u.down_account_id,
                      u.down_company_id,
                      u.up_channel_no,
                      u.up_account_id,
                      u.up_company_id,
                      u.business_type,
                      u.bill_type,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 u.up_draw_face,
                                 0)) up_draw_face,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 u.up_draw_amount,
                                 0)) up_draw_amount,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 u.up_real_amount,
                                 0)) up_real_amount,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 u.down_draw_face,
                                 0)) down_draw_face,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 u.down_draw_amount,
                                 0)) down_draw_amount,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 u.down_real_amount,
                                 0)) down_real_amount,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 u.settle_amount,
                                 0)) settle_amount,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.refund_amount,
                                 u.up_draw_face,
                                 0)) up_draw_face_ref,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.refund_amount,
                                 u.up_draw_amount,
                                 0)) up_draw_amount_ref,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.refund_amount,
                                 u.up_real_amount,
                                 0)) up_real_amount_ref,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.refund_amount,
                                 u.down_draw_face,
                                 0)) down_draw_face_ref,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.refund_amount,
                                 u.down_draw_amount,
                                 0)) down_draw_amount_ref,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.refund_amount,
                                 u.down_real_amount,
                                 0)) down_real_amount_ref,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.refund_amount,
                                 u.settle_amount,
                                 0)) settle_amount_ref
                 from fd_trade_up_fund u
                where u.change_time >= l_collect_date
                  and u.change_time < (l_collect_date + 1)
                  and (u.change_type = pkg_up_fund_change_type.debit_amount or
                      u.change_type = pkg_up_fund_change_type.refund_amount)
                group by u.down_channel_no,
                         u.down_account_id,
                         u.down_company_id,
                         u.up_channel_no,
                         u.up_account_id,
                         u.up_company_id,
                         u.business_type,
                         u.bill_type) loop
    begin
      ---2.添加下游佣金利润数据
      if item.down_channel_no != '0' and item.down_account_id != 0 then
        select count(1), max(t.record_id)
          into l_down_count, l_down_record_id
          from fd_report_commi_profit_daily t
         where t.channel_no = item.down_channel_no
           and t.account_id = item.down_account_id
           and t.channel_type = pkg_channel_type.down_channel
           and t.business_type = item.business_type
           and t.bill_type = item.bill_type
           and t.snap_time = l_collect_date;
      
        if l_down_count = 0 then
          insert into fd_report_commi_profit_daily
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             service_fee,
             refund_service_fee,
             refund_profits,
             snap_time)
          values
            (seq_report_commi_profit_id.nextval,
             item.down_company_id,
             item.down_channel_no,
             item.down_account_id,
             pkg_channel_type.down_channel,
             item.business_type,
             item.bill_type,
             item.down_draw_face,
             item.down_draw_amount,
             item.down_real_amount,
             trunc((item.down_draw_amount - item.down_real_amount), 2),
             decode(item.down_company_id,
                    item.up_company_id,
                    (item.down_real_amount - item.up_real_amount),
                    (item.down_real_amount - item.settle_amount)),
             item.down_draw_face_ref,
             item.down_draw_amount_ref,
             item.down_real_amount_ref,
             trunc((item.down_draw_amount_ref - item.down_real_amount_ref),
                   2),
             0,
             0,
             decode(item.down_company_id,
                    item.up_company_id,
                    (item.down_real_amount_ref - item.up_real_amount_ref),
                    (item.down_real_amount_ref - item.settle_amount_ref)),
             l_collect_date);
        else
          update fd_report_commi_profit_daily t
             set t.total_face         = (t.total_face + item.down_draw_face),
                 t.draw_amount        = (t.draw_amount +
                                        item.down_draw_amount),
                 t.real_amount        = (t.real_amount +
                                        item.down_real_amount),
                 t.commission         = trunc((t.commission +
                                              (item.down_draw_amount -
                                              item.down_real_amount)),
                                              2),
                 t.profits            = (t.profits +
                                        decode(item.down_company_id,
                                                item.up_company_id,
                                                (item.down_real_amount -
                                                item.up_real_amount),
                                                (item.down_real_amount -
                                                item.settle_amount))),
                 t.refund_total_face  = (t.refund_total_face +
                                        item.down_draw_face_ref),
                 t.refund_draw_amount = (t.refund_draw_amount +
                                        item.down_draw_amount_ref),
                 t.refund_real_amount = (t.refund_real_amount +
                                        item.down_real_amount_ref),
                 t.refund_commission  = trunc((t.refund_commission +
                                              (item.down_draw_amount_ref -
                                              item.down_real_amount_ref)),
                                              2),
                 t.refund_profits     = (t.refund_profits +
                                        decode(item.down_company_id,
                                                item.up_company_id,
                                                (item.down_real_amount_ref -
                                                item.up_real_amount_ref),
                                                (item.down_real_amount_ref -
                                                item.settle_amount_ref)))
           where t.record_id = l_down_record_id;
        end if;
      
      end if;
    
      ---3.添加上游佣金利润数据
    
      if item.up_channel_no != '0' and item.up_account_id != 0 then
        select count(1), max(t.record_id)
          into l_up_count, l_up_record_id
          from fd_report_commi_profit_daily t
         where t.channel_no = item.up_channel_no
           and t.account_id = item.up_account_id
           and t.channel_type = pkg_channel_type.up_channel
           and t.business_type = item.business_type
           and t.bill_type = item.bill_type
           and t.snap_time = l_collect_date;
      
        if l_up_count = 0 then
          insert into fd_report_commi_profit_daily
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             service_fee,
             refund_service_fee,
             refund_profits,
             snap_time)
          values
            (seq_report_commi_profit_id.nextval,
             item.up_company_id,
             item.up_channel_no,
             item.up_account_id,
             pkg_channel_type.up_channel,
             item.business_type,
             item.bill_type,
             item.up_draw_face,
             item.up_draw_amount,
             item.up_real_amount,
             trunc((item.up_draw_amount - item.up_real_amount), 2),
             decode(item.down_company_id,
                    item.up_company_id,
                    decode(item.down_account_id,
                           0,
                           (item.down_real_amount - item.up_real_amount),
                           0),
                    (item.settle_amount - item.up_real_amount)),
             item.up_draw_face_ref,
             item.up_draw_amount_ref,
             item.up_real_amount_ref,
             trunc((item.up_draw_amount_ref - item.up_real_amount_ref), 2),
             0,
             0,
             decode(item.down_company_id,
                    item.up_company_id,
                    0,
                    (item.settle_amount_ref - item.up_real_amount_ref)),
             l_collect_date);
        
        else
          update fd_report_commi_profit_daily t
             set t.total_face         = (t.total_face + item.up_draw_face),
                 t.draw_amount        = (t.draw_amount + item.up_draw_amount),
                 t.real_amount        = (t.real_amount + item.up_real_amount),
                 t.commission         = trunc((t.commission +
                                              (item.up_draw_amount -
                                              item.up_real_amount)),
                                              2),
                 t.profits            = (t.profits +
                                        decode(item.down_company_id,
                                                item.up_company_id,
                                                decode(item.down_account_id,
                                                       0,
                                                       (item.down_real_amount -
                                                       item.up_real_amount),
                                                       0),
                                                (item.settle_amount -
                                                item.up_real_amount))),
                 t.refund_total_face  = (t.refund_total_face +
                                        item.up_draw_face_ref),
                 t.refund_draw_amount = (t.refund_draw_amount +
                                        item.up_draw_amount_ref),
                 t.refund_real_amount = (t.refund_real_amount +
                                        item.up_real_amount_ref),
                 t.refund_commission  = trunc((t.refund_commission +
                                              (item.up_draw_amount_ref -
                                              item.up_real_amount_ref)),
                                              2),
                 t.refund_profits     = (t.refund_profits +
                                        decode(item.down_company_id,
                                                item.up_company_id,
                                                0,
                                                (item.settle_amount_ref -
                                                item.up_real_amount_ref)))
           where t.record_id = l_up_record_id;
        end if;
      
      end if;
    
      commit;
    
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_commi_profit_collect', sqlerrm, 1);
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_collect', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_COMMI_PROFIT_DOWN
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_auto_commi_profit_down(v_collect_date in varchar2 default null) as
  --------------------收集下游资金变动佣金利润信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160721000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type number := 0; --数据出现错误，统计类型为0
  l_wait_count      number := 0;
  l_start_time      date := sysdate;
  l_channel_name    varchar2(100);
  l_account_name    varchar2(100);
  l_channel_system  number;
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from fd_trade_up_fund t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then
  
    ---1.收集上游资金变动信息
    for item in (select m.down_company_id,
                        m.down_channel_no,
                        m.down_account_id,
                        m.business_type,
                        m.bill_type,
                        m.order_source,
                        (m.down_draw_unit + nvl(f.down_adjust_unit, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_unit, 0)) down_draw_unit,
                        (m.down_draw_face + nvl(f.down_adjust_face, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_face, 0)) down_draw_face,
                        (m.down_draw_amount + nvl(f.down_adjust_amount, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_amount, 0)) down_draw_amount,
                        (m.down_real_amount + nvl(f.down_adjust_real, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_real, 0)) down_real_amount,
                        m.settle_amount,
                        m.down_draw_unit_ref,
                        m.down_draw_face_ref,
                        m.down_draw_amount_ref,
                        m.down_real_amount_ref,
                        m.settle_amount_ref,
                        nvl(f.up_many_face, 0) up_many_face,
                        nvl(f.up_many_amount, 0) up_many_amount
                   from (select u.down_company_id,
                                u.down_channel_no,
                                u.down_account_id,
                                u.business_type,
                                u.bill_type,
                                max(u.order_source) order_source,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_unit) down_draw_unit,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_face) down_draw_face,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_amount) down_draw_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_real_amount) down_real_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           decode(u.down_company_id,
                                                  u.up_company_id,
                                                  u.up_real_amount,
                                                  decode(u.settle_amount,
                                                         0,
                                                         u.up_real_amount,
                                                         u.settle_amount)),
                                           0)) settle_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_unit) down_draw_unit_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_face) down_draw_face_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_amount) down_draw_amount_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_real_amount) down_real_amount_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           decode(u.down_company_id,
                                                  u.up_company_id,
                                                  u.up_real_amount,
                                                  decode(u.settle_amount,
                                                         0,
                                                         u.up_real_amount,
                                                         u.settle_amount)))) settle_amount_ref
                           from fd_trade_up_fund u
                          where u.change_time >= l_collect_date
                            and u.change_time < (l_collect_date + 1)
                            and (u.change_type =
                                pkg_up_fund_change_type.debit_amount or
                                u.change_type =
                                pkg_up_fund_change_type.refund_amount)
                          group by u.down_company_id,
                                   u.down_channel_no,
                                   u.down_account_id,
                                   u.business_type,
                                   u.bill_type) m
                   left join (select d.channel_no,
                                    d.account_id,
                                    d.business_type,
                                    d.bill_type,
                                    sum(d.down_adjust_face) down_adjust_face,
                                    sum(d.down_adjust_unit) down_adjust_unit,
                                    sum(d.down_adjust_amount) down_adjust_amount,
                                    sum(d.down_adjust_real) down_adjust_real,
                                    sum(d.up_many_face) up_many_face,
                                    sum(d.up_many_amount) up_many_amount
                               from fd_trade_up_fund_differ d
                              where d.record_date = l_collect_date
                              group by d.channel_no,
                                       d.account_id,
                                       d.business_type,
                                       d.bill_type) f on m.down_channel_no =
                                                         f.channel_no
                                                     and m.down_account_id =
                                                         f.account_id
                                                     and m.business_type =
                                                         f.business_type
                                                     and m.bill_type =
                                                         f.bill_type
                   left join (select r.channel_no,
                                    r.account_id,
                                    r.business_type,
                                    sum(r.to_front_face) to_front_face,
                                    sum(r.to_front_unit) to_front_unit,
                                    sum(r.to_front_amount) to_front_amount,
                                    sum(r.to_front_real) to_front_real
                               from fd_trade_up_fund_differ r
                              where r.record_date = l_collect_date
                              group by r.channel_no,
                                       r.account_id,
                                       r.business_type) fr on m.down_channel_no =
                                                              fr.channel_no
                                                          and m.down_account_id =
                                                              fr.account_id
                                                          and m.business_type =
                                                              fr.business_type) loop
      begin
        ---2.添加下游佣金利润数据
        if item.down_channel_no != '0' and item.down_account_id != 0 then
          --3.计算统计类型
        
          l_statistics_type := 0;
          if item.bill_type = pkg_bill_type.back then
            if item.business_type = pkg_business_type.SPHY then
              l_statistics_type := pkg_statistics_type.SPHY;
            else
              l_statistics_type := pkg_statistics_type.FlowBag;
            end if;
          else
            --***从业务类型与分类表中获取分类***
          
            select t.statistics_type
              into l_statistics_type
              from fd_system_business_statis_map t
             where t.local_business_type = item.business_type
               and rownum <= 1;
          
          end if;
        
          ---4.获取渠道账户名称
          select t.channel_name
            into l_channel_name
            from fd_base_down_channel t
           where t.channel_no = item.down_channel_no;
        
          select t.account_name
            into l_account_name
            from fd_base_down_account t
           where t.account_id = item.down_account_id;
        
          --5.获取渠道系统编号，包括平账
          l_channel_system := item.order_source;
          if l_channel_system = 0 then
          
            select max(t.source_system_id)
              into l_channel_system
              from fd_base_down_system_map t
             where t.channel_no = item.down_channel_no;
          end if;
        
          --6.添加数据
          insert into fd_report_commi_profit_daily
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_unit,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits,
             service_fee,
             refund_total_unit,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             refund_profits,
             refund_service_fee,
             up_many_face,
             up_many_amount,
             snap_time,
             statistics_type,
             channel_name,
             account_name,
             channel_source_system)
          values
            (seq_report_commi_profit_id.nextval,
             item.down_company_id,
             item.down_channel_no,
             item.down_account_id,
             pkg_channel_type.down_channel,
             item.business_type,
             item.bill_type,
             item.down_draw_unit,
             item.down_draw_face,
             item.down_draw_amount,
             item.down_real_amount,
             (trunc(item.down_draw_amount, 2) -
             trunc(item.down_real_amount, 2)),
             (item.down_real_amount - item.settle_amount),
             0,
             item.down_draw_unit_ref,
             item.down_draw_face_ref,
             item.down_draw_amount_ref,
             item.down_real_amount_ref,
             (trunc(item.down_draw_amount_ref, 2) -
             trunc(item.down_real_amount_ref, 2)),
             (item.down_real_amount_ref - item.settle_amount_ref),
             0,
             item.up_many_face,
             item.up_many_amount,
             l_collect_date,
             l_statistics_type,
             l_channel_name,
             l_account_name,
             l_channel_system);
        end if;
      
        commit;
      
      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_down', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');
  
    commit;
  end if;
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_down', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_COMMI_PROFIT_SETTLE
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_auto_commi_profit_settle(v_collect_date in varchar2 default null) as
  --------------------收集上游资金变动结算信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160721000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type   number := 0; --数据出现错误，统计类型为0
  l_wait_count        number := 0;
  l_start_time        date := sysdate;
  l_down_company_name varchar2(128);
  l_up_company_name   varchar2(128);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from fd_trade_up_fund t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then
  
    ---1.收集上游资金变动信息
    for item in (select u.down_company_id,
                        u.up_company_id,
                        u.bill_type,
                        u.business_type,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   u.up_draw_unit,
                                   0)) draw_unit,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   u.up_draw_face,
                                   0)) draw_face,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount),
                                   0)) draw_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount),
                                   0)) real_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   u.up_draw_unit)) unit_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   u.up_draw_face)) face_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount))) amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount))) real_ref
                   from fd_trade_up_fund u
                  where u.change_time >= l_collect_date
                    and u.change_time < (l_collect_date + 1)
                    and u.down_company_id != u.up_company_id
                    and u.down_company_id != 0
                    and u.up_company_id != 0
                    and (u.change_type =
                        pkg_up_fund_change_type.debit_amount or
                        u.change_type =
                        pkg_up_fund_change_type.refund_amount)
                  group by u.down_company_id,
                           u.up_company_id,
                           u.bill_type,
                           u.business_type) loop
      begin
      
        --2.计算统计类型
        l_statistics_type := 0;
        if item.bill_type = pkg_bill_type.back then
          if item.business_type = pkg_business_type.SPHY then
            l_statistics_type := pkg_statistics_type.SPHY;
          else
            l_statistics_type := pkg_statistics_type.FlowBag;
          end if;
        
        else
          --***从业务类型与分类表中获取分类***
          select t.statistics_type
            into l_statistics_type
            from fd_system_business_statis_map t
           where t.local_business_type = item.business_type
             and rownum <= 1;
        end if;
      
        ---3.获取公司名称
        select t.sort_name
          into l_down_company_name
          from fd_base_company_info t
         where t.company_id = item.down_company_id;
      
        select t.sort_name
          into l_up_company_name
          from fd_base_company_info t
         where t.company_id = item.up_company_id;
      
        ---4.添加作为下游渠道的结算信息
        insert into fd_report_commi_profit_daily
          (record_id,
           company_id,
           channel_no,
           account_id,
           channel_type,
           business_type,
           bill_type,
           total_unit,
           total_face,
           draw_amount,
           real_amount,
           commission,
           profits,
           service_fee,
           refund_total_unit,
           refund_total_face,
           refund_draw_amount,
           refund_real_amount,
           refund_commission,
           refund_profits,
           refund_service_fee,
           up_many_face,
           up_many_amount,
           snap_time,
           statistics_type,
           channel_name,
           account_name)
        values
          (seq_report_commi_profit_id.nextval,
           item.up_company_id,
           '-',
           item.down_company_id,
           pkg_channel_type.settle_down,
           item.business_type,
           item.bill_type,
           item.draw_unit,
           item.draw_face,
           item.draw_amount,
           item.real_amount,
           0,
           0,
           0,
           item.unit_ref,
           item.face_ref,
           item.amount_ref,
           item.real_ref,
           0,
           0,
           0,
           0,
           0,
           l_collect_date,
           l_statistics_type,
           l_down_company_name,
           l_down_company_name);
      
        ---5.添加作为上游渠道的结算信息
        insert into fd_report_commi_profit_daily
          (record_id,
           company_id,
           channel_no,
           account_id,
           channel_type,
           business_type,
           bill_type,
           total_unit,
           total_face,
           draw_amount,
           real_amount,
           commission,
           profits,
           service_fee,
           refund_total_unit,
           refund_total_face,
           refund_draw_amount,
           refund_real_amount,
           refund_commission,
           refund_profits,
           refund_service_fee,
           up_many_face,
           up_many_amount,
           snap_time,
           statistics_type,
           channel_name,
           account_name)
        values
          (seq_report_commi_profit_id.nextval,
           item.down_company_id,
           '-',
           item.up_company_id,
           pkg_channel_type.settle_up,
           item.business_type,
           item.bill_type,
           item.draw_unit,
           item.draw_face,
           item.draw_amount,
           item.real_amount,
           0,
           0,
           0,
           item.unit_ref,
           item.face_ref,
           item.amount_ref,
           item.real_ref,
           0,
           0,
           0,
           0,
           0,
           l_collect_date,
           l_statistics_type,
           l_up_company_name,
           l_up_company_name);
      
        commit;
      
      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_settle', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');
  
    commit;
  end if;
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_COMMI_PROFIT_UP
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_auto_commi_profit_up(v_collect_date in varchar2 default null) as
  --------------------收集上游资金变动佣金利润信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160721000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type number := 0; --数据出现错误，统计类型为0
  l_wait_count      number := 0;
  l_start_time      date := sysdate;
  l_channel_name    varchar2(100);
  l_account_name    varchar2(100);
  l_channel_system  number;
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from fd_trade_up_fund t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then
  
    ---1.收集上游资金变动信息
    for item in (select u.up_company_id,
                        u.up_channel_no,
                        u.up_account_id,
                        u.business_type,
                        u.bill_type,
                        max(u.order_source) order_source,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_unit) up_draw_unit,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_face) up_draw_face,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_amount) up_draw_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_real_amount) up_real_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.down_company_id,
                                          u.up_company_id,
                                          decode(u.down_channel_no,
                                                 '0',
                                                 0,
                                                 u.up_real_amount), ---有交易平账的需要按0计算上游利润
                                          decode(u.settle_amount,
                                                 0,
                                                 u.up_real_amount,
                                                 u.settle_amount)),
                                   0)) settle_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_unit) up_draw_unit_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_face) up_draw_face_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_amount) up_draw_amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_real_amount) up_real_amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.down_company_id,
                                          u.up_company_id,
                                          u.up_real_amount,
                                          decode(u.settle_amount,
                                                 0,
                                                 u.up_real_amount,
                                                 u.settle_amount)))) settle_amount_ref
                   from fd_trade_up_fund u
                  where u.change_time >= l_collect_date
                    and u.change_time < (l_collect_date + 1)
                    and (u.change_type =
                        pkg_up_fund_change_type.debit_amount or
                        u.change_type =
                        pkg_up_fund_change_type.refund_amount)
                  group by u.up_company_id,
                           u.up_channel_no,
                           u.up_account_id,
                           u.business_type,
                           u.bill_type) loop
      begin
        ---2.添加下游佣金利润数据
        if item.up_channel_no != '0' and item.up_account_id != 0 then
        
          --3.计算统计类型
          l_statistics_type := 0;
          if item.bill_type = pkg_bill_type.back then
            if item.business_type = pkg_business_type.SPHY then
              l_statistics_type := pkg_statistics_type.SPHY;
            else
              l_statistics_type := pkg_statistics_type.FlowBag;
            end if;
          else
            --***从业务类型与分类表中获取分类***
            select t.statistics_type
              into l_statistics_type
              from fd_system_business_statis_map t
             where t.local_business_type = item.business_type
               and rownum <= 1;
          end if;
        
          ---4.获取渠道账户名称
          select t.channel_name
            into l_channel_name
            from fd_base_up_channel t
           where t.channel_no = item.up_channel_no;
        
          select t.account_name
            into l_account_name
            from fd_base_up_account t
           where t.account_id = item.up_account_id;
        
          --5.获取渠道系统编号，包括平账
          l_channel_system := item.order_source;
          if l_channel_system = 0 then
          
            select max(t.source_system_id)
              into l_channel_system
              from fd_base_up_system_map t
             where t.channel_no = item.up_channel_no;
          end if;
        
          ---6.添加数据
          insert into fd_report_commi_profit_daily
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_unit,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits,
             service_fee,
             refund_total_unit,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             refund_profits,
             refund_service_fee,
             up_many_face,
             up_many_amount,
             snap_time,
             statistics_type,
             channel_name,
             account_name,
             channel_source_system)
          values
            (seq_report_commi_profit_id.nextval,
             item.up_company_id,
             item.up_channel_no,
             item.up_account_id,
             pkg_channel_type.up_channel,
             item.business_type,
             item.bill_type,
             item.up_draw_unit,
             item.up_draw_face,
             item.up_draw_amount,
             item.up_real_amount,
             (trunc(item.up_draw_amount, 2) - trunc(item.up_real_amount, 2)),
             (item.settle_amount - item.up_real_amount),
             0,
             item.up_draw_unit_ref,
             item.up_draw_face_ref,
             item.up_draw_amount_ref,
             item.up_real_amount_ref,
             (trunc(item.up_draw_amount_ref, 2) -
             trunc(item.up_real_amount_ref, 2)),
             (item.settle_amount_ref - item.up_real_amount_ref),
             0,
             0,
             0,
             l_collect_date,
             l_statistics_type,
             l_channel_name,
             l_account_name,
             l_channel_system);
        end if;
      
        commit;
      
      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_up', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');
  
    commit;
  end if;
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_up', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_CO_RECV_UPDATE
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_auto_co_recv_update as
  -----------------结算账户余额更新----------------
  l_collect_date      date := trunc(sysdate) - 1;
  l_settle_account_id number;
  l_recv_balance      number;
begin
  for item in (select u.down_company_id,
                      u.up_company_id,
                      sum(decode(u.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) * decode(u.settle_amount,
                                              0,
                                              u.up_real_amount,
                                              u.settle_amount)) settle_amount
                 from fd_trade_up_fund u
                where u.change_time >= l_collect_date
                  and u.change_time < (l_collect_date + 1)
                  and u.down_company_id != u.up_company_id
                  and u.down_company_id != 0
                  and u.up_company_id != 0
                  and (u.change_type = pkg_up_fund_change_type.debit_amount or
                      u.change_type = pkg_up_fund_change_type.refund_amount)
                group by u.down_company_id, u.up_company_id) loop
    begin
    
      ---1.获取公司结算账户
      select t.account_id, t.balance
        into l_settle_account_id, l_recv_balance
        from fd_base_company_account_recv t
       where t.owe_company = item.down_company_id
         and t.recv_company = item.up_company_id
         and t.owe_company != t.recv_company
         and t.status = 0
         and rownum <= 1
         for update;
    
      ---2.修改结算账户余额
      update fd_base_company_account_recv t
         set t.balance = l_recv_balance + item.settle_amount
       where t.account_id = l_settle_account_id;
    
      ---3.添加结算记录
      insert into fd_trade_co_recv_fund
        (change_id,
         account_id,
         change_amount,
         change_type,
         balance,
         change_time,
         has_adjust,
         adjust_id,
         bank_batch_id,
         handle_user,
         remark)
      values
        (seq_trade_co_recv_fund_id.nextval,
         l_settle_account_id,
         item.settle_amount,
         pkg_co_fund_recv_type.add_amount,
         l_recv_balance + item.settle_amount,
         sysdate,
         pkg_sys_boolean.istrue,
         0,
         0,
         'sys',
         '自动添加结算账户余额');
    
      if sql%rowcount = 0 then
        rollback;
        fd_p_write_log('fd_p_auto_co_recv_update' || item.down_company_id || '|' ||
                       item.up_company_id,
                       sqlerrm,
                       1);
      else
        commit;
      end if;
    
    exception
      when others then
        rollback;
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_co_recv_update', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_CO_SETTLE_UPDATE
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_auto_co_settle_update as
  ---------------------自动计算公司间结算金额----------------------
  l_start_settle_time date := sysdate - 3 / 24 / 60; ---更新数据的时间范围
  l_end_settle_time   date := sysdate - 1 / 24 / 60; ---更新数据的时间范围

  l_settle_amount     number;
  l_record_id         number;
  l_settle_account_id number;
  l_result            varchar2(32);

begin
  for item in (select a.record_id,
                      a.down_company_id,
                      a.up_company_id,
                      a.change_type,
                      a.down_real_amount,
                      a.up_draw_face,
                      a.up_real_amount,
                      a.down_channel_no,
                      a.up_channel_no,
                      a.business_type,
                      a.carrier_no,
                      a.province_no,
                      a.change_time
                 from fd_trade_up_fund a
                where a.settle_status = pkg_settle_status.wait_settle
                  and a.change_type in
                      (pkg_up_fund_change_type.debit_amount,
                       pkg_up_fund_change_type.refund_amount)
                  and a.change_time >= l_start_settle_time
                  and a.change_time < l_end_settle_time) loop
    begin
      ---1.锁定记录
      select t.record_id
        into l_record_id
        from fd_trade_up_fund t
       where t.record_id = item.record_id
         and t.settle_status = pkg_settle_status.wait_settle
         for update nowait;
    
      /*      l_result := fd_f_co_settle_cost_get(item.down_company_id,
      item.up_company_id,
      item.up_channel_no,
      item.down_channel_no,
      item.business_type,
      item.carrier_no,
      item.province_no,
      l_settle_cost,
      l_settle_account_id);*/
    
      ---2.获取公司间结算价格
      l_result := fd_f_co_settle_amount_get(item.down_company_id,
                                            item.up_company_id,
                                            item.business_type,
                                            item.up_draw_face,
                                            item.down_real_amount,
                                            item.up_real_amount,
                                            l_settle_amount,
                                            l_settle_account_id);
    
      if l_result = pkg_error_code.success then
        ---3. 修改上游资金变动----结算金额，结算状态，结算时间
        update fd_trade_up_fund t
           set t.settle_amount = l_settle_amount,
               t.settle_status = pkg_settle_status.complete_settle,
               t.settle_time   = sysdate
         where t.record_id = item.record_id;
      
      else
        ---4.修改上游资金变动----结算失败
        update fd_trade_up_fund t
           set t.settle_status = pkg_settle_status.settle_fail
         where t.record_id = item.record_id;
      end if;
      if sql%rowcount = 0 then
        rollback;
        fd_p_write_log('fd_p_auto_co_settle_update_error' ||
                       item.record_id,
                       sqlerrm,
                       1);
      else
        commit;
      end if;
    
    exception
      when others then
        rollback;
    end;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_co_settle_update', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_DAILY_ADD_GET
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_auto_daily_add_get(v_report_date in varchar2 default null) as
  ------------------渠道、银行日加款数据收集------------------
  l_report_date    date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_zc_channel_sys varchar2(32) := 'jz_zc'; --记账直冲
  l_dk_channel_sys varchar2(32) := 'jz_dk'; --记账代扣
  l_bank_sys       varchar2(32) := 'jz_bank'; --记账银行
  l_zc_count       number;
  l_bank_count     number;
  l_dk_count       number;
begin
  ---1.生成的加款数据报表日期获取
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  ---2.检查渠道加款数据是否存在
  select count(1)
    into l_zc_count
    from rpt_merge_report_trade_add t
   where t.snap_time = l_report_date
     and t.add_sys_no = l_zc_channel_sys;

  ---3.渠道加款数据不存在，添加数据
  if l_zc_count = 0 then
    insert into rpt_merge_report_trade_add
      (id,
       channel_no,
       account_id,
       account_type,
       add_sys_no,
       add_amount,
       minus_amount,
       snap_time)
      select seq_rpt_merge_trade_add_id.nextval,
             tab.channel_no,
             tab.account_id,
             tab.account_type,
             l_zc_channel_sys,
             tab.add_amount,
             0,
             tab.snap_time
        from (select t.snap_time,
                     t.channel_no,
                     t.account_id,
                     t.account_type,
                     sum(t.add_amount) add_amount
                from fd_v_base_channel_add t
               where t.snap_time = l_report_date
               group by t.snap_time,
                        t.channel_no,
                        t.account_id,
                        t.account_type) tab;
  end if;

  ---4.检查银行加款数据是否存在
  select count(1)
    into l_bank_count
    from rpt_merge_report_trade_add t
   where t.snap_time = l_report_date
     and t.add_sys_no = l_bank_sys;

  ---5.银行加款数据不存在，添加数据
  if l_bank_count = 0 then
    insert into rpt_merge_report_trade_add
      (id,
       channel_no,
       account_id,
       account_type,
       add_sys_no,
       add_amount,
       minus_amount,
       snap_time)
      select seq_rpt_merge_trade_add_id.nextval,
             '-',
             tab.account_id,
             pkg_report_zero_acc_type.bank_account,
             l_bank_sys,
             tab.add_amount,
             tab.minus_amount,
             tab.snap_time
        from (select t.snap_time,
                     t.account_id,
                     sum(t.add_amount) add_amount,
                     sum(t.minus_amount) minus_amount
                from fd_v_base_bank_change t
               where t.snap_time = l_report_date
               group by t.snap_time, t.account_id) tab;
  end if;

  ---6.检查代扣渠道加款数据是否存在
  select count(1)
    into l_dk_count
    from rpt_merge_report_trade_add t
   where t.snap_time = l_report_date
     and t.add_sys_no = l_dk_channel_sys;

  ---7.代扣渠道加款数据不存在，添加数据
  if l_dk_count = 0 then
    insert into rpt_merge_report_trade_add
      (id,
       channel_no,
       account_id,
       account_type,
       add_sys_no,
       add_amount,
       minus_amount,
       snap_time)
      select seq_rpt_merge_trade_add_id.nextval,
             tab.channel_no,
             tab.account_id,
             decode(tab.account_type,
                    pkg_report_zero_acc_type.up_channel,
                    pkg_report_zero_acc_type.down_channel,
                    pkg_report_zero_acc_type.up_channel),
             l_dk_channel_sys,
             tab.add_amount,
             0,
             tab.snap_time
        from (select t.snap_time,
                     t.channel_no,
                     t.account_id,
                     t.account_type,
                     sum(t.add_amount) add_amount
                from dk_v_base_channel_add t
               where t.snap_time = l_report_date
               group by t.snap_time,
                        t.channel_no,
                        t.account_id,
                        t.account_type) tab;
  end if;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_daily_add_get', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_DIFFER_COLLECT
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_auto_differ_collect(v_collect_date in varchar2 default null) as

  --------------------------------
  --功能：自动收集订单差异，并删除一月前的数据
  --修改人：周荣省
  --修改时间：2019-09-04
  --修改内容：1、修改数据删除时间；2、添加时差数据
  --------------------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  l_delete_date  date;
begin

  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;
  l_delete_date := l_collect_date - 30;

  --1.收集订单差异数据
  insert into fd_trade_differ_summary
    (adjust_id,
     record_date,
     company_id,
     channel_no,
     account_id,
     business_type,
     down_first_face,
     down_first_amount)
    select seq_trade_differ_summary_id.nextval,
           m.record_date,
           m.company_id,
           m.channel_no,
           m.account_id,
           m.business_type,
           m.down_first_face,
           m.down_first_amount
      from (select t.record_date,
                   max(c.company_id) company_id,
                   t.channel_no,
                   t.account_id,
                   t.business_type,
                   sum(t.down_first_face) down_first_face,
                   sum(t.down_first_amount) down_first_amount
              from fd_trade_order_main_differ t
             inner join fd_base_down_channel c on t.channel_no =
                                                  c.channel_no
             where t.record_date >= l_collect_date
               and t.record_date < l_collect_date + 1
               and (t.down_first_face != 0 or t.down_first_amount != 0)
             group by t.record_date,
                      t.channel_no,
                      t.account_id,
                      t.business_type) m
     where m.down_first_face != 0
        or m.down_first_amount != 0;
  --2.添加到记录时差表
  insert into fd_trade_time_differ
    select *
      from fd_trade_order_main_differ t
     where t.record_date >= l_collect_date
       and t.record_date < l_collect_date + 1
       and (t.down_first_face != 0 or t.down_first_amount != 0);

  --3.删除订单差异一月前数据
  delete from fd_trade_order_main_differ t
   where t.record_date >= l_delete_date
     and t.record_date < (l_delete_date + 1)
     and t.down_first_amount = 0
     and t.down_first_face != 0;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('fd_auto_differ_collect', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_DOWN_ADD_APPLY_DEL
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_auto_down_add_apply_del as
  --------------------------------------------------
  --功能：自动作废下游加款申请（00:00:00执行）
  --创建人：周荣省
  --创建时间：2019-09-25
  --------------------------------------------------
  l_apply_id number;
begin
  --1、查找还未处理的申请
  for item in (select t.apply_id
                 from fd_trade_down_add_apply t
                where t.status = pkg_b2e_add_apply_status.status_wait
                  and t.create_time < sysdate - 2 / 24
                  and t.create_time>=sysdate-1-3/24) loop
    begin
      select d.apply_id
        into l_apply_id
        from fd_trade_down_add_apply d
       where d.apply_id = item.apply_id
         and d.status = pkg_b2e_add_apply_status.status_wait
         for update;
      --2、更新状态
      update fd_trade_down_add_apply t
         set t.status     = pkg_b2e_add_apply_status.status_fail,
             t.audit_user = '_sys',
             t.audit_memo = '自动作废未处理申请'
       where t.apply_id = item.apply_id;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_down_add_apply_del',
                       item.apply_id || ',' || sqlerrm,
                       1);
    end;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_down_add_apply_del', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_DOWN_PROFIT_SPLIT
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_auto_down_profit_split(v_start_time in varchar2 default null,
                                                        v_end_time   in varchar2 default null) as
  ------------------将交易利润与下游以平账方式平分给下游----------------
  l_start_time       date := to_date(v_start_time, 'yyyymmddhh24miss');
  l_end_time         date := to_date(v_end_time, 'yyyymmddhh24miss');
  l_need_split_count number;
  l_split_profit     number;
  /*  l_result varchar2(32);*/
begin

  ---1.获取处理的时间区间
  if l_start_time is null or l_end_time is null then
    l_start_time := sysdate - 30 / 24 / 60;
    l_end_time   := sysdate;
  end if;

  ---2.获取时间范围内的数据
  select count(1)
    into l_need_split_count
    from fd_trade_up_fund t
   where t.change_time >= l_start_time
     and t.change_time < l_end_time
     and t.change_type in (pkg_up_fund_change_type.debit_amount,
          pkg_up_fund_change_type.refund_amount)
     and t.down_channel_no in
         (select m.channel_no from fd_system_down_profit_map m)
     and (t.split_profit_status != pkg_split_profit_status.success or
         t.split_profit_status is null);

  if l_need_split_count = 0 then
    return;
  end if;

  ---3.将数据状态设置为正在分配
  update fd_trade_up_fund t
     set t.split_profit_status = pkg_split_profit_status.doing
   where t.change_time >= l_start_time
     and t.change_time < l_end_time
     and t.change_type in (pkg_up_fund_change_type.debit_amount,
          pkg_up_fund_change_type.refund_amount)
     and t.down_channel_no in
         (select m.channel_no from fd_system_down_profit_map m)
     and (t.split_profit_status != pkg_split_profit_status.success or
         t.split_profit_status is null);

  if sql%rowcount != l_need_split_count then
    rollback;
    return;
  else
    commit;
  end if;

  ---4.循环对每笔交易进行利润分配
  for item in (select t.record_id,
                      t.down_channel_no,
                      t.down_account_id,
                      t.down_real_amount,
                      t.up_real_amount,
                      t.business_type,
                      t.bill_type,
                      decode(t.change_type,
                             pkg_up_fund_change_type.debit_amount,
                             1,
                             -1) change_num,
                      m.profit_ratio
                 from fd_trade_up_fund t
                inner join fd_system_down_profit_map m on t.down_channel_no =
                                                          m.channel_no
                where t.change_time >= l_start_time
                  and t.change_time < l_end_time
                  and t.split_profit_status = pkg_split_profit_status.doing) loop
    begin
      l_split_profit := (item.down_real_amount - item.up_real_amount) *
                        item.profit_ratio * item.change_num;
    
      if l_split_profit != 0 then
        /*l_result := fd_f_manual_down_rv_trade(item.down_channel_no,
                                              item.down_account_id,
                                              -1 * l_split_profit, ---减少下游扣款，公司利润减少，渠道余额增加
                                              -1 * l_split_profit,
                                              item.business_type,
                                              item.bill_type,
                                              'sys',
                                              '自动分配利润给下游平账',
                                              pkg_split_profit_status.success);
        if (l_result != pkg_error_code.success) then
          rollback;
          update fd_trade_up_fund t
             set t.split_profit_status = pkg_split_profit_status.failure
           where t.record_id = item.record_id;
        end if;*/
      
        insert into fd_trade_down_manual_yc
          (record_id,
           channel_no,
           account_id,
           adjust_id,
           has_adjust,
           add_type,
           change_amount,
           change_time,
           balance,
           create_user,
           memo,
           real_amount,
           business_type,
           bill_type,
           deal_status)
        values
          (seq_trade_down_manual_yc_id.nextval,
           item.down_channel_no,
           item.down_account_id,
           0,
           0,
           pkg_down_manual_change_type.trade_revise,
           -1 * l_split_profit,
           sysdate,
           0,
           'sys',
           '自动分配利润给下游平账记录',
           -1 * l_split_profit,
           item.business_type,
           item.bill_type,
           pkg_trade_down_yc_deal_status.notdeal);
      end if;
    
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_down_profit_split', sqlerrm, 1);
    end;
  end loop;

  ---5.将分配成功记录状态设置为成功
  update fd_trade_up_fund t
     set t.split_profit_status = pkg_split_profit_status.success
   where t.change_time >= l_start_time
     and t.change_time < l_end_time
     and t.split_profit_status = pkg_split_profit_status.doing;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_down_profit_split', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_DOWN_PROFIT_SPLITADD
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_auto_down_profit_splitadd(v_add_date in varchar2 default null) as
  ---------------分配利润合计平账处理---------------
  l_split_date date := trunc(to_date(v_add_date, 'yyyymmddhh24miss'));
  l_count      number;
  l_fund_id    number;
  l_result     varchar2(32);
  l_roll       boolean := false;
begin
  ---1.获取处理的时间区间
  if l_split_date is null then
    l_split_date := trunc(sysdate - 1);
  end if;

  ---2.获取所有分配的利润数据
  select count(1)
    into l_count
    from fd_trade_down_manual_yc t
   where t.change_time >= l_split_date
     and t.change_time < l_split_date + 1
     and t.deal_status = pkg_trade_down_yc_deal_status.notdeal
     and t.add_type = pkg_down_manual_change_type.trade_revise;

  if l_count = 0 then
    return;
  end if;

  ---3.将数据修改为正在处理
  update fd_trade_down_manual_yc t
     set t.deal_status = pkg_trade_down_yc_deal_status.dealing
   where t.change_time >= l_split_date
     and t.change_time < l_split_date + 1
     and t.deal_status = pkg_trade_down_yc_deal_status.notdeal
     and t.add_type = pkg_down_manual_change_type.trade_revise;

  if sql%rowcount != l_count then
    rollback;
    return;
  else
    commit;
  end if;

  ---4.循环添加平账记录
  for item in (select y.channel_no,
                      y.account_id,
                      y.business_type,
                      y.bill_type,
                      sum(y.change_amount) change_amount,
                      sum(y.real_amount) real_amount
                 from fd_trade_down_manual_yc y
                where y.change_time >= l_split_date
                  and y.change_time < l_split_date + 1
                  and y.deal_status = pkg_trade_down_yc_deal_status.dealing
                group by y.channel_no,
                         y.account_id,
                         y.business_type,
                         y.bill_type) loop
    begin
      l_result := fd_f_manual_down_rv_trade(item.channel_no,
                                            item.account_id,
                                            item.change_amount, ---减少下游扣款，公司利润减少，渠道余额增加
                                            item.real_amount,
                                            item.business_type,
                                            item.bill_type,
                                            'sys',
                                            to_char(l_split_date,
                                                    'yyyy-mm-dd') ||
                                            '利润分配平账',
                                            pkg_split_profit_status.success,
                                            l_fund_id);
      if (l_result != pkg_error_code.success) then
        l_roll := true;
      end if;
    
    exception
      when others then
        l_roll := true;
        fd_p_write_log('fd_p_auto_down_profit_splitadd', sqlerrm, 1);
    end;
  end loop;

  if l_roll then
    rollback;
  
    update fd_trade_down_manual_yc t
       set t.deal_status = pkg_trade_down_yc_deal_status.failure
     where t.change_time >= l_split_date
       and t.change_time < l_split_date + 1
       and t.deal_status = pkg_trade_down_yc_deal_status.dealing;
  else
    update fd_trade_down_manual_yc t
       set t.deal_status = pkg_trade_down_yc_deal_status.ok
     where t.change_time >= l_split_date
       and t.change_time < l_split_date + 1
       and t.deal_status = pkg_trade_down_yc_deal_status.dealing;
  end if;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_down_profit_splitadd', sqlerrm, 1);
  
end;
/

prompt
prompt Creating procedure FD_P_AUTO_FUELCARD_FEE_COLLECT
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_auto_fuelcard_fee_collect(v_collect_date in varchar2 default null) as
  ---------------------加油卡手续费自动收集---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_order_source  number;
  l_company_id    number;
  l_record_count  number;
  l_collect_month date;
begin

  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;
  l_collect_month := trunc(l_collect_date, 'mm');

  --1.收集加油卡下游资金变动
  /*  select t.source_system_id
   into l_order_source
   from fd_base_source_system t
  where t.source_system_name = 'GRS';*/

  for item in (select f.channel_no,
                      sum(decode(f.change_type,
                                 pkg_down_fund_change_type.debit_amount,
                                 1,
                                 -1) * f.service_fee) service_fee
                 from fd_trade_down_fund f
                where f.create_time >= l_collect_date
                  and f.create_time < (l_collect_date + 1)
                  and f.change_type in
                      (pkg_down_fund_change_type.debit_amount,
                       pkg_down_fund_change_type.refund_amount)
                  and f.order_source in (21,41, 161) -----GRS XNCZ  加油卡系统 和聚合发货系统手续费
                group by f.channel_no) loop
    begin
      --2.查询渠道公司
      select t.company_id
        into l_company_id
        from fd_base_down_channel t
       where t.channel_no = item.channel_no;
    
      --3.判断该月是否添加过数据
      select count(1)
        into l_record_count
        from fd_report_service_fee t
       where t.report_month = l_collect_month
         and t.channel_no = item.channel_no;
    
      --4.添加相关加油卡渠道手续费
      if l_record_count > 0 then
        update fd_report_service_fee t
           set t.service_fee = (t.service_fee + item.service_fee)
         where t.report_month = l_collect_month
           and t.channel_no = item.channel_no;
      else
        insert into fd_report_service_fee
          (record_id, report_month, company_id, channel_no, service_fee)
        values
          (seq_report_service_fee_id.nextval,
           l_collect_month,
           l_company_id,
           item.channel_no,
           item.service_fee);
      end if;
    
      if sql%rowcount > 0 then
        commit;
      else
        rollback;
      end if;
    
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_fuelcard_fee_collect', sqlerrm, 1);
    end;
  end loop;

  rollback;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_fuelcard_fee_collect', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_FUELCARD_FEE_COLL_HS
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_auto_fuelcard_fee_coll_hs(v_collect_date in varchar2 default null) as
  ---------------------加油卡手续费自动收集---------------------
  l_collect_date  date := to_date(v_collect_date, 'yyyymmddhh24miss');
  l_order_source  number;
  l_company_id    number;
  l_record_count  number;
  l_collect_month date;
begin

  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;
  l_collect_month := trunc(l_collect_date, 'mm');

  --1.收集加油卡下游资金变动
  select t.source_system_id
    into l_order_source
    from fd_base_source_system t
   where t.source_system_name = 'GRS';

  for item in (select f.channel_no,
                      sum(decode(f.change_type,
                                 pkg_down_fund_change_type.debit_amount,
                                 1,
                                 -1) * f.service_fee) service_fee
                 from fd_trade_down_fund_hs f
                where f.create_time >= l_collect_date
                  and f.create_time < (l_collect_date + 1)
                  and f.change_type in
                      (pkg_down_fund_change_type.debit_amount,
                       pkg_down_fund_change_type.refund_amount)
                  and f.order_source = l_order_source
                group by f.channel_no) loop
    begin
      --2.查询渠道公司
      select t.company_id
        into l_company_id
        from fd_base_down_channel t
       where t.channel_no = item.channel_no;
    
      --3.判断该月是否添加过数据
      select count(1)
        into l_record_count
        from fd_report_service_fee t
       where t.report_month = l_collect_month
         and t.channel_no = item.channel_no;
    
      --4.添加相关加油卡渠道手续费
      if l_record_count > 0 then
        update fd_report_service_fee t
           set t.service_fee = (t.service_fee + item.service_fee)
         where t.report_month = l_collect_month
           and t.channel_no = item.channel_no;
      else
        insert into fd_report_service_fee
          (record_id, report_month, company_id, channel_no, service_fee)
        values
          (seq_report_service_fee_id.nextval,
           l_collect_month,
           l_company_id,
           item.channel_no,
           item.service_fee);
      end if;
    
      if sql%rowcount > 0 then
        commit;
      else
        rollback;
      end if;
    
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_fuelcard_fee_coll_hs', sqlerrm, 1);
    end;
  end loop;

  rollback;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_fuelcard_fee_coll_hs', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_RECV_BALANCE_OFFSET
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_auto_recv_balance_offset as
  ---------------公司间结算收款账户余额相抵---------------
  l_front_count        number;
  l_front_balance      number;
  l_back_count         number;
  l_back_balance       number;
  l_front_account_id   number;
  l_back_account_id    number;
  l_front_lock_balance number;
  l_back_lock_balance  number;
  l_result             varchar2(32);
begin
  for item in (select r.owe_company, r.recv_company
                 from fd_base_company_account_recv r
                where r.status = 0) loop
  
    ---1.获取公司结算账户余额
    select count(1), max(t.balance), max(t.account_id)
      into l_front_count, l_front_balance, l_front_account_id
      from fd_base_company_account_recv t
     where t.owe_company = item.owe_company
       and t.recv_company = item.recv_company
       and t.status = 0;
  
    ---2.获取反向结算账户余额
    select count(1), max(t.balance), max(t.account_id)
      into l_back_count, l_back_balance, l_back_account_id
      from fd_base_company_account_recv t
     where t.owe_company = item.recv_company
       and t.recv_company = item.owe_company
       and t.status = 0;
  
    if l_front_count != 0 and l_back_count != 0 and l_front_balance != 0 and
       l_back_balance != 0 then
      ---3.满足相互抵扣的条件，锁相互抵扣的账户
      select t.balance
        into l_front_lock_balance
        from fd_base_company_account_recv t
       where t.account_id = l_front_account_id
         for update;
    
      select t.balance
        into l_back_lock_balance
        from fd_base_company_account_recv t
       where t.account_id = l_back_account_id
         for update;
    
      ---4.账户余额抵扣
      if l_front_lock_balance >= l_back_lock_balance then
        l_result := fd_f_recv_balance_offset(l_front_account_id,
                                             l_back_account_id,
                                             l_front_lock_balance,
                                             l_back_lock_balance,
                                             l_back_lock_balance);
      else
        l_result := fd_f_recv_balance_offset(l_front_account_id,
                                             l_back_account_id,
                                             l_front_lock_balance,
                                             l_back_lock_balance,
                                             l_front_lock_balance);
      end if;
    end if;
  
    commit;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_recv_balance_offset', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_SERVICE_FEE_COLLECT
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_auto_service_fee_collect as
  ----------------------每日统一计算手续费---------------------
  l_collect_date    date := trunc(sysdate, 'dd') - 1;
  l_fee_fund_count  number;
  l_service_fee     number;
  l_service_account number;
  l_service_balance number;
  l_channel_service number;
  l_bank_service    number;
  l_cap_service     number;
begin

  for item in (select a.company_id from fd_base_company_info a) loop
  
    begin
      ---1.检查手续费是否计算
      select count(1)
        into l_fee_fund_count
        from fd_trade_co_self_fund t
       inner join fd_base_company_account_self s
          on t.account_id = s.account_id
       where t.change_time >= l_collect_date + 1
         and t.change_time < l_collect_date + 2
         and t.change_type = pkg_co_self_fund_type.add_amount
         and s.account_type = pkg_co_self_account_type.service_fee
         and s.company_id = item.company_id;
    
      if l_fee_fund_count = 0 then
        ---2.1.计算需加上的手续费
        select nvl(sum(t.change_amount), 0)
          into l_bank_service
          from fd_bank_cash_fund t
         where t.use_type = pkg_bank_use_type.service_fee
           and t.company_id = item.company_id
           and t.change_type = pkg_bank_fund_change_type.minus_amount
           and t.change_time >= l_collect_date
           and t.change_time < (l_collect_date + 1)
           and t.service_id not in
               (select c.bank_batch_id
                  from fd_trade_co_self_fund c
                 where c.change_time >= l_collect_date
                   and c.change_time < (l_collect_date + 1)
                   and c.bank_batch_id is not null);
      
        ---2.2.下游加款的手续费
        select nvl(sum(t.change_amount), 0)
          into l_channel_service
          from fd_trade_down_manual t
         inner join fd_base_down_channel c
            on t.channel_no = c.channel_no
         where t.add_type in
               (pkg_down_manual_change_type.service_add,
                pkg_down_manual_change_type.service_red)
           and c.company_id = item.company_id
           and t.change_time >= l_collect_date
           and t.change_time < (l_collect_date + 1);
      
        ---2.3.资产账户手续费（转账退款）
        select nvl(sum(t.change_amount), 0)
          into l_cap_service
          from fd_trade_co_cap_fund t
         inner join fd_base_company_account_cap c
            on t.account_id = c.account_id
         where t.change_time >= l_collect_date
           and t.change_time < (l_collect_date + 1)
           and t.change_type = pkg_co_cap_fund_type.service_fee
           and c.company_id = item.company_id;
      
        l_service_fee := l_bank_service + l_channel_service + l_cap_service;
      
        if l_service_fee != 0 then
          ---3.锁手续费账户
          select t.account_id, t.balance
            into l_service_account, l_service_balance
            from fd_base_company_account_self t
           where t.company_id = item.company_id
             and t.account_type = pkg_co_self_account_type.service_fee
                -- and t.status = pkg_sys_boolean.istrue
             and rownum <= 1
             for update;
        
          ---4.手续费账户加上扣除的手续费
          update fd_base_company_account_self t
             set t.balance       =
                 (l_service_balance + l_service_fee),
                 t.last_edit_time = sysdate
           where t.account_id = l_service_account;
        
          ---5.添加资金变动记录
          insert into fd_trade_co_self_fund
            (change_id,
             account_id,
             change_amount,
             change_type,
             balance,
             change_time,
             has_adjust)
          values
            (seq_trade_co_self_fund_id.nextval,
             l_service_account,
             l_service_fee,
             pkg_co_self_fund_type.add_amount,
             (l_service_balance + l_service_fee),
             sysdate,
             pkg_sys_boolean.istrue);
        end if;
      
      end if;
    
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_service_fee_collect', sqlerrm, 1);
    end;
  end loop;

end;
/

prompt
prompt Creating procedure FD_P_AUTO_SYNC2USER_SYSTEM
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_auto_sync2user_system as
  -----------------------将报警数据同步到用户系统-------------------------- 
  l_status number;
  l_msg    varchar2(255);
begin

  ---1.查询最近5分钟等待报警的数据
  for item in (select t.*
                 from fd_system_warn t
                where t.warn_date > sysdate - 5 / 24 / 60
                  and t.sync_status = pkg_balance_sync_status.wait) loop
    begin
      update fd_system_warn t
         set t.sync_status = pkg_balance_sync_status.syncing
       where t.warn_id = item.warn_id
         and t.sync_status = pkg_balance_sync_status.wait;
      if sql%rowcount > 0 then
        ---2. 发送到用户系统
/*        us_sp_add_alarm_msg@us('SA',
                               item.warn_level,
                               item.title,
                               '[CW]' || item.content,
                               item.key_word,
                               l_status,
                               l_msg);
*/      
        ---3. 更新本地状态
        update fd_system_warn t
           set t.sync_status = decode(l_status,
                                      100,
                                      pkg_balance_sync_status.complate,
                                      pkg_balance_sync_status.failed)
         where t.warn_id = item.warn_id;
        commit;
      else
        rollback;
      end if;
      rollback;
    exception
      when others then
        rollback;
    end;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_sync2user_system', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_SYNC_ZERO2MR
prompt =========================================
prompt
create or replace procedure fd_account.fd_p_auto_sync_zero2mr as
  --------------------同步零点余额到18系统---------------------
  l_record_date     date := trunc(sysdate) - 1;
  l_system_no       varchar2(10) := 'SA';
  l_common_system   varchar2(10) := 'CZ';
  l_bank_card_no    varchar2(64);
  l_cap_acount_type number;

begin
  for item in (select z.record_date,
                      z.account_type,
                      z.account_id,
                      z.channel_no,
                      z.account_name,
                      z.channel_name,
                      z.balance
                 from fd_report_zero_balance z
                where z.record_date = l_record_date
                  and z.account_type in
                      (pkg_report_zero_acc_type.up_channel,
                       pkg_report_zero_acc_type.down_channel,
                       pkg_report_zero_acc_type.bank_account,
                       pkg_report_zero_acc_type.cap_account,
                       pkg_report_zero_acc_type.down_commi_account,
                       pkg_report_zero_acc_type.up_commi_account)) loop
    begin
      ---1.同步银行账户零点余额
      if item.account_type = pkg_report_zero_acc_type.bank_account then
        select t.card_no
          into l_bank_card_no
          from fd_bank_account_info t
         where t.account_id = item.account_id;
      
        /*      insert into zw_bank_balance@bhdb
          (record_date,
           bank_id,
           account_no,
           account_name,
           balance,
           created_time,
           system_no)
        values
          (l_record_date,
           item.account_id,
           l_bank_card_no,
           item.account_name,
           item.balance,
           sysdate,
           l_system_no);*/
      end if;
    
      ---2.同步渠道零点余额
      /*            if item.account_type = pkg_report_zero_acc_type.up_channel or
         item.account_type = pkg_report_zero_acc_type.down_channel then
      
              insert into zw_channel_balance@bhdb
          (record_date,
           channel_no,
           channel_name,
           channel_type,
           inner_balance,
           created_time,
           system_no)
        values
          (item.record_date,
           item.channel_no,
           item.channel_name,
           item.account_type,
           item.balance,
           sysdate,
           l_system_no);
      end if;*/
    
      ---3.同步保证金、押金零点余额
      if item.account_type = pkg_report_zero_acc_type.cap_account then
        select t.account_type
          into l_cap_acount_type
          from fd_base_company_account_cap t
         where t.account_id = item.account_id;
      
        ---3.1检查数据账户类型
        /*        if l_cap_acount_type = pkg_co_cap_account_type.deposit or
           l_cap_acount_type = pkg_co_cap_account_type.bond then
        
                  insert into zw_other_fund_balance@bhdb
            (record_date,
             fund_name,
             fund_type,
             balance,
             created_time,
             fund_id,
             system_no)
          values
            (item.record_date,
             item.account_name,
             pkg_18cap_type.capital,
             item.balance,
             sysdate,
             item.account_id,
             l_system_no);
        
        end if;*/
      end if;
    
      ---4.同步渠道佣金
/*      if item.account_type = pkg_report_zero_acc_type.down_commi_account or
         item.account_type = pkg_report_zero_acc_type.up_commi_account then
      
        insert into zw_channel_commission@bhdb
          (record_date,
           channel_no,
           channel_name,
           channel_type,
           money_fee,
           created_time,
           system_no)
        values
          (l_record_date,
           item.channel_no,
           item.channel_name,
           decode(pkg_report_zero_acc_type.up_commi_account, 1, 2),
           item.balance,
           sysdate,
           l_common_system);
      
      end if;*/
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_sync_zero2mr', sqlerrm, 1);
    end;
  
  end loop;
end;
/

prompt
prompt Creating procedure FD_P_AUTO_SYSTEM_LOG_DEL
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_auto_system_log_del as
  -------------------------------------------------
  --功能：删除系统错误日志
  --创建人：周荣省
  --创建时间：2019-09-02
  -------------------------------------------------

begin

  ---1.删除三天前的数据
  delete fd_system_log t
   where t.created_time< trunc(sysdate) - 4;
  commit;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_system_warn_del', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_SYSTEM_WARN_DEL
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_auto_system_warn_del as
  -------------------------------------------------
  --功能：删除系统报警数据
  --创建人：周荣省
  --创建时间：2019-09-02
  -------------------------------------------------

begin

  ---1.删除三天前的数据
  delete fd_system_warn t
   where t.sync_status = 0
     and t.warn_date < trunc(sysdate) - 4;
  commit;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_system_warn_del', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUTO_USE_WARN_DOWN
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_auto_use_warn_down as
  -----------------------下游渠道使用告警----------------------
  l_time_now     date := trunc(sysdate) - 1;
  l_time_start   date := add_months(l_time_now, -1);
  l_count        number;
  l_balance      number;
  l_change_count number;
  l_total_count  number;
begin

  for item in (select tb.channel_no,
                      tb.account_id,
                      a.account_name,
                      c.channel_name,
                      decode(a.status, 0, '启用', '禁用') account_status,
                      decode(c.status, 0, '启用', '禁用') channel_status
                 from fd_base_down_account_map tb
                inner join fd_base_down_account a on tb.account_id =
                                                     a.account_id
                inner join fd_base_down_channel c on tb.channel_no =
                                                     c.channel_no) loop
  
    begin
    
      ---1.获取渠道最近的余额
      select count(1), max(t.balance)
        into l_count, l_balance
        from fd_report_zero_balance t
       where t.account_id = item.account_id
         and t.channel_no = item.channel_no
         and t.account_type = pkg_report_zero_acc_type.down_channel
         and t.record_date = l_time_now
         and rownum <= 2;
    
      if l_count = 1 then
        ---2.1检查最近一月数据总条数
        select count(1)
          into l_total_count
          from fd_report_zero_balance t
         where t.account_id = item.account_id
           and t.channel_no = item.channel_no
           and t.account_type = pkg_report_zero_acc_type.down_channel
           and t.record_date > l_time_start
           and t.record_date <= l_time_now;
      
        ---2.检查最近一月余额不同的数据条数
        select count(1)
          into l_change_count
          from fd_report_zero_balance t
         where t.balance != l_balance
           and t.account_id = item.account_id
           and t.channel_no = item.channel_no
           and t.account_type = pkg_report_zero_acc_type.down_channel
           and t.record_date > l_time_start
           and t.record_date <= l_time_now;
      
        ---3.没有余额不同的数据，渠道连续一月未使用
        if (l_change_count = 0) and (l_total_count > 30) then
          insert into fd_system_warn
            (warn_id,
             uniq_id,
             warn_level,
             warn_type,
             title,
             warn_date,
             content,
             sync_status,
             key_word)
          values
            (seq_system_warn_id.nextval,
             'ZR' || item.account_id,
             5,
             pkg_warn_into_type.use_warn,
             '下游渠道:' || item.channel_name || ' 连续一月未使用.',
             sysdate,
             '下游渠道:' || item.channel_name || ' 渠道状态:' ||
             item.channel_status || '. 连续一月未使用.渠道支付账户:' ||
             item.account_name || ' 支付账户状态:' || item.account_status,
             pkg_balance_sync_status.wait,
             '下游渠道连续一月未使用');
        end if;
      end if;
    
      commit;
    
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_use_warn_down', sqlerrm, 1);
    end;
  end loop;
end;
/

prompt
prompt Creating procedure FD_P_AUTO_USE_WARN_UP
prompt ========================================
prompt
create or replace procedure fd_account.fd_p_auto_use_warn_up as
  -----------------------上游渠道使用告警----------------------
  l_time_now     date := trunc(sysdate) - 1;
  l_time_start   date := add_months(l_time_now, -1);
  l_count        number;
  l_balance      number;
  l_change_count number;
  l_total_count  number;
begin

  for item in (select tb.channel_no,
                      tb.account_id,
                      a.account_name,
                      c.channel_name,
                      decode(a.status, 0, '启用', '禁用') account_status,
                      decode(c.status, 0, '启用', '禁用') channel_status
                 from fd_base_up_account_map tb
                inner join fd_base_up_account a on tb.account_id =
                                                   a.account_id
                inner join fd_base_up_channel c on tb.channel_no =
                                                   c.channel_no
                where a.account_type = pkg_up_account_type.sys_account) loop
  
    begin
    
      ---1.获取渠道最近的余额
      select count(1), max(t.balance)
        into l_count, l_balance
        from fd_report_zero_balance t
       where t.account_id = item.account_id
         and t.channel_no = item.channel_no
         and t.account_type = pkg_report_zero_acc_type.up_channel
         and t.record_date = l_time_now
         and rownum <= 2;
    
      if l_count = 1 then
        ---2.1检查最近一月余额数据总条数
        select count(1)
          into l_total_count
          from fd_report_zero_balance t
         where t.account_id = item.account_id
           and t.channel_no = item.channel_no
           and t.account_type = pkg_report_zero_acc_type.up_channel
           and t.record_date > l_time_start
           and t.record_date <= l_time_now;
      
        ---2.检查最近一月余额不同的数据条数
        select count(1)
          into l_change_count
          from fd_report_zero_balance t
         where t.balance != l_balance
           and t.account_id = item.account_id
           and t.channel_no = item.channel_no
           and t.account_type = pkg_report_zero_acc_type.up_channel
           and t.record_date > l_time_start
           and t.record_date <= l_time_now;
      
        ---3.没有余额不同的数据，渠道连续一月未使用
        if (l_change_count = 0) and (l_total_count > 30) then
          insert into fd_system_warn
            (warn_id,
             uniq_id,
             warn_level,
             warn_type,
             title,
             warn_date,
             content,
             sync_status,
             key_word)
          values
            (seq_system_warn_id.nextval,
             'ZR' || item.account_id,
             5,
             pkg_warn_into_type.use_warn,
             '上游渠道:' || item.channel_name || ' 连续一月未使用.',
             sysdate,
             '上游渠道:' || item.channel_name || ' 渠道状态:' ||
             item.channel_status || '. 连续一月未使用.渠道支付账户为:' ||
             item.account_name || ' 支付账户状态:' || item.account_status,
             pkg_balance_sync_status.wait,
             '上游渠道连续一月未使用');
        end if;
      end if;
    
      commit;
    
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_use_warn_up', sqlerrm, 1);
    end;
  end loop;

end;
/

prompt
prompt Creating procedure FD_P_AUTO_ZERO_BANK_GET
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_auto_zero_bank_get(v_report_date in varchar2 default null) as
  -----------------获取银行零点余额--------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_count           number;
  l_max_record      number;
  l_report_count    number;
  l_max_change_time date;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select a.account_id,
                      a.account_name,
                      a.card_no,
                      a.balance,
                      a.company_id
                 from fd_bank_account_info a) loop
    begin
      ---2.检查记录是否存在
      select count(1)
        into l_report_count
        from fd_report_zero_balance t
       where t.record_date = l_report_date
         and t.account_type = pkg_report_zero_acc_type.bank_account
         and t.account_id = item.account_id
         and rownum <= 1;
    
      if l_report_count = 0 then
      
        ---3.检查渠道资金变动是否存在
        select count(1), max(t.change_time)
          into l_count, l_max_change_time
          from fd_bank_cash_fund t
         where t.change_time >= l_report_date
           and t.change_time < l_report_date + 1
           and t.account_id = item.account_id;
      
        if l_count > 0 then
          ---2.有资金变动，添加最后一笔资金变动的余额
          select max(t.record_id)
            into l_max_record
            from fd_bank_cash_fund t
           where t.change_time = l_max_change_time
             and t.account_id = item.account_id;
        
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.bank_account,
                   item.account_id,
                   '-',
                   t.balance,
                   item.account_name || substr(item.card_no, -4),
                   '-',
                   0,
                   0,
                   item.company_id
              from fd_bank_cash_fund t
             where t.record_id = l_max_record;
        
        else
          ---3.没有资金变动，取昨天零点余额的值
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.bank_account,
                   item.account_id,
                   '-',
                   tab.zero_balance,
                   item.account_name || substr(item.card_no, -4),
                   '-',
                   0,
                   0,
                   item.company_id
              from (select nvl(max(t.balance), item.balance) zero_balance
                      from fd_report_zero_balance t
                     where t.record_date = (l_report_date - 1)
                       and t.account_type =
                           pkg_report_zero_acc_type.bank_account
                       and t.account_id = item.account_id
                       and rownum <= 1) tab;
        end if;
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_zero_bank_get', sqlerrm, 1);
    end;
  end loop;

end;
/

prompt
prompt Creating procedure FD_P_AUTO_ZERO_CAP_GET
prompt =========================================
prompt
create or replace procedure fd_account.fd_p_auto_zero_cap_get(v_report_date in varchar2 default null) as
  --------------------获取资产账户的零点余额-------------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number;
  l_count           number;
  l_max_change_id   number;
  l_max_change_time date;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select c.account_id,
                      c.account_name,
                      c.status,
                      c.balance,
                      c.company_id,
                      c.account_type
                 from fd_base_company_account_cap c
                where c.account_type != pkg_co_cap_account_type.profit) loop
    begin
      ---2.检查记录是否存在
      select count(1)
        into l_report_count
        from fd_report_zero_balance t
       where t.account_type = pkg_report_zero_acc_type.cap_account
         and t.record_date = l_report_date
         and t.account_id = item.account_id;
    
      if l_report_count = 0 then
        ---3.查询资产账户是否有资金变动
        select count(1), max(t.change_time)
          into l_count, l_max_change_time
          from fd_trade_co_cap_fund t
         where t.change_time >= l_report_date
           and t.change_time < (l_report_date + 1)
           and t.account_id = item.account_id;
      
        if l_count > 0 then
          ---3.有资金变动，获取最后一笔变动记录
          select max(t.change_id)
            into l_max_change_id
            from fd_trade_co_cap_fund t
           where t.change_time = l_max_change_time
             and t.account_id = item.account_id;
        
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             co_account_type)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.cap_account,
                   item.account_id,
                   '-',
                   t.balance,
                   item.account_name,
                   '-',
                   0,
                   item.status,
                   item.company_id,
                   item.account_type
              from fd_trade_co_cap_fund t
             where t.change_id = l_max_change_id;
        else
          ---4.没有资金变动，获取前一天的零点余额
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             co_account_type)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.cap_account,
                   item.account_id,
                   '-',
                   tab.zero_balance,
                   item.account_name,
                   '-',
                   0,
                   item.status,
                   item.company_id,
                   item.account_type
              from (select nvl(max(t.balance), item.balance) zero_balance
                      from fd_report_zero_balance t
                     where t.record_date = (l_report_date - 1)
                       and t.account_type =
                           pkg_report_zero_acc_type.cap_account
                       and t.account_id = item.account_id
                       and rownum <= 1) tab;
        
        end if;
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_zero_cap_get', sqlerrm, 1);
    end;
  end loop;
end;
/

prompt
prompt Creating procedure FD_P_AUTO_ZERO_DOWN_COMMI_GET
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_auto_zero_down_commi_get(v_report_date in varchar2 default null) as
  --------------------获取下游佣金账户的零点余额-------------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number;
  l_count           number;
  l_max_change_id   number;
  l_max_change_time date;
  l_before_commi    number;
  l_system_id       number;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  ---2.循环需要后返佣金的下游渠道
  for item in (select c.channel_no,
                      c.channel_name,
                      c.commi_balance,
                      c.company_id,
                      c.status
                 from fd_base_down_channel c) loop
    begin
      ---3.检查下游佣金零点余额是否存在
      select count(1)
        into l_report_count
        from fd_report_zero_balance t
       where t.record_date = l_report_date
         and t.account_type = pkg_report_zero_acc_type.down_commi_account
         and t.channel_no = item.channel_no;
    
      if l_report_count = 0 then
        ---4.检查是否有佣金账户变动记录
        select count(1), max(t.settle_time)
          into l_count, l_max_change_time
          from fd_trade_commission_settle t
         where t.settle_time >= l_report_date
           and t.settle_time < (l_report_date + 1 + 3 / 24)
           and t.channel_no = item.channel_no
           and t.channel_type = pkg_channel_type.down_channel;
      
        select min(t.source_system_id)
          into l_system_id
          from fd_base_down_system_map t
         where t.channel_no = item.channel_no;
      
        if l_count > 0 then
          ---5.获取渠道佣金最后的变动记录
          select max(t.report_id)
            into l_max_change_id
            from fd_trade_commission_settle t
           where t.settle_time = l_max_change_time
             and t.channel_no = item.channel_no
             and t.channel_type = pkg_channel_type.down_channel;
        
          ---6.添加下游佣金零点余额记录
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             channel_name,
             channel_status,
             company_id,
             channel_source_system)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.down_commi_account,
                   0,
                   item.channel_no,
                   t.commi_balance,
                   item.channel_name,
                   item.status,
                   item.company_id,
                   l_system_id
              from fd_trade_commission_settle t
             where t.report_id = l_max_change_id;
        else
          ---7.获取前一天零点余额
          select nvl(max(t.balance), item.commi_balance)
            into l_before_commi
            from fd_report_zero_balance t
           where t.record_date = (l_report_date - 1)
             and t.account_type =
                 pkg_report_zero_acc_type.down_commi_account
             and t.channel_no = item.channel_no;
        
          ---8.没有变动记录，添加前一天零点余额
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             channel_name,
             channel_status,
             company_id,
             channel_source_system)
          values
            (seq_report_zero_balance_id.nextval,
             l_report_date,
             sysdate,
             pkg_report_zero_acc_type.down_commi_account,
             0,
             item.channel_no,
             l_before_commi,
             item.channel_name,
             item.status,
             item.company_id,
             l_system_id);
        end if;
      
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_zero_down_commi_get', sqlerrm, 1);
    end;
  end loop;

end;
/

prompt
prompt Creating procedure FD_P_AUTO_ZERO_DOWN_GET
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_auto_zero_down_get(v_report_date in varchar2 default null) as
  -----------------获取下游零点余额--------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_count           number;
  l_max_record      number;
  l_report_count    number;
  l_max_change_time date;
  l_system_id       number;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select tb.channel_no,
                      tb.account_id,
                      a.account_name,
                      c.channel_name,
                      a.status account_status,
                      c.status channel_status,
                      a.inner_balance,
                      c.company_id,
                      c.warn_balance,
                      (nvl(f.down_first_face, 0) -
                      nvl(ur.down_adjust_face, 0)) down_first_face,
                      (nvl(f.down_first_amount, 0) -
                      nvl(ur.down_adjust_amount, 0)) down_first_amount
                 from fd_base_down_account_map tb
                inner join fd_base_down_account a
                   on tb.account_id = a.account_id
                inner join fd_base_down_channel c
                   on tb.channel_no = c.channel_no
                 left join (select d.channel_no,
                                  d.account_id,
                                  sum(d.down_first_face) down_first_face,
                                  sum(d.down_first_amount) down_first_amount
                             from fd_trade_order_main_differ d
                            where d.record_date = l_report_date
                            group by d.channel_no, d.account_id) f
                   on tb.channel_no = f.channel_no
                  and tb.account_id = f.account_id
                 left join (select u.channel_no,
                                  u.account_id,
                                  sum(u.down_adjust_face) down_adjust_face,
                                  sum(u.down_adjust_amount) down_adjust_amount
                             from fd_trade_up_fund_differ u
                            where u.record_date = l_report_date
                            group by u.channel_no, u.account_id) ur
                   on tb.channel_no = ur.channel_no
                  and tb.account_id = ur.account_id) loop
    begin
      ---0.检查记录是否存在
      select count(1)
        into l_report_count
        from fd_report_zero_balance t
       where t.record_date = l_report_date
         and t.account_type = pkg_report_zero_acc_type.down_channel
         and t.channel_no = item.channel_no
         and t.account_id = item.account_id
         and rownum <= 1;
    
      if l_report_count = 0 then
      
        ---1.检查渠道资金变动是否存在
        select count(1), max(t.create_time)
          into l_count, l_max_change_time
          from fd_trade_down_fund t
         where t.create_time >= l_report_date
           and t.create_time < l_report_date + 1
           and t.account_id = item.account_id
           and t.trade_order_no not like 'JYSJC%';
      
        select min(t.source_system_id)
          into l_system_id
          from fd_base_down_system_map t
         where t.channel_no = item.channel_no;
      
        if l_count > 0 then
          ---2.有资金变动，添加最后一笔资金变动的余额
          select max(t.record_id)
            into l_max_record
            from fd_trade_down_fund t
           where t.create_time = l_max_change_time
             and t.account_id = item.account_id;
        
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             down_first_face,
             down_first_amount,
             channel_source_system,
             warn_balance)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.down_channel,
                   item.account_id,
                   item.channel_no,
                   t.balance,
                   item.account_name,
                   item.channel_name,
                   item.channel_status,
                   item.account_status,
                   item.company_id,
                   item.down_first_face,
                   item.down_first_amount,
                   l_system_id,
                   item.warn_balance
              from fd_trade_down_fund t
             where t.record_id = l_max_record;
        
        else
          ---3.没有资金变动，取昨天零点余额的值
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             down_first_face,
             down_first_amount,
             channel_source_system,
             warn_balance)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.down_channel,
                   item.account_id,
                   item.channel_no,
                   tab.zero_balance,
                   item.account_name,
                   item.channel_name,
                   item.channel_status,
                   item.account_status,
                   item.company_id,
                   0,
                   0,
                   l_system_id,
                   item.warn_balance
              from (select nvl(max(t.balance), item.inner_balance) zero_balance
                      from fd_report_zero_balance t
                     where t.record_date = (l_report_date - 1)
                       and t.account_type =
                           pkg_report_zero_acc_type.down_channel
                       and t.channel_no = item.channel_no
                       and t.account_id = item.account_id
                       and rownum <= 1) tab;
        end if;
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_zero_down_get', sqlerrm, 1);
    end;
  end loop;

end;
/

prompt
prompt Creating procedure FD_P_AUTO_ZERO_IMP_GET
prompt =========================================
prompt
create or replace procedure fd_account.fd_p_auto_zero_imp_get(v_report_date in varchar2 default null) as
  --------------------获取倒款账户的零点余额-------------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number;
  l_count           number;
  l_max_change_id   number;
  l_max_change_time date;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select c.account_id,
                      c.account_name,
                      c.status,
                      c.balance,
                      c.company_id
                 from fd_base_company_account_imp c) loop
    begin
      ---1.检查记录是否存在
      select count(1)
        into l_report_count
        from fd_report_zero_balance t
       where t.account_type = pkg_report_zero_acc_type.imp_account
         and t.record_date = l_report_date
         and t.account_id = item.account_id;

      if l_report_count = 0 then
        ---2.查询资产账户是否有资金变动
        select count(1), max(t.change_time)
          into l_count, l_max_change_time
          from fd_trade_co_imp_fund t
         where t.change_time >= l_report_date
           and t.change_time < (l_report_date + 1)
           and t.account_id = item.account_id;

        if l_count > 0 then
          ---3.有资金变动，获取最后一笔变动记录
          select max(t.change_id)
            into l_max_change_id
            from fd_trade_co_imp_fund t
           where t.change_time = l_max_change_time
             and t.account_id = item.account_id;

          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.imp_account,
                   item.account_id,
                   '-',
                   t.balance,
                   item.account_name,
                   '-',
                   0,
                   item.status,
                   item.company_id
              from fd_trade_co_imp_fund t
             where t.change_id = l_max_change_id;
        else
          ---4.没有资金变动，获取前一天的零点余额
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.imp_account,
                   item.account_id,
                   '-',
                   tab.zero_balance,
                   item.account_name,
                   '-',
                   0,
                   item.status,
                   item.company_id
              from (select nvl(max(t.balance), item.balance) zero_balance
                      from fd_report_zero_balance t
                     where t.record_date = (l_report_date - 1)
                       and t.account_type =
                           pkg_report_zero_acc_type.imp_account
                       and t.account_id = item.account_id
                       and rownum <= 1) tab;

        end if;
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_zero_imp_get', sqlerrm, 1);
    end;
  end loop;
end;
/

prompt
prompt Creating procedure FD_P_AUTO_ZERO_PROFIT_GET
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_auto_zero_profit_get(v_report_date in varchar2 default null) as
  --------------------获取利润账户的零点余额-------------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number;
  l_count           number;
  l_max_change_id   number;
  l_max_change_time date;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select c.account_id,
                      c.account_name,
                      c.status,
                      c.balance,
                      c.company_id,
                      c.account_type
                 from fd_base_company_account_cap c
                where c.account_type = pkg_co_cap_account_type.profit) loop
    begin
      ---2.检查记录是否存在
      select count(1)
        into l_report_count
        from fd_report_zero_balance t
       where t.record_date = l_report_date
         and t.account_type = pkg_report_zero_acc_type.profit_account
         and t.account_id = item.account_id;

      if l_report_count = 0 then
        ---3.查询毛利账户是否有资金变动
        select count(1), max(t.change_time)
          into l_count, l_max_change_time
          from fd_trade_co_cap_fund t
         where t.change_time >= l_report_date
           and t.change_time < (l_report_date + 1 + 3 / 24)
           and t.account_id = item.account_id;

        if l_count > 0 then
          ---5.获取最后资金变动时最大的变动编号
          select max(t.change_id)
            into l_max_change_id
            from fd_trade_co_cap_fund t
           where t.change_time = l_max_change_time
             and t.account_id = item.account_id;

          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             co_account_type)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.profit_account,
                   item.account_id,
                   '-',
                   t.balance,
                   item.account_name,
                   '-',
                   0,
                   item.status,
                   item.company_id,
                   item.account_type
              from fd_trade_co_cap_fund t
             where t.change_id = l_max_change_id;
        else
          ---4.没有资金变动，获取前一天的零点余额
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             co_account_type)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.profit_account,
                   item.account_id,
                   '-',
                   tab.zero_balance,
                   item.account_name,
                   '-',
                   0,
                   item.status,
                   item.company_id,
                   item.account_type
              from (select nvl(max(t.balance), item.balance) zero_balance
                      from fd_report_zero_balance t
                     where t.record_date = (l_report_date - 1)
                       and t.account_type =
                           pkg_report_zero_acc_type.profit_account
                       and t.account_id = item.account_id
                       and rownum <= 1) tab;

        end if;
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_zero_profit_get', sqlerrm, 1);
    end;
  end loop;
end;
/

prompt
prompt Creating procedure FD_P_AUTO_ZERO_RECV_GET
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_auto_zero_recv_get(v_report_date in varchar2 default null) as
  --------------------获取公司间结算账户的零点余额-------------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number;
  l_count           number;
  l_max_change_time date;
  l_max_change_id   number;
begin
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select c.account_id,
                      c.account_name,
                      c.status,
                      c.balance,
                      c.recv_company
                 from fd_base_company_account_recv c) loop
    begin
      ---1.检查记录是否存在
      select count(1)
        into l_report_count
        from fd_report_zero_balance t
       where t.account_type = pkg_report_zero_acc_type.recv_account
         and t.record_date = l_report_date
         and t.account_id = item.account_id;

      if l_report_count = 0 then
        ---2.查询资产账户是否有资金变动
        select count(1), max(t.change_time)
          into l_count, l_max_change_time
          from fd_trade_co_recv_fund t
         where t.change_time >= l_report_date
           and t.change_time < (l_report_date + 1 + 3 / 24) ---结算账户晚上2点结算，3点时包含结算
           and t.account_id = item.account_id;

        if l_count > 0 then
          ---3.有资金变动，获取最后一笔变动记录
          select max(t.change_id)
            into l_max_change_id
            from fd_trade_co_recv_fund t
           where t.change_time = l_max_change_time
             and t.account_id = item.account_id;

          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.recv_account,
                   item.account_id,
                   '-',
                   t.balance,
                   item.account_name,
                   '-',
                   0,
                   item.status,
                   item.recv_company
              from fd_trade_co_recv_fund t
             where t.change_id = l_max_change_id;
        else
          ---4.没有资金变动，获取前一天的零点余额
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.recv_account,
                   item.account_id,
                   '-',
                   tab.zero_balance,
                   item.account_name,
                   '-',
                   0,
                   item.status,
                   item.recv_company
              from (select nvl(max(t.balance), item.balance) zero_balance
                      from fd_report_zero_balance t
                     where t.record_date = (l_report_date - 1)
                       and t.account_type =
                           pkg_report_zero_acc_type.recv_account
                       and t.account_id = item.account_id
                       and rownum <= 1) tab;

        end if;
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_zero_recv_get', sqlerrm, 1);
    end;
  end loop;
end;
/

prompt
prompt Creating procedure FD_P_AUTO_ZERO_SELF_GET
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_auto_zero_self_get(v_report_date in varchar2 default null) as
  --------------------获取独立账户的零点余额-------------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number;
  l_count           number;
  l_max_change_id   number;
  l_max_change_time date;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select c.account_id,
                      c.account_name,
                      c.status,
                      c.balance,
                      c.company_id,
                      c.account_type
                 from fd_base_company_account_self c) loop
    begin
      ---1.检查记录是否存在
      select count(1)
        into l_report_count
        from fd_report_zero_balance t
       where t.account_type = pkg_report_zero_acc_type.self_account
         and t.record_date = l_report_date
         and t.account_id = item.account_id;

      if l_report_count = 0 then
        ---2.查询资产账户是否有资金变动
        select count(1), max(t.change_time)
          into l_count, l_max_change_time
          from fd_trade_co_self_fund t
         where t.change_time >= l_report_date
           and t.change_time < (l_report_date + 1 + 3 / 24)
           and t.account_id = item.account_id;

        if l_count > 0 then
          ---3.有资金变动，获取最后一笔变动记录
          select max(t.change_id)
            into l_max_change_id
            from fd_trade_co_self_fund t
           where t.change_time = l_max_change_time
             and t.account_id = item.account_id;

          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             co_account_type)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.self_account,
                   item.account_id,
                   '-',
                   t.balance,
                   item.account_name,
                   '-',
                   0,
                   item.status,
                   item.company_id,
                   item.account_type
              from fd_trade_co_self_fund t
             where t.change_id = l_max_change_id;
        else
          ---4.没有资金变动，获取前一天的零点余额
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             co_account_type)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.self_account,
                   item.account_id,
                   '-',
                   tab.zero_balance,
                   item.account_name,
                   '-',
                   0,
                   item.status,
                   item.company_id,
                   item.account_type
              from (select nvl(max(t.balance), item.balance) zero_balance
                      from fd_report_zero_balance t
                     where t.record_date = (l_report_date - 1)
                       and t.account_type =
                           pkg_report_zero_acc_type.self_account
                       and t.account_id = item.account_id
                       and rownum <= 1) tab;

        end if;
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_zero_self_get', sqlerrm, 1);
    end;
  end loop;
end;
/

prompt
prompt Creating procedure FD_P_AUTO_ZERO_UP_COMMI_GET
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_auto_zero_up_commi_get(v_report_date in varchar2 default null) as
  --------------------获取上游佣金账户的零点余额-------------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number;
  l_count           number;
  l_max_change_id   number;
  l_max_change_time date;
  l_before_commi    number;
  l_system_id       number;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  ---2.循环需要后返佣金的上游渠道
  for item in (select c.channel_no,
                      c.channel_name,
                      c.commi_balance,
                      c.company_id,
                      c.status,
                      c.classification
                 from fd_base_up_channel c) loop
    begin
      ---3.检查下游佣金零点余额是否存在
      select count(1)
        into l_report_count
        from fd_report_zero_balance t
       where t.record_date = l_report_date
         and t.account_type = pkg_report_zero_acc_type.up_commi_account
         and t.channel_no = item.channel_no;
    
      if l_report_count = 0 then
        ---4.检查是否有佣金账户变动记录
        select count(1), max(t.settle_time)
          into l_count, l_max_change_time
          from fd_trade_commission_settle t
         where t.settle_time >= l_report_date
           and t.settle_time < (l_report_date + 1 + 3 / 24)
           and t.channel_no = item.channel_no
           and t.channel_type = pkg_channel_type.up_channel;
      
        select min(t.source_system_id)
          into l_system_id
          from fd_base_up_system_map t
         where t.channel_no = item.channel_no;
      
        if l_count > 0 then
          ---5.获取渠道佣金最后的变动记录
          select max(t.report_id)
            into l_max_change_id
            from fd_trade_commission_settle t
           where t.settle_time = l_max_change_time
             and t.channel_no = item.channel_no
             and t.channel_type = pkg_channel_type.up_channel;
        
          ---6.添加下游佣金零点余额记录
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             channel_name,
             channel_status,
             company_id,
             channel_source_system,
             channel_classif)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.up_commi_account,
                   0,
                   item.channel_no,
                   t.commi_balance,
                   item.channel_name,
                   item.status,
                   item.company_id,
                   l_system_id,
                   item.classification
              from fd_trade_commission_settle t
             where t.report_id = l_max_change_id;
        else
          ---7.获取前一天零点余额
          select nvl(max(t.balance), item.commi_balance)
            into l_before_commi
            from fd_report_zero_balance t
           where t.record_date = (l_report_date - 1)
             and t.account_type = pkg_report_zero_acc_type.up_commi_account
             and t.channel_no = item.channel_no;
        
          ---8.没有变动记录，添加前一天零点余额
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             channel_name,
             channel_status,
             company_id,
             channel_source_system,
             channel_classif)
          values
            (seq_report_zero_balance_id.nextval,
             l_report_date,
             sysdate,
             pkg_report_zero_acc_type.up_commi_account,
             0,
             item.channel_no,
             l_before_commi,
             item.channel_name,
             item.status,
             item.company_id,
             l_system_id,
             item.classification);
        end if;
      
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_zero_up_commi_get', sqlerrm, 1);
    end;
  end loop;

end;
/

prompt
prompt Creating procedure FD_P_AUTO_ZERO_UP_GET
prompt ========================================
prompt
create or replace procedure fd_account.fd_p_auto_zero_up_get(v_report_date in varchar2 default null) as
  -----------------获取上游零点余额--------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_count           number;
  l_max_record      number;
  l_report_count    number;
  l_max_change_time date;
  l_system_id       number;
begin
  ---1.获取零点余额数据报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select tb.channel_no,
                      tb.account_id,
                      a.account_name,
                      c.channel_name,
                      a.status         account_status,
                      c.status         channel_status,
                      a.inner_balance,
                      c.warn_balance,
                      c.company_id,
                      c.classification
                 from fd_base_up_account_map tb
                inner join fd_base_up_account a
                   on tb.account_id = a.account_id
                inner join fd_base_up_channel c
                   on tb.channel_no = c.channel_no) loop
    begin
      ---0.检查记录是否存在
      select count(1)
        into l_report_count
        from fd_report_zero_balance t
       where t.record_date = l_report_date
         and t.account_type = pkg_report_zero_acc_type.up_channel
         and t.channel_no = item.channel_no
         and t.account_id = item.account_id
         and rownum <= 1;
    
      if l_report_count = 0 then
      
        ---1.检查渠道资金变动是否存在
        select count(1), max(t.change_time)
          into l_count, l_max_change_time
          from fd_trade_up_fund t
         where t.change_time >= l_report_date
           and t.change_time < l_report_date + 1
           and t.up_account_id = item.account_id
           and t.trade_order_no not like 'JYSJC%';
      
        select min(t.source_system_id)
          into l_system_id
          from fd_base_up_system_map t
         where t.channel_no = item.channel_no;
      
        if l_count > 0 then
          ---2.有资金变动，添加最后一笔资金变动的余额
          select max(t.record_id)
            into l_max_record
            from fd_trade_up_fund t
           where t.change_time = l_max_change_time
             and t.up_account_id = item.account_id;
        
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             channel_source_system,
             channel_classif,
             warn_balance)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.up_channel,
                   item.account_id,
                   item.channel_no,
                   t.balance,
                   item.account_name,
                   item.channel_name,
                   item.channel_status,
                   item.account_status,
                   item.company_id,
                   l_system_id,
                   item.classification,
                   item.warn_balance
              from fd_trade_up_fund t
             where t.record_id = l_max_record;
        
        else
          ---3.没有资金变动，取昨天零点余额的值
          insert into fd_report_zero_balance
            (record_id,
             record_date,
             created_time,
             account_type,
             account_id,
             channel_no,
             balance,
             account_name,
             channel_name,
             channel_status,
             account_status,
             company_id,
             channel_source_system,
             channel_classif,
             warn_balance)
            select seq_report_zero_balance_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_report_zero_acc_type.up_channel,
                   item.account_id,
                   item.channel_no,
                   tab.zero_balance,
                   item.account_name,
                   item.channel_name,
                   item.channel_status,
                   item.account_status,
                   item.company_id,
                   l_system_id,
                   item.classification,
                   item.warn_balance
              from (select nvl(max(t.balance), item.inner_balance) zero_balance
                      from fd_report_zero_balance t
                     where t.record_date = (l_report_date - 1)
                       and t.account_type =
                           pkg_report_zero_acc_type.up_channel
                       and t.channel_no = item.channel_no
                       and t.account_id = item.account_id
                       and rownum <= 1) tab;
        end if;
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_auto_zero_up_get', sqlerrm, 1);
    end;
  end loop;

end;
/

prompt
prompt Creating procedure FD_P_AUXILIARY_CS2USER_SYSTEM
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_auxiliary_cs2user_system(v_warn_level number,
                                                          v_title      varchar2,
                                                          v_content    varchar2,
                                                          v_key_word   varchar2,
                                                          v_result     out varchar2) as
  -----------------------将温江机房的报警数据同步到用户系统-------------------------- 
  l_status number;
  l_msg    varchar2(255);
begin

  ---1. 温江机房报警发送到用户系统
  /*us_sp_add_alarm_msg@us('SA_CS',
                         v_warn_level,
                         v_title,
                         '[CW]' || v_content,
                         v_key_word,
                         l_status,
                         l_msg);*/

  ---2.判断同步是否成功
  v_result := pkg_error_code.failure;
  if l_status = 100 then
    v_result := pkg_error_code.success;
  end if;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auxiliary_cs2user_system', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUXILIARY_DOWN_ADD_SYNC
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_auxiliary_down_add_sync(v_company_id   number, ---公司id
                                                         v_order_source number, ---系统编号
                                                         v_channel_no   varchar2, ---下游渠道编号
                                                         v_channel_name varchar2, ---下游渠道名称
                                                         v_account_id   number, ---下游支付账户编号
                                                         v_account_name varchar2, ---下游账户名称
                                                         v_result       out varchar2) as
  ---------------辅助存储过程-下游信息添加同步----------------
  l_channel_count      number;
  l_account_count      number;
  l_down_map_count     number;
  l_down_sys_map_count number;
begin
  fd_p_write_log('fd_p_auxiliary_down_add_sync', '公司编号:'|| v_company_id || '   系统编号:' || v_order_source, 1);
  ---=====================检查下游渠道、账户、渠道账户的关联关系是否存在===========
   if v_account_id is null or v_account_id<=0 then
     v_result:=pkg_error_code.data_error;
     return;
  end if;
  ---1.检查下游渠道
  select count(1)
    into l_channel_count
    from fd_base_down_channel t
   where t.channel_no = v_channel_no;

  if l_channel_count > 0 then
    rollback;
    v_result := pkg_error_code.data_repeat;
    return;
  end if;

  ---2.检查下游支付账户
  select count(1)
    into l_account_count
    from fd_base_down_account t
   where t.account_id = v_account_id;

  if l_account_count > 0 then
    rollback;
    v_result := pkg_error_code.data_repeat;
    return;
  end if;

  ---3.检查渠道与支付账户的对应关系
  select count(1)
    into l_down_map_count
    from fd_base_down_account_map t
   where t.channel_no = v_channel_no
      or t.account_id = v_account_id;

  if l_down_map_count > 0 then
    rollback;
    v_result := pkg_error_code.data_repeat;
    return;
  end if;

  ---4.检查渠道与系统的对应关系
  select count(1)
    into l_down_sys_map_count
    from fd_base_down_system_map t
   where t.source_system_id = v_order_source
     and t.channel_no = v_channel_no;

  if l_down_sys_map_count > 0 then
    rollback;
    v_result := pkg_error_code.data_repeat;
    return;
  end if;

  ---===================添加渠道、账户及对应关系报数据=======================
  ---1.添加下游渠道
  insert into fd_base_down_channel
    (channel_no,
     channel_name,
     service_fee,
     company_id,
     status,
     created_by,
     created_time,
     commi_balance,
     warn_balance,
     warn_type,
     need_commi)
  values
    (v_channel_no,
     v_channel_name,
     0,
     v_company_id,
     pkg_sys_boolean.istrue,
     'sys',
     sysdate,
     0,
     0,
     1,
     pkg_sys_boolean.isfalse);

  if sql%rowcount = 0 then
    rollback;
    v_result := pkg_error_code.data_error;
    return;
  end if;

  ---2.添加下游账户
  insert into fd_base_down_account
    (account_id,
     account_name,
     query_balance,
     inner_balance,
     credit_money,
     status,
     created_by,
     created_time,
     is_auto_add)
  values
    (v_account_id,
     v_account_name,
     0,
     0,
     0,
     pkg_sys_boolean.istrue,
     'sys',
     sysdate,
     pkg_sys_boolean.isfalse);

  if sql%rowcount = 0 then
    rollback;
    v_result := pkg_error_code.data_error;
    return;
  end if;

  ---3.添加下游渠道与账户关联关系
  insert into fd_base_down_account_map
    (map_id, channel_no, account_id, is_main_channel)
  values
    (seq_base_down_account_map_id.nextval,
     v_channel_no,
     v_account_id,
     pkg_sys_boolean.istrue);

  if sql%rowcount = 0 then
    rollback;
    v_result := pkg_error_code.data_error;
    return;
  end if;

  ---4.添加下游渠道与外部系统关联关系
  insert into fd_base_down_system_map
    (map_id, source_system_id, channel_no)
  values
    (seq_base_down_account_map_id.nextval, v_order_source, v_channel_no);

  if sql%rowcount = 0 then
    rollback;
    v_result := pkg_error_code.data_error;
    return;
  end if;

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_auxiliary_down_add_sync', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_AUXILIARY_UP_ADD_SYNC
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_auxiliary_up_add_sync(v_company_id        number, ---所属公司
                                                       v_order_source      number, ---系统编号
                                                       v_channel_no        varchar2, ---渠道编号
                                                       v_channel_name      varchar2, ---渠道名称
                                                       v_account_id        number, ---账户编号
                                                       v_account_name      varchar2, ---账户名称
                                                       v_classification    number, ---渠道分类
                                                       v_capital_class     number, ---渠道资金分类
                                                       v_account_back_type number, -- 上游支付账户银行类型
                                                       v_result            out varchar2) as
  -----------------辅助存储过程-上游信息添加同步----------------
  l_channel_count      number;
  l_account_count      number;
  l_up_map_count       number;
  l_up_sys_map_count   number;
  l_account_sync_count number;

begin
  ---======================检查上游渠道、账户、渠道账户关联信息是否存在============
  if v_account_id is null or v_account_id<=0 then
     v_result:=pkg_error_code.data_error;
     return;
  end if;
  ---1.检查渠道
  select count(1)
    into l_channel_count
    from fd_base_up_channel t
   where t.channel_no = v_channel_no;

  ---2.检查支付账户
  select count(1)
    into l_account_count
    from fd_base_up_account t
   where t.account_id = v_account_id;

  ---3.检查渠道与支付账户关系
  select count(1)
    into l_up_map_count
    from fd_base_up_account_map t
   where t.channel_no = v_channel_no
     and t.account_id = v_account_id;

  ---4.检查渠道与系统关系
  select count(1)
    into l_up_sys_map_count
    from fd_base_up_system_map t
   where t.source_system_id = v_order_source
     and t.channel_no = v_channel_no;

  ---5.检查是否自动更新外部系统查询余额表数据
  select count(1)
    into l_account_sync_count
    from fd_base_up_account_sync t
   where t.account_id = v_account_id;

  ---====================添加相关渠道、账户及关系表数据=======================
  ---1.添加上游渠道
  if (l_channel_count <= 0) then
    insert into fd_base_up_channel
      (channel_no,
       channel_name,
       status,
       service_fee,
       company_id,
       created_by,
       created_time,
       commi_balance,
       warn_balance,
       warn_type,
       max_add,
       min_add,
       need_commi,
       classification,
       capital_class)
    values
      (v_channel_no,
       v_channel_name,
       pkg_sys_boolean.istrue,
       0,
       v_company_id,
       'sys',
       sysdate,
       0,
       0,
       1,
       0,
       0,
       1,
       v_classification,
       v_capital_class);
  end if;

  ---2.添加上游账户
  if (l_account_count <= 0) then
    insert into fd_base_up_account
      (account_id,
       account_name,
       account_type,
       query_balance,
       inner_balance,
       status,
       created_by,
       created_time,
       is_auto_add)
    values
      (v_account_id,
       v_account_name,
       pkg_up_account_type.sys_account,
       0,
       0,
       pkg_sys_boolean.istrue,
       'sys',
       sysdate,
       pkg_sys_boolean.isfalse);
  
  end if;

  ---3.添加上游渠道、账户关联关系
  if (l_up_map_count <= 0) then
    insert into fd_base_up_account_map
      (map_id, channel_no, account_id, is_main_channel)
    values
      (seq_base_up_account_map_id.nextval,
       v_channel_no,
       v_account_id,
       pkg_sys_boolean.istrue);
  end if;

  ---4.添加渠道与外部系统的关联关系
  if (l_up_sys_map_count <= 0) then
    insert into fd_base_up_system_map
      (map_id, source_system_id, channel_no)
    values
      (seq_base_up_system_map_id.nextval, v_order_source, v_channel_no);
  end if;

  ---5.添加是否自动修改外部系统查询余额表数据
  if (l_account_sync_count <= 0) then
    insert into fd_base_up_account_sync
      (id, account_id, need_sync_add)
    values
      (seq_base_up_account_sync_id.nextval,
       v_account_id,
       pkg_sys_boolean.istrue);
  end if;

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_auxiliary_up_add_sync', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_AUTO_BANK_BALANCE
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_b2e_auto_bank_balance as
  ------------------自动创建获取银企直连银行卡余额任务----------------
  l_task_id   number;
  l_task_time date;
  l_content   varchar2(512);
begin
  ---1.获取所有查询状态为等待执行的子记录
  for item in (select b.account_id,
                      b.account_name,
                      b.card_no,
                      b.bank_type,
                      c.merchant_no,
                      c.merchant_password,
                      c.token_key,
                      c.bank_balance_mq,
                      c.user_no,
                      c.user_password,
                      c.language,
                      c.app_id,
                      c.app_ver
                 from fd_bank_account_info b
                inner join fd_b2e_bank_account_api_config c
                   on b.account_id = c.bank_account_id
                where b.is_b2e = pkg_sys_boolean.istrue
                  and not exists
                (select f.record_id
                         from fd_b2e_bank_task f
                        where f.record_id = b.account_id
                          and f.task_type = pkg_task_type.BankBalanceQuery
                          and f.task_status not in
                              (pkg_task_status.Complete,
                               pkg_task_status.failure)
                          and f.timeout_time > sysdate)) loop
    begin
    
      ---2.配置任务参数
      select seq_fdb2ebanktask_auto_id.nextval, sysdate
        into l_task_id, l_task_time
        from dual;
    
      l_content := '{"task_id":"' || l_task_id || '","bank_account_id":"' ||
                   item.account_id || '","card_no":"' || item.card_no ||
                   '","bank_acc_name":"' || item.account_name ||
                   '","merchant_no":"' || item.merchant_no ||
                   '","merchant_password":"' || item.merchant_password ||
                   '","user_no":"' || item.user_no || '","user_password":"' ||
                   item.user_password || '","language":"' || item.language ||
                   '","app_id":"' || item.app_id || '","app_ver":"' ||
                   item.app_ver || '","token_key":"' || item.token_key ||
                   '","bank_type":"' || item.bank_type || '","batch_seq":"' ||
                   seq_b2e_batch_no.nextval || '","batch_sub_seq":"' ||
                   seq_b2e_batch_no.nextval || '"}';
    
      ---3.添加任务记录
      insert into fd_b2e_bank_task
        (task_id,
         task_type,
         record_id,
         mq_name,
         task_status,
         create_time,
         content,
         timeout_time)
      values
        (l_task_id,
         pkg_task_type.BankBalanceQuery,
         item.account_id,
         item.bank_balance_mq,
         pkg_task_status.NotStart,
         l_task_time,
         l_content,
         (sysdate + 5 / 24 / 60));
    
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_b2e_auto_bank_balance', sqlerrm, 1);
    end;
  end loop;

  commit;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_b2e_auto_bank_balance', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_AUTO_EXPIRE_CLOSE
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_b2e_auto_expire_close as
  ------------自动删除前一天的任务-----------
begin

  ---1.删除过期的任务
  delete from fd_b2e_bank_task t where t.create_time < sysdate - 1;
  commit;

  ---2.修改过期的未开始的主记录为取消
  update fd_b2e_payment_record_main t
     set t.payment_audit_type    = pkg_b2e_amount_audit_status.cancel,
         t.payment_audit_status  = pkg_b2e_payment_audit_status.failure,
         t.received_audit_status = pkg_b2e_received_status.failure,
         t.payment_audit_user    = 'sys',
         t.received_audit_user   = 'sys',
         t.received_audit_memo   = '任务已过期'
   where t.expire_time < sysdate
     and t.expire_time >= (sysdate - 70 / 24 / 60)
     and t.payment_audit_status = pkg_b2e_payment_audit_status.wait;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_b2e_auto_expire_close', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_AUTO_HALFHOUR_TRADE
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_b2e_auto_halfhour_trade(v_start_date in varchar2 default null) as
  -----------------半小时交易量收集-----------------
  l_start_time        date := to_date(v_start_date, 'yyyymmddhh24miss');
  l_last_collect_time date;
begin
  ---0.获取开始时间
  if v_start_date is null then
    l_start_time := sysdate - 30 / 24 / 60;
  end if;

  ---1.计算半小时交易量统计开始时间
  if (l_start_time >= trunc(l_start_time, 'hh') + 30 / 24 / 60) then
    l_start_time := (trunc(l_start_time, 'hh') + 30 / 24 / 60);
  else
    l_start_time := trunc(l_start_time, 'hh');
  end if;

  ---2.获取最近的统计时间
  select max(t.collect_time)
    into l_last_collect_time
    from fd_report_channel_halfhour t
   where t.collect_time >= (trunc(l_start_time) - 30);

  l_last_collect_time := nvl(l_last_collect_time,
                             (l_start_time - 30 / 24 / 60));

  ---3.循环添加半小时交易量
  while l_last_collect_time < l_start_time loop
    ---3.1下游半小时交易量统计
    l_last_collect_time := l_last_collect_time + 30 / 24 / 60;
  
    insert into fd_report_channel_halfhour
      (record_id,
       channel_type,
       channel_no,
       order_source,
       trade_count,
       trade_amount,
       collect_time)
      select seq_report_channel_halfhour_id.nextval,
             pkg_channel_type.down_channel,
             tab.down_channel_no,
             tab.order_source,
             tab.trade_count,
             tab.trade_amount,
             l_last_collect_time
        from (select t.down_channel_no,
                     t.order_source,
                     count(decode(t.change_type,
                                  pkg_up_fund_change_type.debit_amount,
                                  1,
                                  -1)) trade_count,
                     sum(decode(t.change_type,
                                pkg_up_fund_change_type.debit_amount,
                                1,
                                -1) * t.down_draw_amount) trade_amount
                from fd_trade_up_fund t
               where t.change_time >= l_last_collect_time
                 and t.change_time < (l_last_collect_time + 30 / 24 / 60)
                 and t.up_draw_face != 0
                 and t.change_type in
                     (pkg_up_fund_change_type.debit_amount,
                      pkg_up_fund_change_type.refund_amount)
               group by t.down_channel_no, t.order_source) tab;
  
    ---3.2上游半小时交易量统计
    insert into fd_report_channel_halfhour
      (record_id,
       channel_type,
       channel_no,
       order_source,
       trade_count,
       trade_amount,
       collect_time)
      select seq_report_channel_halfhour_id.nextval,
             pkg_channel_type.up_channel,
             tab.up_channel_no,
             tab.order_source,
             tab.trade_count,
             tab.trade_amount,
             l_last_collect_time
        from (select t.up_channel_no,
                     t.order_source,
                     count(decode(t.change_type,
                                  pkg_up_fund_change_type.debit_amount,
                                  1,
                                  -1)) trade_count,
                     sum(decode(t.change_type,
                                pkg_up_fund_change_type.debit_amount,
                                1,
                                -1) * t.up_draw_amount) trade_amount
                from fd_trade_up_fund t
               where t.change_time >= l_last_collect_time
                 and t.change_time < (l_last_collect_time + 30 / 24 / 60)
                 and t.up_draw_face != 0
                 and t.change_type in
                     (pkg_up_fund_change_type.debit_amount,
                      pkg_up_fund_change_type.refund_amount)
               group by t.up_channel_no, t.order_source) tab;
  
    commit;
  
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_b2e_auto_halfhour_trade', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_AUTO_PAYMENT_QRY_TASK
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_b2e_auto_payment_qry_task as
  ---------------------上游转款进度查询-------------------

  l_result varchar2(32);
begin
  ---1.获取所有查询状态为等待执行的子记录
  for item in (select r.record_id,
                      r.main_record_id,
                      r.bank_server_id,
                      m.bank_id,
                      nvl(p.code, '-') code,
                      decode(a.bank_payment_type,
                             Pkg_bank_payment_type.proxy_pay,
                             decode(a.rcv_card_type,
                                    pkg_rcv_card_type.is_private,
                                    c.proxy_pri_merchant_no, --代付对私商户号
                                    c.proxy_merchant_no), --代付对公商户号
                             c.merchant_no) merchant_no, --网银支付商户号
                      a.rcv_card_type,
                      c.token_key,
                      decode(a.bank_payment_type,
                             Pkg_bank_payment_type.proxy_pay,
                             c.add_query_mq,
                             c.bank_add_query_mq) query_mq,
                      c.user_no,
                      c.user_password,
                      c.language,
                      c.app_id,
                      c.app_ver,
                      seq_fdb2ebanktask_auto_id.nextval task_id,
                      sysdate task_create_time
                 from fd_b2e_payment_record_details r
                inner join fd_b2e_payment_record_main m
                   on r.main_record_id = m.record_id
                inner join fd_b2e_bank_payment_account a
                   on m.bank_add_type_id = a.id
                inner join fd_b2e_bank_account_api_config c
                   on m.bank_id = c.bank_account_id
                 left join fd_b2e_bank_payment_code_map p
                   on a.bank_payment_type = p.bank_payment_type
                  and p.code_type = pkg_b2e_payment_code_type.pay_query
                where r.next_query_time <= sysdate
                  and r.query_status in
                      (pkg_b2e_details_query_status.Wait,
                       pkg_b2e_details_query_status.Dealing)
                  and not exists
                (select b.record_id
                         from fd_b2e_bank_task b
                        where b.record_id = r.record_id
                          and b.task_type = pkg_task_type.paymentQuery
                          and b.task_status not in
                              (pkg_task_status.Complete,
                               pkg_task_status.failure)
                          and b.timeout_time > sysdate)) loop
    begin
    
      l_result := fd_f_b2e_payment_query_create(item.main_record_id,
                                                item.record_id,
                                                item.task_id,
                                                item.task_create_time,
                                                item.query_mq,
                                                item.merchant_no,
                                                item.user_no,
                                                item.user_password,
                                                item.rcv_card_type,
                                                item.language,
                                                item.app_id,
                                                item.app_ver,
                                                item.bank_id,
                                                item.bank_server_id,
                                                item.code,
                                                item.token_key);
    
      if l_result = pkg_error_code.success then
        commit;
      else
        rollback;
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('fd_p_b2e_auto_payment_qry_task', sqlerrm, 1);
    end;
  end loop;

  commit;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_b2e_auto_payment_qry_task', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_AUTO_PAYMENT_REMEDY
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_b2e_auto_payment_remedy as
  ---------------------上游转款进度手工查询-------------------
  l_result varchar2(32);
begin
  ---1.扫描10分钟到半小时支付状态为等待或
  for item in (select d.record_id, d.submit_status, d.submit_time
                 from fd_b2e_payment_record_details d
                where d.create_time < (sysdate - 30 / 24 / 60)
                  and d.create_time >= (sysdate - 1 / 24)
                  and d.submit_status in
                      (pkg_b2e_details_submit_status.Wait,
                       pkg_b2e_details_submit_status.Dealing)
                  and d.query_status =
                      pkg_b2e_details_query_status.not_start) loop
    begin
      l_result := fd_f_b2e_auto_payment_remedy(item.record_id,
                                               item.submit_status,
                                               item.submit_time);
    
      if l_result = pkg_error_code.success then
        commit;
      else
        rollback;
      end if;
    
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_b2e_auto_payment_remedy', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_AUTO_RECV_TASK
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_b2e_auto_recv_task as
  ------------------下游收款查询任务创建-------------------
  l_result     varchar2(32);
  l_start_time date := trunc(sysdate);
begin
  ---1.定时获取所有需要查询的子账户
  for item in (select a.account_id,
                      a.last_query_time,
                      a.query_interval_time,
                      c.receive_query_mq,
                      c.merchant_no,
                      c.user_no,
                      c.user_password,
                      c.language,
                      c.app_id,
                      c.app_ver,
                      b.card_no
                 from fd_b2e_bank_receive_account a
                inner join fd_b2e_bank_account_api_config c on c.bank_account_id =
                                                               a.account_id
                inner join fd_bank_account_info b on a.account_id =
                                                     b.account_id
               
                where a.status = pkg_sys_boolean.istrue
                  and b.is_b2e = pkg_sys_boolean.istrue
                  and a.last_query_time <
                      sysdate - a.query_interval_time / 24 / 60 / 60) loop
  
    ---2.创建任务
    l_result := fd_f_b2e_recv_query_task(to_char(l_start_time, 'yyyy-mm-dd'),
                                         to_char((l_start_time + 1),
                                                 'yyyy-mm-dd'),
                                         item.account_id,
                                         item.card_no,
                                         item.query_interval_time,
                                         item.receive_query_mq,
                                         item.merchant_no,
                                         item.user_no,
                                         item.user_password,
                                         item.language,
                                         item.app_id,
                                         item.app_ver);
    if l_result != pkg_error_code.success then
      rollback;
    else
      commit;
    end if;
  end loop;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_b2e_auto_recv_task', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_WRITE_FAIL_LOG
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_b2e_write_fail_log(v_account_id  in number,
                                                    v_fail_reason in varchar2) as
  pragma autonomous_transaction; --自治事务
  l_out_error varchar2(1000);
  l_log_count number;
begin
  ---1.获取账户记录的失败日志数
  select count(1)
    into l_log_count
    from fd_b2e_system_log t
   where t.account_id = v_account_id;

  if l_log_count = 0 then
    ---2.没有账户对应的失败记录，则添加一条新纪录
    insert into fd_b2e_system_log
      (id, account_id, account_name, last_fail_time, fail_reason)
      select seq_b2e_system_log_id.nextval,
             t.account_id,
             t.account_name,
             sysdate,
             v_fail_reason
        from fd_base_up_account t
       where t.account_id = v_account_id;
  else
    ---3.已存在失败记录，则修改账户失败日志
    update fd_b2e_system_log t
       set t.last_fail_time = sysdate, t.fail_reason = v_fail_reason
     where t.account_id = v_account_id;
  end if;

  commit;
exception
  when others then
    rollback;
    l_out_error := to_char(sqlerrm);
    return;
end;
/

prompt
prompt Creating procedure FD_P_B2E_AUTO_UP_MAIN_ADD
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_b2e_auto_up_main_add as
  -----------------自动创建出新的加款任务主记录---------
  ---新创建的主记录 
  ---  金额审核状态：运营审核
  ---  支付状态：    未开始
  ---  加款状态：    未开始
  ------------------------------------------------------
  l_work_day_type   number;
  l_calc_range_type number;
  l_result          varchar2(32);
begin
  --1.获取当前时间是否为工作日、高峰期的信息
  l_result := fd_f_b2e_up_date_info_get(l_calc_range_type, l_work_day_type);
  if l_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  --2.选择可以加款的渠道，创建加款主任务
  ---*********************************************************************
  ---@以有渠道配置为判断加款的核心，渠道账户与工作日信息唯一
  ---@配置的渠道、账户必须为系统中存在且有关联关系
  ---@账户必须配置为自动加款的，以此判断是否加款，而非启用禁用
  ---@当配置已审核、在对应工作日信息内，且渠道余额小于报警余额时，生成记录
  ---*********************************************************************
  for item in (select g.channel_account_id,
                      g.up_channel_no,
                      g.amount_calc_type,
                      g.add_duration_hour,
                      g.min_add_amount,
                      g.max_channel_balance,
                      g.max_day_add_amount,
                      c.company_id,
                      a.inner_balance
                 from fd_b2e_up_channel_config g
                inner join fd_base_up_account_map m on g.up_channel_no =
                                                       m.channel_no
                                                   and g.channel_account_id =
                                                       m.account_id
                inner join fd_base_up_channel c on m.channel_no =
                                                   c.channel_no
                inner join fd_base_up_account a on m.account_id =
                                                   a.account_id
                where g.warn_balance >= a.inner_balance
                  and g.date_range_type = l_calc_range_type
                  and g.audit_status = pkg_audit_status.Complete
                  and a.is_auto_add = pkg_sys_boolean.istrue) loop
    begin
      ---3.生成上游加款的转账记录
      l_result := fd_f_b2e_auto_up_channel_add(item.channel_account_id,
                                               item.up_channel_no,
                                               item.company_id,
                                               l_work_day_type,
                                               item.amount_calc_type,
                                               item.add_duration_hour,
                                               item.inner_balance,
                                               item.min_add_amount,
                                               item.max_day_add_amount,
                                               item.max_channel_balance);
    
      ---4.执行结果失败回滚，并记录失败原因，成功提交
      if l_result != pkg_error_code.success then
        fd_p_b2e_write_fail_log(item.channel_account_id, l_result);
        rollback;
      else
        commit;
      end if;
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_b2e_auto_up_main_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_BANK_BALANCE_SAVE
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_b2e_bank_balance_save(v_bank_account_id number,
                                                       v_card_no         varchar2,
                                                       v_bank_acc_name   varchar2,
                                                       v_bank_type       number,
                                                       v_query_balance   number,
                                                       v_result          out varchar2) as
  -------------------完成银行余额查询------------------
begin

  ---1.检查银行账户
  v_result := fd_f_b2e_bank_account_check(v_bank_account_id,
                                          v_card_no,
                                          v_bank_acc_name,
                                          v_bank_type,
                                          v_query_balance);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.完成银行余额查询
  v_result := fd_f_b2e_bank_balance_save(v_bank_account_id,
                                         v_card_no,
                                         v_bank_acc_name,
                                         v_bank_type,
                                         v_query_balance);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_bank_balance_save', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_CO_SERVICE_ADJUST
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_b2e_co_service_adjust(v_recv_record_id number,
                                                       v_adjust_days    number,
                                                       v_hander_user    varchar2,
                                                       v_memo           varchar2,
                                                       v_result         out varchar2) as
  ----------------红冲银企直连手续费收取记录------------
  l_service_record_id number;
  l_bank_record_id    number;
begin
  ---1.检查银行记录,并红冲相关记录
  v_result := fd_f_b2e_co_service_adjust(v_recv_record_id,
                                         v_adjust_days,
                                         l_service_record_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.检查相关数据
  v_result := fd_f_adjust_service_check(l_service_record_id,
                                        v_adjust_days,
                                        l_bank_record_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.红冲手续费
  v_result := fd_f_adjust_service_record(l_service_record_id,
                                         l_bank_record_id,
                                         v_hander_user,
                                         v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.记录操作日志
  fd_p_write_handle_log('银企直连银行手续费红冲',
                        v_hander_user,
                        ('v_recv_record_id=' || v_recv_record_id));

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_co_service_adjust', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_CO_SERVICE_CHARGE
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_b2e_co_service_charge(v_recv_record_id number,
                                                       v_hander_user    varchar2,
                                                       v_memo           varchar2,
                                                       v_result         out varchar2) as
  -----------------银企直连银行收取的手续费录入系统---------------

  l_cap_account_id  number;
  l_bank_account_id number;
  l_service_fee     number;
begin
  ---1.检查相关银企直连付款记录
  v_result := fd_f_b2e_co_recv_check(v_recv_record_id,
                                     l_bank_account_id,
                                     l_service_fee);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.检查账户及金额相关信息
  v_result := fd_f_bank_service_add_check(l_bank_account_id,
                                          l_service_fee,
                                          l_cap_account_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.实体卡入账(锁资产账户、实体卡账户)
  v_result := fd_f_bank_service_fee_add(l_bank_account_id,
                                        l_cap_account_id,
                                        l_service_fee,
                                        v_hander_user,
                                        '',
                                        v_recv_record_id || '|' || v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.完成手续费收取
  v_result := fd_f_b2e_co_service_complete(v_recv_record_id,
                                           v_hander_user,
                                           v_recv_record_id || '|' || v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---5.记录操作日志
  fd_p_write_handle_log('银企直连手续费录入',
                        v_hander_user,
                        ('v_recv_record_id=' || v_recv_record_id));

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_b2e_co_service_charge', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_DOWN_MANUAL_ADD
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_b2e_down_manual_add(v_apply_id        in number, --加款申请编号
                                                     v_bank_account_id number, --加款银行编号
                                                     v_tran_no         varchar2, --柜员号
                                                     v_create_user     varchar2, ---加款人
                                                     v_receive_time    varchar2, --收款日期yyyy-mm-dd hh24:mm:ss
                                                     v_memo            varchar2, --备注信息
                                                     v_error_msg       out varchar2, --错误消息
                                                     v_result          out varchar2) as
  --------------------------------
  --功能：银企直连下游渠道审核加款
  --创建人：周荣省
  --创建时间：2019-09-16
  --------------------------------
  l_bank_batch_id number;
  l_account_name  varchar2(32);
  l_channel_name  varchar2(32);
  l_down_card_no  varchar2(64);

  l_recv_record_id   number;
  l_apply_id         number;
  l_count            number;
  l_down_channel_no  varchar2(32);
  l_down_account_id  number;
  l_apply_account_no varchar2(32);
  l_apply_account_name varchar2(128);
  l_add_amount       number;
  l_receive_time date:=trunc(to_date(v_receive_time, 'yyyy-mm-dd hh24:mi:ss'));
  l_bank_holder_name varchar2(32);
begin
  select count(*)
    into l_count
    from fd_trade_down_add_apply t
   where t.tran_no = v_tran_no
     and t.recive_time =
         l_receive_time;
  --流水号重复
  if (l_count > 0) then
    v_result    := pkg_error_code.tran_no_repeat;
    v_error_msg := '流水号重复';
    return;
  end if;

  --锁申请记录
  select d.apply_id,
         d.channel_no,
         d.account_id,
         d.apply_account_no,
         d.add_amount,
         d.apply_account_name
    into l_apply_id,
         l_down_channel_no,
         l_down_account_id,
         l_apply_account_no,
         l_add_amount,
         l_apply_account_name
    from fd_trade_down_add_apply d
   where d.apply_id = v_apply_id
        --and d.flow_status = pkg_b2e_add_apply_status.status_wait
     and d.status = pkg_b2e_add_apply_status.status_wait
     for update;
  --手工审核
  --判断申请的银行账户在白名单内
  select d.down_holder_card_no,d.bank_holder_name
    into l_down_card_no,l_bank_holder_name
    from fd_b2e_down_white_list d
   where d.down_holder_card_no = l_apply_account_no
     and d.audit_status = pkg_audit_status.Complete
     and d.down_channel_no = l_down_channel_no
     and d.channel_account_id = l_down_account_id;

  ---2.检查下游渠道、账户及其关联情况
  v_result := fd_f_manual_down_add_check(l_down_channel_no,
                                         l_down_account_id,
                                         v_bank_account_id,
                                         l_add_amount,
                                         0,
                                         l_account_name,
                                         l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    v_error_msg := '账号错误';
    return;
  end if;

  ---3.账户手工加款(锁实体卡账户、渠道账户、手续费账户)
  v_result := fd_f_manual_down_add(l_down_channel_no,
                                   l_down_account_id,
                                   v_bank_account_id,
                                   l_add_amount,
                                   0,
                                   v_create_user,
                                   l_down_card_no,
                                   (l_recv_record_id || '|' || v_memo),
                                   l_account_name,
                                   l_channel_name,
                                   l_bank_holder_name,
                                   l_bank_batch_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    v_error_msg := '渠道加款失败';
    return;
  end if;
  --4、申请记录添加银行流水
  update fd_trade_down_add_apply d
     set d.tran_no     = v_tran_no,
         d.status      = pkg_b2e_add_apply_status.status_success,
         d.flow_status = pkg_b2e_add_apply_status.status_wait,
         d.audit_memo  = substr(v_memo, 1, 100),
         d.error_msg   = '手动加款完成',
         d.handle_time = sysdate,
         d.audit_user  = v_create_user,
         d.recive_time = l_receive_time
   where d.apply_id = v_apply_id;
  ---5.记录操作日志
  fd_p_write_handle_log('银企直连下游加款',
                        v_create_user,
                        ('l_recv_record_id=' || l_recv_record_id));
  v_error_msg := '操作成功';
  commit;

exception
  when others then
    rollback;
    v_result    := pkg_error_code.system_busy;
    v_error_msg := '数据异常';
    fd_p_write_log('fd_p_b2e_down_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_MANUAL_RECV_TASK
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_b2e_manual_recv_task(v_bank_account_id number, ---银行账户编号
                                                      v_start_time      varchar2, ---开始时间，格式yyyymmdd
                                                      v_end_time        varchar2, ---结束时间，格式yyyymmdd
                                                      v_create_user     varchar2, ---查询人，自动传空
                                                      v_result          out varchar2) as
  ------------------下游收款查询任务创建-------------------
  l_main_card_no        varchar2(32);
  l_query_interval_time number;
  l_receive_query_mq    varchar2(32);
  l_merchant_no         varchar2(32);
  l_user_no             varchar2(32);
  l_user_password       varchar2(32);
  l_language            varchar2(32);
  l_app_id              varchar2(32);
  l_app_ver             varchar2(32);
begin
  ---1.检查参数
  v_result := fd_f_b2e_recv_query_check(v_bank_account_id,
                                        v_start_time,
                                        v_end_time,
                                        l_main_card_no,
                                        l_query_interval_time,
                                        l_receive_query_mq,
                                        l_merchant_no,
                                        l_user_no,
                                        l_user_password,
                                        l_language,
                                        l_app_id,
                                        l_app_ver);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.创建任务
  v_result := fd_f_b2e_recv_query_task(v_start_time,
                                       v_end_time,
                                       v_bank_account_id,
                                       l_main_card_no,
                                       l_query_interval_time,
                                       l_receive_query_mq,
                                       l_merchant_no,
                                       l_user_no,
                                       l_user_password,
                                       l_language,
                                       l_app_id,
                                       l_app_ver);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('下游收款查询任务创建',
                        v_create_user,
                        ('v_bank_account_id=' || v_bank_account_id));

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_down_recv_task_manual', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_MANUAL_UP_MAIN_ADD
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_b2e_manual_up_main_add(v_up_channel_no varchar2, --加款上游渠道
                                                        v_up_account_id number,
                                                        v_up_card_no    varchar2, ---收款银行卡
                                                        v_up_add_amount number, --加款金额
                                                        v_create_user   varchar2, --创建人，自动传空
                                                        v_add_memo      varchar2, --添加备注
                                                        v_result        out varchar2) as
  -----------------上游手工加款记录创建-----------------
  l_work_day_type      number;
  l_bank_type          number;
  l_calc_range_type    number;
  l_service_fee        number;
  l_sub_count          number;
  l_sub_max_amount     number;
  l_last_sub_amount    number;
  l_last_sub_fee       number;
  l_bank_account_id    number;
  l_white_list_id      number;
  l_channel_company_id number;
  l_rcv_card_type      number;
  l_expire_time        date;
  l_bank_add_type_id   number;
  l_white_bank_type    number;
  l_pay_card_no        varchar2(32);
  l_pay_card_name      varchar2(32);
begin
  ---1.获取工作日、高峰期信息
  v_result := fd_f_b2e_up_date_info_get(l_calc_range_type, l_work_day_type);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---1.检查参数
  v_result := fd_f_b2e_manual_up_main_add_ck(v_up_channel_no,
                                             v_up_account_id,
                                             v_up_card_no,
                                             v_up_add_amount,
                                             l_calc_range_type,
                                             l_white_list_id,
                                             l_channel_company_id,
                                             l_rcv_card_type,
                                             l_white_bank_type);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.选择拆单次数最少、手续费最少的一条加款方式
  v_result := fd_f_b2e_up_add_type_info_get(l_rcv_card_type,
                                            v_up_add_amount,
                                            l_work_day_type,
                                            l_channel_company_id,
                                            l_white_bank_type,
                                            l_service_fee,
                                            l_bank_type,
                                            l_bank_add_type_id,
                                            l_bank_account_id,
                                            l_pay_card_no,
                                            l_pay_card_name,
                                            l_sub_count,
                                            l_sub_max_amount,
                                            l_last_sub_amount,
                                            l_last_sub_fee,
                                            l_expire_time);

  if v_result = pkg_error_code.bank_payment_type_error then
    ---3.1没有加款方式提交报警信息
    commit;
    return;
  elsif v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.创建加款主记录及子记录
  v_result := fd_f_b2e_up_add_record_create(v_up_channel_no,
                                            v_up_account_id,
                                            l_bank_add_type_id,
                                            l_bank_account_id,
                                            l_pay_card_no,
                                            l_pay_card_name,
                                            l_white_list_id,
                                            v_up_card_no,
                                            v_up_add_amount,
                                            l_sub_count,
                                            l_sub_max_amount,
                                            l_service_fee,
                                            l_last_sub_amount,
                                            l_last_sub_fee,
                                            pkg_b2e_create_type.user_create,
                                            l_expire_time,
                                            v_add_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---5.记录操作日志
  fd_p_write_handle_log('银企直连人工创建上游记录',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_add_amount=' || v_up_add_amount));

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_manual_up_main_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_MANUAL_UP_MAIN_EDIT
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_b2e_manual_up_main_edit(v_main_record_id number,
                                                         v_up_channel_no  varchar2, --加款上游渠道
                                                         v_account_id     number,
                                                         v_up_card_no     varchar2, ---收款银行卡
                                                         v_add_type_id    number, --加款方式编号，自动创建传0
                                                         v_up_add_amount  number, --加款金额
                                                         v_create_user    varchar2, --创建人，自动传空
                                                         v_result         out varchar2) as
  -----------------上游手工加款记录修改-----------------
  l_work_day_type   number;
  l_bank_type       number;
  l_add_type        number;
  l_max_amount      number;
  l_calc_range_type number;
  l_service_fee     number;
  l_sub_count       number;
  l_sub_max_amount  number;
  l_last_sub_amount number;
  l_last_sub_fee    number;
  l_bank_account_id number;
  l_expire_time     date;
  l_bank_card_no    varchar2(32);
  l_bank_card_name  varchar2(32);
  l_white_list_id   number;

begin
  ---1.获取工作日、高峰期信息
  v_result := fd_f_b2e_up_date_info_get(l_calc_range_type, l_work_day_type);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.检查参数
  v_result := fd_f_b2e_manual_up_main_edt_ck(v_main_record_id,
                                             v_up_channel_no,
                                             v_account_id,
                                             v_up_card_no,
                                             v_add_type_id,
                                             v_up_add_amount,
                                             l_calc_range_type,
                                             l_work_day_type,
                                             l_bank_account_id,
                                             l_bank_card_no,
                                             l_bank_card_name,
                                             l_white_list_id,
                                             l_bank_type,
                                             l_add_type,
                                             l_max_amount,
                                             l_expire_time);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.计算加款应收取的手续费
  v_result := fd_f_b2e_up_split_order_calc(l_bank_type,
                                           l_add_type,
                                           l_max_amount,
                                           v_up_add_amount,
                                           l_service_fee,
                                           l_sub_count,
                                           l_sub_max_amount,
                                           l_last_sub_amount,
                                           l_last_sub_fee);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.修改加款主记录
  v_result := fd_f_b2e_up_add_record_edit(v_main_record_id,
                                          v_add_type_id,
                                          l_bank_account_id,
                                          l_bank_card_no,
                                          l_bank_card_name,
                                          v_up_card_no,
                                          l_white_list_id,
                                          v_up_add_amount,
                                          l_sub_count,
                                          l_sub_max_amount,
                                          l_service_fee,
                                          l_last_sub_amount,
                                          l_last_sub_fee,
                                          l_expire_time);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---5.记录操作日志
  fd_p_write_handle_log('银企直连人工修改上游记录',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_add_amount=' || v_up_add_amount));

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_manual_up_main_edit', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_PAYMENT_EDIT_AUDIT
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_b2e_payment_edit_audit(v_main_record_id number,
                                                        v_audit_user     varchar2,
                                                        v_memo           varchar2,
                                                        v_result         out varchar2) as
  --------------上游加款任务创建--------------
begin

  ---1.检查相关记录参数
  v_result := fd_f_b2e_payment_audit_check(v_main_record_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.创建所有子记录对应任务
  v_result := fd_f_b2e_payment_task_create(v_main_record_id,
                                           v_audit_user,
                                           v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.添加操作记录
  fd_p_write_handle_log('上游加款任务创建',
                        v_audit_user,
                        ('v_main_record_id=' || v_main_record_id));

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_payment_edit_audit', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_PAYMENT_QUERY_SAVE
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_b2e_payment_query_save(v_sub_record_id   number,
                                                        v_error_code      varchar2,
                                                        v_query_error_msg varchar2,
                                                        v_manual_msg      varchar2,
                                                        v_result          out varchar2) as
  -----------------完成上游转账进度查询----------------
  l_bank_id        number;
  l_main_record_id number;
begin
  ---1.检查任务及记录相关信息
  v_result := fd_f_b2e_payment_query_check(v_sub_record_id,
                                           l_bank_id,
                                           l_main_record_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.完成任务
  v_result := fd_f_b2e_payment_query_save(l_bank_id,
                                          v_sub_record_id,
                                          l_main_record_id,
                                          substr(v_error_code, 0, 32),
                                          substr(v_query_error_msg, 0, 32),
                                          v_manual_msg);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    fd_p_write_log('fd_p_b2e_up_query_save', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_PAYMENT_RECORD_ADJUST
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_b2e_payment_record_adjust(v_main_record_id in number, ---红冲的主记录编号
                                                           v_create_user    in varchar2, ---操作人
                                                           v_adjust_days    in number, ---红冲天数
                                                           v_memo           in varchar2, ---备注
                                                           v_result         out varchar2) as
  -------------------上游加款记录红冲------------------
  l_payment_type number;
begin

  ---0.还原主记录
  v_result := fd_f_b2e_trf_status_adjust(v_main_record_id, l_payment_type);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  if l_payment_type = pkg_payment_type.up_add then
    for item in (select a.record_id
                   from fd_trade_up_manual a
                  where a.change_time >= (trunc(sysdate) - v_adjust_days)
                    and a.has_adjust = pkg_sys_boolean.isfalse
                    and a.memo like '%' || v_main_record_id || '|%') loop
      begin
        ---1. 检查加款记录、账户、余额、手续费
        v_result := fd_f_adjust_up_add_check(item.record_id, v_adjust_days);
        if v_result != pkg_error_code.success then
          rollback;
          return;
        end if;
      
        ---2. 红冲上游手工加款记录
        v_result := fd_f_adjust_up_add_handle(item.record_id,
                                              v_create_user,
                                              v_memo);
        if v_result != pkg_error_code.success then
          rollback;
          return;
        end if;
      end;
    end loop;
  else
    v_result := pkg_error_code.data_not_exists;
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('上游人工加款红充',
                        v_create_user,
                        'v_main_record_id=' || v_main_record_id);

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_up_add_adjust', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_PAYMENT_RESULT_SAVE
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_b2e_payment_result_save(v_sub_record_id number,
                                                         v_error_code    varchar2,
                                                         v_error_msg     varchar2,
                                                         v_server_id     varchar2,
                                                         v_result        out varchar2) as
  -----------------上游加款提交完成操作--------------
  l_bank_id        number;
  l_main_record_id number;
begin
  ---1.检查子记录是否为正在查询状态
  v_result := fd_f_b2e_pymet_adt_save_check(v_sub_record_id,
                                            l_bank_id,
                                            l_main_record_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.根据返回错误码修改主记录资金的提交信息及返回信息
  v_result := fd_f_b2e_up_payment_audit_save(l_main_record_id,
                                             substr(v_error_code, 0, 32),
                                             substr(v_error_msg, 0, 32),
                                             v_sub_record_id,
                                             v_server_id,
                                             l_bank_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_payment_result_save', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_PAYMENT_UP_ADD
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_b2e_payment_up_add(v_main_record_id in number, ---主记录编号
                                                    v_create_user    in varchar2, ---操作员
                                                    v_memo           in varchar2, ---备注
                                                    v_result         out varchar2) as
  ------------------银企直连上游加款----------------
  l_bank_id         number;
  l_up_channal_no   varchar2(32);
  l_add_amount      number;
  l_add_service_fee number;
  l_partner_card    varchar2(64);
  l_account_id      number;
  l_company_id      number;
  l_account_name    varchar2(32);
  l_channel_name    varchar2(32);
  l_bank_holder_name varchar2(100);
begin
  ---1.获取上游加款信息
  v_result := fd_f_b2e_up_add_info_get(v_main_record_id,
                                       l_bank_id,
                                       l_up_channal_no,
                                       l_add_amount,
                                       l_add_service_fee,
                                       l_partner_card,
                                       l_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.上游加款检查
  v_result := fd_f_manual_up_add_check(l_up_channal_no,
                                       l_account_id,
                                       l_bank_id,
                                       l_add_amount,
                                       l_add_service_fee,
                                       l_company_id,
                                       l_account_name,
                                       l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --2.1获取账户名称
  select d.bank_holder_name
    into l_bank_holder_name
    from fd_b2e_payment_record_main t
    left join fd_b2e_up_white_list d on d.id=t.white_list_id
   where t.record_id = v_main_record_id
     and t.payment_audit_status in (pkg_b2e_payment_audit_status.dealing,
          pkg_b2e_payment_audit_status.success)
     and t.received_audit_status = pkg_b2e_received_status.dealing
     and (t.arrival_success_amount - t.received_success_amount) > 0;

  ---3.账户手工加款
  v_result := fd_f_manual_up_add(l_up_channal_no,
                                 l_company_id,
                                 l_account_id,
                                 l_bank_id,
                                 l_add_amount,
                                 l_add_service_fee,
                                 v_create_user,
                                 l_partner_card,
                                 (v_main_record_id || '|' || v_memo),
                                 l_account_name,
                                 l_bank_holder_name,
                                 l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---4.修改加款状态，完成加款
  v_result := fd_f_b2e_up_add_status_edit(v_main_record_id,
                                          l_add_amount,
                                          l_add_service_fee,
                                          v_create_user,
                                          v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---5.记录操作日志
  fd_p_write_handle_log('银企直连上游加款',
                        v_create_user,
                        ('v_main_record_id=' || v_main_record_id));

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_up_add_amount', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_RECV_DOWN_ADD
prompt =========================================
prompt
create or replace procedure fd_account.fd_p_b2e_recv_down_add(v_recv_record_id  number, ---收款记录编号
                                                   v_down_channel_no varchar2, ---下游渠道编号
                                                   v_down_account_id number,
                                                   v_create_user     varchar2, ---加款人
                                                   v_memo            varchar2,
                                                   v_result          out varchar2) as
  ----------------银企直连下游渠道加款----------------
  l_bank_account_id number;
  l_receive_amount  number;
  l_bank_batch_id   number;
  l_account_name    varchar2(32);
  l_channel_name    varchar2(32);
  l_down_card_no    varchar2(64);
begin

  ---1.获取收款记录信息
  v_result := fd_f_b2e_down_add_get(v_recv_record_id,
                                    v_down_channel_no,
                                    v_down_account_id,
                                    l_bank_account_id,
                                    l_receive_amount,
                                    l_down_card_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.检查下游渠道、账户及其关联情况
  v_result := fd_f_manual_down_add_check(v_down_channel_no,
                                         v_down_account_id,
                                         l_bank_account_id,
                                         l_receive_amount,
                                         0,
                                         l_account_name,
                                         l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款(锁实体卡账户、渠道账户、手续费账户)
  v_result := fd_f_manual_down_add(v_down_channel_no,
                                   v_down_account_id,
                                   l_bank_account_id,
                                   l_receive_amount,
                                   0,
                                   v_create_user,
                                   l_down_card_no,
                                   (v_recv_record_id || '|' || v_memo),
                                   l_account_name,
                                   l_channel_name,
                                   '',
                                   l_bank_batch_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---4.修改任务状态
  v_result := fd_f_b2e_down_add_complate(v_recv_record_id,
                                         v_down_channel_no,
                                         v_down_account_id,
                                         l_bank_batch_id,
                                         v_create_user,
                                         0,
                                         v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---5.记录操作日志
  fd_p_write_handle_log('银企直连下游加款',
                        v_create_user,
                        ('v_recv_record_id=' || v_recv_record_id));

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_recv_down_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_RECV_RECORD_ADJUST
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_b2e_recv_record_adjust(v_recv_record_id in number, ---红冲的收款记录编号
                                                        v_create_user    in varchar2, ---操作人
                                                        v_adjust_days    in number, ---红冲天数
                                                        v_memo           in varchar2, ---备注
                                                        v_result         out varchar2) as
  -------------银企直连下游加款红冲-------------
  l_sys_fund_id  number;
  l_receive_type number;
begin
  ---1.修改下游收款记录的加款状态，并获取下游加款记录编号
  v_result := fd_f_b2e_recv_status_adjust(v_recv_record_id,
                                          l_sys_fund_id,
                                          l_receive_type);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  if l_receive_type = pkg_receive_type.down_add then
    ---2.下游加款红冲
    v_result := fd_f_b2e_recv_down_add_adjust(l_sys_fund_id,
                                              v_adjust_days,
                                              v_create_user,
                                              v_memo);
  else
    v_result := pkg_error_code.data_not_exists;
  end if;

  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  ---3.记录操作日志
  fd_p_write_handle_log('银企直连银行收款记录红冲',
                        v_create_user,
                        'v_recv_record_id=' || v_recv_record_id);

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_recv_record_adjust', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_UP_AMOUNT_FORECAST
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_b2e_up_amount_forecast(v_start_time    date,
                                                      v_duration_hour number,
                                                      v_result        out varchar2) as
  ------------------上游渠道交易量预测-----------------
  l_forecast_amount number;
  l_return_info     varchar2(256);
begin

  for item in (select h.channel_no, sum(h.trade_amount) trade_amount
                 from fd_report_channel_halfhour h
                where h.collect_time >= v_start_time
                  and h.collect_time < v_start_time + v_duration_hour / 24
                  and h.channel_type = 1
                group by h.channel_no) loop
    begin
      v_result := fd_f_b2e_up_add_forecast(item.channel_no,
                                           v_start_time,
                                           v_duration_hour,
                                           l_forecast_amount,
                                           l_return_info);
      if v_result = pkg_error_code.success then
        insert into fd_b2e_up_forecast
          (start_time,
           end_time,
           up_channel_no,
           forecast_amount,
           real_amount,
           memo)
        values
          (v_start_time,
           v_start_time + v_duration_hour / 24,
           item.channel_no,
           l_forecast_amount,
           item.trade_amount,
           l_return_info);
        commit;
      end if;
    
    end;
  end loop;

  v_result := pkg_error_code.success;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_b2e_up_amount_forecast', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_WHITELIST_UP_ADD
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_b2e_whitelist_up_add(v_channel_no         in varchar2, ---渠道编号
                                                      v_channel_account_id in number, ---账户编号
                                                      v_bank_holder_name   in varchar2, --持卡人姓名
                                                      v_holder_card_no     in varchar2, --银行账户（卡号）
                                                      v_main_bank_code     in varchar2, --开户行主行行号（网银互联用）
                                                      v_branch_bank_code   in varchar2, --开户行支行行号（大小额用）
                                                      v_bank_type          in number, --银行类型(民生银行，中信银行)
                                                      v_rcv_card_type      in varchar2, --收款账户类型：1:对公；2:对私
                                                      v_account_bank_name  in varchar2, --开户行名称(xxxx支行)
                                                      v_province_no        in varchar2, --账户省份编号
                                                      v_city_no            in varchar2, --城市编号
                                                      v_create_user        in varchar2, --添加人
                                                      v_result             out varchar2) as
  ----------------------------------
  --功能：银企直连添加
  --创建人：周荣省
  --创建时间：2019-07-15
  ----------------------------------
  l_number number;
begin
  ---1.判断账号是否存在
  select count(0)
    into l_number
    from fd_b2e_up_white_list t
   where t.channel_no = v_channel_no
     and t.holder_card_no = v_holder_card_no;
  if l_number > 0 then
    v_result := pkg_error_code.data_repeat;
    return;
  end if;
  --2.删除已存在上游加款配置信息
  delete from fd_b2e_up_channel_config t
   where t.up_channel_no = v_channel_no
     and t.channel_account_id = v_channel_account_id;
  --3.添加白名单
  insert into fd_b2e_up_white_list
    (id,
     channel_no,
     channel_account_id,
     bank_holder_name,
     holder_card_no,
     main_bank_code,
     branch_bank_code,
     bank_type,
     rcv_card_type,
     account_bank_name,
     province_no,
     city_no,
     audit_status,
     sort_id)
  values
    (seq_b2e_up_white_list_id.nextval,
     v_channel_no,
     v_channel_account_id,
     v_bank_holder_name,
     v_holder_card_no,
     v_main_bank_code,
     v_branch_bank_code,
     v_bank_type,
     v_rcv_card_type,
     v_account_bank_name,
     v_province_no,
     v_city_no,
     2,
     0);
  --4.添加上游加款配置信息1
  insert into fd_b2e_up_channel_config
    (type_id,
     date_range_type,
     up_channel_no,
     amount_calc_type,
     warn_balance,
     max_channel_balance,
     min_add_amount,
     max_day_add_amount,
     add_duration_hour,
     audit_status,
     channel_account_id)
  values
    (seq_b2e_up_channel_config_id.nextval,
     1,
     v_channel_no,
     'default',
     5000,
     50000,
     5000,
     1000000,
     2,
     2,
     v_channel_account_id);
  --5.添加上游加款配置信息0
  insert into fd_b2e_up_channel_config
    (type_id,
     date_range_type,
     up_channel_no,
     amount_calc_type,
     warn_balance,
     max_channel_balance,
     min_add_amount,
     max_day_add_amount,
     add_duration_hour,
     audit_status,
     channel_account_id)
  values
    (seq_b2e_up_channel_config_id.nextval,
     0,
     v_channel_no,
     'default',
     5000,
     50000,
     5000,
     1000000,
     2,
     2,
     v_channel_account_id);
  ---6.记录操作日志
  fd_p_write_handle_log('银企直连添加上游账号',
                        v_create_user,
                        ('v_channel_no=' || v_channel_no));
  v_result := pkg_error_code.success;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_whitelist_up_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_B2E_WHITELIST_UP_EDIT
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_b2e_whitelist_up_edit(v_channel_no         in varchar2, ---渠道编号
                                                       v_channel_account_id in number, ---账户编号
                                                       v_bank_holder_name   in varchar2, --持卡人姓名
                                                       v_holder_card_no     in varchar2, --银行账户（卡号）
                                                       v_main_bank_code     in varchar2, --开户行主行行号（网银互联用）
                                                       v_branch_bank_code   in varchar2, --开户行支行行号（大小额用）
                                                       v_bank_type          in number, --银行类型(民生银行，中信银行)
                                                       v_rcv_card_type      in varchar2, --收款账户类型：1:对公；2:对私
                                                       v_account_bank_name  in varchar2, --开户行名称(xxxx支行)
                                                       v_province_no        in varchar2, --账户省份编号
                                                       v_city_no            in varchar2, --城市编号
                                                       v_create_user        in varchar2, --添加人
                                                       v_result             out varchar2) as
  ----------------------------------
  --功能：银企直连修改
  --创建人：周荣省
  --创建时间：2019-07-15
  ----------------------------------
  l_number number;
begin
  ---1.判断账号是否存在
  select count(0)
    into l_number
    from fd_b2e_up_white_list t
   where t.channel_no = v_channel_no
     and t.holder_card_no = v_holder_card_no;
  if l_number <= 0 then
    v_result := pkg_error_code.data_not_exists;
    return;
  end if;
  --2.修改上游白名单
  update fd_b2e_up_white_list t
     set t.channel_account_id = v_channel_account_id,
         t.bank_holder_name   = v_bank_holder_name,
         t.holder_card_no     = v_holder_card_no,
         t.main_bank_code     = v_main_bank_code,
         t.branch_bank_code   = v_branch_bank_code,
         t.bank_type          = v_bank_type,
         t.rcv_card_type      = v_rcv_card_type,
         t.account_bank_name  = v_account_bank_name,
         t.province_no        = v_province_no,
         t.city_no            = v_city_no,
         t.audit_status       = 2
   where t.channel_no = v_channel_no
     and t.holder_card_no = v_holder_card_no;
  --3.检查上游配置表是否已存在该数据
  select count(1)
    into l_number
    from fd_b2e_up_channel_config t
   where t.up_channel_no = v_channel_no;
  if l_number > 0 then
    --4.修改上游配置表审核状态
    update fd_b2e_up_channel_config t
       set t.audit_status = 2, t.channel_account_id = v_channel_account_id
     where t.up_channel_no = v_channel_no;
  else
    --5.添加上游加款配置信息1
    insert into fd_b2e_up_channel_config
      (type_id,
       date_range_type,
       up_channel_no,
       amount_calc_type,
       warn_balance,
       max_channel_balance,
       min_add_amount,
       max_day_add_amount,
       add_duration_hour,
       audit_status,
       channel_account_id)
    values
      (seq_b2e_up_channel_config_id.nextval,
       1,
       v_channel_no,
       'default',
       5000,
       50000,
       5000,
       1000000,
       2,
       2,
       v_channel_account_id);
    --6.添加上游加款配置信息0
    insert into fd_b2e_up_channel_config
      (type_id,
       date_range_type,
       up_channel_no,
       amount_calc_type,
       warn_balance,
       max_channel_balance,
       min_add_amount,
       max_day_add_amount,
       add_duration_hour,
       audit_status,
       channel_account_id)
    values
      (seq_b2e_up_channel_config_id.nextval,
       0,
       v_channel_no,
       'default',
       5000,
       50000,
       5000,
       1000000,
       2,
       2,
       v_channel_account_id);
  end if;
  ---7.记录操作日志
  fd_p_write_handle_log('银企直连修改上游账号',
                        v_create_user,
                        ('v_channel_no=' || v_channel_no));
  v_result := pkg_error_code.success;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_b2e_whitelist_up_edit', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_BAK_DOWN_FUND
prompt =====================================
prompt
create or replace procedure fd_account.fd_p_bak_down_fund(p_delete_time in date default null) is
  l_delete_time date;
  l_end_time    date;
  l_backed_cntr number;
  l_del_cntr    number;
  l_cnt         number;
  l_start_time  date := sysdate;
begin
  /*
  2016-05-13 edit by liangwl
  用于FD_TRADE_DOWN_FUND表历史数据归档到FD_TRADE_DOWN_FUND_HS
  保留15天数据
  */
  execute immediate 'alter session set nls_date_format=''yyyy-mm-dd hh24:mi:ss''';

  l_end_time := trunc(sysdate, 'dd') - 15;
  --若需要可手动设置第一次删除开始时间
  if p_delete_time is not null then
    l_delete_time := p_delete_time;
  else
    --获取上次归档操作最后时间
    select count(*)
      into l_cnt
      from tbl_global_param
     where param_name = 'bak_trade_down_fund';
    if l_cnt = 0 then
      --如果没有,则插入并赋值为21天前开始
      insert into tbl_global_param
        (param_name, time_val, param_desc)
      values
        ('bak_trade_down_fund',
         trunc(sysdate) - 20,
         'down_fund下次备份开始比较条件');
      commit;
      l_delete_time := trunc(sysdate) - 20;
    else
      select nvl(min(time_val), trunc(sysdate) - 20)
        into l_delete_time
        from tbl_global_param
       where param_name = 'bak_trade_down_fund';
    end if;
  end if;
  while (l_delete_time < l_end_time) loop
    --如果当前时间到当天8点了就退出该操作
    if sysdate > trunc(sysdate, 'dd') + 8 / 24 then
      return;
    end if;
  
    --备份
    insert into FD_TRADE_DOWN_FUND_HS
      select /*+ rule*/
       record_id,
       fd_order_id,
       channel_no,
       account_id,
       trade_order_no,
       ext_order_no,
       order_source,
       create_time,
       order_time,
       change_type,
       change_amount,
       balance,
       memo,
       service_fee
        from FD_TRADE_DOWN_FUND
       where create_time < l_delete_time;
    l_backed_cntr := sql%rowcount;
    --删除
    delete /*+ rule*/
    from FD_TRADE_DOWN_FUND
     where create_time < l_delete_time;
    l_del_cntr := sql%rowcount;
    if (l_backed_cntr != l_del_cntr) then
      rollback;
      fd_p_write_log('fd_p_bak_down_fund',
                     '备份与删除条数不一致:' || l_backed_cntr || '<>' || l_del_cntr,
                     1);
    else
      --每次只操作30分钟的数据量，防止操作失败产生大量回滚，删除成功后才到下一个 30分钟
      l_delete_time := l_delete_time + 30 / 24 / 60;
      update tbl_global_param
         set time_val = l_delete_time
       where param_name = 'bak_trade_down_fund';
      --备份成功的日志，主要看运行时长，开始时间，结束时间
      insert into fd_system_log
        (log_id, object_name, error_desc, trace, error_level)
      values
        (seq_system_log_id.nextval,
         'fd_p_bak_down_fund',
         '开始时间=' || l_start_time || '####结束时间=' || sysdate || '##' ||
         l_backed_cntr,
         '',
         0);
      commit;
    end if;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_bak_down_fund', 'down_fund数据归档出错', 1);
end fd_p_bak_down_fund;
/

prompt
prompt Creating procedure FD_P_BAK_ORDER_MAIN
prompt ======================================
prompt
create or replace procedure fd_account.fd_p_bak_order_main(p_delete_time in date default null) is
  l_delete_time date;
  l_end_time    date;
  l_backed_cntr number;
  l_del_cntr    number;
  l_cnt         number;
  l_start_time  date := sysdate;
begin
  /*
  2016-05-13 edit by liangwl
  用于FD_TRADE_ORDER_MAIN表历史数据归档到FD_TRADE_ORDER_MAIN_HS
  保留15天数据
  */
  execute immediate 'alter session set nls_date_format=''yyyy-mm-dd hh24:mi:ss''';

  l_end_time := trunc(sysdate, 'dd') - 15;
  --若需要可手动设置第一次删除开始时间
  if p_delete_time is not null then
    l_delete_time := p_delete_time;
  else
    --获取上次归档操作最后时间
    select count(*)
      into l_cnt
      from tbl_global_param
     where param_name = 'bak_trade_order_main';
    if l_cnt = 0 then
      --如果没有,则插入并赋值为21天前开始
      insert into tbl_global_param
        (param_name, time_val, param_desc)
      values
        ('bak_trade_order_main',
         trunc(sysdate) - 20,
         'order_main下次备份开始比较条件');
      commit;
      l_delete_time := trunc(sysdate) - 20;
    else
      select nvl(min(time_val), trunc(sysdate) - 20)
        into l_delete_time
        from tbl_global_param
       where param_name = 'bak_trade_order_main';
    end if;
  end if;
  while (l_delete_time < l_end_time) loop
    --如果当前时间到当天8点了就退出该操作
    if sysdate > trunc(sysdate, 'dd') + 8 / 24 then
      return;
    end if;
  
    --备份
    insert into FD_TRADE_ORDER_MAIN_HS
      select /*+ rule*/
      *
       /*fd_order_id,
       down_channel_no,
       down_account_id,
       down_company_id,
       trade_order_no,
       ext_order_no,
       order_source,
       create_time,
       order_time,
       business_type,
       carrier_no,
       province_no,
       city_no,
       total_face,
       recharge_unit,
       recharge_account_no*/
        from FD_TRADE_ORDER_MAIN
       where create_time < l_delete_time;
    l_backed_cntr := sql%rowcount;
    --删除
    delete /*+ rule*/
    from FD_TRADE_ORDER_MAIN
     where create_time < l_delete_time;
    l_del_cntr := sql%rowcount;
    if (l_backed_cntr != l_del_cntr) then
      rollback;
      fd_p_write_log('fd_p_bak_order_main',
                     '备份与删除条数不一致:' || l_backed_cntr || '<>' || l_del_cntr,
                     1);
    else
      --每次只操作30分钟的数据量，防止操作失败产生大量回滚，删除成功后才到下一个 30分钟
      l_delete_time := l_delete_time + 30 / 24 / 60;
      update tbl_global_param
         set time_val = l_delete_time
       where param_name = 'bak_trade_order_main';
      --备份成功的日志，主要看运行时长，开始时间，结束时间
      insert into fd_system_log
        (log_id, object_name, error_desc, trace, error_level)
      values
        (seq_system_log_id.nextval,
         'fd_p_bak_order_main',
         '开始时间=' || l_start_time || '####结束时间=' || sysdate || '##' ||
         l_backed_cntr,
         '',
         0);
      commit;
    end if;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_bak_order_main', 'order_main数据归档出错', 1);
end fd_p_bak_order_main;
/

prompt
prompt Creating procedure FD_P_BAK_UP_FUND
prompt ===================================
prompt
create or replace procedure fd_account.fd_p_bak_up_fund(p_delete_time in date default null) is
  l_delete_time date;
  l_end_time    date;
  l_backed_cntr number;
  l_del_cntr    number;
  l_cnt         number;
  l_start_time  date := sysdate;
begin
  /*
  2016-05-13 edit by liangwl
  用于FD_TRADE_UP_FUND表历史数据归档到FD_TRADE_UP_FUND_HS
  保留15天数据
  */
  execute immediate 'alter session set nls_date_format=''yyyy-mm-dd hh24:mi:ss''';

  l_end_time := trunc(sysdate, 'dd') - 15;
  --若需要可手动设置第一次删除开始时间
  if p_delete_time is not null then
    l_delete_time := p_delete_time;
  else
    --获取上次归档操作最后时间
    select count(*)
      into l_cnt
      from tbl_global_param
     where param_name = 'bak_trade_up_fund';
    if l_cnt = 0 then
      --如果没有,则插入并赋值为21天前开始
      insert into tbl_global_param
        (param_name, time_val, param_desc)
      values
        ('bak_trade_up_fund',
         trunc(sysdate) - 20,
         'up_fund下次备份开始比较条件');
      commit;
      l_delete_time := trunc(sysdate) - 20;
    else
      select nvl(min(time_val), trunc(sysdate) - 20)
        into l_delete_time
        from tbl_global_param
       where param_name = 'bak_trade_up_fund';
    end if;
  end if;
  while (l_delete_time < l_end_time) loop
    --如果当前时间到当天8点了就退出该操作
    if sysdate > trunc(sysdate, 'dd') + 8 / 24 then
      return;
    end if;
  
    --备份
    
    --删除
    delete /*+ rule*/
    from FD_TRADE_UP_FUND
     where CHANGE_TIME <= l_delete_time;
    l_del_cntr := sql%rowcount;
    if (l_backed_cntr != l_del_cntr) then
      rollback;
      fd_p_write_log('fd_p_bak_up_fund',
                     '备份与删除条数不一致:' || l_backed_cntr || '<>' || l_del_cntr,
                     1);
    else
      --每次只操作30分钟的数据量，防止操作失败产生大量回滚，删除成功后才到下一个 30分钟
      l_delete_time := l_delete_time + 30 / 24 / 60;
      update tbl_global_param
         set time_val = l_delete_time
       where param_name = 'bak_trade_up_fund';
      --备份成功的日志，主要看运行时长，开始时间，结束时间
      insert into fd_system_log
        (log_id, object_name, error_desc, trace, error_level)
      values
        (seq_system_log_id.nextval,
         'fd_p_bak_up_fund',
         '开始时间=' || l_start_time || '####结束时间=' || sysdate || '##' ||
         l_backed_cntr,
         '',
         0);
      commit;
    end if;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_bak_up_fund', 'up_fund数据归档出错', 1);
end fd_p_bak_up_fund;
/

prompt
prompt Creating procedure FD_P_BANK_ACTIVITY_ADD
prompt =========================================
prompt
create or replace procedure fd_account.fd_p_bank_activity_add(v_act_account_id number,
                                                   v_amount         number,
                                                   v_hander_user    varchar2,
                                                   v_memo           varchar2,
                                                   v_result         out varchar2) as
  ------------------活动专用账户加款---------------------
begin
  ---1.检查活动账户及相关利润账户信息
  v_result := fd_f_bank_act_add_check(v_act_account_id, v_amount);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.进行活动和利润账户加款
  v_result := fd_f_bank_act_add(v_act_account_id,
                                v_amount,
                                v_hander_user,
                                nvl(v_memo, '活动账户应收添加'));
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('活动专用账户加款',
                        v_hander_user,
                        ('v_act_account_id=' || v_act_account_id ||
                        ',v_amount=' || v_amount));

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_bank_activity_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_BANK_ACTIVITY_SETTLE
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_bank_activity_settle(v_bank_account_id number, ---入账实体卡账户
                                                      v_act_account_id  number, ---出账资产账户编号
                                                      v_amount          number, ---入账金额
                                                      v_service_fee     number, ---实体卡收取的手续费，没有为0
                                                      v_hander_user     varchar2, ---操作用户
                                                      v_memo            varchar2, ---可空，备注
                                                      v_result          out varchar2) as
  -----------------活动专用账户结算-----------------
begin
  ---1.检查相关账户及金额
  v_result := fd_f_bank_act_minus_check(v_bank_account_id,
                                        v_act_account_id,
                                        v_amount,
                                        v_service_fee);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.活动专用账户减款
  v_result := fd_f_bank_cap_minus(v_bank_account_id,
                                  v_act_account_id,
                                  pkg_bank_use_type.activity,
                                  v_amount,
                                  v_service_fee,
                                  v_hander_user,
                                  '-',
                                  '-',
                                  '',
                                  nvl(v_memo, '活动账户结算'));
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('活动专用账户减款',
                        v_hander_user,
                        ('v_bank_account_id=' || v_bank_account_id ||
                        ',v_act_account_id=' || v_act_account_id ||
                        ',v_amount=' || v_amount));

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_bank_activity_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_BANK_CAPITAL_ADD
prompt ========================================
prompt
create or replace procedure fd_account.fd_p_bank_capital_add(v_bank_account_id   number, ---出账实体卡账户
                                                  v_cap_account_id    number, ---入账资产账户编号
                                                  v_amount            number, ---出账金额
                                                  v_service_fee       number, ---实体卡收取的手续费，没有为0
                                                  v_hander_user       varchar2, ---操作用户
                                                  v_link_channel_name varchar2, ---可空，关联渠道
                                                  v_link_account_name varchar2, ---可空，关联账户
                                                  v_memo              varchar2, ---可空，备注
                                                  v_remark_name       varchar2, --收付款账户名称
                                                  v_result            out varchar2) as
  --------------------------------------
  --功能：实体卡账户 收取运营投入、押金、保证金、短期
  --修改人：周荣省
  --修改时间：2019-08-27
  --修改内容：添加收付款账户名称
  --------------------------------------
  l_fund_bank_use_type number;
  l_capital_type       number;
  l_number             number;
begin

  ---1.检查账户及金额相关信息
  v_result := fd_f_bank_cap_add_check(v_bank_account_id,
                                      v_cap_account_id,
                                      v_amount,
                                      v_service_fee,
                                      l_capital_type,
                                      l_fund_bank_use_type);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.实体卡入账(锁资产账户、实体卡账户)
  v_result := fd_f_bank_cap_add(v_bank_account_id,
                                v_cap_account_id,
                                l_fund_bank_use_type,
                                v_amount,
                                v_service_fee,
                                v_hander_user,
                                v_link_channel_name,
                                v_link_account_name,
                                v_remark_name,
                                v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('资产账户加款',
                        v_hander_user,
                        ('v_bank_account_id=' || v_bank_account_id ||
                        ',l_capital_type=' || l_capital_type ||
                        ',v_amount=' || v_amount));
  --4.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_cap_account_id
     and t.co_account_type = 4
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(v_cap_account_id,
                                         4,
                                         v_remark_name,
                                         v_hander_user);
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_bank_capital_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_BANK_CAPITAL_MINUS
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_bank_capital_minus(v_bank_account_id   number, ---入账实体卡账户
                                                    v_cap_account_id    number, ---出账资产账户编号
                                                    v_amount            number, ---入账金额
                                                    v_service_fee       number, ---实体卡收取的手续费，没有为0
                                                    v_hander_user       varchar2, ---操作用户
                                                    v_link_channel_name varchar2, ---可空，关联渠道
                                                    v_link_account_name varchar2, ---可空，关联账户
                                                    v_memo              varchar2, ---可空，备注
                                                    v_remark_name       varchar2, --收付款账户名称
                                                    v_result            out varchar2) as
  --------------------------------------
  --功能：实体卡账户 收取运营投入、押金、保证金、短期
  --修改人：周荣省
  --修改时间：2019-08-27
  --修改内容：添加收付款账户名称
  --------------------------------------
  l_capital_type       number;
  l_fund_bank_use_type number;
  l_number             number;
begin

  ---1.检查账户及金额相关信息
  v_result := fd_f_bank_cap_minus_check(v_bank_account_id,
                                        v_cap_account_id,
                                        v_amount,
                                        v_service_fee,
                                        l_capital_type,
                                        l_fund_bank_use_type);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.实体卡入账(锁资产账户、实体卡账户)
  v_result := fd_f_bank_cap_minus(v_bank_account_id,
                                  v_cap_account_id,
                                  l_fund_bank_use_type,
                                  v_amount,
                                  v_service_fee,
                                  v_hander_user,
                                  v_link_channel_name,
                                  v_link_account_name,
                                  v_remark_name,
                                  v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('资产账户减款',
                        v_hander_user,
                        ('v_bank_account_id=' || v_bank_account_id ||
                        ',l_capital_type=' || l_capital_type ||
                        ',v_amount=' || v_amount));

  --4.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_cap_account_id
     and t.co_account_type = 4
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(v_cap_account_id,
                                         4,
                                         v_remark_name,
                                         v_hander_user);
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_bank_capital_minus', sqlerrm, 1);
end;
--===============================================================================================
/

prompt
prompt Creating procedure FD_P_BANK_CAPITAL_PRE_MINUS
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_bank_capital_pre_minus(v_cap_account_id number, ---出账资产账户编号
                                                        v_amount         number, ---入账金额
                                                        v_hander_user    varchar2, ---操作用户
                                                        v_record_no      varchar2, ---外部编号
                                                        v_memo           varchar2, ---可空，备注
                                                        v_result         out varchar2) as
  --------------------预付账户减款------------------
begin

  ---1.检查账户及金额相关信息
  v_result := fd_f_bank_pre_minus_check(v_cap_account_id,
                                        v_amount,
                                        v_record_no);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.实体卡入账(锁资产账户、实体卡账户)
  v_result := fd_f_bank_capital_pre_minus(v_cap_account_id,
                                          v_amount,
                                          v_hander_user,
                                          v_record_no,
                                          v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('预付款账户减款',
                        v_hander_user,
                        ('v_amount=' || v_amount));

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_bank_capital_pre_minus', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_BANK_COMMISION_SETTLE
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_bank_commision_settle(v_channel_no      varchar2, ---渠道编号
                                                       v_channel_type    number, ---渠道类型
                                                       v_bank_account_id number, ---结算实体卡编号
                                                       v_commission      number, ---结算佣金
                                                       v_commi_month     varchar2, ---结算月份(yyyymmddhh24miss)
                                                       v_service_fee     number, ---结算公司支付的手续费
                                                       v_settle_user     varchar2, ---结算人
                                                       v_memo            varchar2, ---备注
                                                       v_remark_name     varchar2, --添加收付款账户名称
                                                       v_result          out varchar2) as
  ---------------------------------------
  --功能：佣金结算
  --修改人：周荣省
  --修改时间：2019-08-26
  --修改内容：添加收付款账户名称
  ---------------------------------------
  l_number     number;
  l_account_id number;
begin
  ---0.记录操作日志
  fd_p_write_handle_log('渠道佣金结算',
                        v_settle_user,
                        ('v_channel_no=' || v_channel_no ||
                        ',v_channel_type=' || v_channel_type ||
                        ',v_commission=' || v_commission));

  ---1.获取并检查结算参数
  v_result := fd_f_bank_commision_check(v_channel_no,
                                        v_channel_type,
                                        v_bank_account_id,
                                        v_commission,
                                        v_service_fee);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.渠道佣金结算
  v_result := fd_f_bank_commision_settle(v_channel_no,
                                         v_channel_type,
                                         v_bank_account_id,
                                         v_commission,
                                         v_commi_month,
                                         v_service_fee,
                                         v_settle_user,
                                         v_remark_name,
                                         v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --4.添加收付款账户
  if (v_channel_type = 2) then
    select t.account_id
      into l_account_id
      from fd_base_down_account_map t
     where t.channel_no = v_channel_no;
  elsif (v_channel_type = 1) then
    select t.account_id
      into l_account_id
      from fd_base_up_account_map t
     where t.channel_no = v_channel_no;
  else
    l_account_id := 0;
  end if;
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = l_account_id
     and t.co_account_type = 6
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(l_account_id,
                                         6,
                                         v_remark_name,
                                         v_settle_user);
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_bank_commision_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_BANK_COMPANY_SETTLE
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_bank_company_settle(v_co_account_id       number, ---公司间结算账户
                                                     v_out_bank_account_id number, ---出账实体卡账户
                                                     v_in_bank_account_id  number, ---入账实体卡账户
                                                     v_amount              number, ---结算加款金额
                                                     v_service_fee         number, ---结算手续费，没有为0
                                                     v_handle_user         varchar2, ---操作人
                                                     v_memo                varchar2, ---备注
                                                     v_remark_name         varchar2, --支出账户名称
                                                     v_remark_name_in      varchar2, --收入账户名
                                                     v_result              out varchar2) as

  ----------------------------------------
  --功能：公司间结算
  --修改人：周荣省
  --修改时间：2019-08-27
  --修改内容：添加收付款账户名称
  ----------------------------------------
  l_number number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('公司间结算',
                        v_handle_user,
                        ('v_co_account_id=' || v_co_account_id ||
                        ',v_amount=' || v_amount));

  ---2.检查公司账户实体卡账户及余额是否正确
  v_result := fd_f_bank_co_settle_check(v_co_account_id,
                                        v_out_bank_account_id,
                                        v_in_bank_account_id,
                                        v_amount,
                                        v_service_fee);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.公司间结算加款
  v_result := fd_f_bank_co_settle_add(v_co_account_id,
                                      v_out_bank_account_id,
                                      v_in_bank_account_id,
                                      v_amount,
                                      v_service_fee,
                                      v_handle_user,
                                      v_remark_name,
                                      v_remark_name_in,
                                      v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  --4.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_out_bank_account_id
     and t.co_account_type = 3
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(v_out_bank_account_id,
                                         3,
                                         v_remark_name,
                                         v_handle_user);
  end if;
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_in_bank_account_id
     and t.co_account_type = 3
     and t.co_account_name = v_remark_name_in;

  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(v_in_bank_account_id,
                                         3,
                                         v_remark_name_in,
                                         v_handle_user);
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_bank_company_settle_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_BANK_FUND_T
prompt ===================================
prompt
create or replace procedure fd_account.fd_p_bank_fund_t(v_bank_account_id in number, ---实体卡账户
                                             v_amount          in number, ---变动金额
                                             v_change_type     in number, ---实体卡变动类型1.加款，2.减款
                                             v_use_type        in number, ---实体卡变动类型
                                             create_user       in varchar2, ---创建人
                                             create_time       in varchar2, ---创建时间
                                             link_channel_no   in varchar2, ---可空，关联渠道
                                             link_account_id   in varchar2, ---可空，关联账户
                                             v_memo            in varchar2,
                                             v_record_no       in varchar2, ---外部记录编号
                                             v_result          out varchar2,
                                             v_msg             out varchar2) as
  ------------------导数据实体卡资金变动------------------
begin
  ---1.检查实体卡账户与金额
  v_result := fd_f_bank_check_t(v_bank_account_id,
                                v_amount,
                                v_change_type,
                                v_use_type,
                                v_record_no);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.实体卡资金变动
  v_result := fd_f_bank_fund_add_t(v_bank_account_id,
                                   v_amount,
                                   v_change_type,
                                   v_use_type,
                                   create_user,
                                   create_time,
                                   link_channel_no,
                                   link_account_id,
                                   v_memo,
                                   v_record_no);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_bank_fund_t', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_BANK_PROFIT_DRAW
prompt ========================================
prompt
create or replace procedure fd_account.fd_p_bank_profit_draw(v_cap_account_id  number, ---毛利账户
                                                  v_bank_account_id number, --实体卡账户编号
                                                  v_profit          number, ---提取的毛利润
                                                  v_service_fee     number, --提取手续费
                                                  v_draw_user       varchar2, ---提款人
                                                  v_memo            varchar2, --备注
                                                  v_result          out varchar2) as
  ---------------公司毛利润提取------------------
begin
  ---0.记录操作日志
  fd_p_write_handle_log('毛利提取',
                        v_draw_user,
                        ('v_cap_account_id=' || v_cap_account_id ||
                        ',v_bank_account_id=' || v_bank_account_id ||
                        ',v_profit=' || v_profit));

  ---1.检查利润相关信息
  v_result := fd_f_bank_profit_check(v_cap_account_id,
                                     v_bank_account_id,
                                     v_profit,
                                     v_service_fee);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.利润提取
  v_result := fd_f_bank_profit_draw(v_cap_account_id,
                                    v_bank_account_id,
                                    v_profit,
                                    v_service_fee,
                                    v_draw_user,
                                    v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_bank_profit_draw', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_BANK_SERVICE_FEE_ADD
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_bank_service_fee_add(v_bank_account_id number, ---出账实体卡账户
                                                      v_amount          number, ---出账金额
                                                      v_hander_user     varchar2, ---操作用户
                                                      v_memo            varchar2, ---可空，备注
                                                      v_remark_name     varchar2, --收付款账户名称
                                                      v_result          out varchar2) as
  --------------------------------------
  --功能;单独收取手续费
  --修改人:周荣省
  --修改时间：2019-08-27
  --修改内容：添加收付款账户名称
  --------------------------------------
  l_cap_account_id number;
  l_number         number;
begin

  ---1.检查账户及金额相关信息
  v_result := fd_f_bank_service_add_check(v_bank_account_id,
                                          v_amount,
                                          l_cap_account_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.实体卡入账(锁资产账户、实体卡账户)
  v_result := fd_f_bank_service_fee_add(v_bank_account_id,
                                        l_cap_account_id,
                                        v_amount,
                                        v_hander_user,
                                        v_remark_name,
                                        v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('单独支付手续费',
                        v_hander_user,
                        ('v_bank_account_id=' || v_bank_account_id ||
                        ',v_amount=' || v_amount));
  --4.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = l_cap_account_id
     and t.co_account_type = 5
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(l_cap_account_id,
                                         5,
                                         v_remark_name,
                                         v_hander_user);
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_bank_service_fee_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_BANK_SERVICE_FEE_MINUS
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_bank_service_fee_minus(v_bank_account_id number, ---入账实体卡账户
                                                        v_amount          number, ---入账金额
                                                        v_hander_user     varchar2, ---操作用户
                                                        v_memo            varchar2, ---可空，备注
                                                        v_remark_name     varchar2, --收付款账户名称
                                                        v_result          out varchar2) as
  --------------------------------------
  --功能;银行卡计息
  --修改人:周荣省
  --修改时间：2019-08-27
  --修改内容：添加收付款账户名称
  --------------------------------------
  l_cap_account_id number;
  l_number         number;
begin

  ---1.检查账户及金额相关信息
  v_result := fd_f_bank_service_minus_check(v_bank_account_id,
                                            v_amount,
                                            l_cap_account_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.实体卡入账
  v_result := fd_f_bank_service_fee_minus(v_bank_account_id,
                                          l_cap_account_id,
                                          v_amount,
                                          v_hander_user,
                                          v_remark_name,
                                          v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('银行卡计息',
                        v_hander_user,
                        ('v_bank_account_id=' || v_bank_account_id ||
                        ',v_amount=' || v_amount));
  --4.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = l_cap_account_id
     and t.co_account_type = 5
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(l_cap_account_id,
                                         5,
                                         v_remark_name,
                                         v_hander_user);
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_bank_service_fee_minus', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_BANK_TRANSFER_HANDER
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_bank_transfer_hander(v_out_bank_account_id number, ---出账实体卡账户
                                                      v_in_bank_account_id  number, ---入账实体卡账户
                                                      v_transfer_amount     number, ---转账金额
                                                      v_out_service_fee     number, ---转账手续费（出账实体卡支付）
                                                      v_hander_user         varchar2, ---操作用户
                                                      v_link_channel_name   varchar2, ---可空，关联渠道
                                                      v_link_account_name   varchar2, ---可空，关联账户
                                                      v_memo                varchar2, ---可空，备注
                                                      v_result              out varchar2) as
  ----------------银行卡转账---------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('银行卡转账',
                        v_hander_user,
                        ('v_out_bank_account_id=' || v_out_bank_account_id ||
                        ',v_in_bank_account_id=' || v_in_bank_account_id ||
                        ',v_transfer_amount=' || v_transfer_amount));

  ---2.检查实体卡账户及金额是否正确
  v_result := fd_f_bank_transfer_check(v_out_bank_account_id,
                                       v_in_bank_account_id,
                                       v_transfer_amount,
                                       v_out_service_fee);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.添加实体卡转账记录(锁出账实体卡、入账实体卡、手续费账户)
  v_result := fd_f_bank_transfer(v_out_bank_account_id,
                                 v_in_bank_account_id,
                                 v_transfer_amount,
                                 v_out_service_fee,
                                 v_hander_user,
                                 v_link_channel_name,
                                 v_link_account_name,
                                 v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_bank_transfer_hander', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_CAP_JFB_SETTLE
prompt ======================================
prompt
create or replace procedure fd_account.fd_p_cap_jfb_settle(v_co_cap_fund_id number, ---集分宝待结算记录变动编号
                                                v_settle_user    varchar2, ---结算人
                                                v_memo           varchar2, ---备注
                                                v_result         out varchar2) as
  --------------集分宝账户开票结算-------------
  l_down_channel_no varchar2(32);
  l_down_account_id number;
  l_change_amount   number;
  l_trade_fund_id number;
begin
  ---1.检查集分宝结算相关信息
  v_result := fd_f_cap_jfb_info_check(v_co_cap_fund_id,
                                      l_down_channel_no,
                                      l_down_account_id,
                                      l_change_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.集分宝账户减款
  v_result := fd_f_cap_jfb_minus(v_co_cap_fund_id, v_settle_user, v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.渠道余额平账减
  v_result := fd_f_manual_down_rv_channel(l_down_channel_no,
                                          l_down_account_id,
                                          pkg_sys_revise_type.balance,
                                          -1 * l_change_amount,
                                          v_settle_user,
                                          v_memo,
                                          l_trade_fund_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_cap_jfb_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_DOWN_ADD_APPLY_DEL
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_down_add_apply_del(v_apply_id in number, --申请ID
                                                    v_memo     in varchar2, --作废原因
                                                    v_user     in varchar2,--操作人
                                                    v_result   out varchar2) as
  --------------------------------------------------
  --功能：作废下游加款申请
  --创建人：周荣省
  --创建时间：2019-09-17
  --------------------------------------------------
  l_apply_id number;
begin
  --1、锁申请
  select t.apply_id
    into l_apply_id
    from fd_trade_down_add_apply t
   where t.apply_id = v_apply_id
     and t.status = pkg_b2e_add_apply_status.status_wait
     for update;
  --2、更新状态
  update fd_trade_down_add_apply t
     set t.status    = pkg_b2e_add_apply_status.status_fail,
         t.audit_user=v_user,
         t.audit_memo=v_memo
   where t.apply_id = l_apply_id;
  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_down_add_apply_del', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_DOWN_AUTO_ADD_ON
prompt ========================================
prompt
create or replace procedure fd_account.fd_p_down_auto_add_on(v_channel_no varchar2, -- 渠道编号
                                                  v_auto_add   number, --开启:0,关闭:1
                                                  v_edit_user  varchar2, --修改人
                                                  v_result     out varchar2,
                                                  v_msg        out varchar2) as

  --------------------------------------------------
  --功能：下游渠道自动加款功能开启
  --创建人：周荣省
  --创建时间：2019-09-23
  --------------------------------------------------
  l_number     number;
  l_date       date := sysdate;
  l_account_id number;
begin
  --开启
  if (v_auto_add = 0) then
    --1.判断改渠道是否添加了白名单
    select count(0)
      into l_number
      from fd_b2e_down_white_list t
     where t.down_channel_no = v_channel_no
       and t.audit_status = pkg_audit_status.Complete;
    if (l_number < 1) then
      v_result := pkg_error_code.not_exists;
      v_msg    := '白名单未添加';
      return;
    end if;
    select t.account_id
      into l_account_id
      from fd_base_down_account_map t
     where t.channel_no = v_channel_no;
    --2.处理银行流水
    for item in (select t.down_holder_card_no
                   from fd_b2e_down_white_list t
                  where t.down_channel_no = v_channel_no
                    and t.audit_status = pkg_audit_status.Complete) loop
      begin
        update fd_b2e_bank_receive_record d
           set d.deal_status = 0,
               d.deal_memo   = '开启自动加款,历史状态改为成功'
         where d.client_card_no = item.down_holder_card_no
           and d.trade_type = 2
           and d.deal_status = Pkg_b2e_deal_status.Wait
           and d.create_time < l_date;
        commit;
      end;
    end loop;
    --3.修改渠道状态
    update fd_base_down_channel t
       set t.auto_add         = 0,
           t.last_edit_user   = v_edit_user,
           t.last_edit_time   = l_date,
           t.auto_add_on_time = l_date
     where t.channel_no = v_channel_no;
    update fd_base_down_account t
       set t.is_auto_add = 0
     where t.account_id = l_account_id;
    v_result := pkg_error_code.success;
    v_msg    := '操作成功';
  elsif (v_auto_add = 1) then
    --关闭
    --4.检查是否还有未处理的申请
    select count(0)
      into l_number
      from fd_trade_down_add_apply t
     where t.channel_no = v_channel_no
       and (t.status <> 0 or t.flow_status <> 0);
    if (l_number > 0) then
      v_result := pkg_error_code.failure;
      v_msg    := '有加款申请未处理,请先处理';
    end if;
    --5.修改渠道状态
    update fd_base_down_channel t
       set t.auto_add       = 1,
           t.last_edit_user = v_edit_user,
           t.last_edit_time = l_date
     where t.channel_no = v_channel_no;
     update fd_base_down_account t
       set t.is_auto_add = 1
     where t.account_id = l_account_id;
    v_result := pkg_error_code.success;
    v_msg    := '操作成功';
  else
    v_result := pkg_error_code.failure;
    v_msg    := '数据错误';
  end if;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := '服务器异常';
    fd_p_write_log('fd_p_down_auto_add_on', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_HANDLE_CHANNEL_DELETE
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_handle_channel_delete(v_channel_no   varchar2, --渠道编号
                                                       v_channel_type number, --渠道类型（1上游2下游）
                                                       v_result       out varchar2) as
  ------------------------手工删除渠道---------------------------
begin
  --==================删除上游渠道信息======================
  if v_channel_type = pkg_channel_type.up_channel then
    --1.删除支付账户信息
    delete from fd_base_up_account t
     where t.account_id in
           (select c.account_id
              from fd_base_up_account_map c
             where c.channel_no = v_channel_no);
  
    --2.删除网银支付信息
    delete from fd_base_up_account_bank t
     where t.account_id in
           (select c.account_id
              from fd_base_up_account_map c
             where c.channel_no = v_channel_no);
  
    --3.删除关联表信息
    delete from fd_base_up_account_map t where t.channel_no = v_channel_no;
  
    --4.删除渠道信息
    delete from fd_base_up_channel t where t.channel_no = v_channel_no;
  
    --5.删除渠道系统关联信息
    delete from fd_base_up_system_map t where t.channel_no = v_channel_no;
  end if;

  --==================删除下游渠道信息======================
  if v_channel_type = pkg_channel_type.down_channel then
    --1.删除支付账户信息
    delete from fd_base_down_account t
     where t.account_id in
           (select c.account_id
              from fd_base_down_account_map c
             where c.channel_no = v_channel_no);
  
    --2.删除关联渠道
    delete from fd_base_down_account_map t
     where t.channel_no = v_channel_no;
  
    --3.删除渠道信息
    delete from fd_base_down_channel t where t.channel_no = v_channel_no;
  
    --4.删除渠道系统关联关系
    delete from fd_base_up_system_map t where t.channel_no = v_channel_no;
  
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_handle_channel_delete', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_HANDLE_CO_ACCOUNT_CREATE
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_handle_co_account_create(v_company_id  number, ---公司编号
                                                          v_create_user varchar2, ---创建人
                                                          v_result      out varchar2) as
  ---------------------创建公司及其相关的账户-------------------
begin
  v_result := fd_f_create_company_account(v_company_id, v_create_user);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_handle_co_account_create', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_HANDLE_CO_SETTLE_MANUAL
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_handle_co_settle_manual as
  ---------------------手工结算公司间结算失败的数据----------------------
  l_start_settle_time date := sysdate - 1; ---更新数据的时间范围
  l_end_settle_time   date := sysdate - 1 / 24 / 60; ---更新数据的时间范围
  l_settle_cost       number;
  l_record_id         number;
  l_settle_account_id number;
  l_result            varchar2(32);
begin
  for item in (select a.record_id,
                      a.down_company_id,
                      a.up_company_id,
                      a.change_type,
                      a.up_draw_face,
                      a.up_real_amount,
                      a.down_channel_no,
                      a.up_channel_no,
                      a.business_type,
                      a.carrier_no,
                      a.province_no
                 from fd_trade_up_fund a
                where a.settle_status = pkg_settle_status.settle_fail
                  and a.change_type in
                      (pkg_up_fund_change_type.debit_amount,
                       pkg_up_fund_change_type.refund_amount)
                  and a.change_time >= l_start_settle_time
                  and a.change_time < l_end_settle_time) loop
    begin
      ---1.锁定记录
      select t.record_id
        into l_record_id
        from fd_trade_up_fund t
       where t.record_id = item.record_id
         and t.settle_status = pkg_settle_status.settle_fail
         for update nowait;
    
      ---2.获取结算折扣
      l_result := fd_f_co_settle_cost_get(item.down_company_id,
                                          item.up_company_id,
                                          item.up_channel_no,
                                          item.down_channel_no,
                                          item.business_type,
                                          item.carrier_no,
                                          item.province_no,
                                          l_settle_cost,
                                          l_settle_account_id);
    
      if l_result = pkg_error_code.success then
        ---3. 修改上游资金变动----结算金额，结算状态，结算时间
        update fd_trade_up_fund t
           set t.settle_amount = l_settle_cost * item.up_draw_face,
               t.settle_status = pkg_settle_status.complete_settle,
               t.settle_time   = sysdate
         where t.record_id = item.record_id;
      
        ---4.修改公司结算账户----余额
        update fd_base_company_account_recv t
           set t.balance = t.balance +
                           decode(item.change_type,
                                  pkg_up_fund_change_type.debit_amount,
                                  l_settle_cost * item.up_draw_face,
                                  -1 * l_settle_cost * item.up_draw_face)
         where t.account_id = l_settle_account_id;
      
      else
        ---5.修改上游资金变动----结算失败
        update fd_trade_up_fund t
           set t.settle_status = pkg_settle_status.settle_fail
         where t.record_id = item.record_id;
      end if;
      if sql%rowcount = 0 then
        rollback;
        fd_p_write_log('fd_p_auto_co_settle_update_error' ||
                       item.record_id,
                       sqlerrm,
                       1);
      else
        commit;
      end if;
    
    exception
      when others then
        rollback;
    end;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_co_settle_update', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_HANDLE_ORDER_FACE_ADJUST
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_handle_order_face_adjust(v_order_source   number,
                                                          v_trade_order_no varchar2,
                                                          v_order_face     number,
                                                          v_order_unit     number,
                                                          v_result         out varchar2) as
  --------------------部分成功下游扣款失败，调整订单面值金额--------------------
begin

  ---1.修改订单面值、规格、金额
  update fd_trade_order_main t
     set t.total_face        = v_order_face,
         t.recharge_unit     = v_order_unit,
         t.down_order_amount = (v_order_unit / t.recharge_unit) *
                               t.down_order_amount
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source;

  if sql%rowcount > 0 then
    v_result := pkg_error_code.success;
    commit;
  end if;

  v_result := pkg_error_code.order_not_exists;
  rollback;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_handle_order_face_adjust', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_HANDLE_PROFIT_ADJUST
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_handle_profit_adjust(v_company_id number,
                                                      v_profit     number,
                                                      v_user       varchar2,
                                                      v_memo       varchar2,
                                                      v_result     out varchar2) as
  -------------手工调整毛利余额-------------
  l_cap_count      number;
  l_account_id     number;
  l_profit_balance number;
  l_profit         number;
  l_change_type    number;
begin
  ---1.检查公司毛利账户
  if v_profit = 0 then
    v_result := pkg_error_code.amount_error;
    rollback;
    return;
  end if;

  select count(1), max(t.account_id)
    into l_cap_count, l_account_id
    from fd_base_company_account_cap t
   where t.company_id = v_company_id
     and t.account_type = pkg_co_cap_account_type.profit
     and rownum <= 2;

  if l_cap_count != 1 then
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;

  ---2.锁公司毛利账户
  select t.balance
    into l_profit_balance
    from fd_base_company_account_cap t
   where t.account_id = l_account_id
     for update;

  ---3.修改账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_profit_balance + v_profit),
         t.last_edit_user = v_user,
         t.last_edit_time = sysdate
   where t.account_id = l_account_id;

  ---4.添加毛利账户变动流水
  if v_profit > 0 then
    l_profit      := v_profit;
    l_change_type := pkg_co_cap_fund_type.add_amount;
  else
    l_profit      := -1 * v_profit;
    l_change_type := pkg_co_cap_fund_type.minus_amount;
  end if;

  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     record_no,
     create_user)
  values
    (seq_trade_co_cap_fund_id.nextval,
     l_account_id,
     l_profit,
     l_change_type,
     (l_profit_balance + v_profit),
     sysdate,
     0,
     pkg_sys_boolean.istrue,
     0,
     v_memo,
     0,
     v_user);

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_handle_profit_adjust', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_IMP_DOWN_ADD
prompt ====================================
prompt
create or replace procedure fd_account.fd_p_imp_down_add(v_down_channel_no in varchar2, ---下游渠道
                                              v_down_account_id in number, ---下游支付账户            
                                              v_bank_account_id in number, ---实体卡账户号
                                              v_imp_account_id  in number, ---倒款账户编号
                                              v_amount          in number, ------渠道到账金额
                                              v_service_fee     in number, ------公司承担手续费
                                              v_create_user     in varchar2, ---加款人
                                              v_memo            in varchar2, ---备注
                                              v_result          out varchar2) as
  --------------下游手工加款---------------
  l_bank_batch_id number;
  l_account_name  varchar2(32);
  l_channel_name  varchar2(32);
begin
  ---1.记录操作日志
  fd_p_write_handle_log('倒款账户下游人工加款',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_imp_account_id=' || v_imp_account_id ||
                        ',v_amount=' || v_amount));

  ---2.检查下游渠道、账户及其关联情况--检查倒款账户
  v_result := fd_f_imp_down_add_check(v_down_channel_no,
                                      v_down_account_id,
                                      v_bank_account_id,
                                      v_imp_account_id,
                                      v_amount,
                                      v_service_fee,
                                      l_account_name,
                                      l_channel_name);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款
  v_result := fd_f_manual_down_add(v_down_channel_no,
                                   v_down_account_id,
                                   v_bank_account_id,
                                   v_amount,
                                   v_service_fee,
                                   v_create_user,
                                   v_imp_account_id,
                                   v_memo,
                                   l_account_name,
                                   l_channel_name,
                                   '',
                                   l_bank_batch_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---4.倒款账户减款
  v_result := fd_f_imp_account_minus(v_down_channel_no,
                                     v_imp_account_id,
                                     l_bank_batch_id,
                                     v_amount,
                                     v_create_user,
                                     v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_imp_down_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_IMP_DOWN_ADD_ADJUST
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_imp_down_add_adjust(v_record_id   in number, ---红冲的加款编号
                                                     v_create_user in varchar2, ---操作人                                                        
                                                     v_adjust_days in number, ---红冲天数
                                                     v_memo        in varchar2, ---备注
                                                     v_result      out varchar2) as
  --------------倒款账户下游加款红冲----------------
  l_change_id number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('到款账户下游加款红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---2. 检查加款记录、账户、余额、手续费--倒款账户信息
  v_result := fd_f_imp_down_add_adj_check(v_record_id,
                                          v_adjust_days,
                                          l_change_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3. 红冲下游手工加款记录
  v_result := fd_f_adjust_down_add_handle(v_record_id,
                                          v_create_user,
                                          v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.红冲倒款账户减款记录
  v_result := fd_f_imp_account_minus_adjust(l_change_id,
                                            v_create_user,
                                            v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_imp_down_add_adjust', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_IMP_MANUAL_ADD
prompt ======================================
prompt
create or replace procedure fd_account.fd_p_imp_manual_add(v_account_id      number, ---倒款账户编号
                                                v_amount          number, ---倒款金额
                                                v_use_type        number, ---倒款类型（2.支付宝倒款3.财富通倒款,99其他）
                                                v_user            varchar2, ---倒款人
                                                v_partner_account varchar2, ---可空，来源账号
                                                v_memo            varchar2, ---可空，备注
                                                v_result          out varchar2) as
  --------------------倒款账户手工加款--------------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('倒款账户加款',
                        v_user,
                        ('v_account_id=' || v_account_id || ',v_amount=' ||
                        v_amount));

  ---2.检查倒款信息
  v_result := fd_f_imp_manual_add_check(v_account_id, v_amount, v_use_type);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.倒款账户加款
  v_result := fd_f_imp_manual_add(v_account_id,
                                  v_amount,
                                  v_use_type,
                                  v_user,
                                  v_partner_account,
                                  v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_imp_manual_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_IMP_MANUAL_ADD_ADJUST
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_imp_manual_add_adjust(v_change_id   number, ---倒款资金变动编号，只有加款时用
                                                       v_user        varchar2, ---红冲人
                                                       v_adjust_days number, ---红冲天数
                                                       v_memo        varchar2, ---可空，备注
                                                       v_result      out varchar2) as
  ---------------------红冲手工倒款---------------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('倒款账户加款红冲',
                        v_user,
                        ('v_change_id=' || v_change_id));

  ---2.检查红冲信息
  v_result := fd_f_imp_manual_add_adj_check(v_change_id, v_adjust_days);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---3.红冲倒款记录
  v_result := fd_f_imp_manual_add_adjust(v_change_id, v_user, v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_imp_manual_add_adjust', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_BALANCE_CLEAR
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_manual_balance_clear(v_account_id    number, --账户ID
                                                      v_channel_type number, --渠道类型,1:上游,2:下游
                                                      v_channel_no    varchar2, --渠道编号
                                                      v_create_user          varchar2, --用户
                                                      v_result        out varchar2) as
  ---------------------------------------------------
  --功能：账户余额归零
  --创建人:陈劢卓
  --创建时间：2019--8-5
  ---------------------------------------------------
  l_balance number := 0;
begin
  --1.判断上游账户是否存在
  if v_channel_type = 1 then
    select t.inner_balance
      into l_balance
      from fd_base_up_account t
     where t.account_id = v_account_id;
  
  else
    select t.inner_balance
      into l_balance
      from fd_base_down_account t
     where t.account_id = v_account_id;
  end if;
  if l_balance < -0.5 or l_balance > 0.5 then
    v_result := pkg_error_code.amount_error;
    return;
  end if;
  --3.渠道余额归零
  if v_channel_type = 1 then
    update fd_base_up_account t
       set t.inner_balance = 0
     where t.account_id = v_account_id;
    --4.零点余额归零
    update fd_report_zero_balance t
       set t.balance = 0
     where t.account_id = v_account_id
       and t.channel_no = v_channel_no
       and t.record_date = trunc(sysdate - 1);
  else
    update fd_base_down_account t
       set t.inner_balance = 0
     where t.account_id = v_account_id;
    --4.零点余额归零
    update fd_report_zero_balance t
       set t.balance = 0
     where t.account_id = v_account_id
       and t.channel_no = v_channel_no
       and t.record_date = trunc(sysdate - 1);
  end if;
  fd_p_write_handle_log('账户余额归零',
                        v_create_user,
                        ('v_channel_no=' || v_channel_no ||
                        ',v_account_id=' || v_account_id));
  commit;
  v_result := pkg_error_code.success;
  return;
exception
  when others then
    rollback;
    fd_p_write_log('fd_base_up_account_balance', sqlerrm, 1);
    v_result := pkg_error_code.system_busy;
    return;
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_BUSINESS_ADD
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_manual_business_add(v_source_system_id    in number, ---系统编号
                                                     v_outer_business_type in number, ---生产系统业务类型编号
                                                     v_outer_business_name in varchar2, ---生产系统业务名称
                                                     v_statistics_type     in number, ------财务类型
                                                     v_result              out varchar2) as
  -------------------------------------
  --功能：添加业务类型
  --创建人：周荣省
  --创建时间：20190708
  -------------------------------------
  l_number         number;
  l_business_type  number;
  l_statitics_type number;
  l_map_id         number;
begin
  --0.判断系统是否存在
  select count(0)
    into l_number
    from fd_base_source_system t
   where t.source_system_id = v_source_system_id;
  if l_number <= 0 then
    v_result := pkg_error_code.data_not_exists;
    return;
  end if;
  --1.检查业务类型是否存在
  select count(0)
    into l_number
    from fd_system_business_map t
   where t.source_system_id = v_source_system_id
     and t.outer_business_type = v_outer_business_type;

  if l_number = 0 then
    --2.添加记账系统业务类型
    select seq_sys_business_info_id.nextval into l_business_type from dual;
    insert into fd_system_business_info
      (business_type, business_type_name)
    values
      (l_business_type, v_outer_business_name);
    --3.添加生产系统关联表
    select seq_sys_business_map_id.nextval into l_map_id from dual;
    insert into fd_system_business_map
      (id, source_system_id, outer_business_type, local_business_type)
    values
      (l_map_id,
       v_source_system_id,
       v_outer_business_type,
       l_business_type);
    --4.添加财务类型
    insert into fd_system_business_statis_map
      (id, local_business_type, statistics_type)
    values
      (seq_sys_business_static_map_id.nextval,
       l_business_type,
       v_statistics_type);
  else
    v_result := pkg_error_code.data_error;
    return;
  end if;
  v_result:=pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_business_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_BUSINESS_EDIT
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_manual_business_edit(v_business_map_id     in number, --生产系统关联表id
                                                      v_source_system_id    in number, ---系统编号
                                                      v_outer_business_type in number, ---生产系统业务类型编号
                                                      v_outer_business_name in varchar2, ---生产系统业务名称
                                                      v_statistics_type     in number, ------财务类型
                                                      v_result              out varchar2) as
  -------------------------------------
  --功能：添加业务类型
  --创建人：周荣省
  --创建时间：20190708
  -------------------------------------
  l_number         number;
  l_business_type  number;
  l_statitics_type number;
  l_map_id         number;
  l_system_id      number;
  l_outer_business number;
begin
  --0.判断系统是否存在
  select count(0)
    into l_number
    from fd_base_source_system t
   where t.source_system_id = v_source_system_id;
  if l_number <= 0 then
    v_result := pkg_error_code.data_not_exists;
    return;
  end if;
  --1.获取参数
  select t.source_system_id, t.outer_business_type, t.local_business_type
    into l_system_id, l_outer_business, l_business_type
    from fd_system_business_map t
   where t.id = v_business_map_id;
  --2.修改财务类型
  update fd_system_business_statis_map t
     set t.statistics_type = v_statistics_type
   where t.local_business_type = l_business_type;
  --3.修改记账系统业务类型
  update fd_system_business_info t
     set t.business_type_name = v_outer_business_name
   where t.business_type = l_business_type;
  --4.修改生产系统关联表
  update fd_system_business_map t
     set t.source_system_id    = v_source_system_id,
         t.outer_business_type = v_outer_business_type
   where t.id = v_business_map_id;
  v_result:=pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_business_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_DOWN_ADD
prompt =======================================
prompt
create or replace procedure fd_account.fd_p_manual_down_add(v_down_channel_no in varchar2, ---下游渠道
                                                 v_down_account_id in number, ---下游支付账户
                                                 v_bank_account_id in number, ---实体卡账户号
                                                 v_amount          in number, ------渠道到账金额
                                                 v_service_fee     in number, ------公司承担手续费
                                                 v_create_user     in varchar2, ---加款人
                                                 v_partner_account in varchar2, ---可空，合作方银行账户
                                                 v_memo            in varchar2, ---备注
                                                 v_v_remark_name   in varchar2, --收付款账户名称
                                                 v_result          out varchar2) as
  --------------下游手工加款---------------
  l_bank_batch_id number;
  l_account_name  varchar2(100);
  l_channel_name  varchar2(100);
  l_number       number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游人工加款',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_amount=' || v_amount));

  ---2.检查下游渠道、账户及其关联情况
  v_result := fd_f_manual_down_add_check(v_down_channel_no,
                                         v_down_account_id,
                                         v_bank_account_id,
                                         v_amount,
                                         v_service_fee,
                                         l_account_name,
                                         l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款(锁实体卡账户、渠道账户、手续费账户)
  v_result := fd_f_manual_down_add(v_down_channel_no,
                                   v_down_account_id,
                                   v_bank_account_id,
                                   v_amount,
                                   v_service_fee,
                                   v_create_user,
                                   v_partner_account,
                                   v_memo,
                                   l_account_name,
                                   l_channel_name,
                                   v_v_remark_name,
                                   l_bank_batch_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --4.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_down_account_id
     and t.co_account_type = 2
     and t.co_account_name = v_v_remark_name;
  if l_number < 1 then
    v_result := fd_f_co_account_name_add(v_down_account_id,
                                         2,
                                         v_v_remark_name,
                                         v_create_user);
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_down_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_DOWN_BORROW_ADD
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_manual_down_borrow_add(v_down_channel_no   in varchar2, ---下游渠道
                                                        v_down_account_id   in number, ---下游支付账户
                                                        v_borrow_account_id in number, ---借支账户编号
                                                        v_amount            in number, ------渠道到账金额
                                                        v_service_fee       in number, ------公司承担手续费
                                                        v_create_user       in varchar2, ---加款人
                                                        v_partner_account   in varchar2, ---可空，合作方银行账户
                                                        v_memo              in varchar2, ---备注
                                                        v_result            out varchar2) as
  --------------下游加款到借支账户---------------
  l_account_name varchar2(32);
  l_channel_name varchar2(32);
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游加款到借支账户',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_amount=' || v_amount));

  ---2.检查下游渠道、账户及其关联情况
  v_result := fd_f_manual_down_borrow_add_ck(v_down_channel_no,
                                             v_down_account_id,
                                             v_borrow_account_id,
                                             v_amount,
                                             v_service_fee,
                                             l_account_name,
                                             l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款(锁实体卡账户、渠道账户、手续费账户)
  v_result := fd_f_manual_down_borrow_add(v_down_channel_no,
                                          v_down_account_id,
                                          v_borrow_account_id,
                                          v_amount,
                                          v_service_fee,
                                          v_create_user,
                                          v_partner_account,
                                          v_memo,
                                          l_account_name,
                                          l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_down_borrow_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_DOWN_COMMI_ADD
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_manual_down_commi_add(v_down_channel_no in varchar2, ---下游渠道
                                                       v_down_account_id in number, ---下游支付账户
                                                       v_commi_month     in varchar2, ---结算月份（yyyymmddhh24miss）
                                                       v_amount          in number, ------渠道到账金额
                                                       v_create_user     in varchar2, ---加款人
                                                       v_memo            in varchar2, ---备注
                                                       v_result          out varchar2) as
  --------------下游渠道佣金转渠道余额---------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游佣金转渠道余额',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_amount=' || v_amount));

  ---2.检查下游渠道、账户及其关联情况
  v_result := fd_f_manual_down_commi_add_ck(v_down_channel_no,
                                            v_down_account_id,
                                            v_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.渠道佣金转渠道余额
  v_result := fd_f_manual_down_commi_add(v_down_channel_no,
                                         v_down_account_id,
                                         v_amount,
                                         v_commi_month,
                                         v_create_user,
                                         v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_down_commi_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_DOWN_DEPOSIT_ADD
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_manual_down_deposit_add(v_down_channel_no in varchar2, ---下游渠道
                                                         v_down_account_id in number, ---下游支付账户
                                                         v_bank_account_id in number, ---实体卡账户号
                                                         v_cap_account_id  in number, ---资产账户编号(押金、保证金)
                                                         v_amount          in number, ------渠道到账金额
                                                         v_create_user     in varchar2, ---加款人
                                                         v_memo            in varchar2, ---备注
                                                         v_result          out varchar2) as
  --------------押金类 资产账户转下游加款---------------
  l_account_name varchar2(32);
  l_channel_name varchar2(32);
begin
  ---1.记录操作日志
  fd_p_write_handle_log('资产账户转下游加款',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_amount=' || v_amount));

  ---2.检查下游渠道、账户及其关联情况
  v_result := fd_f_manual_down_dep_add_ck(v_down_channel_no,
                                          v_down_account_id,
                                          v_bank_account_id,
                                          v_cap_account_id,
                                          v_amount,
                                          l_account_name,
                                          l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款(锁实体卡账户、渠道账户、手续费账户)
  v_result := fd_f_manual_down_dep_add(v_down_channel_no,
                                       v_down_account_id,
                                       v_bank_account_id,
                                       v_cap_account_id,
                                       v_amount,
                                       v_create_user,
                                       v_memo,
                                       l_account_name,
                                       l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_down_deposit_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_DOWN_DRAW
prompt ========================================
prompt
create or replace procedure fd_account.fd_p_manual_down_draw(v_down_channel_no in varchar2, ---下游渠道
                                                  v_down_account_id in number, ---下游支付账户
                                                  v_bank_account_id in number, ---实体卡账户号
                                                  v_amount          in number, ------退款金额
                                                  v_service_fee     in number, ------公司承担手续费
                                                  v_create_user     in varchar2, ---退款人
                                                  v_partner_account in varchar2, ---可空，合作方银行账户
                                                  v_memo            in varchar2, ---备注
                                                  v_remark_name     in varchar2,--收付款账户名称
                                                  v_result          out varchar2) as
  --------------下游渠道提款---------------
  l_account_name  varchar2(100);
  l_channel_name  varchar2(100);
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游渠道提款',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_amount=' || v_amount));

  ---2.检查下游渠道、账户及其关联情况
  v_result := fd_f_manual_down_draw_check(v_down_channel_no,
                                          v_down_account_id,
                                          v_bank_account_id,
                                          v_amount,
                                          v_service_fee,
                                          l_account_name,
                                          l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款(锁实体卡账户、渠道账户、手续费账户)
  v_result := fd_f_manual_down_draw(v_down_channel_no,
                                    v_down_account_id,
                                    v_bank_account_id,
                                    v_amount,
                                    v_service_fee,
                                    v_create_user,
                                    v_partner_account,
                                    v_memo,
                                    l_account_name,
                                    v_remark_name,
                                    l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_down_draw', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_DOWN_FEE_ADD
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_manual_down_fee_add(v_down_channel_no in varchar2, --下游渠道编号
                                                     v_fee_month       in varchar2, --手续费收取时间(yyyymmddhh24miss)
                                                     v_service_fee     in number, --手续费
                                                     v_result          out varchar2) as
  -------------------下游交易手续费手工添加------------------
  l_company_id   number;
  l_record_count number;
  l_record_month date := trunc(to_date(v_fee_month, 'yyyymmddhh24miss'),
                               'mm');
begin
  --1.检查渠道是否存在
  select t.company_id
    into l_company_id
    from fd_base_down_channel t
   where t.channel_no = v_down_channel_no;

  --2.检查月份数据是否存在
  select count(1)
    into l_record_count
    from fd_report_service_fee t
   where t.report_month = l_record_month
     and t.channel_no = v_down_channel_no;

  --3.记录下游渠道手续费
  if l_record_count > 0 then
    update fd_report_service_fee t
       set t.service_fee = v_service_fee
     where t.report_month = l_record_month
       and t.channel_no = v_down_channel_no;
  
  else
    insert into fd_report_service_fee
      (record_id, report_month, company_id, channel_no, service_fee)
    values
      (seq_report_service_fee_id.nextval,
       l_record_month,
       l_company_id,
       v_down_channel_no,
       v_service_fee);
  end if;
  
  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_down_fee_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_DOWN_INNER_TSFER
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_manual_down_inner_tsfer(v_out_channel_no varchar2, ---出账渠道编号
                                                         v_out_account_id number, ---出账账户编号
                                                         v_in_channel_no  varchar2, ---入账渠道编号
                                                         v_in_account_id  number, ---入账账户编号
                                                         v_amount         number, ---内转金额
                                                         v_hander_user    varchar2, ---操作人
                                                         v_memo           varchar2, ---备注
                                                         v_result         out varchar2) as
  ---------------------下游渠道余额内部转移---------------------
begin
  ---1.检查渠道账户相关信息
  v_result := fd_f_manual_down_inner_check(v_out_channel_no,
                                           v_out_account_id,
                                           v_in_channel_no,
                                           v_in_account_id,
                                           v_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.渠道内部转账
  v_result := fd_f_manual_down_inner_tsfer(v_out_channel_no,
                                           v_out_account_id,
                                           v_in_channel_no,
                                           v_in_account_id,
                                           v_amount,
                                           v_hander_user,
                                           v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('下游渠道余额内部转账',
                        v_hander_user,
                        ('v_out_channel_no=' || v_out_channel_no ||
                        ',v_in_channel_no=' || v_in_channel_no ||
                        ',v_amount=' || v_amount));

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_down_inner_tsfer', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_DOWN_RV_CHANNEL
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_manual_down_rv_channel(v_down_channel_no in varchar2, ---下游渠道编号
                                                        v_down_account_id in number, ---下游支付账户             
                                                        v_revise_type     in number, ---平账类型（1.余额平账 2.扣款平账 3.退款平账）
                                                        v_revise_amount   in number, ---账户调整金额（可正、可负）
                                                        v_create_user     in varchar2, ---操作人
                                                        v_memo            in varchar2, ---备注
                                                        v_result          out varchar2) as
  --------------平账、下游手工渠道账户平账---------------
  l_fund_id number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游渠道平账',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_revise_amount=' || v_revise_amount));

  ---2.检查渠道与金额是否正确
  v_result := fd_f_manual_down_rv_channel_ck(v_down_channel_no,
                                             v_down_account_id,
                                             v_revise_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.渠道账户平账
  v_result := fd_f_manual_down_rv_channel(v_down_channel_no,
                                          v_down_account_id,
                                          v_revise_type,
                                          v_revise_amount,
                                          v_create_user,
                                          v_memo,
                                          l_fund_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_down_rv_channel', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_DOWN_RV_TRADE
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_manual_down_rv_trade(v_down_channel_no  in varchar2, ---下游渠道编号
                                                      v_down_account_id  in number, ---下游支付账户
                                                      v_down_draw_amount in number, ---下游扣款金额
                                                      v_down_real_amount in number, ---下游真实金额
                                                      v_business_type    in number, ---业务类型
                                                      v_bill_type        in number, ---交易类型，1前向，2后向
                                                      v_create_user      in varchar2, ---操作人
                                                      v_memo             in varchar2, ---备注
                                                      v_result           out varchar2) as
  --------------------下游渠道交易平账-----------------------
  l_fund_id number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游渠道交易平账',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id));

  ---2.检查下游渠道及账户
  v_result := fd_f_manual_down_rv_trade_ck(v_down_channel_no,
                                           v_down_account_id,
                                           v_down_draw_amount,
                                           v_down_real_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.下游渠道交易平账
  v_result := fd_f_manual_down_rv_trade(v_down_channel_no,
                                        v_down_account_id,
                                        v_down_draw_amount,
                                        v_down_real_amount,
                                        v_business_type,
                                        v_bill_type,
                                        v_create_user,
                                        v_memo,
                                        null,
                                        l_fund_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_down_rv_trade', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_RECV_RV_BALANCE
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_manual_recv_rv_balance(v_account_id_1 number,
                                                        v_account_id_2 number,
                                                        v_amount       number,
                                                        v_user         varchar2,
                                                        v_memo         varchar2,
                                                        v_result       out varchar2) as
  --------------收款账户对冲平账-------------
  l_balance_1      number;
  l_owe_company_1  number;
  l_recv_company_1 number;
  l_balance_2      number;
  l_owe_company_2  number;
  l_recv_company_2 number;
begin
  ---1.锁对冲的账户
  select t.balance, t.owe_company, t.recv_company
    into l_balance_1, l_owe_company_1, l_recv_company_1
    from fd_base_company_account_recv t
   where t.account_id = v_account_id_1
     for update;

  select t.balance, t.owe_company, t.recv_company
    into l_balance_2, l_owe_company_2, l_recv_company_2
    from fd_base_company_account_recv t
   where t.account_id = v_account_id_2
     for update;

  ---2.检查对冲账户
  if l_owe_company_1 != l_recv_company_2 or
     l_recv_company_1 != l_owe_company_2 then
    v_result := pkg_error_code.data_error;
    return;
  end if;

  ---3.修改账户余额
  update fd_base_company_account_recv t
     set t.balance = (l_balance_1 + v_amount)
   where t.account_id = v_account_id_1;

  update fd_base_company_account_recv t
     set t.balance = (l_balance_2 + v_amount)
   where t.account_id = v_account_id_2;

  ---4.添加平账记录
  insert into fd_trade_co_recv_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     handle_user,
     remark)
  values
    (seq_trade_co_recv_fund_id.nextval,
     v_account_id_1,
     v_amount,
     pkg_co_fund_recv_type.add_amount,
     (l_balance_1 + v_amount),
     sysdate,
     pkg_sys_boolean.istrue,
     0,
     0,
     v_user,
     v_memo);

  insert into fd_trade_co_recv_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     handle_user,
     remark)
  values
    (seq_trade_co_recv_fund_id.nextval,
     v_account_id_2,
     v_amount,
     pkg_co_fund_recv_type.add_amount,
     (l_balance_2 + v_amount),
     sysdate,
     pkg_sys_boolean.istrue,
     0,
     0,
     v_user,
     v_memo);

  v_result := pkg_error_code.success;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_recv_rv_balance', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_RELATE_ADD
prompt =========================================
prompt
create or replace procedure fd_account.fd_p_manual_relate_add(v_down_channel_no in varchar2, --下游渠道
                                                   v_down_account_id in number, --下游支付账户
                                                   v_up_channel_no   in varchar2, --上游渠道
                                                   v_up_account_id   in number, --上游支付账户
                                                   v_amount          in number, --加款金额
                                                   v_create_user     in varchar2, --加款人
                                                   v_memo            in varchar2, --备注
                                                   v_result          out varchar2) as
  ---------------------------上下游绑定渠道关联加款------------------------
begin
  ---0.检查加款金额
  v_result := fd_f_manual_relate_amount_ck(v_amount,
                                           pkg_down_manual_change_type.add_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.检查上下游渠道及账户
  v_result := fd_f_manual_relate_check(v_down_channel_no,
                                       v_down_account_id,
                                       v_up_channel_no,
                                       v_up_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.上下游渠道关联加款
  v_result := fd_f_manual_relate_add(v_down_channel_no,
                                     v_down_account_id,
                                     v_up_channel_no,
                                     v_up_account_id,
                                     v_amount,
                                     v_create_user,
                                     v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('上下游关联加款',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_up_channel_no=' || v_up_channel_no ||
                        ',v_amount=' || v_amount));

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_relate_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_RELATE_DRAW
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_manual_relate_draw(v_down_channel_no in varchar2, --下游渠道
                                                    v_down_account_id in number, --下游支付账户
                                                    v_up_channel_no   in varchar2, --上游渠道
                                                    v_up_account_id   in number, --上游支付账户
                                                    v_amount          in number, --提款金额
                                                    v_create_user     in varchar2, --加款人
                                                    v_memo            in varchar2, --备注
                                                    v_result          out varchar2) as
  ---------------------------上下游绑定渠道关联提款------------------------
begin
  ---0.检查加款金额
  v_result := fd_f_manual_relate_amount_ck(v_amount,
                                           pkg_down_manual_change_type.draw_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.检查上下游渠道及账户
  v_result := fd_f_manual_relate_check(v_down_channel_no,
                                       v_down_account_id,
                                       v_up_channel_no,
                                       v_up_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.上下游渠道关联提款
  v_result := fd_f_manual_relate_draw(v_down_channel_no,
                                      v_down_account_id,
                                      v_up_channel_no,
                                      v_up_account_id,
                                      v_amount,
                                      v_create_user,
                                      v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('上下游关联提款',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_up_channel_no=' || v_up_channel_no ||
                        ',v_amount=' || v_amount));
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_relate_draw', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_RV_APPLY_ADD
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_manual_rv_apply_add(v_channel_no    in varchar2, ---渠道编号
                                                     v_channel_type  in number, --渠道类型 1：上游 2：下游
                                                     v_business_type in number, --业务类型
                                                     v_bill_type     in number, --财务类型
                                                     v_differ_amount in number, --差异金额
                                                     v_differ_reason in varchar2, --差异原因
                                                     v_differ_detail in varchar2, --差异详情
                                                     v_apply_user    in varchar2, --申请人
                                                     v_result        out varchar2) as
  -------------------------------------
  --功能：添加平账申请
  --创建人：周荣省
  --创建时间：2019-07-09
  -------------------------------------
  l_account_id number;
  l_apply_id   number;
begin
  --1.判断渠道
  if v_channel_type = 1 then
    --上游
    select c.account_id
      into l_account_id
      from fd_base_up_channel t
      left join fd_base_up_account_map d on d.channel_no = t.channel_no
      left join fd_base_up_account c on c.account_id = d.account_id
     where t.channel_no = v_channel_no;
  elsif v_channel_type = 2 then
    --下游
    select c.account_id
      into l_account_id
      from fd_base_down_channel t
      left join fd_base_down_account_map d on d.channel_no = t.channel_no
      left join fd_base_down_account c on c.account_id = d.account_id
     where t.channel_no = v_channel_no;
  else
    v_result := pkg_error_code.data_error;
    return;
  end if;
  --2.插入申请
  select seq_trade_rv_apply_id.nextval into l_apply_id from dual;
  insert into fd_trade_rv_apply
    (apply_id,
     channel_no,
     account_id,
     channel_type,
     business_type,
     bill_type,
     differ_amount,
     differ_reason,
     differ_detail,
     apply_time,
     apply_user,
     apply_status)
  values
    (l_apply_id,
     v_channel_no,
     l_account_id,
     v_channel_type,
     v_business_type,
     v_bill_type,
     v_differ_amount,
     v_differ_reason,
     v_differ_detail,
     sysdate,
     v_apply_user,
     1);
  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_rv_apply_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_RV_APPLY_EDIT
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_manual_rv_apply_edit(v_apply_id      in number, --编辑
                                                      v_channel_no    in varchar2, ---渠道编号
                                                      v_channel_type  in number, --渠道类型 1：上游 2：下游
                                                      v_business_type in number, --业务类型
                                                      v_bill_type     in number, --财务类型
                                                      v_differ_amount in number, --差异金额
                                                      v_differ_reason in varchar2, --差异原因
                                                      v_differ_detail in varchar2, --差异详情
                                                      v_result        out varchar2) as
  -------------------------------------
  --功能：编辑平账申请
  --创建人：周荣省
  --创建时间：2019-07-09
  -------------------------------------
  l_account_id number;
  l_status     number;
begin
  --1.判断申请状态
  select t.apply_status
    into l_status
    from fd_trade_rv_apply t
   where t.apply_id = v_apply_id;
  if l_status != 1 then
    v_result := pkg_error_code.data_error;
    return;
  end if;
  --2.判断渠道
  if v_channel_type = 1 then
    --上游
    select c.account_id
      into l_account_id
      from fd_base_up_channel t
      left join fd_base_up_account_map d on d.channel_no = t.channel_no
      left join fd_base_up_account c on c.account_id = d.account_id
     where t.channel_no = v_channel_no;
  elsif v_channel_type = 2 then
    --下游
    select c.account_id
      into l_account_id
      from fd_base_down_channel t
      left join fd_base_down_account_map d on d.channel_no = t.channel_no
      left join fd_base_down_account c on c.account_id = d.account_id
     where t.channel_no = v_channel_no;
  else
    v_result := pkg_error_code.data_error;
    return;
  end if;
  --3.编辑申请
  update fd_trade_rv_apply t
     set t.channel_no    = v_channel_no,
         t.account_id    = l_account_id,
         t.channel_type  = v_channel_type,
         t.business_type = v_business_type,
         t.bill_type     = v_bill_type,
         t.differ_amount = v_differ_amount,
         t.differ_reason = v_differ_reason,
         t.differ_detail = v_differ_detail
   where t.apply_id = v_apply_id;
  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_rv_apply_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_SHORT_MSG_ADD
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_manual_short_msg_add(v_down_channel_no in varchar2, ---短信平台下游渠道
                                                      v_self_account_id in number, ---短信平台手续费账户
                                                      v_amount          in number, ---加款金额
                                                      v_create_user     in varchar2, ---操作员
                                                      v_memo            in varchar2, ---备注
                                                      v_result          out varchar2) as
  ------------------短信平台公司费用转手续费账户-----------------
  l_short_msg_sysid number := 71; ---短信平台系统编号
  l_down_account_id number;
begin
  ---1.检查渠道和手续费账户是否为短信平台
  v_result := fd_f_manual_short_msg_check(v_down_channel_no,
                                          v_self_account_id,
                                          l_short_msg_sysid,
                                          v_amount,
                                          l_down_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.渠道和手续费账户同时加款
  v_result := fd_f_manual_short_msg_add(v_down_channel_no,
                                        l_down_account_id,
                                        v_self_account_id,
                                        v_amount,
                                        v_create_user,
                                        v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.记录加款日志
  fd_p_write_handle_log('短信平台费用记录',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_self_account_id=' || v_self_account_id ||
                        ',v_amount=' || v_amount));
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_short_msg_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_TRANS_SERVICE_FEE
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_manual_trans_service_fee(v_trans_account_id  number,
                                                          v_trans_service_fee number,
                                                          v_add_user          varchar2,
                                                          v_memo              varchar2,
                                                          v_result            out varchar2) as
  --------------转账退款手续费统一添加-----------
begin
  ---1.检查账户及余额
  v_result := fd_f_manual_trans_check(v_trans_account_id,
                                      v_trans_service_fee);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.添加转账退款账户手续费(晚上统一加到手续费账户中去)
  v_result := fd_f_manual_trans_service_fee(v_trans_account_id,
                                            v_trans_service_fee,
                                            v_add_user,
                                            v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_trans_service_fee', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_UP_ADD
prompt =====================================
prompt
create or replace procedure fd_account.fd_p_manual_up_add(v_up_channel_no   in varchar2, ---上游渠道编号
                                               v_up_account_id   in number, ---上游账户号
                                               v_bank_account_id in number, ---实体卡账户号
                                               v_amount          in number, ---渠道到账金额
                                               v_service_fee     in number, ---公司承担的手续费
                                               v_create_user     in varchar2, ---操作员
                                               v_partner_account in varchar2, ---可空，上游商户银行账户
                                               v_memo            in varchar2, ---备注
                                               v_remark_name     in varchar2, ---收付款账户名称
                                               v_result          out varchar2) as
  --------------上游手工加款---------------
  l_company_id   number;
  l_account_name varchar2(100);
  l_channel_name varchar2(100);
  l_number       number;
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

begin

  ---1.记录操作日志
  fd_p_write_handle_log('上游人工加款',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_amount=' || v_amount));

  ---2.上游加款检查
  v_result := fd_f_manual_up_add_check(v_up_channel_no,
                                       v_up_account_id,
                                       v_bank_account_id,
                                       v_amount,
                                       v_service_fee,
                                       l_company_id,
                                       l_account_name,
                                       l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款
  v_result := fd_f_manual_up_add(v_up_channel_no,
                                 l_company_id,
                                 v_up_account_id,
                                 v_bank_account_id,
                                 v_amount,
                                 v_service_fee,
                                 v_create_user,
                                 v_partner_account,
                                 v_memo,
                                 l_account_name,
                                 v_remark_name,
                                 l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---4.空充系统对应下游和关联的18上游关联加款
  v_result := fd_f_manual_up_bind_add(v_up_channel_no,
                                      l_company_id,
                                      v_amount,
                                      v_create_user,
                                      v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --5.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = v_up_account_id
     and t.co_account_type = 1
     and t.co_account_name = v_remark_name;
  if l_number < 1 then
    v_result:=fd_f_co_account_name_add(v_up_account_id,
                             1,
                             v_remark_name,
                             v_create_user);
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_up_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_UP_ADD_AMOUNT_CALC
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_manual_up_add_amount_calc(v_up_channel_no varchar2,
                                                           v_up_account_id number,
                                                           v_result        out varchar2,
                                                           v_calc_amount   out number) as
  ----------------计算上游加款的建议加款金额---------------
  l_up_max_add number;
  l_up_min_add number;
begin
  ---1.检查渠道账户信息
  v_result := fd_f_manual_up_channel_check(v_up_channel_no,
                                           v_up_account_id,
                                           l_up_max_add,
                                           l_up_min_add);
  if v_result != pkg_error_code.success then
    v_calc_amount := 0;
    rollback;
    return;
  end if;

  ---2.计算渠道建议加款金额
  v_calc_amount := fd_f_manual_up_add_calc(v_up_channel_no,
                                           l_up_max_add,
                                           l_up_min_add);

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_up_add_amount_calc', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_UP_ADD_SYNC
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_manual_up_add_sync(v_up_channel_no   in varchar2, ---上游渠道编号
                                                    v_bank_card_no    in varchar2, ---实体卡账卡号
                                                    v_sync_add_no     in number, ---同步外部加款记录的编号
                                                    v_amount          in number, ---渠道到账金额
                                                    v_service_fee     in number, ---公司承担的手续费
                                                    v_create_user     in varchar2, ---操作员
                                                    v_partner_account in varchar2, ---可空，上游商户银行账户
                                                    v_memo            in varchar2, ---备注
                                                    v_result          out varchar2) as
  --------------上游手工加款---------------
  l_company_id      number;
  l_up_account_id   number;
  l_bank_account_id number;
  l_account_name    varchar2(32);
  l_channel_name    varchar2(32);
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

begin

  ---1.上游加款检查
  v_result := fd_f_manual_up_add_sync_check(v_up_channel_no,
                                            v_bank_card_no,
                                            v_amount,
                                            v_service_fee,
                                            l_company_id,
                                            l_up_account_id,
                                            l_bank_account_id,
                                            l_account_name,
                                            l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.账户手工加款
  v_result := fd_f_manual_up_add_sync(v_up_channel_no,
                                      l_company_id,
                                      l_up_account_id,
                                      l_bank_account_id,
                                      v_sync_add_no,
                                      v_amount,
                                      v_service_fee,
                                      v_create_user,
                                      v_partner_account,
                                      v_memo,
                                      l_account_name,
                                      l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_up_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_UP_BORROW_ADD
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_manual_up_borrow_add(v_up_channel_no  in varchar2, ---上游渠道编号
                                                      v_up_account_id  in number, ---上游账户号
                                                      v_cap_account_id in number, ---资产账户号
                                                      v_amount         in number, ---渠道到账金额
                                                      v_create_user    in varchar2, ---操作员
                                                      v_memo           in varchar2, ---备注
                                                      v_result         out varchar2) as
  --------------借支类 资产账户给上游手工加款---------------
  l_company_id number;
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

begin
  ---1.记录操作日志
  fd_p_write_handle_log('资产账户转上游加款',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_amount=' || v_amount));

  ---2.上游加款检查
  v_result := fd_f_manual_up_borrow_add_ck(v_up_channel_no,
                                           v_up_account_id,
                                           v_cap_account_id,
                                           v_amount,
                                           l_company_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款
  v_result := fd_f_manual_up_borrow_add(v_up_channel_no,
                                        l_company_id,
                                        v_up_account_id,
                                        v_cap_account_id,
                                        v_amount,
                                        v_create_user,
                                        v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_up_borrow_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_UP_COMMI_ADD
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_manual_up_commi_add(v_up_channel_no in varchar2, ---上游渠道
                                                     v_up_account_id in number, ---上游支付账户
                                                     v_commi_month   in varchar2, ---结算月份（yyyymmddhh24miss）
                                                     v_amount        in number, ------渠道到账金额
                                                     v_create_user   in varchar2, ---加款人
                                                     v_memo          in varchar2, ---备注
                                                     v_result        out varchar2) as
  --------------上游渠道佣金转渠道余额---------------
begin
  ---1.记录操作日志
  fd_p_write_handle_log('上游佣金转渠道余额',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_amount=' || v_amount));

  ---2.检查下游渠道、账户及其关联情况
  v_result := fd_f_manual_up_commi_add_ck(v_up_channel_no,
                                          v_up_account_id,
                                          v_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.渠道佣金转渠道余额
  v_result := fd_f_manual_up_commi_add(v_up_channel_no,
                                       v_up_account_id,
                                       v_amount,
                                       v_commi_month,
                                       v_create_user,
                                       v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_up_commi_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_UP_DEPOSIT_ADD
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_manual_up_deposit_add(v_up_channel_no  in varchar2, ---上游渠道编号
                                                       v_up_account_id  in number, ---上游账户号
                                                       v_cap_account_id in number, ---实体卡账户号
                                                       v_amount         in number, ---渠道到账金额
                                                       v_create_user    in varchar2, ---操作员
                                                       v_memo           in varchar2, ---备注
                                                       v_result         out varchar2) as
  --------------押金类 资产账户给上游手工加款---------------
  l_company_id number;
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

begin
  ---1.记录操作日志
  fd_p_write_handle_log('资产账户转上游加款',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_amount=' || v_amount));

  ---2.上游加款检查
  v_result := fd_f_manual_up_dep_add_ck(v_up_channel_no,
                                        v_up_account_id,
                                        v_cap_account_id,
                                        v_amount,
                                        l_company_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款
  v_result := fd_f_manual_up_dep_add(v_up_channel_no,
                                     l_company_id,
                                     v_up_account_id,
                                     v_cap_account_id,
                                     v_amount,
                                     v_create_user,
                                     v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_up_capital_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_UP_DRAW
prompt ======================================
prompt
create or replace procedure fd_account.fd_p_manual_up_draw(v_up_channel_no   in varchar2, ---上游渠道编号
                                                v_up_account_id   in number, ---上游账户号
                                                v_bank_account_id in number, ---实体卡账户号
                                                v_amount          in number, ---渠道提款金额
                                                v_service_fee     in number, ---公司承担的手续费
                                                v_create_user     in varchar2, ---提款人
                                                v_partner_account in varchar2, ---可空，上游商户银行账户
                                                v_memo            in varchar2, ---备注
                                                v_remark_name     in varchar2,--收付款账户名称
                                                v_result          out varchar2) as
  --------------上游渠道提款---------------
  l_company_id   number;
  l_account_name varchar2(100);
  l_channel_name varchar2(100);
  ----手续费，是指由公司承担的银行卡转款手续费（不由公司承担的手续费，不记入系统，值传0）

begin
  ---1.记录操作日志
  fd_p_write_handle_log('上游渠道提款',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_amount=' || v_amount));

  ---2.上游提款检查
  v_result := fd_f_manual_up_draw_check(v_up_channel_no,
                                        v_up_account_id,
                                        v_bank_account_id,
                                        v_amount,
                                        v_service_fee,
                                        l_company_id,
                                        l_account_name,
                                        l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款
  v_result := fd_f_manual_up_draw(v_up_channel_no,
                                  l_company_id,
                                  v_up_account_id,
                                  v_bank_account_id,
                                  v_amount,
                                  v_service_fee,
                                  v_create_user,
                                  v_partner_account,
                                  v_memo,
                                  l_account_name,
                                  v_remark_name,
                                  l_channel_name);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---4.空充系统对应下游和关联的18上游关联提款
  v_result := fd_f_manual_up_bind_draw(v_up_channel_no,
                                       l_company_id,
                                       v_amount,
                                       v_create_user,
                                       v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_up_draw', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_UP_INNER_TRANSFER
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_manual_up_inner_transfer(v_out_channel_no varchar2, ---出账渠道编号
                                                          v_out_account_id number, ---出账账户编号
                                                          v_in_channel_no  varchar2, ---入账渠道编号
                                                          v_in_account_id  number, ---入账账户编号
                                                          v_amount         number, ---内转金额
                                                          v_hander_user    varchar2, ---操作人
                                                          v_memo           varchar2, ---备注
                                                          v_result         out varchar2) as
  ---------------------上游渠道余额内部转移---------------------
begin
  ---1.检查渠道账户相关信息
  v_result := fd_f_manual_up_inner_check(v_out_channel_no,
                                         v_out_account_id,
                                         v_in_channel_no,
                                         v_in_account_id,
                                         v_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.渠道内部转账
  v_result := fd_f_manual_up_inner_transfer(v_out_channel_no,
                                            v_out_account_id,
                                            v_in_channel_no,
                                            v_in_account_id,
                                            v_amount,
                                            v_hander_user,
                                            v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  
    ---3.记录操作日志
  fd_p_write_handle_log('上游渠道余额内部转账',
                        v_hander_user,
                        ('v_out_channel_no=' || v_out_channel_no ||
                        ',v_in_channel_no=' || v_in_channel_no ||
                        ',v_amount=' || v_amount));

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_up_inter_transfer', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_UP_RV_CHANNEL
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_manual_up_rv_channel(v_up_channel_no in varchar2, ---上游游渠道编号
                                                      v_up_account_id in number, ---上游支付账户编号
                                                      v_revise_type   in number, ---平账类型（1.余额平账 2.扣款平账 3.退款平账）
                                                      v_revise_amount in number, ---账户调整金额（可正、可负）
                                                      v_create_user   in varchar2, ---操作人
                                                      v_memo          in varchar2, ---备注
                                                      v_result        out varchar2) as
  --------------平账、上游手工渠道账户平账---------------
  l_fund_id number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('上游渠道平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_revise_amount=' || v_revise_amount));

  ---2.检查渠道与金额是否正确
  v_result := fd_f_manual_up_rv_channel_ck(v_up_channel_no,
                                           v_up_account_id,
                                           v_revise_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.渠道账户平账
  v_result := fd_f_manual_up_rv_channel(v_up_channel_no,
                                        v_up_account_id,
                                        v_revise_type,
                                        v_revise_amount,
                                        v_create_user,
                                        v_memo,
                                        l_fund_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_up_rv_channel', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_MANUAL_UP_RV_TRADE
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_manual_up_rv_trade(v_up_channel_no  in varchar2, ---上游渠道编号
                                                    v_up_account_id  in number, ---上游支付账户
                                                    v_up_draw_amount in number, ---上游扣款金额
                                                    v_up_real_amount in number, ---上游真实金额
                                                    v_business_type  in number, ---业务类型
                                                    v_bill_type      in number, ---交易类型，1前向，2后向
                                                    v_create_user    in varchar2, ---操作人
                                                    v_memo           in varchar2, ---备注
                                                    v_result         out varchar2) as
  --------------------上游渠道交易平账-----------------------
  l_fund_id number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('上游渠道交易平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id));

  ---2.检查下游渠道及账户
  v_result := fd_f_manual_up_rv_trade_ck(v_up_channel_no,
                                         v_up_account_id,
                                         v_up_draw_amount,
                                         v_up_real_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.下游渠道交易平账
  v_result := fd_f_manual_up_rv_trade(v_up_channel_no,
                                      v_up_account_id,
                                      v_up_draw_amount,
                                      v_up_real_amount,
                                      v_business_type,
                                      v_bill_type,
                                      v_create_user,
                                      v_memo,
                                      l_fund_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_manual_up_rv_trade', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_OPERATE_DAILY_FACE_ADJUST
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_operate_daily_face_adjust(v_start_time varchar2,
                                                           v_end_time   varchar2,
                                                           v_result     out varchar2) as
  ---------------调整每日生成基础报表面值不相等---------------------
begin

  insert into fd_report_commi_profit_daily
    (record_id,
     company_id,
     channel_no,
     account_id,
     channel_type,
     business_type,
     bill_type,
     total_unit,
     total_face,
     draw_amount,
     real_amount,
     commission,
     profits,
     service_fee,
     refund_total_unit,
     refund_total_face,
     refund_draw_amount,
     refund_real_amount,
     refund_commission,
     refund_profits,
     refund_service_fee,
     up_many_face,
     up_many_amount,
     snap_time,
     add_status,
     statistics_type)
    select seq_report_commi_profit_id.nextval,
           tb.company_id,
           tb.channel_no,
           tb.account_id,
           tb.channel_type,
           tb.business_type,
           tb.bill_type,
           0,
           decode(sign(tb.ad_face),
                  -1,
                  trunc(tb.ad_face, 0),
                  round(tb.ad_face, 0)),
           0,
           0,
           0,
           0,
           0,
           0,
           0,
           0,
           0,
           0,
           0,
           0,
           0,
           0,
           tb.snap_time,
           0,
           tb.statistics_type
      from (select m.company_id,
                   p.channel_no,
                   p.account_id,
                   p.channel_type,
                   m.business_type,
                   m.bill_type,
                   decode(p.channel_type, 1, -1, 2, 1, 3, -1, 4, 1, 0) *
                   (m.c / 2) ad_face,
                   cd.snap_time,
                   m.statistics_type
              from (select t.snap_time,
                           t.company_id,
                           t.business_type,
                           t.bill_type,
                           t.statistics_type,
                           (sum(decode(t.channel_type, 1, 1, 3, 1, 0) *
                                (t.total_face - t.refund_total_face)) -
                           sum(decode(t.channel_type, 2, 1, 4, 1, 0) *
                                (t.total_face - t.refund_total_face +
                                 t.up_many_face))) c
                      from fd_report_commi_profit_daily t
                     where t.snap_time >=
                           to_date(v_start_time, 'yyyymmddhh24miss')
                       and t.snap_time <=
                           to_date(v_end_time, 'yyyymmddhh24miss')
                     group by t.snap_time,
                              t.company_id,
                              t.business_type,
                              t.bill_type,
                              t.statistics_type) m
              left join (select d.snap_time,
                               d.company_id,
                               d.business_type,
                               d.bill_type,
                               d.statistics_type,
                               min(d.record_id) record_id
                          from fd_report_commi_profit_daily d
                         where d.snap_time >=
                               to_date(v_start_time, 'yyyymmddhh24miss')
                           and d.snap_time <=
                               to_date(v_end_time, 'yyyymmddhh24miss')
                         group by d.snap_time,
                                  d.company_id,
                                  d.business_type,
                                  d.bill_type,
                                  d.statistics_type,
                                  decode(d.channel_type,
                                         1,
                                         1,
                                         2,
                                         2,
                                         3,
                                         1,
                                         4,
                                         2)) cd on m.snap_time =
                                                   cd.snap_time
                                               and m.company_id =
                                                   cd.company_id
                                               and m.business_type =
                                                   cd.business_type
                                               and m.bill_type =
                                                   cd.bill_type
                                               and m.statistics_type =
                                                   cd.statistics_type
             inner join fd_report_commi_profit_daily p on cd.record_id =
                                                          p.record_id
             where m.c != 0) tb;

  if sql%rowcount = 0 then
    v_result := pkg_error_code.no_need_adjust;
    rollback;
    return;
  end if;

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_operate_daily_face_adjust', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_OPERATE_DAILY_PROF_ADJUST
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_operate_daily_prof_adjust(v_start_time varchar2,
                                                           v_end_time   varchar2,
                                                           v_result     out varchar2) as
  ---------------------------调整每日生成基础报表数据毛利不等--------------------------
begin
  insert into fd_report_commi_profit_daily
    (record_id,
     company_id,
     channel_no,
     account_id,
     channel_type,
     business_type,
     bill_type,
     total_unit,
     total_face,
     draw_amount,
     real_amount,
     commission,
     profits,
     service_fee,
     refund_total_unit,
     refund_total_face,
     refund_draw_amount,
     refund_real_amount,
     refund_commission,
     refund_profits,
     refund_service_fee,
     up_many_face,
     up_many_amount,
     snap_time,
     add_status,
     statistics_type)
    select seq_report_commi_profit_id.nextval,
           x.company_id,
           x.channel_no,
           x.account_id,
           x.channel_type,
           x.business_type,
           x.bill_type,
           0,
           0,
           0,
           0,
           0,
           x.prof_differ,
           0,
           0,
           0,
           0,
           0,
           0,
           0,
           0,
           0,
           0,
           trunc(x.snap_time),
           0,
           x.statistics_type
      from (select m.snap_time,
                   m.company_id,
                   min(c.channel_no) channel_no,
                   min(c.account_id) account_id,
                   min(c.channel_type) channel_type,
                   m.business_type,
                   m.bill_type,
                   m.statistics_type,
                   sum(decode(m.channel_type, 2, 1, 4, 1, 1, -1, 3, -1) *
                       (m.draw_amount - m.commission)),
                   sum(m.profits),
                   (sum(decode(m.channel_type, 2, 1, 4, 1, 1, -1, 3, -1) *
                        (m.draw_amount - m.commission)) - sum(m.profits)) prof_differ
              from (select t.snap_time,
                           t.company_id,
                           t.channel_type,
                           t.business_type,
                           t.bill_type,
                           t.statistics_type,
                           sum(t.draw_amount - t.refund_draw_amount) draw_amount,
                           sum(t.real_amount - t.refund_real_amount) real_amount,
                           sum(t.commission - t.refund_commission) commission,
                           sum(t.profits - t.refund_profits) profits
                      from fd_report_commi_profit_daily t
                     where t.snap_time >=
                           to_date(v_start_time, 'yyyymmddhh24miss')
                       and t.snap_time <=
                           to_date(v_end_time, 'yyyymmddhh24miss')
                     group by t.snap_time,
                              t.company_id,
                              t.channel_type,
                              t.business_type,
                              t.bill_type,
                              t.statistics_type) m
             inner join fd_report_commi_profit_daily c on m.snap_time =
                                                          c.snap_time
                                                      and m.company_id =
                                                          c.company_id
                                                      and m.business_type =
                                                          c.business_type
                                                      and m.bill_type =
                                                          c.bill_type
                                                      and c.channel_type =
                                                          pkg_channel_type.down_channel
             group by m.snap_time,
                      m.company_id,
                      m.business_type,
                      m.bill_type,
                      m.statistics_type) x
     where x.prof_differ >= 1;

  if sql%rowcount = 0 then
    v_result := pkg_error_code.no_need_adjust;
    rollback;
    return;
  end if;

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_operate_daily_prof_adjust', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_OPERATE_SETTLE_ADJUST
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_operate_settle_adjust(v_down_channel_no varchar2, ---下游渠道编号
                                                       v_up_channel_no   varchar2, ---上游渠道编号
                                                       v_business_type   number, ---业务类型
                                                       v_bill_type       number, ---交易类型，1前向，2后向
                                                       v_settle_amount   number, --结算金额
                                                       v_memo            varchar2, --备注
                                                       v_result          out varchar2) as
  ----------------公司间结算数据平账-----------------
  l_down_company_id number;
  l_down_account_id number;
  l_up_company_id   number;
  l_up_account_id   number;
  l_system_id       number;
  l_balance         number;
begin
  --1.检查金额
  if v_settle_amount = 0 then
    v_result := pkg_error_code.amount_error;
    rollback;
    return;
  end if;

  --2.检查渠道
  select c.company_id, a.account_id
    into l_down_company_id, l_down_account_id
    from fd_base_down_account_map t
   inner join fd_base_down_channel c on t.channel_no = c.channel_no
   inner join fd_base_down_account a on t.account_id = a.account_id
   where t.channel_no = v_down_channel_no
     and rownum <= 2;

  select c.company_id, a.account_id, a.inner_balance
    into l_up_company_id, l_up_account_id, l_balance
    from fd_base_up_account_map t
   inner join fd_base_up_channel c on t.channel_no = c.channel_no
   inner join fd_base_up_account a on t.account_id = a.account_id
   where t.channel_no = v_up_channel_no
     and rownum <= 2;

  select t.source_system_id
    into l_system_id
    from fd_base_up_system_map t
   where t.channel_no = v_up_channel_no
     and rownum <= 2;

  ---3.结算平账
  insert into fd_trade_up_fund
    (record_id,
     order_source,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_unit,
     down_draw_face,
     down_draw_amount,
     down_real_amount,
     up_draw_unit,
     up_draw_face,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     balance,
     settle_amount,
     settle_status,
     settle_time,
     memo,
     order_time)
  values
    (seq_trade_up_fund_id.nextval,
     l_system_id,
     v_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_up_channel_no,
     l_up_account_id,
     l_up_company_id,
     0,
     0,
     0,
     0,
     0,
     0,
     0,
     0,
     sysdate,
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     v_business_type,
     l_balance,
     v_settle_amount,
     pkg_settle_status.complete_settle,
     sysdate,
     v_memo,
     sysdate);

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_operate_settle_adjust', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_QUERY_CHANNEL_BALANCE
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_query_channel_balance(v_channel_no    varchar2, --渠道编号
                                                       v_channel_type  number, --渠道类型（1上游2下游）
                                                       v_query_balance out number, --查询余额
                                                       v_inner_balance out number, --理论余额
                                                       v_credit_money  out number, --授信金额（只有下游有）
                                                       v_result        out varchar2) as
  -----------------------查询系统渠道余额---------------------
    pragma autonomous_transaction; --自治事务
begin
  --1.查询渠道余额
  v_result := fd_f_query_channel_balance(v_channel_no,
                                         v_channel_type,
                                         v_query_balance,
                                         v_inner_balance,
                                         v_credit_money);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_query_channel_balance', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_REPORT_ZERO_QUERY_BALANCE
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_report_zero_query_balance(v_channel_no    varchar2, ---渠道编号
                                                           v_channel_type  number, ---1.上游，2下游
                                                           v_query_date    varchar2, ---查询日期(表示具体哪天零点)，格式-yyyymmddhh24miss
                                                           v_query_balance number, ---查询余额
                                                           v_result        out varchar2) as
  ------------------渠道零点查询余额同步-----------------
  pragma autonomous_transaction; --自治事务
  l_count     number;
  l_record_id number;
begin
  ---1.检查查询余额是否同步
  select count(1), max(t.record_id)
    into l_count, l_record_id
    from fd_report_zero_balance t
   where t.record_date =
         trunc(to_date(v_query_date, 'yyyymmddhh24miss')) - 1
     and t.channel_no = v_channel_no
     and t.account_type = v_channel_type
     and t.query_balance is null;

  if l_count = 0 then
    v_result := pkg_error_code.data_repeat;
    rollback;
    return;
  end if;

  ---2.同步对应渠道的查询余额
  update fd_report_zero_balance t
     set t.query_balance = v_query_balance
   where t.record_id = l_record_id;

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    v_result := pkg_error_code.system_busy;
    rollback;
    fd_p_write_log('fd_p_report_zero_query_balance', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_SYNC_OUTSYS_PROFIT
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_sync_outsys_profit(v_system_name varchar2, ---外部系统名称
                                                    v_profit_date varchar2, ---利润所属日期（yyyymmddhh24miss）
                                                    v_profit      number, ---利润数据
                                                    v_result      out varchar2) as
  -------------------外部系统利润同步-----------------
  l_system_id number;
  pragma autonomous_transaction;
begin
  ---1.获取系统编号
  select t.source_system_id
    into l_system_id
    from fd_base_source_system t
   where t.source_system_name = v_system_name;

  ---2.添加利润数据
  insert into fd_report_outsys_profit
    (record_id, source_system_id, record_date, create_time, profit)
  values
    (seq_report_outsys_profit_id.nextval,
     l_system_id,
     to_date(v_profit_date, 'yyyymmddhh24miss'),
     sysdate,
     v_profit);

  ---3.检查同步是否成功
  if sql%rowcount = 0 then
    rollback;
    v_result := pkg_error_code.data_error;
    return;
  end if;

  v_result := pkg_error_code.success;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_sync_outsys_profit', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_SYNC_QUERY_BALANCE
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_sync_query_balance(v_channel_no    varchar2, ---渠道编号
                                                    v_channel_type  number, ---渠道类型1.上游渠道 2.下游渠道
                                                    v_query_balance number, ---查询余额
                                                    v_result        out varchar2) as
  -------------------同步渠道查询余额------------------

  l_account_id number;
  pragma autonomous_transaction;
begin
  if v_channel_type = pkg_channel_type.up_channel then
    ---1.上游渠道同步查询余额
    select t.account_id
      into l_account_id
      from fd_base_up_account_map t
     where t.channel_no = v_channel_no
       and rownum <= 2;
  
    update fd_base_up_account t
       set t.query_balance = v_query_balance
     where t.account_id = l_account_id;
  elsif v_channel_type = pkg_channel_type.down_channel then
    ---2.下游渠道同步查询余额
    select t.account_id
      into l_account_id
      from fd_base_down_account_map t
     where t.channel_no = v_channel_no
       and rownum <= 2;
  
    update fd_base_down_account t
       set t.query_balance = v_query_balance
     where t.account_id = l_account_id;
  
  else
    v_result := pkg_error_code.channel_error;
    return;
  end if;

  ---3.检查同步是否成功
  if sql%rowcount = 0 then
    rollback;
    v_result := pkg_error_code.data_error;
    return;
  end if;

  v_result := pkg_error_code.success;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_sync_query_balance', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_ALL_ORDER_PAY
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_trade_all_order_pay(v_down_channel_no    varchar2,
                                                     v_up_channel_no      varchar2,
                                                     v_up_bill_channel_no varchar2,
                                                     v_business_type      number,
                                                     v_trade_order_no     varchar2,
                                                     v_total_face         number,
                                                     v_order_amount       number,
                                                     v_up_amount          number,
                                                     v_bill_up_amount     number,
                                                     v_down_commision     number,
                                                     v_up_commision       number,
                                                     v_bill_up_commision  number,
                                                     v_service_pay        number,
                                                     v_order_time         varchar2, ---yyyy-mm-dd hh24:mi:ss订单时间
                                                     v_user_id            varchar2, --用户id
                                                     v_phone_no           varchar2, ---合约机号码
                                                     v_user_name          varchar2, --用户姓名
                                                     v_id_card_no         varchar2, --身份账号
                                                     v_rec_address        varchar2, --收货地址
                                                     v_sale_user          varchar2, --销售客服
                                                     v_has_invoice        number, --是否开票
                                                     v_memo               varchar2,
                                                     v_result             out varchar2) as
  -----------------------非冲业务上下游同步扣款-------------------
  l_up_account_id      number;
  l_up_bill_account_id number;
  l_order_source       number;
  l_fd_business_type   number;
begin

  ---1.检查上下游渠道金额信息
  v_result := fd_f_trade_all_pay_check(v_down_channel_no,
                                       v_up_channel_no,
                                       v_up_bill_channel_no,
                                       v_total_face,
                                       v_order_amount,
                                       l_up_account_id,
                                       l_up_bill_account_id,
                                       l_order_source);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(l_order_source,
                                                     v_business_type);

  ---3.从历史库获取订单
  v_result := fd_f_trade_hs_move(l_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success and
     v_result != pkg_error_code.order_not_exists) then
    rollback;
    return;
  else
    commit;
  end if;

  ---4.检查订单是否存在，不存在则创建订单
  v_result := fd_f_trade_order_create_ii(l_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_trade_order_no,
                                         '-',
                                         l_fd_business_type,
                                         '-',
                                         '-',
                                         '-',
                                         v_total_face,
                                         v_total_face,
                                         v_order_amount,
                                         v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---5.订单下游扣款
  v_result := fd_f_trade_down_order_fee_mus(l_order_source,
                                            v_down_channel_no,
                                            v_trade_order_no,
                                            v_trade_order_no,
                                            v_order_time,
                                            v_order_amount,
                                            v_service_pay,
                                            v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---6.预存话费上游扣款
  if nvl(v_up_bill_channel_no, 'null') != 'null' then
    v_result := fd_f_trade_up_order_minus(l_order_source,
                                          v_trade_order_no,
                                          'bill_' || v_trade_order_no,
                                          v_up_bill_channel_no,
                                          l_up_bill_account_id,
                                          0, --上游规格(传0使下游扣款为0)
                                          0, --上游面值(传0使下游扣款为0)
                                          v_bill_up_amount,
                                          (v_bill_up_amount -
                                          v_bill_up_commision),
                                          v_total_face,
                                          v_total_face,
                                          v_order_amount,
                                          (v_order_amount - v_down_commision),
                                          pkg_bill_type.front,
                                          v_order_time,
                                          0,
                                          v_memo);

    if (v_result != pkg_error_code.success) then
      rollback;
      return;
    end if;
  end if;

  ---7.订单上游扣款
  v_result := fd_f_trade_up_order_minus(l_order_source,
                                        v_trade_order_no,
                                        v_trade_order_no,
                                        v_up_channel_no,
                                        l_up_account_id,
                                        v_total_face - v_bill_up_amount,
                                        v_total_face - v_bill_up_amount,
                                        v_up_amount,
                                        (v_up_amount - v_up_commision),
                                        v_total_face,
                                        v_total_face,
                                        v_order_amount,
                                        (v_order_amount - v_down_commision),
                                        pkg_bill_type.front,
                                        v_order_time,
                                        0,
                                        v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---8.记录非充信息
  v_result := fd_f_all_un_order_create(l_order_source,
                                       v_trade_order_no,
                                       v_up_amount,
                                       v_bill_up_amount,
                                       v_user_id,
                                       v_phone_no,
                                       v_user_name,
                                       v_id_card_no,
                                       v_rec_address,
                                       v_sale_user,
                                       v_has_invoice);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_all_order_pay', sqlerrm, 1);

end;
/

prompt
prompt Creating procedure FD_P_TRADE_ALL_ORDER_REFUND
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_trade_all_order_refund(v_down_channel_no    varchar2,
                                                        v_up_channel_no      varchar2,
                                                        v_up_bill_channel_no varchar2,
                                                        v_business_type      number,
                                                        v_trade_order_no     varchar2,
                                                        v_trade_refund_no    varchar2,
                                                        v_refund_face        number,
                                                        v_down_refund_amount number,
                                                        v_up_refund_amount   number,
                                                        v_bill_refund_amount number,
                                                        v_down_commision     number,
                                                        v_up_commision       number,
                                                        v_bill_up_commision  number,
                                                        v_service_refund     number,
                                                        v_memo               varchar2,
                                                        v_result             out varchar2) as
  ---------------非冲业务上下游同步退款----------------
  l_order_source     number;
  l_fd_business_type number;
  l_order_date       varchar2(32) := to_char(sysdate,
                                             'yyyy-mm-dd hh24:mi:ss');
begin
  ---1.获取渠道和系统信息
  v_result := fd_f_trade_all_sys_get(v_down_channel_no, l_order_source);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(l_order_source,
                                                     v_business_type);

  ---3.获取历史库中的数据
  v_result := fd_f_trade_hs_move(l_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---4.检查相关扣款信息
  v_result := fd_f_trade_all_refund_check(l_order_source,
                                          v_trade_order_no,
                                          v_down_refund_amount,
                                          v_up_refund_amount,
                                          v_bill_refund_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---5.下游订单退款
  v_result := fd_f_trade_down_fee_refund(l_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_trade_refund_no,
                                         v_refund_face,
                                         v_refund_face,
                                         v_down_refund_amount,
                                         (v_down_refund_amount -
                                         v_down_commision),
                                         l_order_date,
                                         v_service_refund,
                                         v_memo);

  ---6.预存话费退款
  if nvl(v_up_bill_channel_no, 'null') != 'null' then
    v_result := fd_f_trade_up_order_refund(l_order_source,
                                           v_down_channel_no,
                                           v_up_bill_channel_no,
                                           v_trade_order_no,
                                           'bill_' || v_trade_order_no,
                                           'bill_' || v_trade_refund_no,
                                           1,
                                           l_fd_business_type,
                                           '-',
                                           '-',
                                           0, --(传0使下游扣款为0)
                                           0, --(传0使下游扣款为0)
                                           v_bill_refund_amount,
                                           (v_bill_refund_amount -
                                           v_bill_up_commision),
                                           l_order_date,
                                           0,
                                           v_memo);
  
    if (v_result != pkg_error_code.success) then
      rollback;
      return;
    end if;
  end if;

  ---7.上游支付退款
  v_result := fd_f_trade_up_order_refund(l_order_source,
                                         v_down_channel_no,
                                         v_up_channel_no,
                                         v_trade_order_no,
                                         v_trade_order_no,
                                         v_trade_refund_no,
                                         1,
                                         l_fd_business_type,
                                         '-',
                                         '-',
                                         (v_refund_face -
                                         v_bill_refund_amount),
                                         (v_refund_face -
                                         v_bill_refund_amount),
                                         v_up_refund_amount,
                                         (v_up_refund_amount -
                                         v_up_commision),
                                         l_order_date,
                                         0,
                                         v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---8.记录非充退款信息
  v_result := fd_f_all_un_order_refund(l_order_source,
                                       v_trade_order_no,
                                       v_down_refund_amount,
                                       v_up_refund_amount,
                                       v_bill_refund_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_all_order_refund', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_ADD_APPLY
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_trade_down_add_apply(v_channel_no    varchar2, -- 渠道编号
                                                      v_add_amount    number, -- 加款金额
                                                      v_add_count     number, -- 加款笔数
                                                      v_kh_account_id number, -- 客户子账户ID
                                                      v_qx_account_id number, -- 千行银行账户ID
                                                      v_pay_time      varchar2, -- 付款时间
                                                      v_memo          varchar2, -- 申请备注
                                                      v_apply_user    varchar2, -- 申请人
                                                      v_out_code      out varchar2,
                                                      v_out_msg       out varchar2) as
  l_count_qx          number;
  l_count_kh          number;
  l_account_id        number;
  l_bank_card_no      varchar2(32);
  l_bank_card_name    varchar2(64);
  l_bank_card_address varchar2(128);
  l_bank_type         number;
  l_start_time        date := to_date('2019-09-19', 'yyyy-mm-dd');
  l_pay_time          date := to_date(v_pay_time, 'yyyy-mm-dd hh24:mi:ss');
  l_max_amount        number;
  l_auto_add          number;
  l_has_add           number; --已经添加的申请

  --------------------------------------------------
  --功能：添加下游加款申请
  --创建人：lvwj
  --创建时间：2019-09-19
  --------------------------------------------------

begin
  if (l_start_time > l_pay_time) then
    v_out_code := pkg_error_code.failure;
    v_out_msg  := '转账时间不正确';
    return;
  end if;
  if (v_channel_no is null) then
    v_out_code := pkg_error_code.failure;
    v_out_msg  := '渠道编号不允许为空';
    return;
  end if;
  if (v_add_count is null or v_add_count <= 0 or v_add_count > 30) then
    v_out_code := pkg_error_code.failure;
    v_out_msg  := '笔数不正确,最大支持30笔';
    return;
  end if;
  if (v_add_amount is null or v_add_amount <= 0) then
    v_out_code := pkg_error_code.failure;
    v_out_msg  := '金额不正确';
    return;
  end if;

  select min(t.account_id)
    into l_account_id
    from fd_base_down_account_map t
   where t.channel_no = v_channel_no;

  if (l_account_id is null) then
    v_out_code := pkg_error_code.failure;
    v_out_msg  := '渠道不存在账户';
    return;
  end if;

  select t.auto_amount, t.auto_add
    into l_max_amount, l_auto_add
    from fd_base_down_channel t
   where t.channel_no = v_channel_no;
  if (l_auto_add <> 0) then
    v_out_code := pkg_error_code.failure;
    v_out_msg  := '未开启快捷加款,请联系商务';
    return;
  end if;
  if (v_add_amount > l_max_amount) then
    v_out_code := pkg_error_code.failure;
    v_out_msg  := '单笔最大' || l_max_amount;
    return;
  end if;
  --判断已提交的申请金额
  select nvl(sum(t.add_amount), 0)
    into l_has_add
    from fd_trade_down_add_apply t
   where t.create_time >= trunc(sysdate)
     and t.create_time < trunc(sysdate) - 1
     and t.channel_no = v_channel_no
     and t.status <> 90;
  if (l_has_add + v_add_amount * v_add_count >= l_max_amount) then
    v_out_code := pkg_error_code.failure;
    v_out_msg  := '超过当天自动加款阈值：' || l_max_amount || ',请联系千行手动处理';
    return;
  end if;

  select count(1)
    into l_count_qx
    from fd_bank_account_info t
   where t.account_id = v_qx_account_id;

  if (l_count_qx < 1) then
    v_out_code := pkg_error_code.failure;
    v_out_msg  := '千行银行账户ID不存在';
    return;
  end if;

  select count(1)
    into l_count_kh
    from FD_B2E_DOWN_WHITE_LIST t
   where t.id = v_kh_account_id
     and t.down_channel_no = v_channel_no
     and t.audit_status = 0;

  if (l_count_kh < 1) then
    v_out_code := pkg_error_code.failure;
    v_out_msg  := '客户子账户ID不存在';
    return;
  end if;

  select t.down_holder_card_no,
         t.bank_holder_name,
         t.account_bank_address,
         t.bank_type
    into l_bank_card_no, l_bank_card_name, l_bank_card_address, l_bank_type
    from FD_B2E_DOWN_WHITE_LIST t
   where t.id = v_kh_account_id
     and t.down_channel_no = v_channel_no
     and t.audit_status = 0;

  for i in 1 .. v_add_count loop
    insert into fd_trade_down_add_apply
      (apply_id,
       channel_no,
       account_id,
       add_amount,
       apply_account_no,
       bank_type,
       apply_account_name,
       apply_open_bank_name,
       status,
       create_time,
       create_user,
       pay_time,
       memo,
       flow_status,
       bank_account_id)
    values
      (seq_downaddapply_auto_id.nextval,
       v_channel_no,
       l_account_id,
       v_add_amount,
       l_bank_card_no,
       l_bank_type,
       l_bank_card_name,
       l_bank_card_address,
       10, --
       sysdate,
       v_apply_user,
       l_pay_time,
       v_memo,
       10, --
       v_qx_account_id);
  end loop;
  commit;

  v_out_code := pkg_error_code.success;
  v_out_msg  := '操作成功';

exception
  when others then
    rollback;
    v_out_code := pkg_error_code.failure;
    v_out_msg  := '服务器异常';
    fd_p_write_log('fd_p_trade_down_add_apply',
                   'v_channel_no:' || v_channel_no || ',v_add_amount:' ||
                   v_add_amount || sqlerrm,
                   1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_APPLY_RESET
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_trade_down_apply_reset(v_apply_id  in number, --加款申请编号
                                                        v_edit_user varchar2, --操作人
                                                        v_memo      varchar2, --备注
                                                        v_result    out varchar2, --返回结果
                                                        v_msg       out varchar2 --返回消息
                                                        ) as
  --------------------------------
  --功能：下游自动加款重新匹配
  --创建人：周荣省
  --创建时间：2019-10-02
  --------------------------------
  l_apply_id number;
begin
  --1.锁申请自动处理失败但申请状态为等待处理
  select t.apply_id
    into l_apply_id
    from fd_trade_down_add_apply t
   where t.apply_id = v_apply_id
     and t.status = pkg_b2e_add_apply_status.status_wait
     and t.flow_status = pkg_b2e_add_apply_status.status_fail
     for update;
  --2.更新申请
  update fd_trade_down_add_apply t
     set t.flow_status = pkg_b2e_add_apply_status.status_wait,
         t.error_msg   = '',
         t.audit_memo  = v_memo,
         t.handle_time = sysdate,
         t.audit_user  = v_edit_user
   where t.apply_id = l_apply_id
     and t.status = pkg_b2e_add_apply_status.status_wait
     and t.flow_status = pkg_b2e_add_apply_status.status_fail;
  v_result := pkg_error_code.success;
  v_msg    := '处理成功';
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := '系统繁忙';
    fd_p_write_log('fd_p_trade_down_apply_reset', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_MANUAL_ADD_T
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_trade_down_manual_add_t(v_down_channel_no in varchar2, ---下游渠道
                                                         v_record_no       in varchar2, ---外部加款编号
                                                         v_amount          in number, ---加款金额
                                                         v_service_fee     in number, ---手续费
                                                         v_create_user     in varchar2, ---加款人
                                                         v_pay_time        in varchar2, ---可空，支付时间
                                                         v_partner_account in varchar2, ---可空，合作方银行账户
                                                         v_memo            in varchar2, ---备注
                                                         v_result          out varchar2,
                                                         v_msg             out varchar2) as
  --------------下游手工加款---------------

  l_down_account_id number;
begin
  ---1.1检查下游加款是否重复
  v_result := fd_f_trade_down_add_rd_check(v_record_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.2检查下游渠道、账户及其关联情况
  v_result := fd_f_trade_down_ma_account_t(v_down_channel_no,
                                           pkg_down_manual_change_type.add_amount,
                                           v_service_fee,
                                           l_down_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  /*  ---2.检查数据金额是否正确
  v_result := fd_f_trade_operat_money_check(v_amount, v_service_fee);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;*/

  ---3.账户手工加款
  v_result := fd_f_trade_down_manual_add_t(v_down_channel_no,
                                           l_down_account_id,
                                           v_record_no,
                                           v_amount,
                                           v_service_fee,
                                           v_create_user,
                                           v_pay_time,
                                           v_partner_account,
                                           v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_trade_down_manual_add_t', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_MANU_AC_ADD_T
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_trade_down_manu_ac_add_t(v_down_channel_no in varchar2, ---下游渠道
                                                          v_down_account_id in number, ---下游渠道支付账户
                                                          v_record_no       in varchar2, ---外部加款编号
                                                          v_amount          in number, ---加款金额
                                                          v_service_fee     in number, ---手续费
                                                          v_create_user     in varchar2, ---加款人
                                                          v_pay_time        in varchar2, ---可空，支付时间
                                                          v_partner_account in varchar2, ---可空，合作方银行账户
                                                          v_memo            in varchar2, ---备注
                                                          v_result          out varchar2,
                                                          v_msg             out varchar2) as
  --------------下游手工加款---------------

begin
  ---1.检查下游加款是否重复
  v_result := fd_f_trade_down_add_rd_check(v_record_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.检查下游渠道、账户及其关联情况
  v_result := fd_f_trade_down_ac_account_t(v_down_channel_no,
                                           v_down_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款
  v_result := fd_f_trade_down_manual_add_t(v_down_channel_no,
                                           v_down_account_id,
                                           v_record_no,
                                           v_amount,
                                           v_service_fee,
                                           v_create_user,
                                           v_pay_time,
                                           v_partner_account,
                                           v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_trade_down_manu_ac_add_t', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_ORDER_FEE_PAY
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_trade_down_order_fee_pay(v_order_source        in number, ---来源系统编号
                                                          v_down_channel_no     in varchar2,
                                                          v_trade_order_no      in varchar2, ---外部系统交易订单号
                                                          v_ext_order_no        in varchar2, ---下游商户的订单号
                                                          v_recharge_account_no in varchar2,
                                                          v_business_type       in number,
                                                          v_carrier_no          in varchar2,
                                                          v_province_no         in varchar2,
                                                          v_city_no             in varchar2,
                                                          v_total_face          in number, --面值
                                                          v_recharge_unit       in number, --充值量单位（多少M）
                                                          v_order_time          in varchar2,
                                                          v_order_amount        in number,
                                                          v_service_pay         in number, --手续费
                                                          v_memo                in varchar2,
                                                          v_result              out varchar2,
                                                          v_msg                 out varchar2) as

  ----------------------下游订单支付----------------------
  l_fd_business_type number;
begin
  ---1.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---2.检查扣款是否成功
  v_result := fd_f_trade_down_draw_check(v_order_source, v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    if (v_result = pkg_error_code.data_repeat) then
      v_result := pkg_error_code.success;
    end if;
  
    rollback;
    return;
  end if;

  ---3.检查订单金额
  v_result := fd_f_trade_down_amount_check(v_down_channel_no,
                                           v_order_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---4.历史库获取订单
  v_result := fd_f_trade_pay_hs_move(v_order_source,
                                     v_down_channel_no,
                                     v_trade_order_no,
                                     v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---5.检查订单是否存在，不存在则创建订单
  v_result := fd_f_trade_order_create_ii(v_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_ext_order_no,
                                         v_recharge_account_no,
                                         l_fd_business_type,
                                         v_carrier_no,
                                         v_province_no,
                                         v_city_no,
                                         v_total_face,
                                         v_recharge_unit,
                                         v_order_amount,
                                         v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---6.下游资金变动扣款(锁订单，检查扣款记录是否存在，锁定账户，添加资金变动)
  v_result := fd_f_trade_down_order_fee_mus(v_order_source,
                                            v_down_channel_no,
                                            v_trade_order_no,
                                            v_ext_order_no,
                                            v_order_time,
                                            v_order_amount,
                                            v_service_pay,
                                            v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_trade_down_order_fee_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_ORDER_FEE_REF
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_trade_down_order_fee_ref(v_order_source    in number,
                                                          v_down_channel_no in varchar2,
                                                          v_trade_order_no  in varchar2,
                                                          v_trade_refund_no in varchar2,
                                                          v_refund_unit     in number,
                                                          v_refund_face     in number,
                                                          v_refund_amount   in number,
                                                          v_real_refund     in number,
                                                          v_order_date      in varchar2,
                                                          v_service_fee     in number,
                                                          v_memo            in varchar2,
                                                          v_result          out varchar2) as
  ----------------下游退款------------------
begin
  ---1.获取历史库中的数据
  v_result := fd_f_trade_hs_move(v_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.下游订单退款
  v_result := fd_f_trade_down_fee_refund(v_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_trade_refund_no,
                                         v_refund_unit,
                                         v_refund_face,
                                         v_refund_amount,
                                         v_real_refund,
                                         v_order_date,
                                         v_service_fee,
                                         v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_down_order_fee_ref', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_ORDER_MS_PAY
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_trade_down_order_ms_pay(v_order_source        in number, ---来源系统编号
                                                         v_down_channel_no     in varchar2,
                                                         v_trade_order_no      in varchar2, ---外部系统交易订单号
                                                         v_ext_order_no        in varchar2, ---下游商户的订单号
                                                         v_recharge_account_no in varchar2,
                                                         v_business_type       in number,
                                                         v_carrier_no          in varchar2,
                                                         v_province_no         in varchar2,
                                                         v_city_no             in varchar2,
                                                         v_total_face          in number, --面值
                                                         v_recharge_unit       in number, --充值量单位（多少M）
                                                         v_order_time          in varchar2,
                                                         v_order_amount        in number,
                                                         v_service_pay         in number, --手续费
                                                         v_memo                in varchar2,
                                                         v_result              out varchar2,
                                                         v_msg                 out varchar2) as
  -----------------------------------------------------
  --功能：短信平台专用下游扣款
  --创建人：周荣省
  --创建时间：2019-05-20
  -----------------------------------------------------

  ----------------------下游订单支付----------------------
  l_fd_business_type number;
begin
  ---1.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---2.检查扣款是否成功
  v_result := fd_f_trade_down_draw_check(v_order_source, v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    if (v_result = pkg_error_code.data_repeat) then
      v_result := pkg_error_code.success;
    end if;
  
    rollback;
    return;
  end if;

  ---3.检查订单金额
  v_result := fd_f_trade_down_amount_check(v_down_channel_no,
                                           v_order_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---4.历史库获取订单
  v_result := fd_f_trade_pay_hs_move(v_order_source,
                                     v_down_channel_no,
                                     v_trade_order_no,
                                     v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---5.检查订单是否存在，不存在则创建订单
  v_result := fd_f_trade_order_create_ii(v_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_ext_order_no,
                                         v_recharge_account_no,
                                         l_fd_business_type,
                                         v_carrier_no,
                                         v_province_no,
                                         v_city_no,
                                         v_total_face,
                                         v_recharge_unit,
                                         v_order_amount,
                                         v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---6.下游资金变动扣款(锁订单，检查扣款记录是否存在，锁定账户，添加资金变动)
  v_result := fd_f_trade_down_order_ms_mus(v_order_source,
                                           v_down_channel_no,
                                           v_trade_order_no,
                                           v_ext_order_no,
                                           v_order_time,
                                           v_order_amount,
                                           v_service_pay,
                                           v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_trade_down_order_fee_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_ORDER_MS_REF
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_trade_down_order_ms_ref(v_order_source    in number,
                                                         v_down_channel_no in varchar2,
                                                         v_trade_order_no  in varchar2,
                                                         v_trade_refund_no in varchar2,
                                                         v_refund_unit     in number,
                                                         v_refund_face     in number,
                                                         v_refund_amount   in number,
                                                         v_real_refund     in number,
                                                         v_order_date      in varchar2,
                                                         v_service_fee     in number,
                                                         v_memo            in varchar2,
                                                         v_result          out varchar2) as
  ------------------------------------
  --功能：短信平台下游专用退款
  --创建人：周荣省
  --创建时间：2019-05-20
  ------------------------------------
begin
  ---1.获取历史库中的数据
  v_result := fd_f_trade_hs_move(v_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.下游订单退款
  v_result := fd_f_trade_down_ms_refund(v_order_source,
                                        v_down_channel_no,
                                        v_trade_order_no,
                                        v_trade_refund_no,
                                        v_refund_unit,
                                        v_refund_face,
                                        v_refund_amount,
                                        v_real_refund,
                                        v_order_date,
                                        v_service_fee,
                                        v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_down_order_fee_ref', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_ORDER_PAY
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_trade_down_order_pay(v_order_source        in number, ---来源系统编号
                                                      v_down_channel_no     in varchar2,
                                                      v_trade_order_no      in varchar2, ---外部系统交易订单号
                                                      v_ext_order_no        in varchar2, ---下游商户的订单号
                                                      v_recharge_account_no in varchar2,
                                                      v_business_type       in number,
                                                      v_carrier_no          in varchar2,
                                                      v_province_no         in varchar2,
                                                      v_city_no             in varchar2,
                                                      v_total_face          in number, --面值
                                                      v_recharge_unit       in number, --充值量单位（多少M）
                                                      v_order_time          in varchar2,
                                                      v_order_amount        in number,
                                                      v_memo                in varchar2,
                                                      v_result              out varchar2,
                                                      v_msg                 out varchar2) as

  ----------------------下游订单支付----------------------
begin
  ---1.检查订单金额
  v_result := fd_f_trade_down_amount_check(v_down_channel_no,
                                           v_order_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.1历史库获取订单
  v_result := fd_f_trade_pay_hs_move(v_order_source,
                                     v_down_channel_no,
                                     v_trade_order_no,
                                     v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.检查订单是否存在，不存在则创建订单
  v_result := fd_f_trade_order_create_ii(v_order_source,
                                      v_down_channel_no,
                                      v_trade_order_no,
                                      v_ext_order_no,
                                      v_recharge_account_no,
                                      v_business_type,
                                      v_carrier_no,
                                      v_province_no,
                                      v_city_no,
                                      v_total_face,
                                      v_recharge_unit,
                                      v_order_amount,
                                      v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.下游资金变动扣款(锁订单，检查扣款记录是否存在，锁定账户，添加资金变动)
  v_result := fd_f_trade_down_order_minus(v_order_source,
                                          v_down_channel_no,
                                          v_trade_order_no,
                                          v_ext_order_no,
                                          v_order_time,
                                          v_order_amount,
                                          v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_trade_down_order_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_ORDER_PAY_T
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_trade_down_order_pay_t(v_order_source        in number, ---来源系统编号
                                                        v_down_channel_no     in varchar2,
                                                        v_trade_order_no      in varchar2, ---外部系统交易订单号
                                                        v_ext_order_no        in varchar2, ---下游商户的订单号
                                                        v_recharge_account_no in varchar2,
                                                        v_business_type       in number,
                                                        v_carrier_no          in varchar2,
                                                        v_province_no         in varchar2,
                                                        v_city_no             in varchar2,
                                                        v_total_face          in number,
                                                        v_recharge_unit       in number,
                                                        v_order_time          in varchar2,
                                                        v_order_amount        in number,
                                                        v_pay_time            in varchar2,
                                                        v_memo                in varchar2,
                                                        v_result              out varchar2,
                                                        v_msg                 out varchar2) as

  ----------------------下游订单支付----------------------
begin
  ---1.检查订单金额
  v_result := fd_f_trade_down_amount_check(v_down_channel_no,
                                           v_order_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.检查订单是否存在，不存在则创建订单
  v_result := fd_f_trade_order_create_t(v_order_source,
                                        v_down_channel_no,
                                        v_trade_order_no,
                                        v_ext_order_no,
                                        v_recharge_account_no,
                                        v_business_type,
                                        v_carrier_no,
                                        v_province_no,
                                        v_city_no,
                                        v_total_face,
                                        v_recharge_unit,
                                        v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.下游资金变动扣款(锁订单，检查扣款记录是否存在，锁定账户，添加资金变动)
  v_result := fd_f_trade_down_order_minus_t(v_order_source,
                                            v_down_channel_no,
                                            v_trade_order_no,
                                            v_ext_order_no,
                                            v_order_time,
                                            v_order_amount,
                                            v_pay_time,
                                            v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_trade_down_order_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_ORDER_REFUND
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_trade_down_order_refund(v_order_source    in number,
                                                         v_down_channel_no in varchar2,
                                                         v_trade_order_no  in varchar2,
                                                         v_trade_refund_no in varchar2,
                                                         v_refund_unit     in number,
                                                         v_refund_face     in number,
                                                         v_refund_amount   in number,
                                                         v_real_refund     in number,
                                                         v_memo            in varchar2,
                                                         v_result          out varchar2) as
  ----------------下游退款------------------
begin

  ---1.获取历史库中的数据
  v_result := fd_f_trade_hs_move(v_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;


  v_result := fd_f_trade_down_refund(v_order_source,
                                     v_down_channel_no,
                                     v_trade_order_no,
                                     v_trade_refund_no,
                                     v_refund_unit,
                                     v_refund_face,
                                     v_refund_amount,
                                     v_real_refund,
                                     v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_down_order_refund', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_ORDER_REFUND_T
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_trade_down_order_refund_t(v_order_source    in number,
                                                           v_down_channel_no in varchar2,
                                                           v_trade_order_no  in varchar2,
                                                           v_trade_refund_no in varchar2,
                                                           v_business_type   in number,
                                                           v_carrier_no      in varchar2,
                                                           v_province_no     in varchar2,
                                                           v_refund_unit     in number,
                                                           v_refund_face     in number,
                                                           v_refund_amount   in number,
                                                           v_real_refund     in number,
                                                           v_ext_order_no    in varchar2,
                                                           v_refund_time     in varchar2,
                                                           v_order_time      in varchar2,
                                                           v_memo            in varchar2,
                                                           v_result          out varchar2,
                                                           v_msg             out varchar2) as
  ----------------下游退款------------------
begin
  v_result := fd_f_trade_down_refund_t(v_order_source,
                                       v_down_channel_no,
                                       v_trade_order_no,
                                       v_trade_refund_no,
                                       v_business_type,
                                       v_carrier_no,
                                       v_province_no,
                                       v_refund_unit,
                                       v_refund_face,
                                       v_refund_amount,
                                       v_real_refund,
                                       v_ext_order_no,
                                       v_refund_time,
                                       v_order_time,
                                       v_memo);

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_trade_down_order_refund', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_DOWN_TRANS_REFUND
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_trade_down_trans_refund(v_order_source      in number, ---系统编号
                                                         v_down_channel_no   in varchar2, ---下游渠道
                                                         v_trade_order_no    in varchar2, ---原扣款订单号
                                                         v_trade_refund_no   in varchar2, ---退款编号
                                                         v_refund_account_id in number, ---转账退款账号
                                                         v_refund_unit       in number, ---退款规格
                                                         v_refund_face       in number, ---退款面值
                                                         v_refund_amount     in number, ---退款金额
                                                         v_real_refund       in number, ---退款真实金额
                                                         v_service_fee       in number, ---转账退款手续费
                                                         v_refund_user       in varchar2, ---退款操作人
                                                         v_memo              in varchar2, ---备注
                                                         v_result            out varchar2) as
  --------------------下游转账退款---------------------
begin
  ---1.获取历史库中的数据
  v_result := fd_f_trade_hs_move(v_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.系统转账退款
  v_result := fd_f_trade_down_trans_refund(v_order_source,
                                           v_down_channel_no,
                                           v_trade_order_no,
                                           v_trade_refund_no,
                                           v_refund_account_id,
                                           v_refund_unit,
                                           v_refund_face,
                                           v_refund_amount,
                                           v_real_refund,
                                           v_service_fee,
                                           v_refund_user,
                                           v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_down_transfer_refund', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_UP_AC_ORDER_PAY
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_trade_up_ac_order_pay(v_order_source        in number, --系统id
                                                       v_down_channel_no     in varchar2, --下游渠道编号
                                                       v_up_channel_no       in varchar2, --上游渠道编号
                                                       v_up_account_id       in number, --上游支付账户编号
                                                       v_trade_order_no      in varchar2, --交易系统订单编号
                                                       v_trade_delivery_no   in varchar2, --交易系统发货编号
                                                       v_ext_order_no        in varchar2, --上游渠道方的订单号
                                                       v_recharge_account_no in varchar2, --充值的账号
                                                       v_bill_type           in number, --交易类型，1.前向，2.后向
                                                       v_business_type       in number, --业务类型，
                                                       v_carrier_no          in varchar2, --运营商
                                                       v_province_no         in varchar2, --省份
                                                       v_city_no             in varchar2, --城市
                                                       v_down_order_unit     in number, --下游订单规格
                                                       v_down_order_face     in number, --下游订单面值
                                                       v_down_draw_unit      in number, --下游扣款规格
                                                       v_down_draw_face      in number, --下游扣款面值
                                                       v_down_draw_amount    in number, --下游交易扣款金额
                                                       v_down_real_amount    in number, --下游真实扣款金额
                                                       v_up_draw_unit        in number, --上游扣款规格
                                                       v_up_draw_face        in number, --上游扣款面值
                                                       v_up_draw_amount      in number, --上游交易扣款金额
                                                       v_up_real_amount      in number, --上游真实扣款金额
                                                       v_order_time          in varchar2, --交易系统订单时间
                                                       v_service_fee         in number, --支付手续费
                                                       v_memo                in varchar2, --备注信息
                                                       v_result              out varchar2) as
  --------------一个渠道多个账户的上游订单支付--------------
  l_fd_business_type number;
begin
  ---0.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---1.检查上游渠道、账户及其关联情况
  v_result := fd_f_trade_ac_pay_account_get(v_order_source,
                                            v_up_channel_no,
                                            v_up_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.1历史库获取订单
  v_result := fd_f_trade_pay_hs_move(v_order_source,
                                     v_down_channel_no,
                                     v_trade_order_no,
                                     v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.检查订单是否存在，不存在则创建订单
  v_result := fd_f_trade_order_create_ii(v_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_ext_order_no,
                                         v_recharge_account_no,
                                         l_fd_business_type,
                                         v_carrier_no,
                                         v_province_no,
                                         v_city_no,
                                         v_down_order_face,
                                         v_down_order_unit,
                                         v_down_draw_amount,
                                         v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.上游支付扣款
  v_result := fd_f_trade_up_order_minus(v_order_source,
                                        v_trade_order_no,
                                        v_trade_delivery_no,
                                        v_up_channel_no,
                                        v_up_account_id,
                                        v_up_draw_unit,
                                        v_up_draw_face,
                                        v_up_draw_amount,
                                        fd_f_trade_real_amount_get(v_up_channel_no,---判断上游是否计算佣金
                                                                   pkg_channel_type.up_channel,
                                                                   v_up_draw_amount,
                                                                   v_up_real_amount),
                                        v_down_draw_unit,
                                        v_down_draw_face,
                                        v_down_draw_amount,
                                        fd_f_trade_real_amount_get(v_down_channel_no,---判断下游是否计算佣金
                                                                   pkg_channel_type.down_channel,
                                                                   v_down_draw_amount,
                                                                   v_down_real_amount),
                                        v_bill_type,
                                        v_order_time,
                                        v_service_fee,
                                        v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_up_ac_order_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_UP_AUTO_DOWN_REFUND
prompt =================================================
prompt
create or replace procedure fd_account.fd_p_trade_up_auto_down_refund as
  -------------------自动获取下游退款存入上游资金变动----------------
  l_begin_date date := trunc(sysdate) - 3;
  l_end_date   date := trunc(sysdate);
  --l_end_date     date := sysdate;
  l_record_id number;
begin
  for item in (select r.record_id,
                      r.fd_order_id,
                      r.order_source,
                      r.channel_no,
                      r.trade_order_no,
                      r.refund_unit,
                      r.refund_face,
                      r.refund_amount,
                      r.real_refund
                 from fd_trade_down_refund r
                inner join fd_trade_order_main m on r.fd_order_id =
                                                    m.fd_order_id
                where r.has_syn_up = pkg_sys_boolean.isfalse
                  and m.has_up_trade = pkg_sys_boolean.istrue
                  and r.refund_time >= l_begin_date
                  and r.refund_time < l_end_date) loop
  
    begin
      ---1.锁退款数据，避免重复添加上游
      select t.record_id
        into l_record_id
        from fd_trade_down_refund t
       where t.record_id = item.record_id
         and t.has_syn_up = pkg_sys_boolean.isfalse
         for update nowait;
    
      ---2.添加下游退款到上游资金变动
      insert into fd_trade_up_fund
        (record_id,
         fd_order_id,
         trade_order_no,
         order_source,
         trade_delivery_no,
         down_channel_no,
         down_account_id,
         down_company_id,
         up_channel_no,
         up_account_id,
         up_company_id,
         down_draw_unit,
         down_draw_face,
         down_draw_amount,
         down_real_amount,
         up_draw_unit,
         up_draw_face,
         up_draw_amount,
         up_real_amount,
         change_time,
         change_type,
         bill_type,
         business_type,
         carrier_no,
         province_no,
         balance,
         profits,
         down_commission,
         settle_amount,
         order_time)
        select seq_trade_up_fund_id.nextval,
               t.fd_order_id,
               t.trade_order_no,
               t.order_source,
               '0',
               t.down_channel_no,
               t.down_account_id,
               t.down_company_id,
               '0',
               0,
               0,
               item.refund_unit,
               item.refund_face,
               item.refund_amount,
               item.real_refund,
               0,
               0,
               0,
               0,
               sysdate,
               pkg_up_fund_change_type.refund_amount,
               t.bill_type,
               t.business_type,
               t.carrier_no,
               t.province_no,
               0,
               item.real_refund,
               (item.refund_amount - item.real_refund),
               0,
               t.order_time
          from fd_trade_up_fund t
         where t.fd_order_id = item.fd_order_id
           and t.change_type = pkg_up_fund_change_type.debit_amount
           and rownum <= 1;
    
      ---3.修改下游退款同步上游状态
      if sql%rowcount > 0 then
        update fd_trade_down_refund t
           set t.has_syn_up = pkg_sys_boolean.istrue
         where t.record_id = item.record_id;
      end if;
    
      commit;
    exception
      when others then
        rollback;
    end;
  end loop;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_trade_up_auto_down_refund', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_UP_MANUAL_ADD_T
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_trade_up_manual_add_t(v_up_channel_no   in varchar2, ---上游渠道编号
                                                       v_record_no       in varchar2, ---外部加款记录编号
                                                       v_amount          in number, ---加款金额
                                                       v_service_fee     in number, ---手续费
                                                       v_create_user     in varchar2, ---加款用户
                                                       v_pay_time        in varchar2, ---可空，支付时间
                                                       v_partner_account in varchar2, ---可空，合作方银行账户
                                                       v_memo            in varchar2, ---备注
                                                       v_result          out varchar2,
                                                       v_msg             out varchar2) as
  --------------上游手工加款---------------
  l_up_account_id number;
  l_up_company_id number;
begin

  ---1.1检查订单重复加款
  v_result := fd_f_trade_up_add_rd_check(v_record_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.2检查上游渠道账户信息
  v_result := fd_f_trade_up_manual_account_t(v_up_channel_no,
                                             pkg_up_manual_change_type.add_amount,
                                             v_service_fee,
                                             l_up_account_id,
                                             l_up_company_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  /*  ---2.检查数据金额是否正确
  v_result := fd_f_trade_operat_money_check(v_amount, v_service_fee);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;*/

  ---3.账户手工加款
  v_result := fd_f_trade_up_manual_add_t(v_up_channel_no,
                                         l_up_account_id,
                                         l_up_company_id,
                                         v_record_no,
                                         v_amount,
                                         v_service_fee,
                                         v_create_user,
                                         v_pay_time,
                                         v_partner_account,
                                         v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_trade_up_manual_add_t', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_UP_MANU_AC_ADD_T
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_trade_up_manu_ac_add_t(v_up_channel_no   in varchar2, ---上游渠道编号
                                                        v_up_account_id   in number, ---上游渠道支付账户
                                                        v_record_no       in varchar2, ---外部加款记录编号
                                                        v_amount          in number, ---加款金额
                                                        v_service_fee     in number, ---手续费
                                                        v_create_user     in varchar2, ---加款用户
                                                        v_pay_time        in varchar2, ---可空，支付时间
                                                        v_partner_account in varchar2, ---可空，合作方银行账户
                                                        v_memo            in varchar2, ---备注
                                                        v_result          out varchar2,
                                                        v_msg             out varchar2) as
  --------------上游手工加款---------------
  l_up_company_id number;
begin
  ---1.检查订单重复加款
  v_result := fd_f_trade_up_add_rd_check(v_record_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.检查上游渠道账户信息
  v_result := fd_f_trade_up_ac_account_t(v_up_channel_no,
                                         v_up_account_id,
                                         l_up_company_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.账户手工加款
  v_result := fd_f_trade_up_manual_add_t(v_up_channel_no,
                                         v_up_account_id,
                                         l_up_company_id,
                                         v_record_no,
                                         v_amount,
                                         v_service_fee,
                                         v_create_user,
                                         v_pay_time,
                                         v_partner_account,
                                         v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_trade_up_manual_add_t', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_UP_ORDER_PAY
prompt ==========================================
prompt
create or replace procedure fd_account.fd_p_trade_up_order_pay(v_order_source        in number,
                                                    v_down_channel_no     in varchar2,
                                                    v_up_channel_no       in varchar2,
                                                    v_trade_order_no      in varchar2,
                                                    v_trade_delivery_no   in varchar2,
                                                    v_ext_order_no        in varchar2,
                                                    v_recharge_account_no in varchar2,
                                                    v_bill_type           in number,
                                                    v_business_type       in number,
                                                    v_carrier_no          in varchar2,
                                                    v_province_no         in varchar2,
                                                    v_city_no             in varchar2,
                                                    v_down_order_unit     in number,
                                                    v_down_order_face     in number,
                                                    v_down_draw_unit      in number,
                                                    v_down_draw_face      in number,
                                                    v_down_draw_amount    in number,
                                                    v_down_real_amount    in number,
                                                    v_up_draw_unit        in number,
                                                    v_up_draw_face        in number,
                                                    v_up_draw_amount      in number,
                                                    v_up_real_amount      in number,
                                                    v_order_time          in varchar2,
                                                    v_service_fee         in number, --手续费
                                                    v_memo                in varchar2,
                                                    v_result              out varchar2) as
  --------------上游订单支付--------------
  l_up_account_id    number;
  l_fd_business_type number;
begin
  ---0.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---1.检查上游渠道、账户及其关联情况
  v_result := fd_f_trade_pay_account_get(v_order_source,
                                         v_up_channel_no,
                                         l_up_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.1历史库获取订单
  v_result := fd_f_trade_pay_hs_move(v_order_source,
                                     v_down_channel_no,
                                     v_trade_order_no,
                                     v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.检查订单是否存在，不存在则创建订单
  v_result := fd_f_trade_order_create_ii(v_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_ext_order_no,
                                         v_recharge_account_no,
                                         l_fd_business_type,
                                         v_carrier_no,
                                         v_province_no,
                                         v_city_no,
                                         v_down_order_face,
                                         v_down_order_unit,
                                         v_down_draw_amount,
                                         v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.检查上游扣款的订单面值
  v_result := fd_f_trade_order_face_check(v_trade_order_no,
                                          v_down_order_face,
                                          v_down_draw_face);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---4.上游支付扣款
  v_result := fd_f_trade_up_order_minus(v_order_source,
                                        v_trade_order_no,
                                        v_trade_delivery_no,
                                        v_up_channel_no,
                                        l_up_account_id,
                                        v_up_draw_unit,
                                        v_up_draw_face,
                                        v_up_draw_amount,
                                        fd_f_trade_real_amount_get(v_up_channel_no, ---判断上游是否计算佣金
                                                                   pkg_channel_type.up_channel,
                                                                   v_up_draw_amount,
                                                                   v_up_real_amount),
                                        v_down_draw_unit,
                                        v_down_draw_face,
                                        v_down_draw_amount,
                                        fd_f_trade_real_amount_get(v_down_channel_no, ---判断下游是否计算佣金
                                                                   pkg_channel_type.down_channel,
                                                                   v_down_draw_amount,
                                                                   v_down_real_amount),
                                        v_bill_type,
                                        v_order_time,
                                        v_service_fee,
                                        v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_up_order_pay' || v_trade_order_no,
                   sqlerrm,
                   1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_UP_ORDER_PAY2
prompt ===========================================
prompt
create or replace procedure fd_account.fd_p_trade_up_order_pay2(v_order_source        in number, --外部系统编号
                                                     v_down_channel_no     in varchar2, --下游渠道编号
                                                     v_up_channel_no       in varchar2, --上游渠道编号
                                                     v_trade_order_no      in varchar2, --外部交易订单号
                                                     v_trade_delivery_no   in varchar2, --外部发货编号
                                                     v_ext_order_no        in varchar2, --外部下游渠道记录的订单号
                                                     v_recharge_account_no in varchar2, --充值号码
                                                     v_bill_type           in number, --前后项信息
                                                     v_business_type       in number, --业务类型
                                                     v_carrier_no          in varchar2, --运营商
                                                     v_province_no         in varchar2, --省份编号
                                                     v_city_no             in varchar2, --诚实编号
                                                     v_down_order_unit     in number, --下游订单规格(M)
                                                     v_down_order_face     in number, --下游订单面值(元)
                                                     v_down_draw_unit      in number, --下游订单规格(M)
                                                     v_down_draw_face      in number, --下游订单面值(元)
                                                     v_down_draw_amount    in number, --下游订单扣款金额
                                                     v_down_real_amount    in number, --下游订单真实扣款金额
                                                     v_up_draw_unit        in number, --上游扣款规格(M)
                                                     v_up_draw_face        in number, --上游扣款面值(元)
                                                     v_up_draw_amount      in number, --上游扣款金额
                                                     v_up_real_amount      in number, --上游真实扣款金额
                                                     v_order_time          in varchar2, --外部订单生成时间（yyyy-mm-dd hh24:mi:ss）
                                                     v_service_fee         in number, --手续费
                                                     v_memo                in varchar2, --备注信息
                                                     v_out_change_time     in varchar2, --外部上游扣款发生时间（yyyy-mm-dd hh24:mi:ss）
                                                     v_result              out varchar2) as
  --------------上游订单支付--------------
  l_up_account_id    number;
  l_fd_business_type number;
begin
  ---1.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---2.检查上游渠道、账户及其关联情况
  v_result := fd_f_trade_pay_account_get(v_order_source,
                                         v_up_channel_no,
                                         l_up_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.历史库获取订单
  v_result := fd_f_trade_pay_hs_move2(v_order_source,
                                      v_trade_order_no,
                                      v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---4.检查订单是否存在，不存在则创建订单
  v_result := fd_f_trade_order_create_ii(v_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_ext_order_no,
                                         v_recharge_account_no,
                                         l_fd_business_type,
                                         v_carrier_no,
                                         v_province_no,
                                         v_city_no,
                                         v_down_order_face,
                                         v_down_order_unit,
                                         v_down_draw_amount,
                                         v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---5.检查上游扣款的订单面值
  v_result := fd_f_trade_order_face_check(v_trade_order_no,
                                          v_down_order_face,
                                          v_down_draw_face);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---6.上游支付扣款
  v_result := fd_f_trade_up_order_minus2(v_order_source,
                                         v_trade_order_no,
                                         v_trade_delivery_no,
                                         v_up_channel_no,
                                         l_up_account_id,
                                         v_up_draw_unit,
                                         v_up_draw_face,
                                         v_up_draw_amount,
                                         fd_f_trade_real_amount_get2(v_up_channel_no, ---判断上游是否计算佣金
                                                                     pkg_channel_type.up_channel,
                                                                     v_business_type,
                                                                     v_up_draw_amount,
                                                                     v_up_real_amount),
                                         v_down_draw_unit,
                                         v_down_draw_face,
                                         v_down_draw_amount,
                                         fd_f_trade_real_amount_get2(v_down_channel_no, ---判断下游是否计算佣金
                                                                     pkg_channel_type.down_channel,
                                                                     v_business_type,
                                                                     v_down_draw_amount,
                                                                     v_down_real_amount),
                                         v_bill_type,
                                         v_order_time,
                                         v_service_fee,
                                         v_memo,
                                         v_out_change_time);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_up_order_pay' || v_trade_order_no,
                   sqlerrm,
                   1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_UP_ORDER_PAY_MS
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_trade_up_order_pay_ms(v_order_source        in number, --外部系统编号
                                                       v_down_channel_no     in varchar2, --下游渠道编号
                                                       v_up_channel_no       in varchar2, --上游渠道编号
                                                       v_trade_order_no      in varchar2, --外部交易订单号
                                                       v_trade_delivery_no   in varchar2, --外部发货编号
                                                       v_ext_order_no        in varchar2, --外部下游渠道记录的订单号
                                                       v_recharge_account_no in varchar2, --充值号码
                                                       v_bill_type           in number, --前后项信息
                                                       v_business_type       in number, --业务类型
                                                       v_carrier_no          in varchar2, --运营商
                                                       v_province_no         in varchar2, --省份编号
                                                       v_city_no             in varchar2, --诚实编号
                                                       v_down_order_unit     in number, --下游订单规格(M)
                                                       v_down_order_face     in number, --下游订单面值(元)
                                                       v_down_draw_unit      in number, --下游订单规格(M)
                                                       v_down_draw_face      in number, --下游订单面值(元)
                                                       v_down_draw_amount    in number, --下游订单扣款金额
                                                       v_down_real_amount    in number, --下游订单真实扣款金额
                                                       v_up_draw_unit        in number, --上游扣款规格(M)
                                                       v_up_draw_face        in number, --上游扣款面值(元)
                                                       v_up_draw_amount      in number, --上游扣款金额
                                                       v_up_real_amount      in number, --上游真实扣款金额
                                                       v_order_time          in varchar2, --外部订单生成时间（yyyy-mm-dd hh24:mi:ss）
                                                       v_service_fee         in number, --手续费
                                                       v_memo                in varchar2, --备注信息
                                                       v_out_change_time     in varchar2, --外部上游扣款发生时间（yyyy-mm-dd hh24:mi:ss）
                                                       v_result              out varchar2) as
  ----------------------------------
  --功能：短信平台上游专用扣款
  --创建人：周荣省
  --创建时间：2019-05-20
  ----------------------------------
  l_up_account_id    number;
  l_fd_business_type number;
begin
  ---1.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---2.检查上游渠道、账户及其关联情况
  v_result := fd_f_trade_pay_account_get(v_order_source,
                                         v_up_channel_no,
                                         l_up_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.历史库获取订单
  v_result := fd_f_trade_pay_hs_move2(v_order_source,
                                      v_trade_order_no,
                                      v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---4.检查订单是否存在，不存在则创建订单
  v_result := fd_f_trade_order_create_ii(v_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_ext_order_no,
                                         v_recharge_account_no,
                                         l_fd_business_type,
                                         v_carrier_no,
                                         v_province_no,
                                         v_city_no,
                                         v_down_order_face,
                                         v_down_order_unit,
                                         v_down_draw_amount,
                                         v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---5.检查上游扣款的订单面值
  v_result := fd_f_trade_order_face_check(v_trade_order_no,
                                          v_down_order_face,
                                          v_down_draw_face);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---6.上游支付扣款
  v_result := fd_f_trade_up_order_minus_ms(v_order_source,
                                           v_trade_order_no,
                                           v_trade_delivery_no,
                                           v_up_channel_no,
                                           l_up_account_id,
                                           v_up_draw_unit,
                                           v_up_draw_face,
                                           v_up_draw_amount,
                                           fd_f_trade_real_amount_get2(v_up_channel_no, ---判断上游是否计算佣金
                                                                       pkg_channel_type.up_channel,
                                                                       v_business_type,
                                                                       v_up_draw_amount,
                                                                       v_up_real_amount),
                                           v_down_draw_unit,
                                           v_down_draw_face,
                                           v_down_draw_amount,
                                           fd_f_trade_real_amount_get2(v_down_channel_no, ---判断下游是否计算佣金
                                                                       pkg_channel_type.down_channel,
                                                                       v_business_type,
                                                                       v_down_draw_amount,
                                                                       v_down_real_amount),
                                           v_bill_type,
                                           v_order_time,
                                           v_service_fee,
                                           v_memo,
                                           v_out_change_time);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_up_order_pay' || v_trade_order_no,
                   sqlerrm,
                   1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_UP_ORDER_PAY_T
prompt ============================================
prompt
create or replace procedure fd_account.fd_p_trade_up_order_pay_t(v_order_source        in number,
                                                      v_down_channel_no     in varchar2,
                                                      v_up_channel_no       in varchar2,
                                                      v_trade_order_no      in varchar2,
                                                      v_trade_delivery_no   in varchar2,
                                                      v_ext_order_no        in varchar2,
                                                      v_recharge_account_no in varchar2,
                                                      v_bill_type           in number,
                                                      v_business_type       in number,
                                                      v_carrier_no          in varchar2,
                                                      v_province_no         in varchar2,
                                                      v_city_no             in varchar2,
                                                      v_down_order_unit     in number,
                                                      v_down_order_face     in number,
                                                      v_down_draw_unit      in number,
                                                      v_down_draw_face      in number,
                                                      v_down_draw_amount    in number,
                                                      v_down_real_amount    in number,
                                                      v_up_draw_unit        in number,
                                                      v_up_draw_face        in number,
                                                      v_up_draw_amount      in number,
                                                      v_up_real_amount      in number,
                                                      v_order_time          in varchar2,
                                                      v_pay_time            in varchar2,
                                                      v_memo                in varchar2,
                                                      v_result              out varchar2,
                                                      v_msg                 out varchar2) as
  --------------上游订单支付--------------
  l_up_account_id number;
begin
  ---1.检查上游渠道、账户及其关联情况
  v_result := fd_f_trade_pay_account_get(v_order_source,
                                         v_up_channel_no,
                                         l_up_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---1.1历史库获取订单
  v_result := fd_f_trade_pay_hs_move(v_order_source,
                                     v_down_channel_no,
                                     v_trade_order_no,
                                     v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;

  ---2.检查订单是否存在，不存在则创建订单
  v_result := fd_f_trade_order_create_t(v_order_source,
                                        v_down_channel_no,
                                        v_trade_order_no,
                                        v_ext_order_no,
                                        v_recharge_account_no,
                                        v_business_type,
                                        v_carrier_no,
                                        v_province_no,
                                        v_city_no,
                                        v_down_order_face,
                                        v_down_order_unit,
                                        v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.上游支付扣款
  v_result := fd_f_trade_up_order_minus_t(v_order_source,
                                          v_trade_order_no,
                                          v_trade_delivery_no,
                                          v_up_channel_no,
                                          l_up_account_id,
                                          v_up_draw_unit,
                                          v_up_draw_face,
                                          v_up_draw_amount,
                                          v_up_real_amount,
                                          v_down_draw_unit,
                                          v_down_draw_face,
                                          v_down_draw_amount,
                                          v_down_real_amount,
                                          v_bill_type,
                                          v_pay_time,
                                          v_order_time,
                                          v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_trade_up_order_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_UP_ORDER_REFUND
prompt =============================================
prompt
create or replace procedure fd_account.fd_p_trade_up_order_refund(v_order_source          in number,
                                                       v_down_channel_no       in varchar2,
                                                       v_up_channel_no         in varchar2,
                                                       v_trade_order_no        in varchar2,
                                                       v_trade_delivery_no     in varchar2,
                                                       v_trade_refund_no       in varchar2,
                                                       v_bill_type             in number,
                                                       v_business_type         in number,
                                                       v_carrier_no            in varchar2,
                                                       v_province_no           in varchar2,
                                                       v_up_refund_unit        in number,
                                                       v_up_refund_face        in number,
                                                       v_up_refund_amount      in number,
                                                       v_up_refund_real_amount in number,
                                                       v_order_time            in varchar2,
                                                       v_service_fee           in number, ---手续费
                                                       v_memo                  in varchar2,
                                                       v_result                out varchar2) as
  --------------上游订单退款--------------
  l_fd_business_type number;
begin
  ---0.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---1.获取历史库中的数据
  v_result := fd_f_trade_hs_move(v_order_source,
                                 v_down_channel_no,
                                 v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;
  ---2.上游支付退款
  v_result := fd_f_trade_up_order_refund(v_order_source,
                                         v_down_channel_no,
                                         v_up_channel_no,
                                         v_trade_order_no,
                                         v_trade_delivery_no,
                                         v_trade_refund_no,
                                         v_bill_type,
                                         l_fd_business_type,
                                         v_carrier_no,
                                         v_province_no,
                                         v_up_refund_unit,
                                         v_up_refund_face,
                                         v_up_refund_amount,
                                         fd_f_trade_real_amount_get(v_up_channel_no,---判断上游是否计算佣金
                                                                    pkg_channel_type.up_channel,
                                                                    v_up_refund_amount,
                                                                    v_up_refund_real_amount),
                                         v_order_time,
                                         v_service_fee,
                                         v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_up_order_refund' || v_trade_order_no,
                   sqlerrm,
                   1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_UP_ORDER_REFUND2
prompt ==============================================
prompt
create or replace procedure fd_account.fd_p_trade_up_order_refund2(v_order_source          in number, --外部系统编号
                                                        v_down_channel_no       in varchar2, --外部下游渠道编号
                                                        v_up_channel_no         in varchar2, --上游渠道编号
                                                        v_trade_order_no        in varchar2, --外部交易订单号
                                                        v_trade_delivery_no     in varchar2, --外部发货订单号
                                                        v_trade_refund_no       in varchar2, --外部退款编号
                                                        v_bill_type             in number, --前后项信息
                                                        v_business_type         in number, --业务类型
                                                        v_carrier_no            in varchar2, --运营商编号
                                                        v_province_no           in varchar2, --省份编号
                                                        v_up_refund_unit        in number, --上游退款规格(M)
                                                        v_up_refund_face        in number, --上游退款面值(元)
                                                        v_up_refund_amount      in number, --上游退款金额
                                                        v_up_refund_real_amount in number, --上游退款真实金额
                                                        v_order_time            in varchar2, --外部订单生成时间（yyyy-mm-dd hh24:mi:ss）
                                                        v_service_fee           in number, ---手续费
                                                        v_memo                  in varchar2, --备注信息
                                                        v_out_change_time       in varchar2, --外部上游退款发生时间（yyyy-mm-dd hh24:mi:ss）
                                                        v_result                out varchar2) as
  --------------上游订单退款--------------
  l_fd_business_type number;
begin
  ---0.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---1.获取历史库中的数据
  v_result := fd_f_trade_pay_hs_move2(v_order_source,
                                      v_trade_order_no,
                                      v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;
  ---2.上游支付退款
  v_result := fd_f_trade_up_order_refund2(v_order_source,
                                          v_down_channel_no,
                                          v_up_channel_no,
                                          v_trade_order_no,
                                          v_trade_delivery_no,
                                          v_trade_refund_no,
                                          v_bill_type,
                                          l_fd_business_type,
                                          v_carrier_no,
                                          v_province_no,
                                          v_up_refund_unit,
                                          v_up_refund_face,
                                          v_up_refund_amount,
                                          fd_f_trade_real_amount_get2(v_up_channel_no, ---判断上游是否计算佣金
                                                                      pkg_channel_type.up_channel,
                                                                      v_business_type,
                                                                      v_up_refund_amount,
                                                                      v_up_refund_real_amount),
                                          v_order_time,
                                          v_service_fee,
                                          v_memo,
                                          v_out_change_time);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_up_order_refund' || v_trade_order_no,
                   sqlerrm,
                   1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_UP_ORDER_REFUND_MS
prompt ================================================
prompt
create or replace procedure fd_account.fd_p_trade_up_order_refund_ms(v_order_source          in number, --外部系统编号
                                                          v_down_channel_no       in varchar2, --外部下游渠道编号
                                                          v_up_channel_no         in varchar2, --上游渠道编号
                                                          v_trade_order_no        in varchar2, --外部交易订单号
                                                          v_trade_delivery_no     in varchar2, --外部发货订单号
                                                          v_trade_refund_no       in varchar2, --外部退款编号
                                                          v_bill_type             in number, --前后项信息
                                                          v_business_type         in number, --业务类型
                                                          v_carrier_no            in varchar2, --运营商编号
                                                          v_province_no           in varchar2, --省份编号
                                                          v_up_refund_unit        in number, --上游退款规格(M)
                                                          v_up_refund_face        in number, --上游退款面值(元)
                                                          v_up_refund_amount      in number, --上游退款金额
                                                          v_up_refund_real_amount in number, --上游退款真实金额
                                                          v_order_time            in varchar2, --外部订单生成时间（yyyy-mm-dd hh24:mi:ss）
                                                          v_service_fee           in number, ---手续费
                                                          v_memo                  in varchar2, --备注信息
                                                          v_out_change_time       in varchar2, --外部上游退款发生时间（yyyy-mm-dd hh24:mi:ss）
                                                          v_result                out varchar2) as
  -------------------------------
  --功能：短信平台上游专用退款
  --创建人：周荣省
  --创建时间：2019-05-20
  -------------------------------
  l_fd_business_type number;
begin
  ---0.获取记账系统业务类型
  l_fd_business_type := fd_f_trade_business_type_get(v_order_source,
                                                     v_business_type);

  ---1.获取历史库中的数据
  v_result := fd_f_trade_pay_hs_move2(v_order_source,
                                      v_trade_order_no,
                                      v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  else
    commit;
  end if;
  ---2.上游支付退款
  v_result := fd_f_trade_up_order_refund_ms(v_order_source,
                                            v_down_channel_no,
                                            v_up_channel_no,
                                            v_trade_order_no,
                                            v_trade_delivery_no,
                                            v_trade_refund_no,
                                            v_bill_type,
                                            l_fd_business_type,
                                            v_carrier_no,
                                            v_province_no,
                                            v_up_refund_unit,
                                            v_up_refund_face,
                                            v_up_refund_amount,
                                            fd_f_trade_real_amount_get2(v_up_channel_no, ---判断上游是否计算佣金
                                                                        pkg_channel_type.up_channel,
                                                                        v_business_type,
                                                                        v_up_refund_amount,
                                                                        v_up_refund_real_amount),
                                            v_order_time,
                                            v_service_fee,
                                            v_memo,
                                            v_out_change_time);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('fd_p_trade_up_order_refund' || v_trade_order_no,
                   sqlerrm,
                   1);
end;
/

prompt
prompt Creating procedure FD_P_TRADE_UP_ORDER_REFUND_T
prompt ===============================================
prompt
create or replace procedure fd_account.fd_p_trade_up_order_refund_t(v_order_source          in number,
                                                         v_down_channel_no       in varchar2,
                                                         v_up_channel_no         in varchar2,
                                                         v_trade_order_no        in varchar2,
                                                         v_trade_delivery_no     in varchar2,
                                                         v_trade_refund_no       in varchar2,
                                                         v_bill_type             in number,
                                                         v_business_type         in number,
                                                         v_carrier_no            in varchar2,
                                                         v_province_no           in varchar2,
                                                         v_down_draw_unit        in number,
                                                         v_down_draw_face        in number,
                                                         v_down_draw_amount      in number,
                                                         v_down_real_amount      in number,
                                                         v_up_refund_unit        in number,
                                                         v_up_refund_face        in number,
                                                         v_up_refund_amount      in number,
                                                         v_up_refund_real_amount in number,
                                                         v_refund_time           in varchar2,
                                                         v_memo                  in varchar2,
                                                         v_result                out varchar2,
                                                         v_msg                   out varchar2) as
  --------------上游订单退款--------------
begin
  ---1.上游支付退款
  v_result := fd_f_trade_up_order_refund_t(v_order_source,
                                           v_down_channel_no,
                                           v_up_channel_no,
                                           v_trade_order_no,
                                           v_trade_delivery_no,
                                           v_trade_refund_no,
                                           v_bill_type,
                                           v_business_type,
                                           v_carrier_no,
                                           v_province_no,
                                           v_down_draw_unit,
                                           v_down_draw_face,
                                           v_down_draw_amount,
                                           v_down_real_amount,
                                           v_up_refund_unit,
                                           v_up_refund_face,
                                           v_up_refund_amount,
                                           v_up_refund_real_amount,
                                           v_refund_time,
                                           v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('fd_p_trade_up_order_refund', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_DOWN_PROFIT_GET
prompt ================================================
prompt
create or replace procedure fd_account.income_p_auto_down_profit_get(v_get_date in varchar2 default null) as
  -----------------收入单元下游利润统计---------------
  l_get_date date := to_date(v_get_date, 'yyyymmddhh24miss');
begin
  ---1.获取利润收集时间
  if l_get_date is null then
    l_get_date := trunc(sysdate) - 1;
  end if;

  ---2.获取直充利润
  insert into income_down_trade
    (id,
     trade_date,
     channel_no,
     trade_type,
     trade_amount,
     trade_rv_profit,
     trade_profit)
    select seq_income_down_tradeid.nextval,
           l_get_date,
           tab.down_channel_no,
           tab.statistics_type,
           tab.down_draw,
           tab.down_rv_profit,
           tab.down_profit
      from (select t.down_channel_no,
                   m.statistics_type,
                   sum(decode(t.change_type, 2, 1, -1) * t.down_draw_amount) down_draw,
                   sum(decode(t.order_source, 0, 1, 0) *
                       decode(t.change_type, 2, 1, -1) *
                       (t.down_real_amount - t.up_real_amount)) down_rv_profit,
                   sum(decode(t.change_type, 2, 1, -1) *
                       (t.down_real_amount - t.up_real_amount)) down_profit
              from fd_trade_up_fund t
             inner join fd_system_business_statis_map m
                on t.business_type = m.local_business_type
             where t.change_time >= l_get_date
               and t.change_time < (l_get_date + 1)
               and t.change_type in (2, 3)
               and t.down_channel_no not in ('0', '-')
             group by t.down_channel_no, m.statistics_type) tab;

  ---3.获取代付利润
  insert into income_down_trade
    (id,
     trade_date,
     channel_no,
     trade_type,
     trade_amount,
     trade_rv_profit,
     trade_profit)
    select seq_income_down_tradeid.nextval,
           l_get_date,
           tab.down_channel_no,
           tab.statistics_type,
           tab.down_draw,
           tab.down_rv_profit,
           tab.down_profit
      from (select t.down_channel_no,
                   m.statistics_type,
                   sum(decode(t.change_type, 2, 1, -1) * t.down_draw_amount) down_draw,
                   sum(decode(t.order_source, 0, 1, 0) *
                       decode(t.change_type, 2, 1, -1) *
                       (t.up_real_amount - t.down_real_amount)) down_rv_profit,
                   sum(decode(t.change_type, 2, 1, -1) *
                       (t.up_real_amount - t.down_real_amount)) down_profit
              from dk_trade_up_fund t
             inner join fd_system_business_statis_map m
                on t.business_type = m.local_business_type
             where t.change_time >= l_get_date
               and t.change_time < (l_get_date + 1)
               and t.change_type in (2, 3)
               and t.down_channel_no not in ('0', '-')
             group by t.down_channel_no, m.statistics_type) tab;
  commit;
exception
  when others then
    rollback;
    fd_p_write_log('income_p_auto_down_profit_get', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_DOWN_PFT_BTH
prompt =============================================
prompt
create or replace procedure fd_account.income_p_auto_down_pft_bth(v_start_date in varchar2,
                                                       v_end_date   in varchar2) as
  ------------------批量生成上游收入单元数据-----------------
  l_collect_date date;
begin
  l_collect_date := to_date(v_start_date, 'yyyymmddhh24miss');
  loop
    income_p_auto_down_profit_get(to_char(l_collect_date,
                                          'yyyymmddhh24miss'));
    l_collect_date := l_collect_date + 1;
    exit when l_collect_date > to_date(v_end_date, 'yyyymmddhh24miss');
  end loop;
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_DOWN_PROFIT_HS
prompt ===============================================
prompt
create or replace procedure fd_account.income_p_auto_down_profit_hs(v_get_date in varchar2 default null) as
  -----------------收入单元下游利润统计---------------
  l_get_date date := to_date(v_get_date, 'yyyymmddhh24miss');
begin
  ---1.获取利润收集时间
  if l_get_date is null then
    l_get_date := trunc(sysdate) - 1;
  end if;

  ---2.获取直充利润
  insert into income_down_trade
    (id,
     trade_date,
     channel_no,
     trade_type,
     trade_amount,
     trade_rv_profit,
     trade_profit)
    select seq_income_down_tradeid.nextval,
           l_get_date,
           tab.down_channel_no,
           tab.statistics_type,
           tab.down_draw,
           tab.down_rv_profit,
           tab.down_profit
      from (select t.down_channel_no,
                   m.statistics_type,
                   sum(decode(t.change_type, 2, 1, -1) * t.down_draw_amount) down_draw,
                   sum(decode(t.order_source, 0, 1, 0) *
                       decode(t.change_type, 2, 1, -1) *
                       (t.down_real_amount - t.up_real_amount)) down_rv_profit,
                   sum(decode(t.change_type, 2, 1, -1) *
                       (t.down_real_amount - t.up_real_amount)) down_profit
              from fd_trade_up_fund_hs t
             inner join fd_system_business_statis_map m
                on t.business_type = m.local_business_type
             where t.change_time >= l_get_date
               and t.change_time < (l_get_date + 1)
               and t.change_type in (2, 3)
               and t.down_channel_no not in ('0', '-')
             group by t.down_channel_no, m.statistics_type) tab;

  ---3.获取代付利润
  insert into income_down_trade
    (id,
     trade_date,
     channel_no,
     trade_type,
     trade_amount,
     trade_rv_profit,
     trade_profit)
    select seq_income_down_tradeid.nextval,
           l_get_date,
           tab.down_channel_no,
           tab.statistics_type,
           tab.down_draw,
           tab.down_rv_profit,
           tab.down_profit
      from (select t.down_channel_no,
                   m.statistics_type,
                   sum(decode(t.change_type, 2, 1, -1) * t.down_draw_amount) down_draw,
                   sum(decode(t.order_source, 0, 1, 0) *
                       decode(t.change_type, 2, 1, -1) *
                       (t.up_real_amount - t.down_real_amount)) down_rv_profit,
                   sum(decode(t.change_type, 2, 1, -1) *
                       (t.up_real_amount - t.down_real_amount)) down_profit
              from dk_trade_up_fund t
             inner join fd_system_business_statis_map m
                on t.business_type = m.local_business_type
             where t.change_time >= l_get_date
               and t.change_time < (l_get_date + 1)
               and t.change_type in (2, 3)
               and t.down_channel_no not in ('0', '-')
             group by t.down_channel_no, m.statistics_type) tab;
  commit;
exception
  when others then
    rollback;
    fd_p_write_log('income_p_auto_down_profit_hs', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_DOWN_PFT_BTH_HS
prompt ================================================
prompt
create or replace procedure fd_account.income_p_auto_down_pft_bth_hs(v_start_date in varchar2,
                                                          v_end_date   in varchar2) as
  ------------------批量生成上游收入单元数据-----------------
  l_collect_date date;
begin
  l_collect_date := to_date(v_start_date, 'yyyymmddhh24miss');
  loop
    income_p_auto_down_profit_hs(to_char(l_collect_date,
                                         'yyyymmddhh24miss'));
    l_collect_date := l_collect_date + 1;
    exit when l_collect_date > to_date(v_end_date, 'yyyymmddhh24miss');
  end loop;
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_DOWN_UP_PFT_HS
prompt ===============================================
prompt
create or replace procedure fd_account.income_p_auto_down_up_pft_hs(v_get_date in varchar2 default null) as
  -----------------获取下游指定上游的交易量-------------------
  l_get_date date := to_date(v_get_date, 'yyyymmddhh24miss');
begin
  ---1.获取利润收集时间
  if l_get_date is null then
    l_get_date := trunc(sysdate) - 1;
  end if;

  ---2.获取上游对应下游渠道交易量
  insert into income_down_up_trade
    (id,
     trade_date,
     down_channel_no,
     up_channel_no,
     trade_amount,
     trade_profit)
    select seq_income_down_up_tradeid.nextval,
           l_get_date,
           tab.down_channel_no,
           tab.up_channel_no,
           tab.draw_amount,
           tab.profit
      from (select t.down_channel_no,
                   t.up_channel_no,
                   sum(decode(t.change_type, 2, 1, -1) * t.down_draw_amount) draw_amount,
                   sum(decode(t.change_type, 2, 1, -1) *
                       (t.down_draw_amount - t.up_draw_amount)) profit
              from fd_trade_up_fund_hs t
             where t.change_time >= l_get_date
               and t.change_time < (l_get_date + 1)
               and t.change_type in (2, 3)
               and t.up_channel_no in
                   (select c.up_channel_no from income_down_up_config c)
             group by t.down_channel_no, t.up_channel_no) tab;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('income_p_auto_down_up_pft_hs', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_DOWN_UP_PFTBTHHS
prompt =================================================
prompt
create or replace procedure fd_account.income_p_auto_down_up_pftbthhs(v_start_date in varchar2,
                                                            v_end_date   in varchar2) as
  ------------------批量生成指定上游对应下游交易数据数据-----------------
  l_collect_date date;
begin
  l_collect_date := to_date(v_start_date, 'yyyymmddhh24miss');
  loop
    income_p_auto_down_up_pft_hs(to_char(l_collect_date,
                                            'yyyymmddhh24miss'));
    l_collect_date := l_collect_date + 1;
    exit when l_collect_date > to_date(v_end_date, 'yyyymmddhh24miss');
  end loop;
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_DOWN_UP_PROFIT
prompt ===============================================
prompt
create or replace procedure fd_account.income_p_auto_down_up_profit(v_get_date in varchar2 default null) as
  -----------------获取下游指定上游的交易量-------------------
  l_get_date date := to_date(v_get_date, 'yyyymmddhh24miss');
begin
  ---1.获取利润收集时间
  if l_get_date is null then
    l_get_date := trunc(sysdate) - 1;
  end if;

  ---2.获取上游对应下游渠道交易量
  insert into income_down_up_trade
    (id,
     trade_date,
     down_channel_no,
     up_channel_no,
     trade_amount,
     trade_profit)
    select seq_income_down_up_tradeid.nextval,
           l_get_date,
           tab.down_channel_no,
           tab.up_channel_no,
           tab.draw_amount,
           tab.profit
      from (select t.down_channel_no,
                   t.up_channel_no,
                   sum(decode(t.change_type, 2, 1, -1) * t.down_draw_amount) draw_amount,
                   sum(decode(t.change_type, 2, 1, -1) *
                       (t.down_draw_amount - t.up_draw_amount)) profit
              from fd_trade_up_fund t
             where t.change_time >= l_get_date
               and t.change_time < (l_get_date + 1)
               and t.change_type in (2, 3)
               and t.up_channel_no in
                   (select c.up_channel_no from income_down_up_config c)
             group by t.down_channel_no, t.up_channel_no) tab;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('income_p_auto_down_up_profit', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_DOWN_UP_PFT_BTH
prompt ================================================
prompt
create or replace procedure fd_account.income_p_auto_down_up_pft_bth(v_start_date in varchar2,
                                                          v_end_date   in varchar2) as
  ------------------批量生成指定上游对应下游交易数据数据-----------------
  l_collect_date date;
begin
  l_collect_date := to_date(v_start_date, 'yyyymmddhh24miss');
  loop
    income_p_auto_down_up_profit(to_char(l_collect_date,
                                         'yyyymmddhh24miss'));
    l_collect_date := l_collect_date + 1;
    exit when l_collect_date > to_date(v_end_date, 'yyyymmddhh24miss');
  end loop;
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_UP_PROFIT_GET
prompt ==============================================
prompt
create or replace procedure fd_account.income_p_auto_up_profit_get(v_get_date in varchar2 default null) as
  ------------------收入单元上游利润统计-----------------
  l_get_date date := to_date(v_get_date, 'yyyymmddhh24miss');
begin
  ---1.获取利润收集时间
  if l_get_date is null then
    l_get_date := trunc(sysdate) - 1;
  end if;

  ---2.获取上游利润\上游统计排除指定下游
  insert into income_up_trade
    (id,
     trade_date,
     channel_no,
     province_no,
     trade_type,
     trade_amount,
     trade_profit)
    select seq_income_up_tradeid.nextval,
           l_get_date,
           tab.up_channel_no,
           tab.province_no,
           tab.statistics_type,
           tab.up_trade,
           tab.up_profit
      from (select t.up_channel_no,
                   t.province_no,
                   m.statistics_type,
                   sum(decode(t.change_type, 2, 1, -1) * t.up_draw_amount) up_trade,
                   sum(decode(t.change_type, 2, 1, -1) *
                       (t.down_real_amount - t.up_real_amount)) up_profit
              from fd_trade_up_fund t
             inner join fd_system_business_statis_map m
                on t.business_type = m.local_business_type
             where t.change_time >= l_get_date
               and t.change_time < (l_get_date + 1)
               and t.change_type in (2, 3)
               and t.up_channel_no not in ('0', '-')
               and t.down_channel_no != 'hzczth'
               and t.order_source in (1, 181)
             group by t.up_channel_no, t.province_no, m.statistics_type) tab;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('income_p_auto_down_profit_get', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_UP_PROFIT_BATCH
prompt ================================================
prompt
create or replace procedure fd_account.income_p_auto_up_profit_batch(v_start_date in varchar2,
                                                          v_end_date   in varchar2) as
  ------------------批量生成上游收入单元数据-----------------
  l_collect_date date;
begin
  l_collect_date := to_date(v_start_date, 'yyyymmddhh24miss');
  loop
    income_p_auto_up_profit_get(to_char(l_collect_date, 'yyyymmddhh24miss'));
    l_collect_date := l_collect_date + 1;
    exit when l_collect_date > to_date(v_end_date, 'yyyymmddhh24miss');
  end loop;
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_UP_PROFIT_GET_HS
prompt =================================================
prompt
create or replace procedure fd_account.income_p_auto_up_profit_get_hs(v_get_date in varchar2 default null) as
  ------------------收入单元上游利润统计-----------------
  l_get_date date := to_date(v_get_date, 'yyyymmddhh24miss');
begin
  ---1.获取利润收集时间
  if l_get_date is null then
    l_get_date := trunc(sysdate) - 1;
  end if;

  ---2.获取上游利润
  insert into income_up_trade
    (id,
     trade_date,
     channel_no,
     province_no,
     trade_type,
     trade_amount,
     trade_profit)
    select seq_income_up_tradeid.nextval,
           l_get_date,
           tab.up_channel_no,
           tab.province_no,
           tab.statistics_type,
           tab.up_trade,
           tab.up_profit
      from (select t.up_channel_no,
                   t.province_no,
                   m.statistics_type,
                   sum(decode(t.change_type, 2, 1, -1) * t.up_draw_amount) up_trade,
                   sum(decode(t.change_type, 2, 1, -1) *
                       (t.down_real_amount - t.up_real_amount)) up_profit
              from fd_trade_up_fund_hs t
             inner join fd_system_business_statis_map m
                on t.business_type = m.local_business_type
             where t.change_time >= l_get_date
               and t.change_time < (l_get_date + 1)
               and t.change_type in (2, 3)
               and t.up_channel_no not in ('0', '-')
               and t.down_channel_no != 'hzczth'
               and t.order_source in (1, 181)
             group by t.up_channel_no, t.province_no, m.statistics_type) tab;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('income_p_auto_up_profit_get_hs', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_UP_PROFIT_BTH_HS
prompt =================================================
prompt
create or replace procedure fd_account.income_p_auto_up_profit_bth_hs(v_start_date in varchar2,
                                                             v_end_date   in varchar2) as
  ------------------批量生成上游收入单元数据-----------------
  l_collect_date date;
begin
  l_collect_date := to_date(v_start_date, 'yyyymmddhh24miss');
  loop
    income_p_auto_up_profit_get_hs(to_char(l_collect_date,
                                           'yyyymmddhh24miss'));
    l_collect_date := l_collect_date + 1;
    exit when l_collect_date > to_date(v_end_date, 'yyyymmddhh24miss');
  end loop;
end;
/

prompt
prompt Creating procedure INCOME_P_AUTO_UP_RV_GET
prompt ==========================================
prompt
create or replace procedure fd_account.income_p_auto_up_rv_get(v_get_date in varchar2 default null) as
  -------------------非充、sp、收卡对应上游平账利润收集--------------------
  l_get_date     date := to_date(v_get_date, 'yyyymmddhh24miss');
  l_xnfc_down    varchar2(32) := 'rv_xnfc_down'; --虚拟的平账非充下游
  l_xnsp_down    varchar2(32) := 'rv_xnsp_down'; --虚拟的平账sp下游
  l_xnsk_down    varchar2(32) := 'rv_xnsk_down'; --虚拟的平账收卡下游
  l_fc_stat      number := 6; --非充分类编号
  l_sp_stat      number := 7; --sp分类编号
  l_sk_stat      number := 8; --收卡分类编号
  l_fc_rv_amount number;
  l_sp_rv_amount number;
  l_sk_rv_amount number;
begin
  ---1.获取利润收集时间
  if l_get_date is null then
    l_get_date := trunc(sysdate) - 1;
  end if;

  ---2.获取非充上游平账利润
  select nvl(sum(t.down_real_amount - t.up_real_amount), 0)
    into l_fc_rv_amount
    from fd_trade_up_fund t
   where t.change_time >= l_get_date
     and t.change_time < (l_get_date + 1)
     and t.change_type = 2
     and t.order_source = 0
     and t.down_channel_no in ('0', '-')
     and t.business_type in
         (select m.local_business_type
            from fd_system_business_statis_map m
           where m.statistics_type = l_fc_stat);

  if l_fc_rv_amount != 0 then
    insert into income_down_trade
      (id,
       trade_date,
       channel_no,
       trade_type,
       trade_amount,
       trade_rv_profit,
       trade_profit)
    values
      (seq_income_down_tradeid.nextval,
       l_get_date,
       l_xnfc_down,
       l_fc_stat,
       0,
       l_fc_rv_amount,
       l_fc_rv_amount);
  end if;

  ---3.获取sp上游平账利润
  select nvl(sum(t.up_real_amount - t.down_real_amount), 0)
    into l_sp_rv_amount
    from dk_trade_up_fund t
   where t.change_time >= l_get_date
     and t.change_time < (l_get_date + 1)
     and t.change_type = 2
     and t.order_source = 0
     and t.down_channel_no in ('0', '-')
     and t.business_type in
         (select m.local_business_type
            from fd_system_business_statis_map m
           where m.statistics_type = l_sp_stat);

  if l_sp_rv_amount != 0 then
    insert into income_down_trade
      (id,
       trade_date,
       channel_no,
       trade_type,
       trade_amount,
       trade_rv_profit,
       trade_profit)
    values
      (seq_income_down_tradeid.nextval,
       l_get_date,
       l_xnsp_down,
       l_sp_stat,
       0,
       l_sp_rv_amount,
       l_sp_rv_amount);
  end if;

  ---4.获取收卡上游平账利润
  select nvl(sum(t.up_real_amount - t.down_real_amount), 0)
    into l_sk_rv_amount
    from dk_trade_up_fund t
   where t.change_time >= l_get_date
     and t.change_time < (l_get_date + 1)
     and t.change_type = 2
     and t.order_source = 0
     and t.down_channel_no in ('0', '-')
     and t.business_type in
         (select m.local_business_type
            from fd_system_business_statis_map m
           where m.statistics_type = l_sk_stat);

  if l_sk_rv_amount != 0 then
    insert into income_down_trade
      (id,
       trade_date,
       channel_no,
       trade_type,
       trade_amount,
       trade_rv_profit,
       trade_profit)
    values
      (seq_income_down_tradeid.nextval,
       l_get_date,
       l_xnsk_down,
       l_sk_stat,
       0,
       l_sk_rv_amount,
       l_sk_rv_amount);
  end if;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('income_p_auto_up_rv_get', sqlerrm, 1);
  
end;
/

prompt
prompt Creating procedure INCOME_P_DOWN_CHANNEL_GROUPING
prompt =================================================
prompt
create or replace procedure fd_account.income_p_down_channel_grouping(v_down_group_id     number, ---下游收入单元分组编号
                                                           v_down_group_name   varchar2, ---下游收入单元分组名称
                                                           v_down_channel_no   varchar2, ---下游收入单元渠道名称
                                                           v_down_channel_name varchar2, ---下游渠道名称
                                                           v_result            out varchar2) as
  ----------------下游渠道收入单元分组数据同步----------------
begin
  v_result := income_f_down_channel_grouping(v_down_group_id,
                                             v_down_group_name,
                                             v_down_channel_no,
                                             v_down_channel_name);
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('income_p_down_channel_grouping', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure INCOME_P_UP_EXCLUDE_SYNC
prompt ===========================================
prompt
create or replace procedure fd_account.income_p_up_exclude_sync(v_up_channel_no varchar2,
                                                     v_need_exclude  number, --需要排除，0需要，1不需要
                                                     v_result        out varchar2) as
  ---------------上游排除统计渠道同步-------------
begin
  v_result := income_f_up_exclude_sync(v_up_channel_no, v_need_exclude);

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('income_p_up_exclude_sync', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure INCOME_P_UP_PROVINCE_GROUPING
prompt ================================================
prompt
create or replace procedure fd_account.income_p_up_province_grouping(v_up_group_id   number, ---上游收入单元分组编号
                                                          v_up_group_name varchar2, ---上游收入单元分组名称
                                                          v_province_no   varchar2, ---上游收入单元省份名称
                                                          v_result        out varchar2) as
  ----------------上游省份收入单元分组数据同步----------------
  l_up_group_count    number;
  l_up_province_count number;
begin
  --1.检查分组数据是否存在
  select count(1)
    into l_up_group_count
    from fd_system_dictionary t
   where t.belong_enum = 'UpIncomeGroup'
     and t.value = v_up_group_id;

  --2.分组不存在创建分组
  if l_up_group_count = 0 then
    insert into fd_system_dictionary
      (id,
       value,
       description,
       belong_enum,
       sort_id,
       group_id,
       belong_system,
       status)
    values
      (seq_system_dictionary_id.nextval,
       v_up_group_id,
       v_up_group_name,
       'UpIncomeGroup',
       0,
       '*',
       '*',
       0);
  end if;

  --3.检查省份分组数据是否存在
  select count(1)
    into l_up_province_count
    from income_up_group_map t
   where t.province_no = v_province_no;

  --4.创建修改省份分组信息
  if l_up_province_count > 0 then
    update income_up_group_map t
       set t.up_group_id = v_up_group_id
     where t.province_no = v_province_no;
  else
    insert into income_up_group_map
      (id, province_no, up_group_id)
    values
      (seq_income_up_group_mapid.nextval, v_province_no, v_up_group_id);
  end if;

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('income_p_up_province_grouping', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure RPT_P_AUTO_UNIT_DOWN_DK_GET
prompt ==============================================
prompt
create or replace procedure fd_account.rpt_p_auto_unit_down_dk_get(v_collect_date in varchar2 default null) as
  ----------------收入单元下游代扣交易信息收集---------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  l_record_count number;
begin
  ---1.获取收集交易信息的日期
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---2.循环获取渠道交易信息
  for item in (select m.down_channel_no,
                      m.channel_name,
                      m.down_company_id,
                      m.order_source,
                      m.business_type,
                      m.trade_count,
                      m.trade_debit,
                      (m.trade_profit - nvl(s.sys_paid_money, 0)) trade_profit,
                      m.rv_amount
                 from (select f.down_channel_no,
                              max(c.channel_name) channel_name,
                              f.down_company_id,
                              f.order_source,
                              f.business_type,
                              count(1) trade_count,
                              sum(decode(f.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) *
                                  decode(f.dk_order_id,
                                         0,
                                         0,
                                         f.down_draw_amount)) trade_debit, ---排除掉平账的扣款
                              sum(decode(f.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) *
                                  decode(f.dk_order_id,
                                         0,
                                         0,
                                         (f.up_real_amount -
                                         f.down_real_amount))) trade_profit, ---排除掉平账的利润
                              sum(decode(f.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) * decode(f.dk_order_id,
                                                      0,
                                                      f.down_real_amount,
                                                      0)) rv_amount ---交易平账影响利润的金额
                         from dk_trade_up_fund f
                        inner join dk_base_down_channel c on f.down_channel_no =
                                                             c.channel_no
                        where f.change_time > l_collect_date
                          and f.change_time < (l_collect_date + 1)
                          and f.down_channel_no != '0' ---排除掉上游交易平账的数据
                          and f.down_account_id != 0
                          and f.change_type in
                              (pkg_up_fund_change_type.debit_amount,
                               pkg_up_fund_change_type.refund_amount)
                        group by f.down_channel_no,
                                 f.down_company_id,
                                 f.order_source,
                                 f.business_type) m
                 left join (select d.channel_no,
                                  d.business_type,
                                  sum(d.sys_cost) sys_paid_money
                             from dk_trade_refund_sys_cost d
                            where trunc(d.record_date, 'dd') =
                                  l_collect_date
                            group by d.channel_no, d.business_type) s on m.down_channel_no =
                                                                         s.channel_no
                                                                     and m.business_type =
                                                                         s.business_type) loop
    begin
      ---3.检查数据是否存在
      select count(1)
        into l_record_count
        from rpt_unit_report_trade t
       where t.snap_time = l_collect_date
         and t.channel_no = item.down_channel_no
         and t.channel_type = pkg_channel_type.up_channel
         and t.company_id = item.down_company_id
         and t.source_system_id = item.order_source
         and t.business_type = item.business_type
         and t.is_history_data = pkg_sys_boolean.isfalse;
    
      ---4.没有添加渠道交易信息，则添加
      if l_record_count = 0 then
        insert into rpt_unit_report_trade
          (id,
           channel_no,
           channel_name,
           channel_type,
           company_id,
           source_system_id,
           business_type,
           trade_count,
           trade_debit_amount,
           trade_profit,
           rv_amount,
           is_history_data,
           snap_time,
           sys_no)
        values
          (seq_rpt_report_trade_id.nextval,
           item.down_channel_no,
           item.channel_name,
           pkg_channel_type.up_channel,
           item.down_company_id,
           item.order_source,
           item.business_type,
           item.trade_count,
           item.trade_debit,
           item.trade_profit,
           item.rv_amount,
           pkg_sys_boolean.isfalse,
           l_collect_date,
           'dk');
      end if;
    
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('rpt_p_auto_unit_down_dk_get', sqlerrm, 1);
        fd_p_b2e_warn_info_set('auto_err' ||
                               to_char(sysdate, 'yyyymmddhh24miss'),
                               pkg_warn_into_type.auto_error,
                               '时间:' ||
                               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                               ' 自动生成代扣下游收入单元利润数据错误.',
                               '时间:' ||
                               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                               '自动生成代扣下游收入单元利润数据错误',
                               '存储过程自动脚本执行错误');
    end;
  end loop;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('rpt_p_auto_unit_down_dk_get', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure RPT_P_AUTO_UNIT_DOWN_TRADE_GET
prompt =================================================
prompt
create or replace procedure fd_account.rpt_p_auto_unit_down_trade_get(v_collect_date in varchar2 default null) as
  ----------------收入单元下游交易信息收集---------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  l_record_count number;
begin
  ---1.获取收集交易信息的日期
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---2.循环获取渠道交易信息
  for item in (select f.down_channel_no,
                      max(c.channel_name) channel_name,
                      f.down_company_id,
                      f.order_source,
                      f.business_type,
                      count(1) trade_count,
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.fd_order_id, 0, 0, f.down_draw_amount)) trade_debit, ---排除掉平账的扣款
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.fd_order_id,
                                 0,
                                 0,
                                 (f.down_real_amount - f.up_real_amount))) trade_profit, ---排除掉平账的利润
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.fd_order_id, 0, f.down_real_amount, 0)) rv_amount ---交易平账影响利润的金额
                 from fd_trade_up_fund f
                inner join fd_base_down_channel c on f.down_channel_no =
                                                     c.channel_no
                where f.change_time >= l_collect_date
                  and f.change_time < (l_collect_date + 1)
                  and f.down_channel_no != '0' ---排除掉上游交易平账的数据
                  and f.down_account_id != 0
                  and f.change_type in
                      (pkg_up_fund_change_type.debit_amount,
                       pkg_up_fund_change_type.refund_amount)
                group by f.down_channel_no,
                         f.down_company_id,
                         f.order_source,
                         f.business_type) loop
    begin
      ---3.检查数据是否存在
      select count(1)
        into l_record_count
        from rpt_unit_report_trade t
       where t.snap_time = l_collect_date
         and t.channel_no = item.down_channel_no
         and t.channel_type = pkg_channel_type.down_channel
         and t.company_id = item.down_company_id
         and t.source_system_id = item.order_source
         and t.business_type = item.business_type
         and t.is_history_data = pkg_sys_boolean.isfalse;
    
      ---4.没有添加渠道交易信息，则添加
      if l_record_count = 0 then
        insert into rpt_unit_report_trade
          (id,
           channel_no,
           channel_name,
           channel_type,
           company_id,
           source_system_id,
           business_type,
           trade_count,
           trade_debit_amount,
           trade_profit,
           rv_amount,
           is_history_data,
           snap_time,
           sys_no)
        values
          (seq_rpt_report_trade_id.nextval,
           item.down_channel_no,
           item.channel_name,
           pkg_channel_type.down_channel,
           item.down_company_id,
           item.order_source,
           item.business_type,
           item.trade_count,
           item.trade_debit,
           item.trade_profit,
           item.rv_amount,
           pkg_sys_boolean.isfalse,
           l_collect_date,
           'fd');
      end if;
    
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('rpt_p_auto_unit_down_trade_get', sqlerrm, 1);
        fd_p_b2e_warn_info_set('auto_err' ||
                               to_char(sysdate, 'yyyymmddhh24miss'),
                               pkg_warn_into_type.auto_error,
                               '时间:' ||
                               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                               ' 自动生成下游收入单元利润数据错误.',
                               '时间:' ||
                               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                               '自动生成下游收入单元利润数据错误',
                               '存储过程自动脚本执行错误');
    end;
  end loop;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('rpt_p_auto_unit_down_trade_get', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure RPT_P_AUTO_UNIT_DOWN_TRADE_HS
prompt ================================================
prompt
create or replace procedure fd_account.rpt_p_auto_unit_down_trade_hs(v_collect_date in varchar2 default null) as
  ----------------收入单元下游交易信息收集---------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  l_record_count number;
begin
  ---1.获取收集交易信息的日期
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---2.循环获取渠道交易信息
  for item in (select f.down_channel_no,
                      max(c.channel_name) channel_name,
                      f.down_company_id,
                      f.order_source,
                      f.business_type,
                      count(1) trade_count,
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.fd_order_id, 0, 0, f.down_draw_amount)) trade_debit, ---排除掉平账的扣款
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.fd_order_id,
                                 0,
                                 0,
                                 (f.down_real_amount - f.up_real_amount))) trade_profit, ---排除掉平账的利润
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.fd_order_id, 0, f.down_real_amount, 0)) rv_amount ---交易平账影响利润的金额
                 from fd_trade_up_fund_hs f
                inner join fd_base_down_channel c on f.down_channel_no =
                                                     c.channel_no
                where f.change_time >= l_collect_date
                  and f.change_time < (l_collect_date + 1)
                  and f.down_channel_no != '0' ---排除掉上游交易平账的数据
                  and f.down_account_id != 0
                  and f.change_type in
                      (pkg_up_fund_change_type.debit_amount,
                       pkg_up_fund_change_type.refund_amount)
                group by f.down_channel_no,
                         f.down_company_id,
                         f.order_source,
                         f.business_type) loop
    begin
      ---3.检查数据是否存在
      select count(1)
        into l_record_count
        from rpt_unit_report_trade t
       where t.snap_time = l_collect_date
         and t.channel_no = item.down_channel_no
         and t.channel_type = pkg_channel_type.down_channel
         and t.company_id = item.down_company_id
         and t.source_system_id = item.order_source
         and t.business_type = item.business_type
         and t.is_history_data = pkg_sys_boolean.istrue;
    
      ---4.没有添加渠道交易信息，则添加
      if l_record_count = 0 then
        insert into rpt_unit_report_trade
          (id,
           channel_no,
           channel_name,
           channel_type,
           company_id,
           source_system_id,
           business_type,
           trade_count,
           trade_debit_amount,
           trade_profit,
           rv_amount,
           is_history_data,
           snap_time,
           sys_no)
        values
          (seq_rpt_report_trade_id.nextval,
           item.down_channel_no,
           item.channel_name,
           pkg_channel_type.down_channel,
           item.down_company_id,
           item.order_source,
           item.business_type,
           item.trade_count,
           item.trade_debit,
           item.trade_profit,
           item.rv_amount,
           pkg_sys_boolean.istrue,
           l_collect_date,
           'fd');
      end if;
    
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('rpt_p_auto_unit_down_trade_hs', sqlerrm, 1);
        fd_p_b2e_warn_info_set('auto_err' ||
                               to_char(sysdate, 'yyyymmddhh24miss'),
                               pkg_warn_into_type.auto_error,
                               '时间:' ||
                               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                               ' 自动生成下游收入单元利润数据错误.',
                               '时间:' ||
                               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                               '自动生成下游收入单元利润数据错误',
                               '存储过程自动脚本执行错误');
    end;
  end loop;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('rpt_p_auto_unit_down_trade_hs', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure RPT_P_AUTO_UNIT_UP_DK_GET
prompt ============================================
prompt
create or replace procedure fd_account.rpt_p_auto_unit_up_dk_get(v_collect_date in varchar2 default null) as
  ----------------收入单元上游代扣交易信息收集---------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  l_record_count number;
begin
  ---1.获取收集交易信息的日期
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---2.循环获取渠道交易信息
  for item in (select f.up_channel_no,
                      max(c.channel_name) channel_name,
                      f.up_company_id,
                      f.order_source,
                      f.business_type,
                      count(1) trade_count,
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.dk_order_id, 0, 0, f.up_draw_amount)) trade_debit, ---排除上游交易平账的扣款
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.dk_order_id,
                                 0,
                                 0,
                                 (f.up_real_amount - f.down_real_amount))) trade_profit, ---排除上游交易平账的利润
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.dk_order_id, 0, f.up_real_amount, 0)) rv_amount ---上游交易平账影响利润的金额
                 from dk_trade_up_fund f
                inner join dk_base_up_channel c on f.up_channel_no =
                                                   c.channel_no
                where f.change_time >= l_collect_date
                  and f.change_time < (l_collect_date + 1)
                  and f.up_channel_no != '0' ---排除掉下游交易平账的数据
                  and f.up_account_id != 0
                  and f.change_type in
                      (pkg_up_fund_change_type.debit_amount,
                       pkg_up_fund_change_type.refund_amount)
                group by f.up_channel_no,
                         f.up_company_id,
                         f.order_source,
                         f.business_type) loop
    begin
      ---3.检查数据是否存在
      select count(1)
        into l_record_count
        from rpt_unit_report_trade t
       where t.snap_time = l_collect_date
         and t.channel_no = item.up_channel_no
         and t.channel_type = pkg_channel_type.down_channel
         and t.company_id = item.up_company_id
         and t.source_system_id = item.order_source
         and t.business_type = item.business_type
         and t.is_history_data = pkg_sys_boolean.isfalse;
    
      ---4.没有添加渠道交易信息，则添加
      if l_record_count = 0 then
        insert into rpt_unit_report_trade
          (id,
           channel_no,
           channel_name,
           channel_type,
           company_id,
           source_system_id,
           business_type,
           trade_count,
           trade_debit_amount,
           trade_profit,
           rv_amount,
           is_history_data,
           snap_time,
           sys_no)
        values
          (seq_rpt_report_trade_id.nextval,
           item.up_channel_no,
           item.channel_name,
           pkg_channel_type.down_channel,
           item.up_company_id,
           item.order_source,
           item.business_type,
           item.trade_count,
           item.trade_debit,
           item.trade_profit,
           item.rv_amount,
           pkg_sys_boolean.isfalse,
           l_collect_date,
           'dk');
      end if;
    
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('rpt_p_auto_unit_up_dk_get', sqlerrm, 1);
        fd_p_b2e_warn_info_set('auto_err' ||
                               to_char(sysdate, 'yyyymmddhh24miss'),
                               pkg_warn_into_type.auto_error,
                               '时间:' ||
                               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                               ' 自动生成代扣上游收入单元利润数据错误.',
                               '时间:' ||
                               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                               '自动生成代扣上游收入单元利润数据错误',
                               '存储过程自动脚本执行错误');
    end;
  end loop;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('rpt_p_auto_unit_up_dk_get', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure RPT_P_AUTO_UNIT_UP_TRADE_GET
prompt ===============================================
prompt
create or replace procedure fd_account.rpt_p_auto_unit_up_trade_get(v_collect_date in varchar2 default null) as
  ----------------收入单元上游交易信息收集---------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  l_record_count number;
begin
  ---1.获取收集交易信息的日期
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---2.循环获取渠道交易信息
  for item in (select f.up_channel_no,
                      max(c.channel_name) channel_name,
                      f.up_company_id,
                      f.order_source,
                      f.business_type,
                      count(1) trade_count,
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.fd_order_id, 0, 0, f.up_draw_amount)) trade_debit, ---排除上游交易平账的扣款
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.fd_order_id,
                                 0,
                                 0,
                                 (f.down_real_amount - f.up_real_amount))) trade_profit, ---排除上游交易平账的利润
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.fd_order_id, 0, f.up_real_amount, 0)) rv_amount ---上游交易平账影响利润的金额
                 from fd_trade_up_fund f
                inner join fd_base_up_channel c on f.up_channel_no =
                                                   c.channel_no
                where f.change_time >= l_collect_date
                  and f.change_time < (l_collect_date + 1)
                  and f.up_channel_no != '0' ---排除掉下游交易平账的数据
                  and f.up_account_id != 0
                  and f.change_type in
                      (pkg_up_fund_change_type.debit_amount,
                       pkg_up_fund_change_type.refund_amount)
                group by f.up_channel_no,
                         f.up_company_id,
                         f.order_source,
                         f.business_type) loop
    begin
      ---3.检查数据是否存在
      select count(1)
        into l_record_count
        from rpt_unit_report_trade t
       where t.snap_time = l_collect_date
         and t.channel_no = item.up_channel_no
         and t.channel_type = pkg_channel_type.up_channel
         and t.company_id = item.up_company_id
         and t.source_system_id = item.order_source
         and t.business_type = item.business_type
         and t.is_history_data = pkg_sys_boolean.isfalse;
    
      ---4.没有添加渠道交易信息，则添加
      if l_record_count = 0 then
        insert into rpt_unit_report_trade
          (id,
           channel_no,
           channel_name,
           channel_type,
           company_id,
           source_system_id,
           business_type,
           trade_count,
           trade_debit_amount,
           trade_profit,
           rv_amount,
           is_history_data,
           snap_time,
           sys_no)
        values
          (seq_rpt_report_trade_id.nextval,
           item.up_channel_no,
           item.channel_name,
           pkg_channel_type.up_channel,
           item.up_company_id,
           item.order_source,
           item.business_type,
           item.trade_count,
           item.trade_debit,
           item.trade_profit,
           item.rv_amount,
           pkg_sys_boolean.isfalse,
           l_collect_date,
           'fd');
      end if;
    
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('rpt_p_auto_unit_up_trade_get', sqlerrm, 1);
        fd_p_b2e_warn_info_set('auto_err' ||
                               to_char(sysdate, 'yyyymmddhh24miss'),
                               pkg_warn_into_type.auto_error,
                               '时间:' ||
                               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                               ' 自动生成上游收入单元利润数据错误.',
                               '时间:' ||
                               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                               '自动生成上游收入单元利润数据错误',
                               '存储过程自动脚本执行错误');
    end;
  end loop;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('rpt_p_auto_unit_up_trade_get', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure RPT_P_AUTO_UNIT_UP_TRADE_HS
prompt ==============================================
prompt
create or replace procedure fd_account.rpt_p_auto_unit_up_trade_hs(v_collect_date in varchar2 default null) as
  ----------------收入单元上游交易信息收集---------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  l_record_count number;
begin
  ---1.获取收集交易信息的日期
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---2.循环获取渠道交易信息
  for item in (select f.up_channel_no,
                      max(c.channel_name) channel_name,
                      f.up_company_id,
                      f.order_source,
                      f.business_type,
                      count(1) trade_count,
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.fd_order_id, 0, 0, f.up_draw_amount)) trade_debit, ---排除上游交易平账的扣款
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.fd_order_id,
                                 0,
                                 0,
                                 (f.down_real_amount - f.up_real_amount))) trade_profit, ---排除上游交易平账的利润
                      sum(decode(f.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) *
                          decode(f.fd_order_id, 0, f.up_real_amount, 0)) rv_amount ---上游交易平账影响利润的金额
                 from fd_trade_up_fund_hs f
                inner join fd_base_up_channel c on f.up_channel_no =
                                                   c.channel_no
                where f.change_time >= l_collect_date
                  and f.change_time < (l_collect_date + 1)
                  and f.up_channel_no != '0' ---排除掉下游交易平账的数据
                  and f.up_account_id != 0
                  and f.change_type in
                      (pkg_up_fund_change_type.debit_amount,
                       pkg_up_fund_change_type.refund_amount)
                group by f.up_channel_no,
                         f.up_company_id,
                         f.order_source,
                         f.business_type) loop
    begin
      ---3.检查数据是否存在
      select count(1)
        into l_record_count
        from rpt_unit_report_trade t
       where t.snap_time = l_collect_date
         and t.channel_no = item.up_channel_no
         and t.channel_type = pkg_channel_type.up_channel
         and t.company_id = item.up_company_id
         and t.source_system_id = item.order_source
         and t.business_type = item.business_type
         and t.is_history_data = pkg_sys_boolean.istrue;
    
      ---4.没有添加渠道交易信息，则添加
      if l_record_count = 0 then
        insert into rpt_unit_report_trade
          (id,
           channel_no,
           channel_name,
           channel_type,
           company_id,
           source_system_id,
           business_type,
           trade_count,
           trade_debit_amount,
           trade_profit,
           rv_amount,
           is_history_data,
           snap_time,
           sys_no)
        values
          (seq_rpt_report_trade_id.nextval,
           item.up_channel_no,
           item.channel_name,
           pkg_channel_type.up_channel,
           item.up_company_id,
           item.order_source,
           item.business_type,
           item.trade_count,
           item.trade_debit,
           item.trade_profit,
           item.rv_amount,
           pkg_sys_boolean.istrue,
           l_collect_date,
           'fd');
      end if;
    
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('rpt_p_auto_unit_up_trade_get_hs', sqlerrm, 1);
        fd_p_b2e_warn_info_set('auto_err' ||
                               to_char(sysdate, 'yyyymmddhh24miss'),
                               pkg_warn_into_type.auto_error,
                               '时间:' ||
                               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                               ' 自动生成上游收入单元利润数据错误.',
                               '时间:' ||
                               to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') ||
                               '自动生成上游收入单元利润数据错误',
                               '存储过程自动脚本执行错误');
    end;
  end loop;

  commit;
exception
  when others then
    rollback;
    fd_p_write_log('rpt_p_auto_unit_up_trade_get_hs', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure SP_SYNC_CHANNEL_INFO
prompt =======================================
prompt
create or replace procedure fd_account.sp_sync_channel_info(v_channel_no          varchar2, -- 渠道编号
                                                 v_channel_name        varchar2, -- 渠道名称
                                                 v_channel_type        number, -- 渠道类型: 1-上游渠道 2-下游渠道
                                                 v_company_id          number, -- 公司编号
                                                 v_status              number, -- 渠道状态: 0-启用 1-禁用
                                                 v_is_back             number, -- 是否后返佣金: 0-需要 1-不需要
                                                 v_bus_type            number, -- 渠道业务类型
                                                 v_capital_class       number, -- 渠道资金分类: 1-普通话费 2-普通流量 3-特殊话费 4-特殊流量 0-其他渠道
                                                 v_bill_type           number, -- 开票类型: 1-前向 2-后向
                                                 v_manage_user         varchar2, -- 管理人员
                                                 v_system_no           number, -- 系统编号
                                                 v_up_exclude          number, -- 上游是否需要排除: 0-需要排除 1-不需要排除(下游渠道传1)
                                                 v_down_group_id       number, -- 下游分组编号(上游传0)
                                                 v_down_group_name     varchar2, -- 下游分组名称(上游传空)
                                                 v_channel_create_date varchar2, ---创建时间yyyy-mm-dd hh24:mi:ss
                                                 v_channel_create_user varchar2, ---创建人
                                                 v_channel_company     varchar2,
                                                 v_out_status          out number -- 状态: 100-成功 200-失败
                                                 ) as
  l_number              number;
  l_status              number;
  l_reslut              varchar2(32);
  l_channel_create_user varchar2(32);
  --主要功能:更新渠道名称
begin
  l_status := v_status;
  if (l_status is not null and l_status <> 0) then
    l_status := 1;
  end if;
  l_channel_create_user := '_sys';
  if v_channel_create_user is not null then
    l_channel_create_user := v_channel_create_user;
  end if;
  if (v_channel_type = 1) then
    select count(*)
      into l_number
      from fd_base_up_channel t
     inner join fd_base_up_system_map k on k.channel_no = t.channel_no
     where t.channel_no = v_channel_no
       and k.source_system_id = v_system_no;
    if (l_number >= 1) then
      update fd_base_up_channel t
         set t.channel_name    = v_channel_name,
             t.company_id      = v_company_id,
             t.status          = v_status,
             t.need_commi      = v_is_back,
             t.classification  = nvl(v_bus_type, t.classification),
             t.capital_class   = nvl(v_capital_class, 0),
             t.bill_type       = nvl(v_bill_type, 1),
             t.manage_user     = v_manage_user,
             t.channel_company = v_channel_company
       where t.channel_no = v_channel_no;
      if (sql%rowcount >= 1) then
        /*        l_reslut := income_f_up_exclude_sync(v_channel_no, v_up_exclude);
          if l_reslut != pkg_error_code.success then
            v_out_status := 200;
            rollback;
            return;
          end if;
        */
        v_out_status := 100;
      else
        v_out_status := 200;
      end if;
      commit;
      return;
    end if;
    insert into fd_base_up_channel
      (channel_no,
       channel_name,
       status,
       service_fee,
       company_id,
       created_by,
       created_time,
       need_commi,
       classification,
       capital_class,
       bill_type,
       manage_user,
       channel_company)
    values
      (v_channel_no,
       v_channel_name,
       l_status,
       0,
       v_company_id,
       l_channel_create_user,
       to_date(v_channel_create_date, 'yyyy-mm-dd hh24:mi:ss'),
       v_is_back,
       v_bus_type,
       v_capital_class,
       v_bill_type,
       v_manage_user,
       v_channel_company);
  
    l_number := seq_base_up_account_id.nextval;
    insert into fd_base_up_account
      (account_id,
       account_name,
       account_type,
       query_balance,
       inner_balance,
       status,
       created_by)
    values
      (l_number, v_channel_name || '支付', 1, 0, 0, 0, '_sys');
    insert into fd_base_up_account_map
      (map_id, channel_no, account_id, is_main_channel)
    values
      (seq_base_up_account_map_id.nextval, v_channel_no, l_number, 0);
    insert into fd_base_up_system_map
    values
      (seq_base_up_system_map_id.nextval,
       nvl(v_system_no, 1),
       v_channel_no);
    if (sql%rowcount >= 1) then
      /*      l_reslut := income_f_up_exclude_sync(v_channel_no, v_up_exclude);
      if l_reslut != pkg_error_code.success then
        v_out_status := 200;
        rollback;
        return;
      end if;*/
    
      v_out_status := 100;
    else
      v_out_status := 200;
    end if;
  else
    select count(*)
      into l_number
      from fd_base_down_channel t
     inner join fd_base_down_system_map k on k.channel_no = t.channel_no
     where t.channel_no = v_channel_no
       and k.source_system_id = v_system_no;
    if (l_number >= 1) then
      update fd_base_down_channel t
         set t.channel_name    = v_channel_name,
             t.company_id      = v_company_id,
             t.status          = v_status,
             t.need_commi      = v_is_back,
             t.channel_company = v_channel_company
       where t.channel_no = v_channel_no;
      if (sql%rowcount >= 1) then
        l_reslut := income_f_down_channel_grouping(v_down_group_id,
                                                   v_down_group_name,
                                                   v_channel_no,
                                                   v_channel_name);
        if l_reslut != pkg_error_code.success then
          v_out_status := 200;
          rollback;
          return;
        end if;
      
        v_out_status := 100;
      else
        v_out_status := 200;
      end if;
      commit;
      return;
    end if;
    insert into fd_base_down_channel
      (channel_no,
       channel_name,
       service_fee,
       company_id,
       status,
       created_by,
       created_time,
       need_commi,
       manage_user,
       channel_company)
    values
      (v_channel_no,
       v_channel_name,
       0,
       v_company_id,
       l_status,
       l_channel_create_user,
       to_date(v_channel_create_date, 'yyyy-mm-dd hh24:mi:ss'),
       v_is_back,
       v_manage_user,
       v_channel_company);
    l_number := seq_base_down_account_id.nextval;
    insert into fd_base_down_account
      (account_id,
       account_name,
       query_balance,
       inner_balance,
       credit_money,
       status,
       created_by)
    values
      (l_number, v_channel_name || '支付', 0, 0, 0, 0, '_sys');
    insert into fd_base_down_account_map
      (map_id, channel_no, account_id, is_main_channel)
    values
      (seq_base_up_account_map_id.nextval, v_channel_no, l_number, 0);
    insert into fd_base_down_system_map
    values
      (seq_base_down_system_map_id.nextval,
       nvl(v_system_no, 1),
       v_channel_no);
    if (sql%rowcount >= 1) then
      l_reslut := income_f_down_channel_grouping(v_down_group_id,
                                                 v_down_group_name,
                                                 v_channel_no,
                                                 v_channel_name);
      if l_reslut != pkg_error_code.success then
        v_out_status := 200;
        rollback;
        return;
      end if;
    
      v_out_status := 100;
    else
      v_out_status := 200;
    end if;
  end if;
  commit;
exception
  when others then
    fd_p_write_log('sp_sync_channel_info', sqlerrm, 200);
    rollback;
end;
/

prompt
prompt Creating procedure SP_SYNC_CHANNEL_STATUS
prompt =========================================
prompt
create or replace procedure fd_account.sp_sync_channel_status(v_channel_no   varchar2,
                                                   v_channel_type number,
                                                   v_status       number,
                                                   v_out_status   out number --100 成功 200 失败
                                                   ) as
  l_status number;
begin
  l_status := v_status;
  if (l_status <> 0) then
    l_status := 1;
  end if;
  if (v_channel_type = 1) then
    update fd_base_up_channel t
       set t.status = l_status
     where t.channel_no = v_channel_no;
  else
    update fd_base_down_channel t
       set t.status = l_status
     where t.channel_no = v_channel_no;
  end if;

  if (sql%rowcount >= 1) then
    v_out_status := 100;
  else
    v_out_status := 200;
  end if;

  commit;
end;
/

prompt
prompt Creating procedure SP_SYNC_DK_CHANNEL
prompt =====================================
prompt
create or replace procedure fd_account.sp_sync_dk_channel(v_channel_no   varchar2,
                                               v_channel_name varchar2,
                                               v_company_no   varchar2,
                                               v_system_no    varchar2,
                                               v_channel_type number, --1:上游 2:下游
                                               v_ret_code     out number) as
  /*
  功能:sp同步渠道
  作者:jiyi
  时间:2016-12-21
  */
  l_account_id number;
  l_msg        varchar2(1024);
begin
  if (v_channel_type = 1) then
    insert into dk_base_up_channel
      (channel_no,
       channel_name,
       status,
       service_fee,
       company_id,
       created_by,
       created_time,
       last_edit_user,
       last_edit_time,
       commi_balance,
       max_add,
       min_add,
       need_commi)
    values
      (v_channel_no,
       v_channel_name,
       0,
       0,
       v_company_no,
       'admin',
       sysdate,
       'admin',
       sysdate,
       0,
       0,
       0,
       1);

    l_account_id := seq_dk_up_account_id.nextval;
    insert into dk_base_up_account
      (account_id,
       account_name,
       query_balance,
       inner_balance,
       status,
       created_by,
       created_time,
       last_edit_user,
       last_edit_time,
       account_type)
    values
      (l_account_id,
       v_channel_name,
       0,
       0,
       0,
       'admin',
       sysdate,
       'admin',
       sysdate,
       1);

    insert into dk_base_up_account_map
      (map_id, channel_no, account_id, is_main_channel)
    values
      (seq_base_up_account_map_id.nextval, v_channel_no, l_account_id, 0);

    insert into dk_base_up_system_map
      (map_id, source_system_id, channel_no)
    values
      (seq_base_up_system_map_id.nextval, v_system_no, v_channel_no);
  else
    insert into dk_base_down_channel
      (channel_no,
       channel_name,
       service_fee,
       company_id,
       status,
       created_by,
       created_time,
       last_edit_user,
       last_edit_time,
       commi_balance,
       need_commi)
    values
      (v_channel_no,
       v_channel_name,
       0,
       v_company_no,
       0,
       'admin',
       sysdate,
       'admin',
       sysdate,
       0,
       1);

    l_account_id := seq_dk_base_down_account_id.nextval;
    insert into dk_base_down_account
      (account_id,
       account_name,
       query_balance,
       inner_balance,
       status,
       created_by,
       created_time,
       last_edit_user,
       last_edit_time)
    values
      (l_account_id,
       v_channel_name,
       0,
       0,
       0,
       'admin',
       sysdate,
       'admin',
       sysdate);

    insert into dk_base_down_account_map
      (map_id, channel_no, account_id, is_main_channel)
    values
      (seq_dk_down_account_map_id.nextval, v_channel_no, l_account_id, 0);

    insert into dk_base_down_system_map
      (map_id, source_system_id, channel_no)
    values
      (seq_base_down_system_map_id.nextval, v_system_no, v_channel_no);
  end if;

  v_ret_code := 100;
  commit;
exception
  when others then
    rollback;
    v_ret_code := 200;
    l_msg      := sqlerrm || ',' || dbms_utility.format_error_backtrace;
end;
/

prompt
prompt Creating procedure SUP_P_AUTO_DOWN_DAILY_MANUAL
prompt ===============================================
prompt
create or replace procedure fd_account.sup_p_auto_down_daily_manual(v_report_date in varchar2 default null) as
  -----------------收集sup上游加款日报表信息--------------
  l_report_date date := to_date(v_report_date, 'yyyymmddhh24miss');

begin
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  ---1.收集日期当天的下游加款数据

  for item in (select l_report_date as record_date,
                      t.down_channel_no,
                      t.down_account_id,
                      dc.company_id,
                      dc.source_system_id,
                      sum(decode(t.change_type,
                                 pkg_sup_up_manual_type.pick_amount,
                                 -1,
                                 pkg_sup_up_manual_type.red_pick,
                                 -1,
                                 1) * t.change_amount) change_amount
                 from sup_trade_down_manual t
                inner join sup_base_down_channel dc
                   on dc.channel_no = t.down_channel_no
                where t.change_time >= l_report_date
                  and t.change_time < (l_report_date + 1)
                  and t.change_type != pkg_sup_up_manual_type.trade_revise
                group by t.down_channel_no,
                         t.down_account_id,
                         dc.company_id,
                         dc.source_system_id) loop
  
    ---2.循环添加下游数据到sup加款日报表
  
    -----2循环开始-----
    begin
    
      ---2.1添加数据
      insert into sup_report_daily_manual
        (record_id,
         report_date,
         channel_no,
         account_id,
         company_id,
         system_id,
         channel_type,
         way_change_count,
         way_change_face,
         way_change_amount,
         physical_change_count,
         physical_change_face,
         physical_change_amount,
         electronic_change_count,
         electronic_change_face,
         electronic_change_amount)
      values
        (seq_sup_report_daily_manual_id.nextval,
         item.record_date,
         item.down_channel_no,
         item.down_account_id,
         item.company_id,
         item.source_system_id,
         pkg_channel_type.down_channel,
         0,
         0,
         0,
         0,
         0,
         0,
         0,
         0,
         item.change_amount);
      commit;
    exception
      when others then
        rollback;
        insert into fd_system_warn
          (warn_id,
           uniq_id,
           warn_level,
           warn_type,
           title,
           warn_date,
           content,
           sync_status,
           key_word)
        values
          (seq_system_warn_id.nextval,
           'sup_p_down_report_daily_manual failed',
           5,
           pkg_warn_into_type.auto_error,
           'sup加款日报表自动报警',
           sysdate,
           'sup加款日报表自动报警',
           pkg_balance_sync_status.wait,
           '自动报警');
        commit;
        fd_p_write_log('sup_p_down_report_daily_manual', sqlerrm, 1);
      
    end;
  end loop;
  -----2循环结束-----

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_down_report_daily_manual', sqlerrm, 1);
  
end;
/

prompt
prompt Creating procedure SUP_P_AUTO_DOWN_DAILY_TRADE
prompt ==============================================
prompt
create or replace procedure fd_account.sup_p_auto_down_daily_trade(v_report_date in varchar2 default null) as
  -----------------收集sup下游交易日报表信息--------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_wait_count      number := 0;
  l_statistics_type number := 0; --数据出现错误，统计类型为0

begin
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查(若有数据则执行1~2，反之直接返回)
  select count(1)
    into l_wait_count
    from sup_trade_up_fund t
   where t.change_time >= l_report_date
     and t.change_time < (l_report_date + 1)
     and t.change_type in
         (pkg_sup_up_fund_type.debit_amount,
          pkg_sup_up_fund_type.refund_amount)
     and rownum <= 2;

  if l_wait_count = 0 then
    return;
  end if;

  ---1.收集日期当天的下游渠道交易数据
  for item in (select l_report_date as record_date,
                      t.down_channel_no,
                      t.down_account_id,
                      t.down_company_id,
                      dc.source_system_id down_system,
                      t.bill_type,
                      t.business_type,
                      sum(decode(t.change_type,
                                 pkg_sup_up_fund_type.refund_amount,
                                 -1,
                                 1) * t.down_draw_count) down_draw_count,
                      sum(decode(t.change_type,
                                 pkg_sup_up_fund_type.refund_amount,
                                 -1,
                                 1) * t.down_draw_unit) down_draw_unit,
                      sum(decode(t.change_type,
                                 pkg_sup_up_fund_type.refund_amount,
                                 -1,
                                 1) * t.down_draw_face) down_draw_face,
                      sum(decode(t.change_type,
                                 pkg_sup_up_fund_type.refund_amount,
                                 -1,
                                 1) * t.down_draw_amount) down_draw_amount
                 from sup_trade_up_fund t
                inner join sup_base_down_channel dc
                   on dc.channel_no = t.down_channel_no
                where t.change_time >= l_report_date
                  and t.change_time < (l_report_date + 1)
                  and t.change_type in
                      (pkg_sup_up_fund_type.debit_amount,
                       pkg_sup_up_fund_type.refund_amount)
                  and t.down_channel_no != '-'
                group by t.down_channel_no,
                         t.down_account_id,
                         t.down_company_id,
                         dc.source_system_id,
                         t.bill_type,
                         t.business_type) loop
  
    ---2.循环添加到sup交易日报表
  
    -----2循环开始-----
    begin
    
      ---2.1获取财务分类
      l_statistics_type := 0;
    
      if item.bill_type = pkg_bill_type.back then
        l_statistics_type := pkg_statistics_type.FlowBag;
      else
        --***从业务类型与分类表中获取分类***
        select t.statistics_type
          into l_statistics_type
          from fd_system_business_statis_map t
         where t.local_business_type = item.business_type
           and rownum <= 1;
      end if;
    
      ---2.2添加数据
      insert into sup_report_daily_trade
        (record_id,
         report_date,
         channel_no,
         account_id,
         company_id,
         system_id,
         channel_type,
         bill_type,
         business_type,
         statistics_type,
         trade_count,
         trade_unit,
         trade_face,
         trade_amount)
      values
        (seq_sup_report_daily_trade_id.nextval,
         item.record_date,
         item.down_channel_no,
         item.down_account_id,
         item.down_company_id,
         item.down_system,
         pkg_channel_type.down_channel,
         item.bill_type,
         item.business_type,
         l_statistics_type,
         item.down_draw_count,
         item.down_draw_unit,
         item.down_draw_face,
         item.down_draw_amount);
      commit;
    exception
      when others then
        rollback;
        insert into fd_system_warn
          (warn_id,
           uniq_id,
           warn_level,
           warn_type,
           title,
           warn_date,
           content,
           sync_status,
           key_word)
        values
          (seq_system_warn_id.nextval,
           'sup_p_down_report_daily_trade failed',
           5,
           pkg_warn_into_type.auto_error,
           'sup交易日报表自动报警',
           sysdate,
           'sup交易日报表自动报警',
           pkg_balance_sync_status.wait,
           '自动报警');
        commit;
        fd_p_write_log('sup_p_down_report_daily_trade', sqlerrm, 1);
      
    end;
  end loop;
  -----2循环结束-----

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_down_report_daily_trade', sqlerrm, 1);
  
end;
/

prompt
prompt Creating procedure SUP_P_AUTO_DOWN_ZERO_BALANCE
prompt ===============================================
prompt
create or replace procedure fd_account.sup_p_auto_down_zero_balance(v_report_date in varchar2 default null) as
  -----------------获取sup下游渠道零点余额--------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number := 0;
  l_count           number;
  l_max_record      number;
  l_max_change_time date;

  l_ex_count                number;
  l_electronic_card_balance number;

begin

  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  ---1.获取下游渠道数据
  for item in (select t.channel_no       as down_channel_no,
                      t.account_id       as down_account_id,
                      t.company_id       as down_company_id,
                      t.source_system_id as down_system
                 from sup_base_down_channel t) loop
  
    -----2循环开始-----
    begin
    
      ---2.1检查当天零点余额是否已存在
      select count(1)
        into l_report_count
        from sup_report_zero_balance zb
       where zb.zero_date = l_report_date
         and zb.channel_no = item.down_channel_no
         and zb.account_id = item.down_account_id
         and zb.company_id = item.down_company_id
         and zb.channel_type = pkg_channel_type.down_channel
         and rownum <= 1;
    
      if l_report_count = 0 then
      
        ---2.2检查当天是否有余额数据
        select count(1), max(t.change_time)
          into l_count, l_max_change_time
          from sup_trade_down_fund t
         where t.change_time >= l_report_date
           and t.change_time < (l_report_date + 1)
           and t.down_channel_no = item.down_channel_no
           and t.down_account_id = item.down_account_id
           and t.down_company_id = item.down_company_id;
      
        if l_count > 0 then
          ---2.3（有数据）获取最后一条数据，添加到sup零点余额表
          select max(t.record_id)
            into l_max_record
            from sup_trade_down_fund t
           where t.change_time = l_max_change_time
             and t.down_channel_no = item.down_channel_no
             and t.down_account_id = item.down_account_id
             and t.down_company_id = item.down_company_id;
        
          ---***添加数据***---
          insert into sup_report_zero_balance
            (record_id,
             zero_date,
             create_date,
             channel_no,
             account_id,
             company_id,
             system_id,
             channel_type,
             on_way_count,
             on_way_face,
             on_way_balance,
             physical_card_count,
             physical_card_face,
             physical_card_balance,
             electronic_card_count,
             electronic_card_face,
             electronic_card_balance)
            select seq_sup_report_zero_balance_id.nextval,
                   l_report_date + 1,
                   sysdate,
                   item.down_channel_no,
                   item.down_account_id,
                   item.down_company_id,
                   item.down_system,
                   pkg_channel_type.down_channel,
                   0,
                   0,
                   0,
                   0,
                   0,
                   0,
                   0,
                   0,
                   t.balance
              from sup_trade_down_fund t
             where t.record_id = l_max_record;
        
          if sql%rowcount != 1 then
            return;
          end if;
        
        else
          ---2.4（无数据）获取前一天零点余额，添加sup零点余额表
          select count(1), max(t.electronic_card_balance)
            into l_ex_count, l_electronic_card_balance
            from sup_report_zero_balance t
           where t.zero_date = (l_report_date - 1)
             and t.channel_no = item.down_channel_no
             and t.account_id = item.down_account_id
             and t.company_id = item.down_company_id
             and t.channel_type = pkg_channel_type.down_channel;
        
          if l_ex_count = 1 then
          
            ---***添加数据***---
            insert into sup_report_zero_balance
              (record_id,
               zero_date,
               create_date,
               channel_no,
               account_id,
               company_id,
               system_id,
               channel_type,
               on_way_count,
               on_way_face,
               on_way_balance,
               physical_card_count,
               physical_card_face,
               physical_card_balance,
               electronic_card_count,
               electronic_card_face,
               electronic_card_balance)
            values
              (seq_sup_report_zero_balance_id.nextval,
               l_report_date + 1,
               sysdate,
               item.down_channel_no,
               item.down_account_id,
               item.down_company_id,
               item.down_system,
               pkg_channel_type.down_channel,
               0,
               0,
               0,
               0,
               0,
               0,
               0,
               0,
               l_electronic_card_balance);
          
          else
            ---2.5前一天也无数据时，取当前账户余额作为零点余额
            insert into sup_report_zero_balance
              (record_id,
               zero_date,
               create_date,
               channel_no,
               account_id,
               company_id,
               system_id,
               channel_type,
               on_way_count,
               on_way_face,
               on_way_balance,
               physical_card_count,
               physical_card_face,
               physical_card_balance,
               electronic_card_count,
               electronic_card_face,
               electronic_card_balance)
              select seq_sup_report_zero_balance_id.nextval,
                     l_report_date + 1,
                     sysdate,
                     item.down_channel_no,
                     item.down_account_id,
                     item.down_company_id,
                     item.down_system,
                     pkg_channel_type.down_channel,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     t.balance
                from sup_base_down_account t
               where t.account_id = item.down_account_id;
          
            if sql%rowcount != 1 then
              return;
            end if;
          
          end if;
        end if;
      end if;
      commit;
    exception
      when others then
        rollback;
        insert into fd_system_warn
          (warn_id,
           uniq_id,
           warn_level,
           warn_type,
           title,
           warn_date,
           content,
           sync_status,
           key_word)
        values
          (seq_system_warn_id.nextval,
           'sup_p_down_zero_balance_get failed',
           5,
           pkg_warn_into_type.auto_error,
           'sup零点余额自动报警',
           sysdate,
           'sup零点余额自动报警',
           pkg_balance_sync_status.wait,
           '自动报警');
        commit;
        fd_p_write_log('sup_p_down_zero_balance_get', sqlerrm, 1);
    end;
  end loop;
  -----2循环结束-----

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_down_zero_balance_get', sqlerrm, 1);
  
end;
/

prompt
prompt Creating procedure SUP_P_AUTO_UP_DAILY_MANUAL
prompt =============================================
prompt
create or replace procedure fd_account.sup_p_auto_up_daily_manual(v_report_date in varchar2 default null) as
  -----------------收集sup上游加款日报表信息--------------
  l_report_date date := to_date(v_report_date, 'yyyymmddhh24miss');

begin

  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  ---1.收集日期当天的上游加款数据
  for item in (select l_report_date as record_date,
                      t.up_channel_no,
                      t.up_account_id,
                      uc.company_id,
                      uc.source_system_id,
                      sum(decode(t.change_type,
                                 pkg_sup_up_manual_type.pick_amount,
                                 -1,
                                 pkg_sup_up_manual_type.red_pick,
                                 -1,
                                 1) * t.way_change_count) way_change_count,
                      sum(decode(t.change_type,
                                 pkg_sup_up_manual_type.pick_amount,
                                 -1,
                                 pkg_sup_up_manual_type.red_pick,
                                 -1,
                                 1) * t.way_change_face) way_change_face,
                      sum(decode(t.change_type,
                                 pkg_sup_up_manual_type.pick_amount,
                                 -1,
                                 pkg_sup_up_manual_type.red_pick,
                                 -1,
                                 1) * t.way_change_amount) way_change_amount,
                      sum(decode(t.change_type,
                                 pkg_sup_up_manual_type.pick_amount,
                                 -1,
                                 pkg_sup_up_manual_type.red_pick,
                                 -1,
                                 1) * t.physical_change_count) physical_change_count,
                      sum(decode(t.change_type,
                                 pkg_sup_up_manual_type.pick_amount,
                                 -1,
                                 pkg_sup_up_manual_type.red_pick,
                                 -1,
                                 1) * t.physical_change_face) physical_change_face,
                      sum(decode(t.change_type,
                                 pkg_sup_up_manual_type.pick_amount,
                                 -1,
                                 pkg_sup_up_manual_type.red_pick,
                                 -1,
                                 1) * t.physical_change_amount) physical_change_amount,
                      sum(decode(t.change_type,
                                 pkg_sup_up_manual_type.pick_amount,
                                 -1,
                                 pkg_sup_up_manual_type.red_pick,
                                 -1,
                                 1) * t.electronic_change_count) electronic_change_count,
                      sum(decode(t.change_type,
                                 pkg_sup_up_manual_type.pick_amount,
                                 -1,
                                 pkg_sup_up_manual_type.red_pick,
                                 -1,
                                 1) * t.electronic_change_face) electronic_change_face,
                      sum(decode(t.change_type,
                                 pkg_sup_up_manual_type.pick_amount,
                                 -1,
                                 pkg_sup_up_manual_type.red_pick,
                                 -1,
                                 1) * t.electronic_change_amount) electronic_change_amount
                 from sup_trade_up_manual t
                inner join sup_base_up_channel uc
                   on uc.channel_no = t.up_channel_no
                where t.change_time >= l_report_date
                  and t.change_time < (l_report_date + 1)
                  and t.change_type != pkg_sup_up_manual_type.trade_revise
                group by t.up_channel_no,
                         t.up_account_id,
                         uc.company_id,
                         uc.source_system_id) loop
  
    ---2.循环添加上游数据到sup加款日报表
  
    -----2循环开始-----
    begin
    
      ---2.1添加数据
      insert into sup_report_daily_manual
        (record_id,
         report_date,
         channel_no,
         account_id,
         company_id,
         system_id,
         channel_type,
         way_change_count,
         way_change_face,
         way_change_amount,
         physical_change_count,
         physical_change_face,
         physical_change_amount,
         electronic_change_count,
         electronic_change_face,
         electronic_change_amount)
      values
        (seq_sup_report_daily_manual_id.nextval,
         item.record_date,
         item.up_channel_no,
         item.up_account_id,
         item.company_id,
         item.source_system_id,
         pkg_channel_type.up_channel,
         item.way_change_count,
         item.way_change_face,
         item.way_change_amount,
         item.physical_change_count,
         item.physical_change_face,
         item.physical_change_amount,
         item.electronic_change_count,
         item.electronic_change_face,
         item.electronic_change_amount);
      commit;
    exception
      when others then
        rollback;
        insert into fd_system_warn
          (warn_id,
           uniq_id,
           warn_level,
           warn_type,
           title,
           warn_date,
           content,
           sync_status,
           key_word)
        values
          (seq_system_warn_id.nextval,
           'sup_p_up_report_daily_manual failed',
           5,
           pkg_warn_into_type.auto_error,
           'sup加款日报表自动报警',
           sysdate,
           'sup加款日报表自动报警',
           pkg_balance_sync_status.wait,
           '自动报警');
        commit;
        fd_p_write_log('sup_p_up_report_daily_manual', sqlerrm, 1);
    end;
  end loop;
  -----2循环结束-----

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_up_report_daily_manual', sqlerrm, 1);
  
end;
/

prompt
prompt Creating procedure SUP_P_AUTO_UP_DAILY_TRADE
prompt ============================================
prompt
create or replace procedure fd_account.sup_p_auto_up_daily_trade(v_report_date in varchar2 default null) as
  -----------------收集sup上游交易日报表信息--------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_wait_count      number := 0;
  l_statistics_type number := 0; --数据出现错误，统计类型为0

begin
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查(若有数据则执行1~2，反之直接返回)
  select count(1)
    into l_wait_count
    from sup_trade_up_fund t
   where t.change_time >= l_report_date
     and t.change_time < (l_report_date + 1)
     and t.change_type in
         (pkg_sup_up_fund_type.debit_amount,
          pkg_sup_up_fund_type.refund_amount)
     and rownum <= 2;

  if l_wait_count = 0 then
    return;
  end if;

  ---1.收集日期当天的上游渠道交易数据
  for item in (select l_report_date as record_date,
                      t.up_channel_no,
                      t.up_account_id,
                      t.up_company_id,
                      uc.source_system_id up_system,
                      t.bill_type,
                      t.business_type,
                      sum(decode(t.change_type,
                                 pkg_sup_up_fund_type.refund_amount,
                                 -1,
                                 1) * t.up_draw_count) up_draw_count,
                      sum(decode(t.change_type,
                                 pkg_sup_up_fund_type.refund_amount,
                                 -1,
                                 1) * t.up_draw_unit) up_draw_unit,
                      sum(decode(t.change_type,
                                 pkg_sup_up_fund_type.refund_amount,
                                 -1,
                                 1) * t.up_draw_face) up_draw_face,
                      sum(decode(t.change_type,
                                 pkg_sup_up_fund_type.refund_amount,
                                 -1,
                                 1) * t.up_draw_amount) up_draw_amount
                 from sup_trade_up_fund t
                inner join sup_base_up_channel uc
                   on uc.channel_no = t.up_channel_no
                where t.change_time >= l_report_date
                  and t.change_time < (l_report_date + 1)
                  and t.change_type in
                      (pkg_sup_up_fund_type.debit_amount,
                       pkg_sup_up_fund_type.refund_amount)
                group by t.up_channel_no,
                         t.up_account_id,
                         t.up_company_id,
                         uc.source_system_id,
                         t.bill_type,
                         t.business_type) loop
  
    ---2.循环添加到sup交易日报表
  
    -----2循环开始-----
    begin
    
      ---2.1获取财务分类
      l_statistics_type := 0;
    
      if item.bill_type = pkg_bill_type.back then
        l_statistics_type := pkg_statistics_type.FlowBag;
      else
        --***从业务类型与分类表中获取分类***
        select t.statistics_type
          into l_statistics_type
          from fd_system_business_statis_map t
         where t.local_business_type = item.business_type
           and rownum <= 1;
      end if;
    
      ---2.2添加数据
      insert into sup_report_daily_trade
        (record_id,
         report_date,
         channel_no,
         account_id,
         company_id,
         system_id,
         channel_type,
         bill_type,
         business_type,
         statistics_type,
         trade_count,
         trade_unit,
         trade_face,
         trade_amount)
      values
        (seq_sup_report_daily_trade_id.nextval,
         item.record_date,
         item.up_channel_no,
         item.up_account_id,
         item.up_company_id,
         item.up_system,
         pkg_channel_type.up_channel,
         item.bill_type,
         item.business_type,
         l_statistics_type,
         item.up_draw_count,
         item.up_draw_unit,
         item.up_draw_face,
         item.up_draw_amount);
      commit;
    exception
      when others then
        rollback;
        insert into fd_system_warn
          (warn_id,
           uniq_id,
           warn_level,
           warn_type,
           title,
           warn_date,
           content,
           sync_status,
           key_word)
        values
          (seq_system_warn_id.nextval,
           'sup_p_up_report_daily_trade failed',
           5,
           pkg_warn_into_type.auto_error,
           'sup交易日报表自动报警',
           sysdate,
           'sup交易日报表自动报警',
           pkg_balance_sync_status.wait,
           '自动报警');
        commit;
        fd_p_write_log('sup_p_up_report_daily_trade', sqlerrm, 1);
      
    end;
  end loop;
  -----2循环结束-----

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_up_report_daily_trade', sqlerrm, 1);
  
end;
/

prompt
prompt Creating procedure SUP_P_AUTO_UP_ZERO_BALANCE
prompt =============================================
prompt
create or replace procedure fd_account.sup_p_auto_up_zero_balance(v_report_date in varchar2 default null) as
  -----------------获取sup上游零点余额--------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number := 0;
  l_count           number;
  l_max_record      number;
  l_max_change_time date;

  l_ex_count                number;
  l_on_way_count            number;
  l_on_way_face             number;
  l_on_way_balance          number;
  l_physical_card_count     number;
  l_physical_card_face      number;
  l_physical_card_balance   number;
  l_electronic_card_count   number;
  l_electronic_card_face    number;
  l_electronic_card_balance number;

begin

  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  ---1.获取上游渠道数据
  for item in (select t.channel_no       as up_channel_no,
                      t.account_id       as up_account_id,
                      t.company_id       as up_company_id,
                      t.source_system_id as up_system
                 from sup_base_up_channel t) loop
  
    -----2循环开始-----
    begin
    
      ---2.1检查当天零点余额是否已存在
      select count(1)
        into l_report_count
        from sup_report_zero_balance zb
       where zb.zero_date = l_report_date
         and zb.channel_no = item.up_channel_no
         and zb.account_id = item.up_account_id
         and zb.company_id = item.up_company_id
         and zb.channel_type = pkg_channel_type.up_channel
         and rownum <= 1;
    
      if l_report_count = 0 then
      
        ---2.2检查当天是否有余额数据,获取资金最后变动时间
        select count(1), max(t.change_time)
          into l_count, l_max_change_time
          from sup_trade_up_fund t
         where t.change_time >= l_report_date
           and t.change_time < (l_report_date + 1)
           and t.up_channel_no = item.up_channel_no
           and t.up_account_id = item.up_account_id
           and t.up_company_id = item.up_company_id;
      
        if l_count > 0 then
          ---2.3（有数据）获取最后一条数据，添加到sup零点余额表
          select max(t.record_id)
            into l_max_record
            from sup_trade_up_fund t
           where t.change_time = l_max_change_time
             and t.up_channel_no = item.up_channel_no
             and t.up_account_id = item.up_account_id
             and t.up_company_id = item.up_company_id;
        
          ---***添加数据***---
          insert into sup_report_zero_balance
            (record_id,
             zero_date,
             create_date,
             channel_no,
             account_id,
             company_id,
             system_id,
             channel_type,
             on_way_count,
             on_way_face,
             on_way_balance,
             physical_card_count,
             physical_card_face,
             physical_card_balance,
             electronic_card_count,
             electronic_card_face,
             electronic_card_balance)
            select seq_sup_report_zero_balance_id.nextval,
                   l_report_date + 1,
                   sysdate,
                   item.up_channel_no,
                   item.up_account_id,
                   item.up_company_id,
                   item.up_system,
                   pkg_channel_type.up_channel,
                   t.way_count_balance,
                   t.way_face_balance,
                   t.way_card_balance,
                   t.physical_count_balance,
                   t.physical_face_balance,
                   t.physical_card_balance,
                   t.electronic_count_balance,
                   t.electronic_face_balance,
                   t.electronic_card_balance
              from sup_trade_up_fund t
             where t.record_id = l_max_record;
        
          if sql%rowcount != 1 then
            return;
          end if;
        
        else
          ---2.4（无数据）获取前一天零点余额，添加sup零点余额表
          select count(1),
                 max(t.on_way_count),
                 max(t.on_way_face),
                 max(t.on_way_balance),
                 max(t.physical_card_count),
                 max(t.physical_card_face),
                 max(t.physical_card_balance),
                 max(t.electronic_card_count),
                 max(t.electronic_card_face),
                 max(t.electronic_card_balance)
            into l_ex_count,
                 l_on_way_count,
                 l_on_way_face,
                 l_on_way_balance,
                 l_physical_card_count,
                 l_physical_card_face,
                 l_physical_card_balance,
                 l_electronic_card_count,
                 l_electronic_card_face,
                 l_electronic_card_balance
            from sup_report_zero_balance t
           where t.zero_date = (l_report_date - 1)
             and t.account_id = item.up_account_id
             and t.channel_no = item.up_channel_no
             and t.company_id = item.up_company_id
             and t.channel_type = pkg_channel_type.up_channel;
        
          if l_ex_count = 1 then
          
            ---***添加数据***---
            insert into sup_report_zero_balance
              (record_id,
               zero_date,
               create_date,
               channel_no,
               account_id,
               company_id,
               system_id,
               channel_type,
               on_way_count,
               on_way_face,
               on_way_balance,
               physical_card_count,
               physical_card_face,
               physical_card_balance,
               electronic_card_count,
               electronic_card_face,
               electronic_card_balance)
            values
              (seq_sup_report_zero_balance_id.nextval,
               l_report_date + 1,
               sysdate,
               item.up_channel_no,
               item.up_account_id,
               item.up_company_id,
               item.up_system,
               pkg_channel_type.up_channel,
               l_on_way_count,
               l_on_way_face,
               l_on_way_balance,
               l_physical_card_count,
               l_physical_card_face,
               l_physical_card_balance,
               l_electronic_card_count,
               l_electronic_card_face,
               l_electronic_card_balance);
          
          else
            ---2.5前一天也无数据时，取当前账户余额作为零点余额
            insert into sup_report_zero_balance
              (record_id,
               zero_date,
               create_date,
               channel_no,
               account_id,
               company_id,
               system_id,
               channel_type,
               on_way_count,
               on_way_face,
               on_way_balance,
               physical_card_count,
               physical_card_face,
               physical_card_balance,
               electronic_card_count,
               electronic_card_face,
               electronic_card_balance)
              select seq_sup_report_zero_balance_id.nextval,
                     l_report_date + 1,
                     sysdate,
                     item.up_channel_no,
                     item.up_account_id,
                     item.up_company_id,
                     item.up_system,
                     pkg_channel_type.up_channel,
                     t.on_way_count,
                     t.on_way_face,
                     t.on_way_balance,
                     t.physical_card_count,
                     t.physical_card_face,
                     t.physical_card_balance,
                     t.electronic_card_count,
                     t.electronic_card_face,
                     t.electronic_card_balance
                from sup_base_up_account t
               where t.account_id = item.up_account_id;
          
            if sql%rowcount != 1 then
              return;
            end if;
          
          end if;
        end if;
      end if;
      commit;
    exception
      when others then
        rollback;
        insert into fd_system_warn
          (warn_id,
           uniq_id,
           warn_level,
           warn_type,
           title,
           warn_date,
           content,
           sync_status,
           key_word)
        values
          (seq_system_warn_id.nextval,
           'sup_p_up_zero_balance_get failed',
           5,
           pkg_warn_into_type.auto_error,
           'sup零点余额自动报警',
           sysdate,
           'sup零点余额自动报警',
           pkg_balance_sync_status.wait,
           '自动报警');
        commit;
        fd_p_write_log('sup_p_up_zero_balance_get', sqlerrm, 1);
    end;
  end loop;
  -----2循环结束-----

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_up_zero_balance_get', sqlerrm, 1);
  
end;
/

prompt
prompt Creating procedure SUP_P_MANUAL_ADD_UP
prompt ======================================
prompt
create or replace procedure fd_account.sup_p_manual_add_up(v_up_channel_no   varchar2, --上游渠道
                                                v_bank_account_id number, --银行账户
                                                v_add_count       number, --增加数量
                                                v_add_face        number, --增加面值
                                                v_add_amount      number, --增加金额
                                                v_service_fee     number, --手续费
                                                v_memo            varchar2, --备注
                                                v_create_user     varchar2, --创建人
                                                v_remark_name     varchar2, --收付款账号名称
                                                v_result          out varchar2) as
  ---------------------------------------
  --功能：sup上游渠道加款
  --创建人：周荣省
  --创建时间：2019-07-01
  ---------------------------------------
  l_result              varchar2(32);
  l_up_account_id       number;
  l_up_company_id       number;
  l_system_id           number;
  l_up_channel_name     varchar2(128);
  l_up_account_name     varchar2(128);
  l_sup_down_channel_no varchar2(32);
  l_sup_down_accout_id  number;
  l_18_up_channel_no    varchar2(32);
  l_18_up_accout_id     number;
  l_bank_card_no        varchar2(64);
  l_bank_fund_id        number;
  l_bank_service_id     number;
  l_bank_relate_id      number;
  l_number              number;
begin
  ---1.检查加款信息
  l_result := sup_f_up_add_check(v_up_channel_no,
                                 v_bank_account_id,
                                 v_add_count,
                                 v_add_face,
                                 v_add_amount,
                                 v_service_fee,
                                 l_up_account_id,
                                 l_up_company_id,
                                 l_system_id,
                                 l_up_channel_name,
                                 l_up_account_name,
                                 l_sup_down_channel_no,
                                 l_sup_down_accout_id,
                                 l_18_up_channel_no,
                                 l_18_up_accout_id);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---2.银行账户扣款
  l_result := sup_f_up_add_bank_minus(v_bank_account_id,
                                      v_add_amount,
                                      v_service_fee,
                                      l_up_channel_name,
                                      l_up_account_name,
                                      v_memo,
                                      v_remark_name,
                                      v_create_user,
                                      l_bank_card_no,
                                      l_bank_fund_id,
                                      l_bank_service_id,
                                      l_bank_relate_id);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---3.sup上游渠道加款
  l_result := sup_f_up_channel_add(v_up_channel_no,
                                   l_up_account_id,
                                   l_up_company_id,
                                   l_system_id,
                                   l_bank_card_no,
                                   l_bank_fund_id,
                                   l_bank_service_id,
                                   l_bank_relate_id,
                                   v_add_count,
                                   v_add_face,
                                   v_add_amount,
                                   v_memo,
                                   v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---4.sup下游渠道加款
  l_result := sup_f_down_channel_add(l_sup_down_channel_no,
                                     l_sup_down_accout_id,
                                     l_up_company_id,
                                     l_system_id,
                                     l_bank_relate_id,
                                     v_add_face,
                                     v_add_amount,
                                     v_memo,
                                     v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---5.用卡生产系统上游渠道加款
  l_result := sup_f_pro_up_channel_add(l_18_up_channel_no,
                                       l_18_up_accout_id,
                                       l_up_company_id,
                                       l_bank_relate_id,
                                       v_add_amount,
                                       v_memo,
                                       v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---6.记录操作日志
  fd_p_write_handle_log('sup上游关联加款',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        'v_bank_account_id=' || v_bank_account_id ||
                        ',v_add_amount=' || v_add_amount));

  --7.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = l_up_account_id
     and t.co_account_type = 7
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(l_up_account_id,
                                         7,
                                         v_remark_name,
                                         v_create_user);
  end if;

  commit;
  v_result := pkg_error_code.success;
  return;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_add_up', sqlerrm, 1);
    v_result := pkg_error_code.system_busy;
    return;
end;
/

prompt
prompt Creating procedure SUP_P_MANUAL_ADD_UP_ADJUST
prompt =============================================
prompt
create or replace procedure fd_account.sup_p_manual_add_up_adjust(v_add_record_id number,--加款记录id
                                                       v_memo          varchar2,--备注
                                                       v_create_user   varchar2,--操作人
                                                       v_result        out varchar2) as
  -------------------------------------
  --功能：sup上游渠道加款红冲
  --创建人：周荣省
  --创建时间：2019-07-02
  -------------------------------------
  l_result           varchar2(32);
  l_bank_record_id   number;
  l_bank_service_id  number;
  l_bank_relate_id   number;
  l_adjust_relate_id number;
  l_up_channel_no    varchar2(32);
  l_change_time      date;
begin
  ---1.检查上游加款相关记录数据
  l_result := sup_f_up_add_adjust_check(v_add_record_id,
                                        l_up_channel_no,
                                        l_change_time,
                                        l_bank_record_id,
                                        l_bank_service_id,
                                        l_bank_relate_id);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:=l_result;
    return;
  end if;

  ---2.上游加款银行流水记录红冲
  l_result := sup_f_up_add_bank_adjust(l_bank_record_id,
                                       l_bank_service_id,
                                       l_bank_relate_id,
                                       v_memo,
                                       v_create_user,
                                       l_adjust_relate_id);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:=l_result;
    return;
  end if;

  ---3.上游加款记录红冲
  l_result := sup_f_up_add_adjust(v_add_record_id,
                                  l_adjust_relate_id,
                                  v_memo,
                                  v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:=l_result;
    return;
  end if;

  ---4.上游加款关联下游红冲
  l_result := sup_f_down_add_adjust(l_up_channel_no,
                                    l_bank_relate_id,
                                    l_change_time,
                                    l_adjust_relate_id,
                                    v_memo,
                                    v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:=l_result;
    return;
  end if;

  ---5.上游加款关联生产系统上游红冲
  l_result := sup_f_pro_up_add_adjust(l_up_channel_no,
                                      l_bank_relate_id,
                                      l_change_time,
                                      l_adjust_relate_id,
                                      v_memo,
                                      v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:=l_result;
    return;
  end if;

  ---6.记录操作日志
  fd_p_write_handle_log('sup上游加款红冲',
                        v_create_user,
                        ('v_add_record_id=' || v_add_record_id));

  commit;
  v_result:=pkg_error_code.success;
  return;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_add_up_adjust', sqlerrm, 1);
    v_result:= pkg_error_code.system_busy;
    return;
end;
/

prompt
prompt Creating procedure SUP_P_MANUAL_DOWN_RV_BALANCE
prompt ===============================================
prompt
create or replace procedure fd_account.sup_p_manual_down_rv_balance(v_down_channel_no varchar2, --下游渠道编号
                                                         v_rv_amount       number, --平账金额
                                                         v_memo            varchar2, --备注
                                                         v_create_user     varchar2, --操作人
                                                         v_result          out varchar2) as
  ------------------------------------------------
  --功能：sup下游渠道余额平账
  --创建人：周荣省
  --创建时间：2019-07-02
  ------------------------------------------------
  l_result          varchar2(32);
  l_down_account_id number;
  l_down_company_id number;
  l_system_id       number;

begin
  ---1.检查余额平账信息
  l_result := sup_f_down_balance_rv_check(v_down_channel_no,
                                          v_rv_amount,
                                          l_down_account_id,
                                          l_down_company_id,
                                          l_system_id);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---2.sup下游渠道账户余额平账
  l_result := sup_f_down_balance_rv(v_down_channel_no,
                                    v_rv_amount,
                                    l_down_account_id,
                                    l_down_company_id,
                                    l_system_id,
                                    v_memo,
                                    v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('sup下游渠道余额平账',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        'v_rv_amount=' || v_rv_amount));

  commit;
  v_result := pkg_error_code.success;
  return;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_down_rv_balance', sqlerrm, 1);
    v_result := pkg_error_code.system_busy;
    return;
end;
/

prompt
prompt Creating procedure SUP_P_MANUAL_DOWN_RV_TRADE
prompt =============================================
prompt
create or replace procedure fd_account.sup_p_manual_down_rv_trade(v_down_channel_no varchar2, --下游渠道编号
                                                       v_rv_count        number, --平账数量
                                                       v_rv_face         number, --平账面值
                                                       v_rv_amount       number, --平账金额
                                                       v_bill_type       number, --前后向：1前向，2后向
                                                       v_business_type   number, --业务类型
                                                       v_memo            varchar2, --备注
                                                       v_create_user     varchar2,
                                                       v_result          out varchar2) as
  -----------------------------------------------
  --功能：sup下游渠道交易平账
  --创建人：周荣省
  --创建时间：2019-07-02
  -----------------------------------------------
  l_result          varchar2(32);
  l_down_account_id number;
  l_down_company_id number;
  l_system_id       number;

begin
  ---1.检查交易平账信息
  l_result := sup_f_down_trade_rv_check(v_down_channel_no,
                                        v_rv_count,
                                        v_rv_face,
                                        v_rv_amount,
                                        v_business_type,
                                        l_down_account_id,
                                        l_down_company_id,
                                        l_system_id);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---2.sup下游渠道账户交易平账
  l_result := sup_f_down_trade_rv(v_down_channel_no,
                                  v_rv_count,
                                  v_rv_face,
                                  v_rv_amount,
                                  l_down_account_id,
                                  l_down_company_id,
                                  l_system_id,
                                  v_bill_type,
                                  v_business_type,
                                  v_memo,
                                  v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('sup下游渠道交易平账',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        'v_rv_amount=' || v_rv_amount));

  commit;
  v_result := pkg_error_code.success;
  return;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_down_rv_trade', sqlerrm, 1);
    v_result := pkg_error_code.system_busy;
    return;
end;
/

prompt
prompt Creating procedure SUP_P_MANUAL_DRAW_UP
prompt =======================================
prompt
create or replace procedure fd_account.sup_p_manual_draw_up(v_up_channel_no   varchar2, --上游渠道
                                                 v_bank_account_id number, --银行账户
                                                 v_draw_type       number, --资金种类
                                                 v_draw_count      number, --减少数量
                                                 v_draw_face       number, --减少面值
                                                 v_draw_amount     number, --提款金额
                                                 v_memo            varchar2, --备注
                                                 v_create_user     varchar2, --操作人
                                                 v_remark_name     varchar2, --收付款账户名称
                                                 v_result          out varchar2) as
  ----------------------------------------
  --功能：sup上游渠道提款
  --创建人：周荣省
  --创建时间：2019-07-01
  ----------------------------------------
  l_result              varchar2(32);
  l_up_account_id       number;
  l_up_company_id       number;
  l_system_id           number;
  l_up_channel_name     varchar2(32);
  l_up_account_name     varchar2(32);
  l_sup_down_channel_no varchar2(32);
  l_sup_down_accout_id  number;
  l_18_up_channel_no    varchar2(32);
  l_18_up_accout_id     number;
  l_bank_card_no        varchar2(64);
  l_bank_fund_id        number;
  l_bank_relate_id      number;
  l_number              number;

begin
  ---1.检查提款信息
  l_result := sup_f_up_draw_check(v_bank_account_id,
                                  v_up_channel_no,
                                  v_draw_type,
                                  v_draw_count,
                                  v_draw_face,
                                  v_draw_amount,
                                  l_up_account_id,
                                  l_up_company_id,
                                  l_system_id,
                                  l_up_channel_name,
                                  l_up_account_name,
                                  l_sup_down_channel_no,
                                  l_sup_down_accout_id,
                                  l_18_up_channel_no,
                                  l_18_up_accout_id);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---2.银行账户加款
  l_result := sup_f_up_draw_bank_plus(v_bank_account_id,
                                      v_draw_amount,
                                      l_up_channel_name,
                                      l_up_account_name,
                                      v_create_user,
                                      v_memo,
                                      v_remark_name,
                                      l_bank_card_no,
                                      l_bank_relate_id,
                                      l_bank_fund_id);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---3.sup上游渠道减款
  l_result := sup_f_up_channel_draw(v_up_channel_no,
                                    l_up_account_id,
                                    l_up_company_id,
                                    v_draw_type,
                                    v_draw_count,
                                    v_draw_face,
                                    v_draw_amount,
                                    l_bank_card_no,
                                    l_system_id,
                                    l_bank_fund_id,
                                    l_bank_relate_id,
                                    v_memo,
                                    v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---4.sup下游渠道减款
  l_result := sup_f_down_channel_draw(l_sup_down_channel_no,
                                      l_sup_down_accout_id,
                                      l_up_company_id,
                                      l_system_id,
                                      l_bank_relate_id,
                                      v_draw_face,
                                      v_draw_amount,
                                      v_memo,
                                      v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---5.用卡生产系统上游渠道减款
  l_result := sup_f_pro_up_channel_draw(l_18_up_channel_no,
                                        l_18_up_accout_id,
                                        l_up_company_id,
                                        l_bank_relate_id,
                                        v_draw_amount,
                                        v_memo,
                                        v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result := l_result;
    return;
  end if;

  ---6.记录操作日志
  fd_p_write_handle_log('sup上游关联提款',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        'v_bank_account_id=' || v_bank_account_id ||
                        ',v_draw_amount=' || v_draw_amount));
  --7.添加收付款账户
  select count(0)
    into l_number
    from fd_base_co_account_name t
   where t.account_id = l_up_account_id
     and t.co_account_type = 7
     and t.co_account_name = v_remark_name;
  if (l_number < 1) then
    v_result := fd_f_co_account_name_add(l_up_account_id,
                                         7,
                                         v_remark_name,
                                         v_create_user);
  end if;

  commit;
  v_result := pkg_error_code.success;
  return;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_draw_up', sqlerrm, 1);
    v_result := pkg_error_code.system_busy;
    return;
end;
/

prompt
prompt Creating procedure SUP_P_MANUAL_DRAW_UP_ADJUST
prompt ==============================================
prompt
create or replace procedure fd_account.sup_p_manual_draw_up_adjust(v_draw_record_id number,--提款id
                                                        v_memo           varchar2,--备注
                                                        v_create_user    varchar2,--操作人
                                                        v_result         out varchar2) as
  ---------------------------------------------
  --功能：sup上游渠道提款红冲
  --创建人：周荣省
  --创建时间：2019-07-02
  ---------------------------------------------
  l_result           varchar2(32);
  l_bank_record_id   number;
  l_bank_relate_id   number;
  l_adjust_relate_id number;
  l_up_channel_no    varchar2(32);
  l_change_time      date;

begin
  ---1.检查上游提款相关记录数据
  l_result := sup_f_up_draw_adjust_check(v_draw_record_id,
                                         l_up_channel_no,
                                         l_change_time,
                                         l_bank_record_id,
                                         l_bank_relate_id);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:=l_result;
    return;
  end if;

  ---2.上游减款银行流水记录红冲
  l_result := sup_f_up_draw_bank_adjust(l_bank_record_id,
                                        l_bank_relate_id,
                                        v_memo,
                                        v_create_user,
                                        l_adjust_relate_id);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:=l_result;
    return;
  end if;

  ---3.上游减款记录红冲
  l_result := sup_f_up_draw_adjust(v_draw_record_id,
                                   l_adjust_relate_id,
                                   v_memo,
                                   v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:=l_result;
    return;
  end if;

  ---4.上游减款关联下游红冲
  l_result := sup_f_down_draw_adjust(l_up_channel_no,
                                     l_bank_relate_id,
                                     l_change_time,
                                     l_adjust_relate_id,
                                     v_memo,
                                     v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:=l_result;
    return;
  end if;

  ---5.上游减款关联生产系统上游红冲
  l_result := sup_f_pro_up_draw_adjust(l_up_channel_no,
                                       l_bank_relate_id,
                                       l_change_time,
                                       l_adjust_relate_id,
                                       v_memo,
                                       v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:=l_result;
    return;
  end if;

  ---6.记录操作日志
  fd_p_write_handle_log('sup上游提款红冲',
                        v_create_user,
                        ('v_draw_record_id=' || v_draw_record_id));

  commit;
  v_result:= pkg_error_code.success;
  return;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_draw_up_adjust', sqlerrm, 1);
    v_result:= pkg_error_code.system_busy;
    return;
end;
/

prompt
prompt Creating procedure SUP_P_MANUAL_UP_RV_BALANCE
prompt =============================================
prompt
create or replace procedure fd_account.sup_p_manual_up_rv_balance(v_up_channel_no varchar2,
                                                       v_rv_type       number,
                                                       v_rv_count      number,
                                                       v_rv_face       number,
                                                       v_rv_amount     number,
                                                       v_memo          varchar2,
                                                       v_create_user   varchar2,
                                                       v_result        out varchar2) as
  -------------------------------------------
  --功能：sup上游渠道余额平账
  --创建人：周荣省
  --创建时间：2019-0701
  -------------------------------------------
  --PRAGMA AUTONOMOUS_TRANSACTION;
  l_result        varchar2(32);
  l_up_account_id number;
  l_up_company_id number;
  l_system_id     number;

begin
  ---1.检查余额平账信息
  l_result := sup_f_up_balance_rv_check(v_up_channel_no,
                                        v_rv_type,
                                        v_rv_count,
                                        v_rv_face,
                                        v_rv_amount,
                                        l_up_account_id,
                                        l_up_company_id,
                                        l_system_id);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:= l_result;
    return;
  end if;

  ---2.sup上游渠道账户余额平账
  l_result := sup_f_up_balance_rv(v_up_channel_no,
                                  v_rv_type,
                                  v_rv_count,
                                  v_rv_face,
                                  v_rv_amount,
                                  l_up_account_id,
                                  l_up_company_id,
                                  l_system_id,
                                  v_memo,
                                  v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:= l_result;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('sup上游渠道余额平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        'v_rv_type=' || v_rv_type || 'v_rv_amount=' ||
                        v_rv_amount));

  commit;
  v_result:= pkg_error_code.success;
  return;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_up_rv_balance', sqlerrm, 1);
    v_result:= pkg_error_code.system_busy;
    return;
end;
/

prompt
prompt Creating procedure SUP_P_MANUAL_UP_RV_TRADE
prompt ===========================================
prompt
create or replace procedure fd_account.sup_p_manual_up_rv_trade(v_up_channel_no varchar2,
                                                    v_rv_count      number,
                                                    v_rv_face       number,
                                                    v_rv_amount     number,
                                                    v_bill_type     number,
                                                    v_business_type number,
                                                    v_memo          varchar2,
                                                    v_create_user   varchar2,
                                                    v_result out varchar2)
  as
  ----------------------------------
  --功能：sup上游渠道交易平账
  --创建人：周荣省
  --创建时间：2019-07-01
  ----------------------------------
  l_result        varchar2(32);
  l_up_account_id number;
  l_up_company_id number;
  l_system_id     number;

begin
  ---1.检查交易平账信息
  l_result := sup_f_up_trade_rv_check(v_up_channel_no,
                                      v_rv_count,
                                      v_rv_face,
                                      v_rv_amount,
                                      v_business_type,
                                      l_up_account_id,
                                      l_up_company_id,
                                      l_system_id);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:=l_result;
    return;
  end if;

  ---2.sup上游渠道账户交易平账
  l_result := sup_f_up_trade_rv(v_up_channel_no,
                                v_rv_count,
                                v_rv_face,
                                v_rv_amount,
                                l_up_account_id,
                                l_up_company_id,
                                l_system_id,
                                v_bill_type,
                                v_business_type,
                                v_memo,
                                v_create_user);
  if l_result != pkg_error_code.success then
    rollback;
    v_result:=l_result;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('sup上游渠道交易平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        'v_rv_amount=' || v_rv_amount));

  commit;
  v_result:=pkg_error_code.success;
  return;

exception
  when others then
    rollback;
    fd_p_write_log('sup_p_manual_up_rv_trade', sqlerrm, 1);
    v_result:=pkg_error_code.system_busy;
    return;
end;
/

prompt
prompt Creating procedure SUP_P_RELATE_ADD_MAP
prompt =======================================
prompt
create or replace procedure fd_account.sup_p_relate_add_map(v_sup_up_channel_no   varchar2, --sup上游渠道
                                                 v_sup_down_channel_no varchar2, --sup下游渠道
                                                 v_pro_up_channel_no   varchar2, --生产系统上游渠道（需为千行）
                                                 v_result              out varchar2) as
  ---------------------------------------------------
  --功能：sup渠道关联
  --创建人：周荣省
  --创建时间：2019-07-01
  ---------------------------------------------------
  l_number number;
begin
  --1.判断sup下游渠道
  select count(0)
    into l_number
    from sup_base_down_channel t
   where t.channel_no = v_sup_down_channel_no;
  if l_number < 1 then
    v_result := pkg_error_code.data_not_exists;
    return;
  end if;
  --2.判断生产系统上游渠道
  select count(0)
    into l_number
    from fd_base_up_channel t
   where t.company_id = 1
     and t.channel_no = v_pro_up_channel_no
     and t.channel_no in
         (select s.pro_up_channel_no from sup_base_pro_up_scope s);
  if l_number < 1 then
    v_result := pkg_error_code.data_not_exists;
    return;
  end if;
  --3.判断是否已经存在绑定
  select count(0)
    into l_number
    from sup_base_relate_add_map t
   where t.sup_up_channel_no = v_sup_up_channel_no;

  if l_number > 0 then
    --已经存在，修改
    update sup_base_relate_add_map
       set sup_down_channel_no = v_sup_down_channel_no,
           pro_up_channel_no   = v_pro_up_channel_no
     where sup_up_channel_no = v_sup_up_channel_no;
  else
    --不存在，添加
    insert into sup_base_relate_add_map
      (map_id, sup_up_channel_no, sup_down_channel_no, pro_up_channel_no)
    values
      (seq_sup_base_relate_add_map_id.nextval,
       v_sup_up_channel_no,
       v_sup_down_channel_no,
       v_pro_up_channel_no);
  end if;
  commit;
  v_result := pkg_error_code.success;
  return;
exception
  when others then
    rollback;
    fd_p_write_log('sup_p_relate_add_map', sqlerrm, 1);
    v_result := pkg_error_code.system_busy;
    return;
end;
/

prompt
prompt Creating procedure SUP_P_SYNC_CHANNEL_INFO
prompt ==========================================
prompt
create or replace procedure fd_account.sup_p_sync_channel_info(v_channel_no      varchar2, ---渠道编号
                                                    v_channel_name    varchar2, ---渠道名称
                                                    v_company_id      number, ---渠道所属公司编号
                                                    v_system_id       number, ---渠道所属系统编号
                                                    v_statistics_type number, ---上游渠道的财务分类，下游为0
                                                    v_channel_type    number, ---渠道类型，1上游，2下游
                                                    v_status          number, ---渠道状态，0启用，1禁用
                                                    v_operate_user    varchar2, ---操作人
                                                    v_operate_time    varchar2, ---操作时间,格式 yyyy-mm-dd hh24:mi:ss
                                                    v_result          out varchar2,
                                                    v_msg             out varchar2) as
  ----------------------渠道信息添加修改同步------------------
  pragma autonomous_transaction; --自治事务
  l_count number;
begin
  ---1.检查基础信息是否正确  
  v_result := sup_f_sync_channel_check(v_company_id,
                                       v_system_id,
                                       v_statistics_type,
                                       v_channel_type);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  if v_channel_type = 1 then
    ---2.检查上游渠道是否存在
    select count(1)
      into l_count
      from sup_base_up_channel t
     where t.channel_no = v_channel_no;
  
    if l_count = 0 then
      ---3.上游渠道创建
      v_result := sup_f_up_channel_create(v_channel_no,
                                          v_channel_name,
                                          v_company_id,
                                          v_system_id,
                                          v_statistics_type,
                                          v_status,
                                          v_operate_user,
                                          v_operate_time);
      if v_result != pkg_error_code.success then
        rollback;
        return;
      end if;
    
    else
      ---4.上游渠道更新
      v_result := sup_f_up_channel_update(v_channel_no,
                                          v_channel_name,
                                          v_company_id,
                                          v_system_id,
                                          v_statistics_type,
                                          v_status,
                                          v_operate_user,
                                          v_operate_time);
      if v_result != pkg_error_code.success then
        rollback;
        return;
      end if;
    
    end if;
  else
    ---5.检查下游渠道是否存在
    select count(1)
      into l_count
      from sup_base_down_channel t
     where t.channel_no = v_channel_no;
  
    if l_count = 0 then
      ---6.下游渠道创建
      v_result := sup_f_down_channel_create(v_channel_no,
                                            v_channel_name,
                                            v_company_id,
                                            v_system_id,
                                            v_status,
                                            v_operate_user,
                                            v_operate_time);
      if v_result != pkg_error_code.success then
        rollback;
        return;
      end if;
    else
      ---7.下游渠道更新
      v_result := sup_f_down_channel_update(v_channel_no,
                                            v_channel_name,
                                            v_company_id,
                                            v_system_id,
                                            v_status,
                                            v_operate_user,
                                            v_operate_time);
      if v_result != pkg_error_code.success then
        rollback;
        return;
      end if;
    end if;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('sup_p_sync_channel_info', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure SUP_P_SYNC_UP_CAPITAL_TRANSFER
prompt =================================================
prompt
create or replace procedure fd_account.sup_p_sync_up_capital_transfer(v_up_channel_no varchar2, ---上游渠道编号
                                                           v_transfer_type number, ---操作类型：1.实体卡入库，2.电子卡密入库，3.实体卡转电子卡密
                                                           v_card_count    number, ---卡张数
                                                           v_card_face     number, ---卡面值
                                                           v_card_amount   number, ---卡金额
                                                           v_change_time   varchar2, ---生成系统发生转移的时间，格式：yyyy-mm-dd hh24:mi:ss
                                                           v_memo          varchar2, ---备注信息
                                                           v_create_by     varchar2, ---操作人
                                                           v_result        out varchar2,
                                                           v_msg           out varchar2) as
  ----------------上游资产余额转移----------------
  pragma autonomous_transaction; --自治事务
  l_up_account_id number;
  l_company_id    number;
  l_system_id     number;
begin
  ---1.基础信息检查
  v_result := sup_f_sync_up_transfer_check(v_up_channel_no,
                                           v_card_count,
                                           v_card_face,
                                           v_card_amount,
                                           l_up_account_id,
                                           l_company_id,
                                           l_system_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  if v_transfer_type = 1 then
    ---2.实体卡入库
    v_result := sup_f_up_physical_storage(v_up_channel_no,
                                          l_up_account_id,
                                          l_company_id,
                                          l_system_id,
                                          v_card_count,
                                          v_card_face,
                                          v_card_amount,
                                          v_change_time,
                                          v_memo,
                                          v_create_by);
    if v_result != pkg_error_code.success then
      rollback;
      return;
    end if;
  
  elsif v_transfer_type = 2 then
    ---3.电子卡密入库
    v_result := sup_f_up_electronic_storage(v_up_channel_no,
                                            l_up_account_id,
                                            l_company_id,
                                            l_system_id,
                                            v_card_count,
                                            v_card_face,
                                            v_card_amount,
                                            v_change_time,
                                            v_memo,
                                            v_create_by);
    if v_result != pkg_error_code.success then
      rollback;
      return;
    end if;
  
  elsif v_transfer_type = 3 then
    ---4.实体卡转电子卡密
    v_result := sup_f_up_physical_2_electronic(v_up_channel_no,
                                               l_up_account_id,
                                               l_company_id,
                                               l_system_id,
                                               v_card_count,
                                               v_card_face,
                                               v_card_amount,
                                               v_change_time,
                                               v_memo,
                                               v_create_by);
    if v_result != pkg_error_code.success then
      rollback;
      return;
    end if;
  
  else
    v_result := pkg_error_code.system_busy;
    v_msg    := '操作类型不存在';
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('sup_p_sync_up_capital_transfer', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure SUP_P_TRADE_DOWN_ORDER_PAY
prompt =============================================
prompt
create or replace procedure fd_account.sup_p_trade_down_order_pay(v_down_channel_no varchar2, ---下游渠道编号
                                                       v_trade_order_no  varchar2, ---下游交易订单号
                                                       v_business_type   number, ---业务类型
                                                       v_carrier_no      varchar2, ---运营商
                                                       v_province_no     varchar2, ---省份
                                                       v_city_no         varchar2, ---城市
                                                       v_order_unit      number, ---订单规格
                                                       v_order_face      number, ---订单金额面值
                                                       v_order_amount    number, ---订单扣款金额
                                                       v_order_time      varchar2, ---生成系统订单生成时间，格式：yyyy-mm-dd hh24:mi:ss
                                                       v_change_time     varchar2, ---生成系统下游扣款时间，格式：yyyy-mm-dd hh24:mi:ss
                                                       v_memo            varchar2, ---扣款备注信息
                                                       v_result          out varchar2,
                                                       v_msg             out varchar2) as
  ----------------------下游订单扣款----------------------
  pragma autonomous_transaction; --自治事务
  l_company_id          number;
  l_system_id           number;
  l_down_account_id     number;
  l_local_business_type number;
  l_sup_order_id        number;
begin
  ---1.检查获取基础信息
  v_result := sup_f_down_pay_check(v_down_channel_no,
                                   v_business_type,
                                   v_order_unit,
                                   v_order_face,
                                   v_order_amount,
                                   l_company_id,
                                   l_system_id,
                                   l_down_account_id,
                                   l_local_business_type);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.历史库数据转移
  v_result := sup_f_history_trade_move(l_system_id,
                                       v_trade_order_no,
                                       v_order_time);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  else
    commit;
  end if;

  ---3.检查订单是否存在，不存在则创建订单
  v_result := sup_f_trade_order_create(l_system_id,
                                       l_company_id,
                                       v_down_channel_no,
                                       l_down_account_id,
                                       v_trade_order_no,
                                       l_local_business_type,
                                       v_carrier_no,
                                       v_province_no,
                                       v_city_no,
                                       v_order_unit,
                                       v_order_face,
                                       v_order_amount,
                                       v_order_time,
                                       l_sup_order_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.下游订单扣款
  v_result := sup_f_down_trade_debit(v_down_channel_no,
                                     l_down_account_id,
                                     l_company_id,
                                     l_system_id,
                                     l_sup_order_id,
                                     v_trade_order_no,
                                     l_local_business_type,
                                     v_order_face,
                                     v_order_amount,
                                     v_order_time,
                                     v_change_time,
                                     v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('sup_p_trade_down_order_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure SUP_P_TRADE_DOWN_ORDER_REFUND
prompt ================================================
prompt
create or replace procedure fd_account.sup_p_trade_down_order_refund(v_down_channel_no varchar2, ---下游渠道编号
                                                          v_trade_order_no  varchar2, ---下游交易订单号
                                                          v_trade_refund_no varchar2, ---下游退款编号
                                                          v_refund_face     number, ---退款金额面值
                                                          v_refund_amount   number, ---退款金额
                                                          v_order_time      varchar2, ---生成系统订单生成时间，格式：yyyy-mm-dd hh24:mi:ss
                                                          v_change_time     varchar2, ---生成系统下游退款时间，格式：yyyy-mm-dd hh24:mi:ss
                                                          v_memo            varchar2, ---扣款备注信息
                                                          v_result          out varchar2,
                                                          v_msg             out varchar2) as
  ----------------------下游订单退款------------------
  pragma autonomous_transaction; --自治事务
  l_system_id       number;
  l_down_account_id number;
  l_down_company_id number;
begin
  ---1.检查退款基本信息  
  v_result := sup_f_down_refund_check(v_down_channel_no,
                                      v_refund_face,
                                      v_refund_amount,
                                      l_system_id,
                                      l_down_company_id,
                                      l_down_account_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.获取历史数据
  v_result := sup_f_history_trade_move(l_system_id,
                                       v_trade_order_no,
                                       v_order_time);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  else
    commit;
  end if;

  ---3.订单退款
  v_result := sup_f_down_order_refund(v_down_channel_no,
                                      l_down_account_id,
                                      l_down_company_id,
                                      l_system_id,
                                      v_trade_order_no,
                                      v_trade_refund_no,
                                      v_refund_face,
                                      v_refund_amount,
                                      v_order_time,
                                      v_change_time,
                                      v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('sup_p_trade_down_order_refund', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure SUP_P_TRADE_UP_ORDER_PAY
prompt ===========================================
prompt
create or replace procedure fd_account.sup_p_trade_up_order_pay(v_up_channel_no     varchar2, ---上游渠道编号
                                                     v_down_channel_no   varchar2, ---下游渠道编号
                                                     v_trade_order_no    varchar2, ---交易订单号
                                                     v_trade_delivery_no varchar2, ---交易发货编号
                                                     v_bill_type         number, ---开票信息，前后项，1前向，不开票，2后项，需要开票
                                                     v_business_type     number, ---业务类型
                                                     v_carrier_no        varchar2, ---运营商
                                                     v_province_no       varchar2, ---省份
                                                     v_city_no           varchar2, ---城市编号
                                                     v_order_unit        number, ---订单规格
                                                     v_order_face        number, ---订单金额面值
                                                     v_order_Amount      number, ---订单金额
                                                     v_up_draw_count     number, ---上游扣款消耗库存卡张数
                                                     v_up_draw_unit      number, ---上游扣款规格
                                                     v_up_draw_face      number, ---上游扣款金额面值
                                                     v_up_draw_amount    number, ---上游扣款金额
                                                     v_order_time        varchar2, ---订单创建时间
                                                     v_change_time       varchar2, ---上游扣款发生时间
                                                     v_memo              varchar2, ---备注信息
                                                     v_result            out varchar2,
                                                     v_msg               out varchar2) as
  ------------------上游订单支付----------------------
  pragma autonomous_transaction; --自治事务
  l_down_account_id     number;
  l_up_account_id       number;
  l_company_id          number;
  l_system_id           number;
  l_local_business_type number;
  l_sup_order_id        number;
begin
  ---1.检查参数基本信息
  v_result := sup_f_up_pay_check(v_up_channel_no,
                                 v_down_channel_no,
                                 v_business_type,
                                 v_order_face,
                                 v_order_amount,
                                 v_up_draw_count,
                                 v_up_draw_face,
                                 v_up_draw_amount,
                                 l_down_account_id,
                                 l_up_account_id,
                                 l_company_id,
                                 l_system_id,
                                 l_local_business_type);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.历史库数据转移当前库
  v_result := sup_f_history_trade_move(l_system_id,
                                       v_trade_order_no,
                                       v_order_time);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  else
    commit;
  end if;

  ---3.检查订单是否存在，不存在则创建订单
  v_result := sup_f_trade_order_create(l_system_id,
                                       l_company_id,
                                       v_down_channel_no,
                                       l_down_account_id,
                                       v_trade_order_no,
                                       l_local_business_type,
                                       v_carrier_no,
                                       v_province_no,
                                       v_city_no,
                                       v_order_unit,
                                       v_order_face,
                                       v_order_amount,
                                       v_order_time,
                                       l_sup_order_id);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---4.上游订单扣款
  v_result := sup_f_up_order_pay(v_up_channel_no,
                                 l_up_account_id,
                                 v_down_channel_no,
                                 l_down_account_id,
                                 l_company_id,
                                 l_system_id,
                                 l_sup_order_id,
                                 v_trade_order_no,
                                 v_trade_delivery_no,
                                 v_bill_type,
                                 l_local_business_type,
                                 v_carrier_no,
                                 v_province_no,
                                 v_city_no,
                                 v_order_unit,
                                 v_order_face,
                                 v_order_amount,
                                 v_up_draw_count,
                                 v_up_draw_unit,
                                 v_up_draw_face,
                                 v_up_draw_amount,
                                 v_order_time,
                                 v_change_time,
                                 v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  v_result := pkg_error_code.success;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('sup_p_trade_up_order_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure SUP_P_TRADE_UP_ORDER_REFUND
prompt ==============================================
prompt
create or replace procedure fd_account.sup_p_trade_up_order_refund(v_up_channel_no     varchar2, ---上游渠道编号
                                                        v_down_channel_no   varchar2, ---下游渠道编号
                                                        v_trade_order_no    varchar2, ---交易订单号
                                                        v_trade_delivery_no varchar2, ---订单发货编号
                                                        v_trade_refund_no   varchar2, ---订单上游退款编号
                                                        v_bill_type         number, ---开票信息，前后项，1前向，不开票，2后项，需要开票
                                                        v_business_type     number, ---业务类型
                                                        v_up_refund_count   number, ---上游退款卡张数
                                                        v_up_refund_unit    number, ---上游退款规格
                                                        v_up_refund_face    number, ---上游退款金额面值
                                                        v_up_refund_amount  number, ---上游退款金额
                                                        v_order_time        varchar2, ---订单创建时间
                                                        v_change_time       varchar2, ---上游退款发生时间
                                                        v_memo              varchar2, ---备注信息
                                                        v_result            out varchar2,
                                                        v_msg               out varchar2) as
  -----------------------上游订单退款--------------------
  pragma autonomous_transaction; --自治事务
  l_up_account_id       number;
  l_down_account_id     number;
  l_company_id          number;
  l_system_id           number;
  l_local_business_type number;
begin
  ---1.检查基本信息
  v_result := sup_f_up_refund_check(v_up_channel_no,
                                    v_down_channel_no,
                                    v_business_type,
                                    v_up_refund_count,
                                    v_up_refund_face,
                                    v_up_refund_amount,
                                    l_up_account_id,
                                    l_down_account_id,
                                    l_company_id,
                                    l_system_id,
                                    l_local_business_type);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  ---2.历史库数据转移当前库
  v_result := sup_f_history_trade_move(l_system_id,
                                       v_trade_order_no,
                                       v_order_time);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  else
    commit;
  end if;

  ---3.上游订单退款
  v_result := sup_f_up_order_refund(v_up_channel_no,
                                    l_up_account_id,
                                    v_down_channel_no,
                                    l_down_account_id,
                                    l_company_id,
                                    l_system_id,
                                    v_bill_type,
                                    l_local_business_type,
                                    v_trade_order_no,
                                    v_trade_delivery_no,
                                    v_trade_refund_no,
                                    v_up_refund_count,
                                    v_up_refund_unit,
                                    v_up_refund_face,
                                    v_up_refund_amount,
                                    v_order_time,
                                    v_change_time,
                                    v_memo);
  if v_result != pkg_error_code.success then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    v_msg    := sqlerrm;
    fd_p_write_log('sup_p_trade_up_order_refund', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_CREATE_BUSINESS_TYPE
prompt ==========================================
prompt
create or replace procedure fd_account.yx_create_business_type(v_out_business_type in number, --生产系统业务类型编号
                                                    v_business_name     in varchar2, --业务类型名称
                                                    v_industry_type     in number, --行业类型
                                                    v_system_no         in number, --外部系统编号
                                                    v_out_status        out number --100:成功，200：失败
                                                    ) as
  ---------------------------------------------
  --主要功能：创建生产系统业务类型
  --创建人：周荣省
  --创建时间：2019-03-22
  ---------------------------------------------
  l_number        number;
  l_business_type number; --记账形同类型编号
begin
  --1、检查业务类型是否存在
  select count(*)
    into l_number
    from yx_base_business_map t
   where t.outer_business_type = v_out_business_type
     and t.outer_system_no = v_system_no;
  if (l_number >= 1) then
    --存在，修改
    select t.local_business_type
      into l_business_type
      from yx_base_business_map t
     where t.outer_business_type = v_out_business_type
       and t.outer_system_no = v_system_no;
  
    --修改记账系统业务类型名称
    update fd_system_business_info t
       set t.business_type_name = v_business_name
     where t.business_type = l_business_type;
  
    --修改关联表
    update yx_base_business_map t
       set t.industry_type = v_industry_type
     where t.outer_business_type = v_out_business_type
       and t.outer_system_no = v_system_no;
    if (sql%rowcount >= 1) then
      v_out_status := 100;
    else
      v_out_status := 200;
    end if;
    commit;
    return;
  end if;
  --不存在，添加
  select seq_system_business_info_id.nextval into l_number from dual;
  insert into fd_system_business_info
    (business_type, business_type_name)
  values
    (l_number, v_business_name);

  insert into yx_base_business_map
    (business_map_id,
     outer_business_type,
     local_business_type,
     industry_type,
     outer_system_no)
  values
    (seq_yxbasebusinessmap_auto_id.nextval,
     v_out_business_type,
     l_number,
     v_industry_type,
     v_system_no);
  if (sql%rowcount >= 1) then
    v_out_status := 100;
  else
    v_out_status := 200;
  end if;
  commit;
exception
  when others then
    rollback;
    fd_p_write_log('yx_create_business_type', sqlerrm, 200);
end;
/

prompt
prompt Creating procedure YX_P_ADJUST_AGENT_DRAW
prompt =========================================
prompt
create or replace procedure fd_account.yx_p_adjust_agent_draw(v_record_id   in number, ---记录编号
                                                   v_adjust_days in number, ---红冲天数
                                                   v_create_user in varchar2, ---创建人
                                                   v_memo        in varchar2, ---备注
                                                   v_result      out varchar2) as

  /*
      功能介绍:代理商提款红冲
      创建人:邓孝辉
      创建时间:2019/3/22
  */
begin
  ---1. 记录日志
  fd_p_write_handle_log('营销-代理商提款红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---2. 检查提款记录,账户,余额,手续费
  v_result := yx_f_adjust_agent_draw_check(v_record_id, v_adjust_days);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3. 红冲代理商提款
  v_result := yx_f_adjust_agent_draw(v_record_id, v_create_user, v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result:=pkg_error_code.system_busy;
    fd_p_write_log('yx_p_adjust_agent_draw', sqlerrm, 1);

end;
/

prompt
prompt Creating procedure YX_P_ADJUST_DOWN_ADD
prompt =======================================
prompt
create or replace procedure fd_account.yx_p_adjust_down_add(v_record_id   in number, ---记录编号
                                                 v_adjust_days in number, ---红冲天数
                                                 v_create_user in varchar2, ---创建人
                                                 v_memo        in varchar2, ---备注
                                                 v_result      out varchar2) as

  /*
      功能介绍:下游加款红冲
      创建人:邓孝辉
      创建时间:2019/3/22
  */
begin
  ---1. 记录日志
  fd_p_write_handle_log('营销-下游加款红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---2. 检查加款记录,账户
  v_result := yx_f_adjust_down_add_check(v_record_id, v_adjust_days);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3. 红冲下游加款
  v_result := yx_f_adjust_down_add(v_record_id, v_create_user, v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result:=pkg_error_code.system_busy;
    fd_p_write_log('yx_p_adjust_down_add', sqlerrm, 1);
  
end;
/

prompt
prompt Creating procedure YX_P_ADJUST_DOWN_DRAW
prompt ========================================
prompt
create or replace procedure fd_account.yx_p_adjust_down_draw(v_record_id   in number, ---记录编号
                                                   v_adjust_days in number, ---红冲天数
                                                   v_create_user in varchar2, ---创建人
                                                   v_memo        in varchar2, ---备注
                                                   v_result      out varchar2) as

  /*
      功能介绍:下游提款红冲
      创建人:邓孝辉
      创建时间:2019/3/22
  */
begin
  ---1. 记录日志
  fd_p_write_handle_log('营销-下游提款红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---2. 检查提款记录,账户,余额,手续费
  v_result := yx_f_adjust_down_draw_check(v_record_id, v_adjust_days);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3. 下游提款红冲
  v_result := yx_f_adjust_down_draw(v_record_id, v_create_user, v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result:=pkg_error_code.system_busy;
    fd_p_write_log('yx_p_adjust_down_draw', sqlerrm, 1);

end;
/

prompt
prompt Creating procedure YX_P_ADJUST_UP_ADD
prompt =====================================
prompt
create or replace procedure fd_account.yx_p_adjust_up_add(v_record_id   in number, ---记录编号
                                                   v_adjust_days in number, ---红冲天数
                                                   v_create_user in varchar2, ---创建人
                                                   v_memo        in varchar2, ---备注
                                                   v_result      out varchar2) as

  /*
      功能介绍:上游加款红冲
      创建人:邓孝辉
      创建时间:2019/3/22
  */
begin
  ---1. 记录日志
  fd_p_write_handle_log('营销-上游加款红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---2. 检查加款记录,账户,余额,手续费
  v_result := yx_f_adjust_up_add_check(v_record_id, v_adjust_days);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3. 红冲上游加款
  v_result := yx_f_adjust_up_add(v_record_id, v_create_user, v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result:=pkg_error_code.system_busy;
    fd_p_write_log('yx_p_adjust_up_add', sqlerrm, 1);

end;
/

prompt
prompt Creating procedure YX_P_ADJUST_UP_DRAW
prompt ======================================
prompt
create or replace procedure fd_account.yx_p_adjust_up_draw(v_record_id   in number, ---记录编号
                                                   v_adjust_days in number, ---红冲天数
                                                   v_create_user in varchar2, ---创建人
                                                   v_memo        in varchar2, ---备注
                                                   v_result      out varchar2) as

  /*
      功能介绍:上游提款红冲
      创建人:邓孝辉
      创建时间:2019/3/22
  */
begin
  ---1. 记录日志
  fd_p_write_handle_log('营销-上游提款红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---2. 检查提款记录,账户,余额,手续费
  v_result := yx_f_adjust_up_draw_check(v_record_id, v_adjust_days);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3. 红冲上游提款
  v_result := yx_f_adjust_up_draw(v_record_id, v_create_user, v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result:=pkg_error_code.system_busy;
    fd_p_write_log('yx_p_adjust_up_draw', sqlerrm, 1);

end;
/

prompt
prompt Creating procedure YX_P_ADJUST_UP_SERVICE_DRAW
prompt ==============================================
prompt
create or replace procedure fd_account.yx_p_adjust_up_service_draw(v_record_id   in number, ---记录编号
                                                        v_adjust_days in number, ---红冲天数
                                                        v_create_user in varchar2, ---创建人
                                                        v_memo        in varchar2, ---备注
                                                        v_result      out varchar2) as

  /*
      功能介绍:上游服务费提现红冲
      创建人:邓孝辉
      创建时间:2019/3/22
  */
begin
  ---1. 记录日志
  fd_p_write_handle_log('营销-服务费提现红冲',
                        v_create_user,
                        'v_record_id=' || v_record_id);

  ---2. 检查加款记录,账户,余额,手续费
  v_result := yx_f_adjust_up_service_d_check(v_record_id, v_adjust_days);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3. 红冲上游加款
  v_result := yx_f_adjust_up_service_draw(v_record_id, v_create_user, v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_adjust_up_service_draw', sqlerrm, 1);

end;
/

prompt
prompt Creating procedure YX_P_AUTO_AGENT_FUND_DAILY
prompt =============================================
prompt
create or replace procedure fd_account.yx_p_auto_agent_fund_daily(v_report_date in varchar2 default null) as
  /*
         功能介绍:代理人资金变动日统计
         创建人:邓孝辉
         创建时间:2019/4/02
  */
  l_report_date  date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count number;
  l_length       number;

begin
  if (l_report_date is null) then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select a.agent_id,
                      a.agent_name,
                      a.company_id,
                      a.balance,
                      a.status
                 from yx_base_agent a) loop
    begin
      --1.检查是否已经存在记录
      select count(1)
        into l_report_count
        from yx_report_fund_daily y
       where y.report_time = l_report_date
         and y.channel_type = pkg_yx_channel_type.agent_channel
         and y.channel_no = item.agent_id
         and y.company_id = item.company_id;
    
      --2.查询变动类型条数
      select count(1)
        into l_length
        from (select t.change_type, t.business_type
                from yx_trade_agent_fund t
               where t.change_time >= l_report_date
                 and t.change_time < l_report_date + 1
                 and t.agent_id = item.agent_id
               group by t.change_type, t.business_type);
    
      if (l_report_count < l_length) then
        insert into yx_report_fund_daily
          (record_id,
           report_time,
           channel_type,
           channel_no,
           change_type,
           daily_sum_amount,
           company_id,
           business_type)
          select seq_yxreportfunddaily_auto_id.nextval,
                 l_report_date,
                 pkg_yx_channel_type.agent_channel,
                 item.agent_id,
                 ta.change_type,
                 ta.daily_amount,
                 item.company_id,
                 ta.business_type
            from (select f.change_type,
                         f.business_type,
                         sum(f.change_amount) daily_amount
                    from yx_trade_agent_fund f
                   where f.agent_id = item.agent_id
                     and f.change_time >= l_report_date
                     and f.change_time < l_report_date + 1
                     and not exists
                   (select b.change_type
                            from yx_report_fund_daily b
                           where b.change_type = f.change_type
                             and b.report_time = l_report_date
                             and b.channel_no = item.agent_id
                             and b.channel_type =
                                 pkg_yx_channel_type.agent_channel
                             and b.company_id = item.company_id)
                   group by f.change_type, f.business_type) ta;
      
      end if;
     commit;
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_agent_fund_daily', sqlerrm, 1);
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('yx_p_auto_agent_fund_daily', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_AUTO_DIFFER_COLLECT
prompt ===========================================
prompt
create or replace procedure fd_account.yx_p_auto_differ_collect(v_collect_date in varchar2 default null) as
  -------------------------------------
  --主要功能：删除五天前时间差异为0的数据
  --创建人：周荣省
  --创建时间：2019-04-09
  -------------------------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  l_delete_date  date;
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;
  --1、删除5天前的数据
  l_delete_date := l_collect_date - 5;
  delete from yx_trade_order_main_differ t
   where t.record_date >= l_delete_date
     and t.record_date < (l_delete_date + 1)
     and t.down_first_face = 0;
  commit;
end;
/

prompt
prompt Creating procedure YX_P_AUTO_DOWN_FUND_DAILY
prompt ============================================
prompt
create or replace procedure fd_account.yx_p_auto_down_fund_daily(v_report_date in varchar2 default null) as
  /*
         功能介绍:下游资金变动日统计
         创建人:邓孝辉
         创建时间:2019/4/02
  */
  l_report_date  date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count number;
  l_length       number;

begin
  if (l_report_date is null) then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select a.channel_no, a.company_id from yx_base_down_channel a) loop
    begin
      --1.检查是否已经存在记录
      select count(1)
        into l_report_count
        from yx_report_fund_daily y
       where y.report_time = l_report_date
         and y.channel_type = pkg_yx_channel_type.down_channel
         and y.channel_no = item.channel_no
         and y.company_id = item.company_id;
    
      --2.查询变动类型条数
      select count(1)
        into l_length
        from (select t.change_type
                from yx_trade_down_fund t
               where t.change_time >= l_report_date
                 and t.change_time < l_report_date + 1
                 and t.down_channel_no = item.channel_no
               group by t.change_type);
    
      if (l_report_count < l_length) then
        insert into yx_report_fund_daily
          (record_id,
           report_time,
           channel_type,
           channel_no,
           change_type,
           daily_sum_amount,
           company_id)
          select seq_yxreportfunddaily_auto_id.nextval,
                 l_report_date,
                 pkg_yx_channel_type.down_channel,
                 item.channel_no,
                 ta.change_type,
                 ta.daily_amount,
                 item.company_id
            from (select f.change_type, sum(f.change_amount) daily_amount
                    from yx_trade_down_fund f
                   where f.down_channel_no = item.channel_no
                     and f.change_time >= l_report_date
                     and f.change_time < l_report_date + 1
                     and not exists
                   (select b.change_type
                            from yx_report_fund_daily b
                           where b.change_type = f.change_type
                             and b.report_time = l_report_date
                             and b.channel_no = item.channel_no
                             and b.channel_type =
                                 pkg_yx_channel_type.down_channel
                             and b.company_id = item.company_id)
                   group by f.change_type) ta;
      end if;
     commit;
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_down_fund_daily', sqlerrm, 1);
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('yx_p_auto_down_fund_daily', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_AUTO_EXPENSE_ADD_CAP
prompt ============================================
prompt
create or replace procedure fd_account.yx_p_auto_expense_add_cap(v_add_date in varchar2 default null) as
  ----------------------------------------------------
  --主要功能：将费用资金变动定时添加到三方费用资金变动
  --创建人：周荣省
  --创建时间：2019-03-27
  ----------------------------------------------------
  l_add_date          date := to_date(v_add_date, 'yyyymmddhh24miss'); --输入时间转换成年月日时分秒格式
  l_all_change_amount number; --费用表内变动费用总和
  l_max_record_id     number; --最新记录
  l_balance           number; --费用表最新的账户余额

  --l_account_id number; --费用账户
  l_company_id number; --公司

  l_expense_balance number; --费用账户余额
begin
  --1、获取添加三方账户资金变动时间
  if l_add_date is null then
    l_add_date := trunc(sysdate) - 1;
  end if;
  for item in (select t.account_id,
                      sum(t.change_amount) l_all_change_amount,
                      max(t.record_id) l_max_record_id
                 from yx_trade_expense t
                where t.change_time >= l_add_date
                  and t.change_time < l_add_date + 1
                  and t.income_type=pkg_yx_expense_type.income_type_out
                group by t.account_id) loop
    begin
      --2、锁并修改费用账户
      select t.balance
        into l_expense_balance
        from fd_base_company_account_cap t
       where t.account_id = item.account_id
         for update;
    
      update fd_base_company_account_cap t
         set t.balance = (l_expense_balance + item.l_all_change_amount)
       where t.account_id = item.account_id;
      if (sql%rowcount = 0) then
        rollback;
        return;
      end if;
      --3、添加三方账户资金变动
      insert into fd_trade_co_cap_fund
        (change_id,
         account_id,
         change_amount,
         change_type,
         balance,
         change_time,
         memo)
      values
        (seq_trade_co_cap_fund_id.nextval,
         item.account_id,
         item.l_all_change_amount,
         pkg_co_cap_fund_type.add_amount,
         (l_expense_balance + item.l_all_change_amount),
         sysdate,
         '-sys');
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_expense_add_cap', sqlerrm, 1);
    end;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('yx_p_auto_expense_add_cap', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_AUTO_INCOME_ADD_CAP
prompt ===========================================
prompt
create or replace procedure fd_account.yx_p_auto_income_add_cap(v_add_date in varchar2 default null) as
  ----------------------------------------------------
  --主要功能：将费用资金变动定时添加到三方费用资金变动
  --创建人：周荣省
  --创建时间：2019-03-27
  ----------------------------------------------------
  l_add_date          date := to_date(v_add_date, 'yyyymmddhh24miss'); --输入时间转换成年月日时分秒格式
  l_all_change_amount number; --费用表内变动费用总和
  l_max_record_id     number; --最新记录
  l_balance           number; --费用表最新的账户余额

  --l_account_id number; --费用账户
  l_company_id number; --公司

  l_expense_balance number; --费用账户余额
begin
  --1、获取添加三方账户资金变动时间
  if l_add_date is null then
    l_add_date := trunc(sysdate) - 1;
  end if;
  for item in (select t.account_id,
                      sum(t.change_amount) l_all_change_amount,
                      max(t.record_id) l_max_record_id
                 from yx_trade_expense t
                where t.change_time >= l_add_date
                  and t.change_time < l_add_date + 1
                  and t.income_type=pkg_yx_expense_type.income_type_in
                group by t.account_id) loop
    begin
      --2、锁并修改费用账户
      select t.balance
        into l_expense_balance
        from fd_base_company_account_cap t
       where t.account_id = item.account_id
         for update;

      update fd_base_company_account_cap t
         set t.balance = (l_expense_balance + item.l_all_change_amount)
       where t.account_id = item.account_id;
      if (sql%rowcount = 0) then
        rollback;
        return;
      end if;
      --3、添加三方账户资金变动
      insert into fd_trade_co_cap_fund
        (change_id,
         account_id,
         change_amount,
         change_type,
         balance,
         change_time,
         memo)
      values
        (seq_trade_co_cap_fund_id.nextval,
         item.account_id,
         item.l_all_change_amount,
         pkg_co_cap_fund_type.add_amount,
         (l_expense_balance + item.l_all_change_amount),
         sysdate,
         '-sys');
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_expense_add_cap', sqlerrm, 1);
    end;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('yx_p_auto_expense_add_cap', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_AUTO_REPORT_DAIYL
prompt =========================================
prompt
create or replace procedure fd_account.yx_p_auto_report_daiyl(v_collect_date in varchar2 default null) as
  /*
         功能介绍:统计日交易报表
         创建人:邓孝辉
         创建时间:2019/3/20
         修改内容：增加发行统计
         修改人：周荣省
         修改时间：2019-06-10
  */

  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  l_start_time   date := sysdate;
  l_count        number;

begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  for item in (select ta1.*, nvl(ta2.agent_fee, 0) agent_fee
                 from (select t.up_channel_no,
                              t.down_channel_no,
                              t.agent_id,
                              t.business_type,
                              sum(t.down_draw_face +
                                  nvl(t2.down_adjust_face, 0)) down_draw_face,
                              sum(t.down_draw_amount +
                                  nvl(t2.down_adjust_amount, 0)) down_draw_amount,
                              count(decode(t.yx_order_id,
                                           '-',
                                           null,
                                           t.yx_order_id)) order_count,
                              sum(t.dowm_handling_fee) handling_fee,
                              sum(t.up_draw_face) up_draw_face,
                              sum(t.up_draw_amount) up_draw_amount,
                              sum(t.income_amount +
                                  nvl(t2.down_adjust_income, 0)) income_amount,
                              sum(t.up_real_amount) up_real_amount,
                              sum(t.down_real_amount +
                                  nvl(t2.down_adjust_real, 0)) down_real_amount,
                              sum(t.service_fee) service_fee,
                              sum(t.down_coupon_amount) down_coupon_amount
                         from (select max(tab.up_channel_no) up_channel_no,
                                      max(tab.down_channel_no) down_channel_no,
                                      max(tab.agent_id) agent_id,
                                      max(tab.business_type) business_type,
                                      tab.yx_order_id,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_amount,
                                                 1,
                                                 -1) * down_draw_face) down_draw_face,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_amount,
                                                 1,
                                                 -1) * down_draw_amount) down_draw_amount,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_amount,
                                                 1,
                                                 -1) * up_draw_face) up_draw_face,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_amount,
                                                 1,
                                                 -1) * dowm_handling_fee) dowm_handling_fee,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_amount,
                                                 1,
                                                 -1) * up_draw_amount) up_draw_amount,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_amount,
                                                 1,
                                                 -1) * income_amount) income_amount,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_amount,
                                                 1,
                                                 -1) * up_servie_fee) service_fee,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_amount,
                                                 1,
                                                 -1) * tab.down_real_amount) down_real_amount,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_amount,
                                                 1,
                                                 -1) * tab.up_real_amount) up_real_amount,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_amount,
                                                 1,
                                                 -1) * tab.coupon_amount) down_coupon_amount
                                 from yx_trade_up_fund tab
                                where tab.change_time >= l_collect_date
                                  and tab.change_time < l_collect_date + 1
                                  and tab.change_type in
                                      (pkg_up_fund_change_type.debit_amount,
                                       pkg_up_fund_change_type.refund_amount)
                                  and tab.yx_order_id > 0
                                group by tab.yx_order_id) t
                         left join (select ta.yx_order_id,
                                          max(ta.channel_no) channel_no,
                                          max(ta.business_type) business_type,
                                          sum(ta.down_adjust_face) down_adjust_face,
                                          sum(ta.down_adjust_unit) down_adjust_unit,
                                          sum(ta.down_adjust_amount) down_adjust_amount,
                                          sum(ta.down_adjust_real) down_adjust_real,
                                          sum(ta.down_adjust_income) down_adjust_income
                                     from yx_trade_up_fund_differ ta
                                    where ta.record_date >= l_collect_date
                                      and ta.record_date < l_collect_date + 1
                                    group by ta.yx_order_id) t2 on t2.yx_order_id =
                                                                   t.yx_order_id
                                                               and t2.channel_no =
                                                                   t.down_channel_no
                                                               and t2.business_type =
                                                                   t.business_type
                        group by t.up_channel_no,
                                 t.down_channel_no,
                                 t.agent_id,
                                 t.business_type) ta1
                 left join (select a.up_channel_no,
                                  a.down_channel_no,
                                  a.agent_id,
                                  a.business_type,
                                  sum(decode(a.change_type,
                                             pkg_up_fund_change_type.debit_amount,
                                             1,
                                             -1) * a.change_amount) agent_fee
                             from yx_trade_agent_fund a
                            where a.change_time >= l_collect_date
                              and a.change_time < l_collect_date + 1
                              and a.change_type in
                                  (pkg_up_fund_change_type.debit_amount,
                                   pkg_up_fund_change_type.refund_amount)
                            group by a.up_channel_no,
                                     a.down_channel_no,
                                     a.agent_id,
                                     a.business_type) ta2 on ta2.up_channel_no =
                                                             ta1.up_channel_no
                                                         and ta2.down_channel_no =
                                                             ta1.down_channel_no
                                                         and ta2.agent_id =
                                                             ta1.agent_id
                                                         and ta2.business_type =
                                                             ta1.business_type) loop
    begin
      select count(1)
        into l_count
        from yx_report_daily yrd
       where yrd.report_time = l_collect_date
         and yrd.up_channel_no = item.up_channel_no
         and yrd.down_channel_no = item.down_channel_no
         and yrd.agent_id = item.agent_id
         and yrd.business_type = item.business_type
         and yrd.issue = 0;
    
      if (l_count = 0) then
        if item.up_channel_no != '0' and item.down_channel_no != '0' then
          insert into yx_report_daily
            (record_id,
             report_time,
             up_channel_no,
             down_channel_no,
             agent_id,
             business_type,
             up_draw_face,
             up_draw_amount,
             order_count,
             servie_fee,
             agency_fee,
             handling_fee,
             down_draw_face,
             down_draw_amount,
             income_amount,
             down_real_amount,
             up_real_amount,
             down_coupon_amount)
          values
            (seq_yxreportdaily_auto_id.nextval,
             l_collect_date,
             item.up_channel_no,
             item.down_channel_no,
             item.agent_id,
             item.business_type,
             item.up_draw_face,
             item.up_draw_amount,
             item.order_count,
             item.service_fee,
             item.agent_fee,
             item.handling_fee,
             item.down_draw_face,
             item.down_draw_amount,
             item.income_amount,
             item.down_real_amount,
             item.up_real_amount,
             item.down_coupon_amount);
        end if;
        commit;
      end if;
    
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_report_daiyl', sqlerrm, 1);
    end;
  end loop;
  --发行统计
  for item in (select ta1.*, nvl(ta2.agent_fee, 0) agent_fee
                 from (select t.up_channel_no,
                              t.down_channel_no,
                              t.agent_id,
                              t.business_type,
                              sum(t.down_draw_face +
                                  nvl(t2.down_adjust_face, 0)) down_draw_face,
                              sum(t.down_draw_amount +
                                  nvl(t2.down_adjust_amount, 0)) down_draw_amount,
                              count(decode(t.yx_order_id,
                                           '-',
                                           null,
                                           t.yx_order_id)) order_count,
                              sum(t.dowm_handling_fee) handling_fee,
                              sum(t.up_draw_face) up_draw_face,
                              sum(t.up_draw_amount) up_draw_amount,
                              sum(t.income_amount +
                                  nvl(t2.down_adjust_income, 0)) income_amount,
                              sum(t.up_real_amount) up_real_amount,
                              sum(t.down_real_amount +
                                  nvl(t2.down_adjust_real, 0)) down_real_amount,
                              sum(t.service_fee) service_fee,
                              sum(t.down_coupon_amount) down_coupon_amount
                         from (select max(tab.up_channel_no) up_channel_no,
                                      max(tab.down_channel_no) down_channel_no,
                                      max(tab.agent_id) agent_id,
                                      max(tab.business_type) business_type,
                                      tab.yx_order_id,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_issue,
                                                 1,
                                                 -1) * down_draw_face) down_draw_face,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_issue,
                                                 1,
                                                 -1) * down_draw_amount) down_draw_amount,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_issue,
                                                 1,
                                                 -1) * up_draw_face) up_draw_face,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_issue,
                                                 1,
                                                 -1) * dowm_handling_fee) dowm_handling_fee,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_issue,
                                                 1,
                                                 -1) * up_draw_amount) up_draw_amount,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_issue,
                                                 1,
                                                 -1) * income_amount) income_amount,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_issue,
                                                 1,
                                                 -1) * up_servie_fee) service_fee,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_issue,
                                                 1,
                                                 -1) * tab.down_real_amount) down_real_amount,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_issue,
                                                 1,
                                                 -1) * tab.up_real_amount) up_real_amount,
                                      sum(decode(tab.change_type,
                                                 pkg_up_fund_change_type.debit_amount,
                                                 1,
                                                 -1) * tab.coupon_amount) down_coupon_amount
                                 from yx_trade_up_fund tab
                                where tab.change_time >= l_collect_date
                                  and tab.change_time < l_collect_date + 1
                                  and tab.change_type in
                                      (pkg_up_fund_change_type.debit_issue,
                                       pkg_up_fund_change_type.refund_issue)
                                  and tab.yx_order_id > 0
                                group by tab.yx_order_id) t
                         left join (select ta.yx_order_id,
                                          max(ta.channel_no) channel_no,
                                          max(ta.business_type) business_type,
                                          sum(ta.down_adjust_face) down_adjust_face,
                                          sum(ta.down_adjust_unit) down_adjust_unit,
                                          sum(ta.down_adjust_amount) down_adjust_amount,
                                          sum(ta.down_adjust_real) down_adjust_real,
                                          sum(ta.down_adjust_income) down_adjust_income
                                     from yx_trade_up_fund_differ ta
                                    where ta.record_date >= l_collect_date
                                      and ta.record_date < l_collect_date + 1
                                    group by ta.yx_order_id) t2 on t2.yx_order_id =
                                                                   t.yx_order_id
                                                               and t2.channel_no =
                                                                   t.down_channel_no
                                                               and t2.business_type =
                                                                   t.business_type
                        group by t.up_channel_no,
                                 t.down_channel_no,
                                 t.agent_id,
                                 t.business_type) ta1
                 left join (select a.up_channel_no,
                                  a.down_channel_no,
                                  a.agent_id,
                                  a.business_type,
                                  sum(decode(a.change_type,
                                             pkg_up_fund_change_type.debit_issue,
                                             1,
                                             -1) * a.change_amount) agent_fee
                             from yx_trade_agent_fund a
                            where a.change_time >= l_collect_date
                              and a.change_time < l_collect_date + 1
                              and a.change_type in
                                  (pkg_up_fund_change_type.debit_issue,
                                   pkg_up_fund_change_type.refund_issue)
                            group by a.up_channel_no,
                                     a.down_channel_no,
                                     a.agent_id,
                                     a.business_type) ta2 on ta2.up_channel_no =
                                                             ta1.up_channel_no
                                                         and ta2.down_channel_no =
                                                             ta1.down_channel_no
                                                         and ta2.agent_id =
                                                             ta1.agent_id
                                                         and ta2.business_type =
                                                             ta1.business_type) loop
    begin
      select count(1)
        into l_count
        from yx_report_daily yrd
       where yrd.report_time = l_collect_date
         and yrd.up_channel_no = item.up_channel_no
         and yrd.down_channel_no = item.down_channel_no
         and yrd.agent_id = item.agent_id
         and yrd.business_type = item.business_type
         and yrd.issue = 1;
    
      if (l_count = 0) then
        if item.up_channel_no != '0' and item.down_channel_no != '0' then
          insert into yx_report_daily
            (record_id,
             report_time,
             up_channel_no,
             down_channel_no,
             agent_id,
             business_type,
             up_draw_face,
             up_draw_amount,
             order_count,
             servie_fee,
             agency_fee,
             handling_fee,
             down_draw_face,
             down_draw_amount,
             income_amount,
             down_real_amount,
             up_real_amount,
             down_coupon_amount,
             issue)
          values
            (seq_yxreportdaily_auto_id.nextval,
             l_collect_date,
             item.up_channel_no,
             item.down_channel_no,
             item.agent_id,
             item.business_type,
             item.up_draw_face,
             item.up_draw_amount,
             item.order_count,
             item.service_fee,
             item.agent_fee,
             item.handling_fee,
             item.down_draw_face,
             item.down_draw_amount,
             item.income_amount,
             item.down_real_amount,
             item.up_real_amount,
             item.down_coupon_amount,
             1);
        end if;
        commit;
      end if;
    
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_report_daiyl', sqlerrm, 1);
    end;
  end loop;
  --平账
  for item in (select ta1.*, nvl(ta2.agent_fee, 0) agent_fee
                 from (select tab.up_channel_no,
                              tab.down_channel_no,
                              tab.agent_id,
                              tab.business_type,
                              count(decode(tab.yx_order_id,
                                           '-',
                                           null,
                                           tab.yx_order_id)) order_count,
                              sum(decode(tab.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) * down_draw_face) down_draw_face,
                              sum(decode(tab.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) * down_draw_amount) down_draw_amount,
                              sum(decode(tab.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) * up_draw_face) up_draw_face,
                              sum(decode(tab.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) * dowm_handling_fee) handling_fee,
                              sum(decode(tab.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) * up_draw_amount) up_draw_amount,
                              sum(decode(tab.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) * income_amount) income_amount,
                              sum(decode(tab.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) * up_servie_fee) service_fee,
                              sum(decode(tab.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) * tab.down_real_amount) down_real_amount,
                              sum(decode(tab.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) * tab.up_real_amount) up_real_amount,
                              sum(decode(tab.change_type,
                                         pkg_up_fund_change_type.debit_amount,
                                         1,
                                         -1) * tab.coupon_amount) down_coupon_amount
                         from yx_trade_up_fund tab
                        where tab.change_time >= l_collect_date
                          and tab.change_time < l_collect_date + 1
                          and tab.change_type in
                              (pkg_up_fund_change_type.debit_amount,
                               pkg_up_fund_change_type.refund_amount)
                          and tab.yx_order_id = 0
                        group by tab.up_channel_no,
                                 tab.down_channel_no,
                                 tab.agent_id,
                                 tab.business_type) ta1
                 left join (select a.up_channel_no,
                                  a.down_channel_no,
                                  a.agent_id,
                                  a.business_type,
                                  sum(decode(a.change_type,
                                             pkg_up_fund_change_type.debit_amount,
                                             1,
                                             -1) * a.change_amount) agent_fee
                             from yx_trade_agent_fund a
                            where a.change_time >= l_collect_date
                              and a.change_time < l_collect_date + 1
                              and a.change_type in
                                  (pkg_up_fund_change_type.debit_amount,
                                   pkg_up_fund_change_type.refund_amount)
                            group by a.up_channel_no,
                                     a.down_channel_no,
                                     a.agent_id,
                                     a.business_type) ta2 on ta2.up_channel_no =
                                                             ta1.up_channel_no
                                                         and ta2.down_channel_no =
                                                             ta1.down_channel_no
                                                         and ta2.agent_id =
                                                             ta1.agent_id
                                                         and ta2.business_type =
                                                             ta1.business_type) loop
    begin
      select count(1)
        into l_count
        from yx_report_daily yrd
       where yrd.report_time = l_collect_date
         and yrd.up_channel_no = item.up_channel_no
         and yrd.down_channel_no = item.down_channel_no
         and yrd.agent_id = item.agent_id
         and yrd.business_type = item.business_type
         and yrd.issue = 0;
    
      if (l_count = 0) then
        if item.up_channel_no != '0' or item.down_channel_no != '0' then
          insert into yx_report_daily
            (record_id,
             report_time,
             up_channel_no,
             down_channel_no,
             agent_id,
             business_type,
             up_draw_face,
             up_draw_amount,
             order_count,
             servie_fee,
             agency_fee,
             handling_fee,
             down_draw_face,
             down_draw_amount,
             income_amount,
             down_real_amount,
             up_real_amount,
             down_coupon_amount)
          values
            (seq_yxreportdaily_auto_id.nextval,
             l_collect_date,
             item.up_channel_no,
             item.down_channel_no,
             item.agent_id,
             item.business_type,
             item.up_draw_face,
             item.up_draw_amount,
             item.order_count,
             item.service_fee,
             item.agent_fee,
             item.handling_fee,
             item.down_draw_face,
             item.down_draw_amount,
             item.income_amount,
             item.down_real_amount,
             item.up_real_amount,
             item.down_coupon_amount);
        end if;
        commit;
      end if;
    
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_report_daiyl', sqlerrm, 1);
    end;
  end loop;

  for item in (select t.up_channel_no,
                      t.down_channel_no,
                      t.agent_id,
                      t.business_type,
                      sum(decode(t.change_type,
                                 pkg_up_fund_change_type.debit_amount,
                                 1,
                                 -1) * t.change_amount) agent_fee
                 from yx_trade_agent_fund t
                where t.change_time >= l_collect_date
                  and t.change_time < l_collect_date + 1
                  and t.change_type in
                      (pkg_up_fund_change_type.debit_amount,
                       pkg_up_fund_change_type.refund_amount)
                group by t.up_channel_no,
                         t.down_channel_no,
                         t.agent_id,
                         t.business_type) loop
  
    begin
      select count(1)
        into l_count
        from yx_report_daily yrd
       where yrd.report_time = l_collect_date
         and yrd.up_channel_no = item.up_channel_no
         and yrd.down_channel_no = item.down_channel_no
         and yrd.agent_id = item.agent_id
         and yrd.business_type = item.business_type
         and yrd.issue = 0;
    
      if l_count = 0 then
        if item.up_channel_no != '0' or
           item.down_channel_no != '0' and item.agent_id != '0' then
          insert into yx_report_daily
            (record_id,
             report_time,
             up_channel_no,
             down_channel_no,
             agent_id,
             business_type,
             up_draw_face,
             up_draw_amount,
             order_count,
             servie_fee,
             agency_fee,
             handling_fee,
             down_draw_face,
             down_draw_amount,
             income_amount,
             down_real_amount,
             up_real_amount)
          values
            (seq_yxreportdaily_auto_id.nextval,
             l_collect_date,
             item.up_channel_no,
             item.down_channel_no,
             item.agent_id,
             item.business_type,
             0,
             0,
             0,
             0,
             item.agent_fee,
             0,
             0,
             0,
             0,
             0,
             0);
        end if;
        commit;
      end if;
    
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_report_daiy1', sqlerrm, 1);
    end;
  end loop;

  fd_p_proc_log('yx_p_auto_report_daiyl', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('yx_p_auto_report_daiyl', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_AUTO_UP_FUND_DAILY
prompt ==========================================
prompt
create or replace procedure fd_account.yx_p_auto_up_fund_daily(v_report_date in varchar2 default null) as
  /*
         功能介绍:上游资金变动日统计
         创建人:邓孝辉
         创建时间:2019/4/02
  */
  l_report_date  date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count number;

  l_length number;

begin
  if (l_report_date is null) then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select a.channel_no, a.company_id from yx_base_up_channel a) loop
    begin
      --1.检查是否已经存在记录
      select count(1)
        into l_report_count
        from yx_report_fund_daily y
       where y.report_time = l_report_date
         and y.channel_type = pkg_yx_channel_type.up_channel
         and y.channel_no = item.channel_no
         and y.company_id = item.company_id;
    
      --2. 查询变动类型条数
      select count(1)
        into l_length
        from (select f.change_type, f.business_type
                from yx_trade_up_fund f
               where f.change_time >= l_report_date
                 and f.change_time < l_report_date + 1
                 and f.up_channel_no = item.channel_no
               group by f.change_type, f.business_type);
    
      if (l_report_count < l_length) then
        insert into yx_report_fund_daily
          (record_id,
           report_time,
           channel_type,
           channel_no,
           change_type,
           daily_sum_amount,
           company_id,
           business_type)
          select seq_yxreportfunddaily_auto_id.nextval,
                 l_report_date,
                 pkg_yx_channel_type.up_channel,
                 item.channel_no,
                 ta.change_type,
                 ta.daily_amount,
                 item.company_id,
                 ta.business_type
            from (select f.change_type,
                         f.business_type,
                         sum(f.up_draw_amount) daily_amount
                    from yx_trade_up_fund f
                   where f.up_channel_no = item.channel_no
                     and f.change_time >= l_report_date
                     and f.change_time < l_report_date + 1
                     and not exists
                   (select 1
                            from yx_report_fund_daily b
                           where b.change_type = f.change_type
                             and b.business_type = f.business_type
                             and b.report_time = l_report_date
                             and b.channel_no = item.channel_no
                             and b.channel_type =
                                 pkg_yx_channel_type.up_channel
                             and b.company_id = item.company_id)
                   group by f.change_type, f.business_type) ta;
      
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_up_fund_daily', sqlerrm, 1);
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('yx_p_auto_up_fund_daily', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_AUTO_ZERO_AGENT
prompt =======================================
prompt
create or replace procedure fd_account.yx_p_auto_zero_agent(v_report_date in varchar2 default null) as
  /*
         功能介绍:代理人零点余额,代理人时零点余额表中channel_no是agent_id,channel_name是agent_name
         创建人:邓孝辉
         创建时间:2019/3/21
  */
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number;
  l_fund_count      number;
  l_max_change_time date;
  l_max_record_id   number;

begin
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select a.agent_id,
                      a.agent_name,
                      a.company_id,
                      a.balance,
                      a.status,
                      c.source_system_id
                 from yx_base_agent a
                 left join yx_base_down_channel c on c.channel_no=a.down_channel_no) loop
    begin
      --1.检查是否已经有记录
      select count(1)
        into l_report_count
        from yx_report_zero_balance z
       where z.report_time = l_report_date
         and z.account_type = pkg_yx_acc_type.agent_acc
         and z.channel_no = item.agent_id
         and z.company_id = item.company_id
         and rownum <= 1;
    
      if (l_report_count = 0) then
        ---2.是否存在资金变动
        select count(1), max(f.change_time)
          into l_fund_count, l_max_change_time
          from yx_trade_agent_fund f
         where f.change_time >= l_report_date
           and f.change_time < l_report_date + 1
           and f.agent_id = item.agent_id;
      
        if (l_fund_count > 0) then
          select max(a.record_id)
            into l_max_record_id
            from yx_trade_agent_fund a
           where a.change_time = l_max_change_time
             and a.agent_id = item.agent_id;
        
          insert into yx_report_zero_balance
            (record_id,
             report_time,
             create_time,
             account_type,
             account_id,
             channel_no,
             channel_name,
             balance,
             channel_status,
             CHANNEL_SOURCE_SYSTEM,
             company_id)
            select seq_yxzerobalance_auto_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_yx_acc_type.agent_acc,
                   0,
                   item.agent_id,
                   item.agent_name,
                   y.balance,
                   item.status,
                   item.source_system_id,
                   item.company_id
              from yx_trade_agent_fund y
             where y.record_id = l_max_record_id;
        else
          insert into yx_report_zero_balance
            (record_id,
             report_time,
             create_time,
             account_type,
             account_id,
             channel_no,
             channel_name,
             balance,
             channel_status,
             CHANNEL_SOURCE_SYSTEM,
             company_id)
            select seq_yxzerobalance_auto_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_yx_acc_type.agent_acc,
                   0,
                   item.agent_id,
                   item.agent_name,
                   tab.balance,
                   item.status,
                   item.source_system_id,
                   item.company_id
              from (select nvl(max(r.balance), item.balance) balance
                      from yx_report_zero_balance r
                     where r.report_time = l_report_date - 1
                       and r.account_type = pkg_yx_acc_type.agent_acc
                       and r.channel_no = item.agent_id
                       and rownum <= 1) tab;
        end if;
      
      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_zero_agent', sqlerrm, 1);
    end;
  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('yx_p_auto_zero_agent', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_AUTO_ZERO_DOWN
prompt ======================================
prompt
create or replace procedure fd_account.yx_p_auto_zero_down(v_report_date in varchar2 default null) as

  /*
    功能介绍:获取下游零点余额
    创建人:邓孝辉
    创建时间:2019/3/21
  */

  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss');
  l_report_count    number;
  l_count           number;
  l_max_change_time date;
  l_max_record      number;
begin
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;

  for item in (select t.channel_no,
                      t.channel_name,
                      t.company_id,
                      t.account_id,
                      t.source_system_id,
                      t.status,
                      a.account_name,
                      a.query_balance,
                      a.inner_balance,
                      (nvl(f.down_first_face, 0) -
                      nvl(ur.down_adjust_face, 0)) down_first_face,
                      (nvl(f.down_first_amount, 0) -
                      nvl(ur.down_adjust_real, 0)) down_first_amount
                 from yx_base_down_channel t
                 left join yx_base_down_account a
                   on a.account_id = t.account_id
                 left join (select d.channel_no,
                                  d.account_id,
                                  sum(d.down_first_face) down_first_face,
                                  sum(d.down_first_amount) down_first_amount
                             from yx_trade_order_main_differ d
                            where d.record_date = l_report_date
                            group by d.channel_no, d.account_id) f 
                  on f.channel_no= t.channel_no and f.account_id = t.account_id
                 left join (select u.channel_no,
                                  u.account_id,
                                  sum(u.down_adjust_face) down_adjust_face,
                                  sum(u.down_adjust_real) down_adjust_real
                             from yx_trade_up_fund_differ u
                            where u.record_date = l_report_date
                            group by u.channel_no, u.account_id) ur
                            on ur.channel_no=t.channel_no and ur.account_id=t.account_id ) loop
    begin
      ---1. 查询记录是否存在
      select count(1)
        into l_report_count
        from yx_report_zero_balance z
       where z.report_time = l_report_date
         and z.account_type = pkg_yx_acc_type.down_channel
         and z.account_id = item.account_id
         and z.channel_no = item.channel_no
         and z.company_id = item.company_id
         and z.channel_source_system = item.source_system_id
         and rownum <= 1;

      if (l_report_count = 0) then

        ---2. 检查是否存在资金变动
        select count(1), max(f.change_time)
          into l_count, l_max_change_time
          from yx_trade_down_fund f
         where f.change_time >= l_report_date
           and f.change_time < l_report_date + 1
           and f.down_account_id = item.account_id;

        if (l_count > 0) then
          select max(ytdf.record_id)
            into l_max_record
            from yx_trade_down_fund ytdf
           where ytdf.change_time = l_max_change_time
             and ytdf.down_account_id = item.account_id;

          insert into yx_report_zero_balance
            (record_id,
             report_time,
             create_time,
             account_type,
             account_id,
             channel_no,
             channel_name,
             balance,
             query_balance,
             channel_status,
             company_id,
             channel_source_system,
             DOWN_FIRST_FACE,
             DOWN_FIRST_AMOUNT)
            select seq_yxzerobalance_auto_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_yx_acc_type.down_channel,
                   item.account_id,
                   item.channel_no,
                   item.channel_name,
                   t.balance,
                   item.query_balance,
                   item.status,
                   item.company_id,
                   item.source_system_id,
                   item.down_first_face,
                   item.down_first_amount
              from yx_trade_down_fund t
             where t.record_id = l_max_record;

        else
          insert into yx_report_zero_balance
            (record_id,
             report_time,
             create_time,
             account_type,
             account_id,
             channel_no,
             channel_name,
             balance,
             query_balance,
             channel_status,
             company_id,
             channel_source_system)
            select seq_yxzerobalance_auto_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_yx_acc_type.down_channel,
                   item.account_id,
                   item.channel_no,
                   item.channel_name,
                   tab.balance,
                   item.query_balance,
                   item.status,
                   item.company_id,
                   item.source_system_id
              from (select nvl(max(b.balance), item.inner_balance) balance
                      from yx_report_zero_balance b
                     where b.report_time = l_report_date - 1
                       and b.account_type = pkg_yx_acc_type.down_channel
                       and b.channel_no = item.channel_no
                       and b.account_id = item.account_id
                       and rownum <= 1) tab;

        end if;

      end if;
      commit;
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_zero_down', sqlerrm, 1);
    end;

  end loop;

exception
  when others then
    rollback;
    fd_p_write_log('yx_p_auto_zero_down', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_AUTO_ZERO_DOWN_SEND
prompt ===========================================
prompt
create or replace procedure fd_account.yx_p_auto_zero_down_send(v_report_date in varchar2 default null) as
  ----------------------------------------------------
  --功能介绍:获取下游发行成本零点余额
  --创建人:周荣省
  --创建时间:2019-06-10
  --------------------------------------------------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss'); --输入时间转换成年月日时分秒格式
  l_report_count    number;
  l_fund_count      number;
  l_max_change_time date;
  l_max_record_id   number;
  l_issue_balance   number := 0;

begin
  --1、获取零点余额报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;
  for item in (select c.channel_no,
                      c.channel_name,
                      c.company_id,
                      c.source_system_id,
                      c.status,
                      c.account_id,
                      c.issue_balance,
                      (nvl(f.down_first_face, 0) -
                      nvl(ur.down_adjust_face, 0)) down_first_face,
                      (nvl(f.down_first_amount, 0) -
                      nvl(ur.down_adjust_real, 0)) down_first_amount
                 from yx_base_down_channel c
                 left join (select d.channel_no,
                                  d.account_id,
                                  sum(d.down_first_face) down_first_face,
                                  sum(d.down_first_amount) down_first_amount
                             from yx_trade_order_main_differ d
                            where d.record_date = l_report_date
                            group by d.channel_no, d.account_id) f on f.channel_no =
                                                                      c.channel_no
                                                                  and f.account_id = 0
                 left join (select u.channel_no,
                                  u.account_id,
                                  sum(u.down_adjust_face) down_adjust_face,
                                  sum(u.down_adjust_real) down_adjust_real
                             from yx_trade_up_fund_differ u
                            where u.record_date = l_report_date
                            group by u.channel_no, u.account_id) ur on ur.channel_no =
                                                                       c.channel_no
                                                                   and ur.account_id = 0) loop
    begin
    
      ---2.查询记录是否存在
      select count(1)
        into l_report_count
        from yx_report_zero_balance b
       where b.report_time = l_report_date
         and b.account_type = pkg_yx_acc_type.send_revenue
         and b.channel_no = item.channel_no
         and b.company_id = item.company_id
         and b.channel_source_system = item.source_system_id
         and b.account_id = 0
         and rownum <= 1;
      --2.1记录未生成
      if (l_report_count = 0) then
        --3.判断是否存在资金变动
        select count(1), max(t.change_time)
          into l_fund_count, l_max_change_time
          from yx_trade_down_fund t
         where t.change_time >= l_report_date
           and t.change_time < l_report_date + 1
           and t.down_channel_no = item.channel_no
           and t.change_type in (pkg_down_fund_change_type.debit_issue,
                pkg_down_fund_change_type.refund_issue);
        --4.获取发行收入零点余额
        if l_fund_count > 0 then
          select max(t.record_id)
            into l_max_record_id
            from yx_trade_down_fund t
           where t.change_time = l_max_change_time
             and t.down_channel_no = item.channel_no
             and t.change_type in (pkg_down_fund_change_type.debit_issue,
                  pkg_down_fund_change_type.refund_issue);
          select t.balance
            into l_issue_balance
            from yx_trade_down_fund t
           where t.record_id = l_max_record_id;
        else
          select nvl(max(t.balance), item.issue_balance)
            into l_issue_balance
            from yx_report_zero_balance t
           where t.report_time = l_report_date - 1
             and t.account_type = pkg_yx_acc_type.send_revenue
             and t.channel_no = item.channel_no
             and t.company_id = item.company_id
             and t.channel_source_system = item.source_system_id
             and t.account_id = 0
             and rownum <= 1;
        end if;
        --5.添加零点余额
        insert into yx_report_zero_balance
          (record_id,
           report_time,
           create_time,
           account_type,
           account_id,
           channel_no,
           channel_name,
           balance,
           query_balance,
           channel_status,
           company_id,
           channel_source_system,
           DOWN_FIRST_FACE,
           DOWN_FIRST_AMOUNT)
        values
          (seq_yxzerobalance_auto_id.nextval,
           l_report_date,
           sysdate,
           pkg_yx_acc_type.send_revenue,
           0,
           item.channel_no,
           item.channel_name,
           l_issue_balance,
           0,
           item.status,
           item.company_id,
           item.source_system_id,
           item.down_first_face,
           item.down_first_amount);
      end if;
      commit;
    
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_zero_up_send', sqlerrm, 1);
    end;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('yx_p_auto_zero_up_send', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_AUTO_ZERO_SERVICE
prompt =========================================
prompt
create or replace procedure fd_account.yx_p_auto_zero_service(v_report_date in varchar2 default null) as
  /*
         功能介绍:获取上游零点余额
         创建人:邓孝辉
         创建时间:2019/3/21
  */
  l_report_date       date := to_date(v_report_date, 'yyyymmddhh24miss'); --输入时间转换成年月日时分秒格式
  l_report_count      number;
  l_yesterday_count   number;
  l_yesterday_balance number := 0;
  l_sum_balance       number;
  l_draw_service      number;

begin
  --1、获取零点余额报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;
  for item in (select c.channel_no,
                      c.channel_name,
                      c.company_id,
                      c.source_system_id,
                      c.status,
                      c.account_id,
                      c.service_balance
                 from yx_base_up_channel c) loop
    begin
    
      ---2.查询记录是否存在
      select count(1)
        into l_report_count
        from yx_report_zero_balance b
       where b.report_time = l_report_date
         and b.account_type = pkg_yx_acc_type.service_fee_acc
         and b.channel_no = item.channel_no
         and b.company_id = item.company_id
         and b.channel_source_system = item.source_system_id
         and b.account_id = 0
         and rownum <= 1;
    
      if (l_report_count = 0) then
        select count(1)
          into l_yesterday_count
          from yx_report_zero_balance b
         where b.report_time = l_report_date - 1
           and b.account_type = pkg_yx_acc_type.service_fee_acc
           and b.channel_no = item.channel_no
           and b.company_id = item.company_id
           and b.channel_source_system = item.source_system_id
           and b.account_id = 0
           and rownum <= 1;
      
        if (l_yesterday_count > 0) then
          select b.balance
            into l_yesterday_balance
            from yx_report_zero_balance b
           where b.report_time = l_report_date - 1
             and b.account_type = pkg_yx_acc_type.service_fee_acc
             and b.channel_no = item.channel_no
             and b.company_id = item.company_id
             and b.channel_source_system = item.source_system_id
             and b.account_id = 0
             and rownum <= 1;
        end if;
      
        select sum(decode(t.change_type,
                          pkg_up_fund_change_type.refund_amount,
                          -1,
                          pkg_up_fund_change_type.debit_amount,
                          1) * t.up_servie_fee),
               sum(decode(t.change_type,
                          pkg_up_fund_change_type.service_tran_balance,
                          -1,
                          pkg_up_fund_change_type.service_draw,
                          -1) * t.up_real_amount)
          into l_sum_balance, l_draw_service
          from yx_trade_up_fund t
         where t.change_time >= l_report_date
           and t.change_time < l_report_date + 1
           and t.up_channel_no = item.channel_no
           and t.up_company_id = item.company_id
           and t.change_type in
               (pkg_up_fund_change_type.debit_amount,
                pkg_up_fund_change_type.refund_amount,
                pkg_up_fund_change_type.service_tran_balance,
                pkg_up_fund_change_type.service_draw);
      
        insert into yx_report_zero_balance
          (record_id,
           report_time,
           create_time,
           account_type,
           account_id,
           channel_no,
           channel_name,
           balance,
           channel_status,
           company_id,
           channel_source_system)
        values
          (seq_yxzerobalance_auto_id.nextval,
           l_report_date,
           sysdate,
           pkg_yx_acc_type.service_fee_acc,
           0,
           item.channel_no,
           item.channel_name,
           l_yesterday_balance + l_sum_balance + l_draw_service,
           item.status,
           item.company_id,
           item.source_system_id);
      
      end if;
      commit;
    
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_zero_service', sqlerrm, 1);
    end;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('yx_p_auto_zero_service', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_AUTO_ZERO_UP
prompt ====================================
prompt
create or replace procedure fd_account.yx_p_auto_zero_up(v_report_date in varchar2 default null) as
  /*
         功能介绍:获取上游零点余额
         创建人:邓孝辉
         创建时间:2019/3/21
  */
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss'); --输入时间转换成年月日时分秒格式
  l_report_count    number;
  l_fund_count      number;
  l_max_change_time date;
  l_max_record_id   number;

begin
  --1、获取零点余额报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;
  for item in (select c.channel_no,
                      c.channel_name,
                      c.company_id,
                      c.source_system_id,
                      c.status,
                      c.account_id,
                      a.account_name,
                      a.query_balance,
                      a.inner_balance
                 from yx_base_up_channel c
                 left join yx_base_up_account a on a.account_id =
                                                   c.account_id) loop
    begin
    
      ---2.查询记录是否存在
      select count(1)
        into l_report_count
        from yx_report_zero_balance b
       where b.report_time = l_report_date
         and b.account_type = pkg_yx_acc_type.up_channel
         and b.channel_no = item.channel_no
         and b.company_id = item.company_id
         and b.channel_source_system = item.source_system_id
         and b.account_id = item.account_id
         and rownum <= 1;
    
      if (l_report_count = 0) then
      
        ---3. 是否存在资金变动
        select count(1), max(t.change_time)
          into l_fund_count, l_max_change_time
          from yx_trade_up_fund t
         where t.change_time >= l_report_date 
           and t.change_time < l_report_date+1
           and t.up_account_id = item.account_id
           and t.change_type in (pkg_up_fund_change_type.add_amount,
                pkg_up_fund_change_type.debit_amount,
                pkg_up_fund_change_type.refund_amount,
                pkg_up_fund_change_type.draw_amount);
      
        if (l_fund_count > 0) then
          select max(uf.record_id)
            into l_max_record_id
            from yx_trade_up_fund uf
           where uf.change_time = l_max_change_time
             and uf.up_account_id = item.account_id
             and uf.change_type in (pkg_up_fund_change_type.add_amount,
                  pkg_up_fund_change_type.debit_amount,
                  pkg_up_fund_change_type.refund_amount,
                  pkg_up_fund_change_type.draw_amount);
        
          insert into yx_report_zero_balance
            (record_id,
             report_time,
             create_time,
             account_type,
             account_id,
             channel_no,
             channel_name,
             balance,
             query_balance,
             channel_status,
             company_id,
             channel_source_system)
            select seq_yxzerobalance_auto_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_yx_acc_type.up_channel,
                   item.account_id,
                   item.channel_no,
                   item.channel_name,
                   t.balance,
                   item.query_balance,
                   item.status,
                   item.company_id,
                   item.source_system_id
              from yx_trade_up_fund t
             where t.record_id = l_max_record_id;
        
        else
        
          insert into yx_report_zero_balance
            (record_id,
             report_time,
             create_time,
             account_type,
             account_id,
             channel_no,
             channel_name,
             balance,
             query_balance,
             channel_status,
             company_id,
             channel_source_system)
            select seq_yxzerobalance_auto_id.nextval,
                   l_report_date,
                   sysdate,
                   pkg_yx_acc_type.up_channel,
                   item.account_id,
                   item.channel_no,
                   item.channel_name,
                   tab.balance,
                   item.query_balance,
                   item.status,
                   item.company_id,
                   item.source_system_id
              from (select nvl(max(b.balance), item.inner_balance) balance
                      from yx_report_zero_balance b
                     where b.report_time = l_report_date - 1
                       and b.account_type = pkg_yx_acc_type.up_channel
                       and b.channel_no = item.channel_no
                       and b.account_id = item.account_id
                       and rownum <= 1) tab;
        end if;
      
      end if;
      commit;
    
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_zero_up', sqlerrm, 1);
    end;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('yx_p_auto_zero_up', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_AUTO_ZERO_UP_SEND
prompt =========================================
prompt
create or replace procedure fd_account.yx_p_auto_zero_up_send(v_report_date in varchar2 default null) as
  ----------------------------------------------------
  --功能介绍:获取上游发行成本零点余额
  --创建人:周荣省
  --创建时间:2019-06-10
  --------------------------------------------------------
  l_report_date     date := to_date(v_report_date, 'yyyymmddhh24miss'); --输入时间转换成年月日时分秒格式
  l_report_count    number;
  l_fund_count      number;
  l_max_change_time date;
  l_max_record_id   number;
  l_issue_balance   number := 0;

begin
  --1、获取零点余额报表时间
  if l_report_date is null then
    l_report_date := trunc(sysdate) - 1;
  end if;
  for item in (select c.channel_no,
                      c.channel_name,
                      c.company_id,
                      c.source_system_id,
                      c.status,
                      c.account_id,
                      c.issue_balance
                 from yx_base_up_channel c) loop
    begin
    
      ---2.查询记录是否存在
      select count(1)
        into l_report_count
        from yx_report_zero_balance b
       where b.report_time = l_report_date
         and b.account_type = pkg_yx_acc_type.send_cost
         and b.channel_no = item.channel_no
         and b.company_id = item.company_id
         and b.channel_source_system = item.source_system_id
         and b.account_id = 0
         and rownum <= 1;
      --2.1记录未生成
      if (l_report_count = 0) then
        --3.判断是否存在资金变动
        select count(1), max(t.change_time)
          into l_fund_count, l_max_change_time
          from yx_trade_up_fund t
         where t.change_time >= l_report_date
           and t.change_time < l_report_date + 1
           and t.up_channel_no = item.channel_no
           and t.change_type in (pkg_up_fund_change_type.debit_issue,
                pkg_up_fund_change_type.refund_issue);
        --4.获取发行收入零点余额
        if l_fund_count > 0 then
          select max(t.record_id)
            into l_max_record_id
            from yx_trade_up_fund t
           where t.change_time = l_max_change_time
             and t.up_channel_no = item.channel_no
             and t.change_type in (pkg_up_fund_change_type.debit_issue,
                  pkg_up_fund_change_type.refund_issue);
          select t.balance
            into l_issue_balance
            from yx_trade_up_fund t
           where t.record_id = l_max_record_id;
        else
          select nvl(max(t.balance), item.issue_balance)
            into l_issue_balance
            from yx_report_zero_balance t
           where t.report_time = l_report_date - 1
             and t.account_type = pkg_yx_acc_type.send_cost
             and t.channel_no = item.channel_no
             and t.company_id = item.company_id
             and t.channel_source_system = item.source_system_id
             and t.account_id = 0
             and rownum <= 1;
        end if;
        --5.添加零点余额
        insert into yx_report_zero_balance
          (record_id,
           report_time,
           create_time,
           account_type,
           account_id,
           channel_no,
           channel_name,
           balance,
           query_balance,
           channel_status,
           company_id,
           channel_source_system)
        values
          (seq_yxzerobalance_auto_id.nextval,
           l_report_date,
           sysdate,
           pkg_yx_acc_type.send_cost,
           0,
           item.channel_no,
           item.channel_name,
           l_issue_balance,
           0,
           item.status,
           item.company_id,
           item.source_system_id);
      end if;
      commit;
    
    exception
      when others then
        rollback;
        fd_p_write_log('yx_p_auto_zero_up_send', sqlerrm, 1);
    end;
  end loop;
exception
  when others then
    rollback;
    fd_p_write_log('yx_p_auto_zero_up_send', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_CREATE_CHANNEL_INFO
prompt ===========================================
prompt
create or replace procedure fd_account.yx_p_create_channel_info(v_channel_no    in varchar2, --渠道编号
                                                     v_channel_name  in varchar2, --渠道名称
                                                     v_channel_type  in number, --渠道类型: 1-上游渠道 2-下游渠道
                                                     v_isupdate      in number, --是否是修改：1-新建，2-修改
                                                     v_company_id    in number, --公司编号
                                                     v_status        in number, -- 渠道状态: 0-启用 1-禁用
                                                     v_system_no     in number, -- 系统编号
                                                     v_warn_balance  in number, --报警余额
                                                     v_commi_balance in number, --佣金余额
                                                     v_channel_class in number, --渠道类型1：自有渠道2：银行渠道3：行业渠道
                                                     v_user in varchar2,--创建人、修改人
                                                     v_msg           out varchar2 --返回消息
                                                     ) as
  ----------------------------------
  --主要功能：记账系统后台创建或修改渠道信息
  --创建人：周荣省
  --创建时间：2019-04-24
  ----------------------------------
  l_number number;
  l_status number;
begin
  l_status := v_status;
  if (l_status is not null and l_status <> 0) then
    l_status := 1;
  end if;
  if (v_channel_type = 1) then
    --上游
    --判断渠道是否存在(要求不同渠道的渠道编号必须不相同）
    select count(*)
      into l_number
      from yx_base_up_channel t
     where t.channel_no = v_channel_no;
    if (l_number >= 1) then
      --渠道已经存在
      if v_isupdate <> 2 then
        v_msg := '渠道已经存在';
        rollback;
        return;
      end if;
      update yx_base_up_channel t
         set t.channel_name   = v_channel_name,
             t.company_id     = v_company_id,
             t.status         = l_status,
             t.last_edit_user = v_user,
             t.last_edit_time = sysdate
       where t.channel_no = v_channel_no
         and t.source_system_id = v_system_no;
      if (sql%rowcount >= 1) then
        v_msg := pkg_error_code.success;
      else
        v_msg := '修改失败';
      end if;
      commit;
      return;
    end if;
    --渠道不存在，添加
    if v_isupdate <> 1 then
      v_msg := '渠道不存在';
      rollback;
      return;
    end if;
    l_number := seq_yxbaseupaccount_auto_id.nextval;
    --添加上游账户
    insert into yx_base_up_account
      (account_id,
       account_name,
       query_balance,
       inner_balance,
       created_user,
       created_time)
    values
      (l_number, v_channel_name || '支付', 0, 0, v_user, sysdate);
    --添加上游渠道
    insert into yx_base_up_channel
      (channel_no,
       channel_name,
       company_id,
       source_system_id,
       warn_balance,
       commi_balance,
       account_id,
       status,
       created_user,
       created_time,
       service_balance)
    values
      (v_channel_no,
       v_channel_name,
       v_company_id,
       v_system_no,
       v_warn_balance,
       v_commi_balance,
       l_number,
       l_status,
       v_user,
       sysdate,
       0);
  
    if (sql%rowcount >= 1) then
      v_msg := pkg_error_code.success;
    else
      v_msg := '添加失败';
    end if;
  else
    --下游
    --判断渠道是否存在
    select count(*)
      into l_number
      from yx_base_down_channel t
     where t.channel_no = v_channel_no;
    if (l_number >= 1) then
      if v_isupdate <> 2 then
        v_msg := '渠道已经存在';
        rollback;
        return;
      end if;
      --渠道已经存在，修改
      update yx_base_down_channel t
         set t.channel_name   = v_channel_name,
             t.company_id     = v_company_id,
             t.status         = l_status,
             t.last_edit_user = v_user,
             t.last_edit_time = sysdate
       where t.channel_no = v_channel_no
         and t.source_system_id = v_system_no;
      if (sql%rowcount >= 1) then
        v_msg := pkg_error_code.success;
      else
        v_msg :='修改失败';
      end if;
      commit;
      return;
    end if;
    --渠道不存在，添加
    if v_isupdate <> 1 then
      v_msg := '渠道不存在';
      rollback;
      return;
    end if;
    l_number := seq_yxbasedownaccount_auto_id.nextval;
    --添加下游账户
    insert into yx_base_down_account
      (account_id,
       account_name,
       query_balance,
       inner_balance,
       created_user,
       created_time)
    values
      (l_number, v_channel_name || '支付', 0, 0, v_user, sysdate);
    --添加下游渠道
    insert into yx_base_down_channel
      (channel_no,
       channel_name,
       company_id,
       source_system_id,
       warn_balance,
       commi_balance,
       account_id,
       status,
       channel_class,
       created_user,
       created_time)
    values
      (v_channel_no,
       v_channel_name,
       v_company_id,
       v_system_no,
       v_warn_balance,
       v_commi_balance,
       l_number,
       l_status,
       v_channel_class,
       v_user,
       sysdate);
  
    if (sql%rowcount >= 1) then
      v_msg := pkg_error_code.success;
    else
      v_msg := '添加失败';
    end if;
  end if;
  commit;
exception
  when others then
    v_msg := '操作失败';
    rollback;
    fd_p_write_log('yx_sync_channel_info', sqlerrm, 200);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_ADD_CREDIT
prompt =========================================
prompt
create or replace procedure fd_account.yx_p_manual_add_credit(v_down_channel_no in varchar2, --下游渠道编号
                                                   v_credit_amount   in number, --授信金额
                                                   v_create_user     in varchar2, ---操作人
                                                   v_result          out varchar2) as
  ---------------------------------------------------------
  --功能：下游渠道添加授信余额
  --创建人：周荣省
  --创建时间：2019-06-17
  ---------------------------------------------------------
  l_down_account_id number; --下游渠道账号
begin
  --1.查找下游渠道账号
  select t.account_id
    into l_down_account_id
    from yx_base_down_channel t
   where t.channel_no = v_down_channel_no;
  --2.修改账户授信
  update yx_base_down_account t
     set t.credit_money = v_credit_amount
   where t.account_id = l_down_account_id;
  ---3.记录操作日志
  fd_p_write_handle_log('营销-修改授信余额',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || l_down_account_id));
  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_add_credit', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_AGENT_DRAW
prompt =========================================
prompt
create or replace procedure fd_account.yx_p_manual_agent_draw(v_agent_id        in   varchar2,   ---代理人编号
                                                   v_bank_account_id in   number,   ---实体卡编号
                                                   v_amount          in   number,   ---提现金额
                                                   v_service_fee     in   number,   ---手续费
                                                   v_memo            in   varchar2, ---备注
                                                   v_create_user     in   varchar2, ---创建人
                                                   v_result          out varchar2) as

    /*
       功能介绍:代理人提款
       创建人:邓孝辉
       创建时间:2019/3/19
    */
    l_agent_name   varchar2(32);
begin
  ---1. 记录操作日志
  fd_p_write_handle_log('营销-代理人人工提款',
                         v_create_user,
                         ('v_agent_id=' ||v_agent_id ||
                         'v_amount=' || v_amount));

   ---2. 检查代理人及其关联情况
   v_result:=yx_f_manual_agent_draw_check(v_agent_id,
                                          v_bank_account_id,
                                          v_service_fee,
                                          v_amount,
                                          l_agent_name);

   if(v_result!=pkg_error_code.success) then
    rollback;
    return;
   end if;

   ---3. 代理人提现(锁实体卡账户、代理人账户)
   v_result:=yx_f_manual_agent_draw(v_agent_id,
                                    v_bank_account_id,
                                    v_amount,
                                    v_service_fee,
                                    v_memo,
                                    v_create_user,
                                    l_agent_name);

   if(v_result!=pkg_error_code.success) then
    rollback;
    return;
   end if;

   commit;

exception
  when others then
    rollback;
    v_result:=pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_agent_draw',sqlerrm,1);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_AGENT_RV_FEE
prompt ===========================================
prompt
create or replace procedure fd_account.yx_p_manual_agent_rv_fee(v_agent_id       in    varchar2,
                                                     v_agent_fee      in    number,
                                                     v_business_type  in    number,
                                                     v_create_user    in    varchar2,
                                                     v_memo           in    varchar2,
                                                     v_result         out   varchar2) as
     /*
      创建人:邓孝辉
      创建时间:2019-5-6
      简介:代理费平账
     */
     l_down_channel_no             varchar2(32);
     l_down_company_id             number;
    begin
      --1. 校验代理费,代理信息
      v_result:=yx_f_manual_agent_rv_check(v_agent_id,
                                           v_agent_fee);
       if(v_result!=pkg_error_code.success) then
        rollback;
        return;
       end if;

      --2.代理费平账
      v_result:=yx_f_manual_agent_rv_fee(v_agent_id,
                                         v_agent_fee,
                                         l_down_channel_no,
                                         l_down_company_id,
                                         v_business_type,
                                         v_create_user,
                                         v_memo);
       if(v_result!=pkg_error_code.success) then
        rollback;
        return;
       end if;

      --3.添加日志
        fd_p_write_handle_log('营销-代理费平账',
                        v_create_user,
                        ('v_agent_id=' || v_agent_id ||
                        ',v_agent_fee=' || v_agent_fee));
         commit;
      exception
        when others then
          rollback;
          v_result:=pkg_error_code.system_busy;
          fd_p_write_log('yx_p_manual_agent_rv_fee',sqlerrm,1);
     end;
/

prompt
prompt Creating procedure YX_P_MANUAL_DOWN_ADD
prompt =======================================
prompt
create or replace procedure fd_account.yx_p_manual_down_add(v_down_channel_no in varchar2, --下游渠道编号
                                                 v_bank_account_id in number, --实体卡账户号
                                                 v_amount          in number, --加款金额
                                                 v_create_user     in varchar2, --加款人
                                                 v_memo            in varchar2, --备注
                                                 v_result          out varchar2) as

/*
   功能描述:下游渠道加款
   创建人:邓孝辉
   创建时间:2019/3/18
*/
l_account_id   number;
l_account_name varchar2(32);
l_channel_name varchar2(32);

begin
 --1.记录日志操作
  fd_p_write_handle_log('营销-下游人工加款',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_amount=' || v_amount));

  --2.检查下游渠道,账户以及关联情况
  v_result:=yx_f_manual_down_add_check(v_down_channel_no,
                                       v_bank_account_id,
                                       v_amount,
                                       l_account_name,
                                       l_channel_name,
                                       l_account_id);

  if(v_result!=pkg_error_code.success) then
      rollback;
      return;
  end if;


  --3.账户手工加款(锁实体银行卡,渠道账户)
  v_result:=yx_f_manual_down_add(v_down_channel_no,
                                 v_bank_account_id,
                                 v_amount,
                                 v_create_user,
                                 v_memo,
                                 l_account_id,
                                 l_account_name,
                                 l_channel_name);

  if(v_result!=pkg_error_code.success) then
      rollback;
      return;
  end if;

   commit;

exception
  when others then
    rollback;
     v_result:=pkg_error_code.system_busy;
     fd_p_write_log('yx_p_manual_down_add',sqlerrm,1);
end ;
/

prompt
prompt Creating procedure YX_P_MANUAL_DOWN_DRAW
prompt ========================================
prompt
create or replace procedure fd_account.yx_p_manual_down_draw(v_down_channel_no  in varchar2, --下游渠道编号
                                                   v_bank_account_id in number,   --实体卡账户号
                                                   v_service_fee     in number,   --手续费
                                                   v_amount          in number,   --提款金额
                                                   v_create_user     in varchar2, --创建人
                                                   v_memo            in varchar2, --备注
                                                   v_result          out varchar2) as


/*
       功能介绍:下游提款
       创建人:邓孝辉
       创建时间:2019/3/18
*/
 l_account_name varchar2(32);
 l_channel_name varchar2(32);
 l_account_id   number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('营销-下游渠道人工提款',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_amount=' || v_amount));

  ---2.检查下游渠道、账户及其关联情况
  v_result:=yx_f_manual_down_draw_check(v_down_channel_no,
                                        v_bank_account_id,
                                        v_service_fee,
                                        v_amount,
                                        l_account_name,
                                        l_channel_name,
                                        l_account_id);

  if(v_result!=pkg_error_code.success) then
   rollback;
   return;
  end if;


  ---3.账户手工提款(锁实体卡账户、渠道账户)
  v_result:=yx_f_manual_down_draw(v_down_channel_no,
                                  l_account_id,
                                  v_bank_account_id,
                                  v_service_fee,
                                  v_amount,
                                  v_create_user,
                                  v_memo,
                                  l_account_name,
                                  l_channel_name);

  if(v_result!=pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result:=pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_down_draw',sqlerrm,10);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_DOWN_INNER_TSFER
prompt ===============================================
prompt
create or replace procedure fd_account.yx_p_manual_down_inner_tsfer(v_out_channel_no in varchar2, --转出账户
                                                         v_in_channel_no  in varchar2, --转入账户
                                                         v_amount         in number, --转出金额
                                                         v_hander_user    in varchar2,
                                                         v_memo           in varchar2, --备注
                                                         v_result         out varchar2) as

  /*
   创建者:邓孝辉
   创建时间:2019-04-30
   简介:下游余额内转
  */
  l_out_account_id number;
  l_in_account_id  number;
begin
  --1.校验转入转出渠道信息
  v_result := yx_f_manual_down_inner_check(v_out_channel_no,
                                           v_in_channel_no,
                                           v_amount,
                                           l_out_account_id,
                                           l_in_account_id);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --2.渠道内部转账
  v_result := yx_f_manual_down_inner_tsfer(v_out_channel_no,
                                           v_in_channel_no,
                                           v_amount,
                                           v_hander_user,
                                           v_memo,
                                           l_out_account_id,
                                           l_in_account_id);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  --3.记录日志操作
  fd_p_write_handle_log('下游渠道余额内部转账',
                        v_hander_user,
                        ('v_out_channel_no=' || v_out_channel_no ||
                        ',v_in_channel_no=' || v_in_channel_no ||
                        ',v_amount=' || v_amount));
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_down_inner_tsfer', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_DOWN_ISSUE_ADD
prompt =============================================
prompt
create or replace procedure fd_account.yx_p_manual_down_issue_add(v_down_channel_no in varchar2, --下游渠道编号
                                                       v_bank_account_id in number, --实体卡账户号
                                                       v_amount          in number, --加款金额
                                                       v_create_user     in varchar2, --加款人
                                                       v_memo            in varchar2, --备注
                                                       v_result          out varchar2) as

  /*
     功能描述:下游渠道发行加款
     创建人:周荣省
     创建时间:2019/6/4
  */
  l_account_id   number;
  l_account_name varchar2(32);
  l_channel_name varchar2(32);

begin
  --1.记录日志操作
  fd_p_write_handle_log('营销-下游人工发行加款',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_amount=' || v_amount));

  --2.检查下游渠道,账户以及关联情况
  v_result := yx_f_manual_down_add_check(v_down_channel_no,
                                         v_bank_account_id,
                                         v_amount,
                                         l_account_name,
                                         l_channel_name,
                                         l_account_id);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  --发行加款渠道账户为0
  l_account_id := 0;
  --3.账户手工加款(锁实体银行卡,渠道账户)
  v_result := yx_f_manual_down_issue_add(v_down_channel_no,
                                   v_bank_account_id,
                                   v_amount,
                                   v_create_user,
                                   v_memo,
                                   l_account_id,
                                   l_account_name,
                                   l_channel_name);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_down_issue_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_DOWN_RV_CHANNEL
prompt ==============================================
prompt
create or replace procedure fd_account.yx_p_manual_down_rv_channel(v_down_channel_no in varchar2, ---下游渠道编号
                                                        v_down_account_id in number, ---下游支付账户
                                                        v_revise_type     in number, ---平账类型（1.余额平账 2.扣款平账 3.退款平账）
                                                        v_revise_amount   in number, ---账户调整金额（可正、可负）
                                                        v_issue            in number, --发行类型，0：普通交易扣款，1：发行卡或优惠券扣款
                                                        v_create_user     in varchar2, ---操作人
                                                        v_memo            in varchar2, ---备注
                                                        v_result          out varchar2) as
  -----------------------------
  --功能：平账、下游手工渠道账户平账
  --创建人：周荣省
  --创建时间：2019-07-30
  -----------------------------
  l_fund_id number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('下游营销渠道余额平账',
                        v_create_user,
                        ('v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || v_down_account_id ||
                        ',v_revise_amount=' || v_revise_amount));

  ---2.检查渠道与金额是否正确
  v_result := yx_f_manual_down_rv_channel_ck(v_down_channel_no,
                                             v_down_account_id,
                                             v_revise_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.渠道账户平账
  v_result := yx_f_manual_down_rv_channel(v_down_channel_no,
                                          v_down_account_id,
                                          v_revise_type,
                                          v_issue,
                                          v_revise_amount,
                                          v_create_user,
                                          v_memo,
                                          l_fund_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_down_rv_channel', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_DOWN_RV_TRADE
prompt ============================================
prompt
create or replace procedure fd_account.yx_p_manual_down_rv_trade(v_channel_no    in    varchar2,
                                                      v_draw_amount   in    number,
                                                      v_real_amount   in    number,
                                                      v_business_type in    number,
                                                      v_create_user   in    varchar2,
                                                      v_memo          in    varchar2,
                                                      v_result        out   varchar2) as

/*
 创建人:邓孝辉
 创建时间:2019-05-05
 简介:营销下游平账
*/
l_down_account_id             number;
l_down_company_id          number;
begin

  --1.检查下游信息
   v_result:=yx_f_manual_down_rv_trade_ck(v_channel_no,
                                         v_draw_amount,
                                         v_real_amount,
                                         l_down_account_id,
                                         l_down_company_id);

   if(v_result!=pkg_error_code.success) then
     rollback;
     return;
   end if;

  --2.下游渠道平账
  v_result:=yx_f_manual_down_rv_trade(v_channel_no,
                                      l_down_account_id,
                                      l_down_company_id,
                                      v_draw_amount,
                                      v_real_amount,
                                      v_business_type,
                                      v_create_user,
                                      v_memo);
   if(v_result!=pkg_error_code.success) then
     rollback;
     return;
   end if;

  --3.记录里日志
    fd_p_write_handle_log('营销-下游渠道交易平账',
                          v_create_user,
                          ('v_channel_no=' || v_channel_no ||
                          ',v_down_account_id=' || l_down_account_id));

  commit;
  exception
    when others then
      rollback;
          v_result := pkg_error_code.system_busy;
      fd_p_write_log('yx_p_manual_down_rv_trade', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_RV_TRADE
prompt =======================================
prompt
create or replace procedure fd_account.yx_p_manual_rv_trade(v_order_source     in number, --订单来源系统编号
                                                 v_up_channel_no    in varchar2, ---上游渠道编号
                                                 v_up_draw_face     in number, --上游扣款面值,+扣款增加，-扣款减少
                                                 v_up_draw_amount   in number, ---上游扣款金额,+扣款增加，-扣款减少
                                                 v_up_real_amount   in number, ---上游真实金额,+扣款增加，-扣款减少
                                                 v_up_service_fee   in number, --上游服务费,+服务费增加，-服务费减少
                                                 v_down_channel_no  in varchar2, --下游渠道编号
                                                 v_down_draw_face   in number, --下游扣款面值,+扣款增加，-扣款减少
                                                 v_down_draw_amount in number, --下游扣款金额,+扣款增加，-扣款减少
                                                 v_down_real_amount in number, --下游真实金额,+扣款增加，-扣款减少
                                                 v_down_hand_fee    in number, --下游手续费，+手续费增加，-手续费减少
                                                 v_down_coupon      in number, --推广成本，优惠券，+推广成本增加，-推广成本减少
                                                 v_agent_id         in varchar2, --代理人编号,无代理人时为0
                                                 v_agency_fee       in number, --代理费，+代理费增加，-代理费减少
                                                 v_business_type    in number, ---业务类型
                                                 v_create_user      in varchar2, ---操作人
                                                 v_issue            in number, --发行类型，0：普通交易扣款，1：发行卡或优惠券扣款
                                                 v_memo             in varchar2, ---备注
                                                 v_result           out varchar2) as
  ---------------------------------------------
  --功能：交易平账，上游，下游，代理人，服务费，代理费，手续费，推广成本。（发行服务与一般扣款一致）
  --创建人：周荣省
  --创建时间：2019-06-13
  ---------------------------------------------
  l_up_account_id   number; --上游账户
  l_up_company_id   number; --上游所属公司
  l_down_account_id number; --下游账户
  l_down_company_id number; --下游所属公司
begin

  ---1.检查上游渠道及账户
  v_result := yx_f_manual_up_rv_trade_ck(v_up_channel_no,
                                         v_up_draw_amount,
                                         v_up_real_amount,
                                         l_up_account_id,
                                         l_up_company_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --2.检查下游信息
  v_result := yx_f_manual_down_rv_trade_ck(v_down_channel_no,
                                           v_down_draw_amount,
                                           v_down_real_amount,
                                           l_down_account_id,
                                           l_down_company_id);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --3.检查代理人
  if v_agent_id is not null and v_agent_id != '0' then
    v_result := yx_f_manual_agent_rv_check(v_agent_id, v_agency_fee);
    if (v_result != pkg_error_code.success) then
      rollback;
      return;
    end if;
  end if;

  ---2.上游渠道交易平账
  v_result := yx_f_manual_rv_trade(v_order_source,
                                   v_up_channel_no, --上游
                                   v_up_draw_face,
                                   l_up_account_id,
                                   l_up_company_id,
                                   v_up_draw_amount,
                                   v_up_real_amount,
                                   v_up_service_fee,
                                   v_down_channel_no, --下游
                                   v_down_draw_face,
                                   l_down_account_id,
                                   l_down_company_id,
                                   v_down_draw_amount,
                                   v_down_real_amount,
                                   v_down_hand_fee,
                                   v_down_coupon,
                                   v_agent_id, --代理人
                                   v_agency_fee,
                                   v_business_type,
                                   v_create_user,
                                   v_issue,
                                   v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('营销-交易平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || l_up_account_id) ||
                        ',v_down_channel_no=' || v_down_channel_no ||
                        ',v_down_account_id=' || l_down_account_id ||
                        ',v_agent_id=' || v_agent_id);
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_rv_trade', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_UP_ADD
prompt =====================================
prompt
create or replace procedure fd_account.yx_p_manual_up_add(v_up_channel_no    in  varchar2,    ---上游渠道编号
                                               v_bank_account_id  in  number,      ---实体账户编号
                                               v_service_fee      in  number,      ---手续费
                                               v_amount           in  number,      ---加款金额
                                               v_create_user      in  varchar2,    ---创建人
                                               v_memo             in  varchar2,    ---备注
                                               v_result           out varchar2
                                               ) as

/*
     功能介绍:上游渠道人工加款
     创建人:邓孝辉
     创建时间:2019/3/19
*/

l_account_id           number;
l_account_name         varchar2(32);
l_channel_name         varchar2(32);
l_up_company_id        number;
begin
  ---1.记录操作日志
    fd_p_write_handle_log('营销-上游渠道人工加款',
                         v_create_user,
                         ('v_up_channel_no=' ||v_up_channel_no ||
                         'v_amount=' || v_amount));


  ---2. 检查上游渠道,账户及其关联信息
  v_result:=yx_f_manual_up_add_check(v_up_channel_no,
                                     v_bank_account_id,
                                     v_service_fee,
                                     v_amount,
                                     l_account_id,
                                     l_account_name,
                                     l_channel_name,
                                     l_up_company_id);

  if(v_result!=pkg_error_code.success) then
   rollback;
   return;
  end if;

  ---3. 上有渠道加款(锁银行卡实体,账户信息)
  v_result:=yx_f_manual_up_add(v_up_channel_no,
                               l_up_company_id,
                               l_account_id,
                               v_bank_account_id,
                               v_service_fee,
                               v_amount,
                               v_create_user,
                               v_memo,
                               l_account_name,
                               l_channel_name);

  if(v_result!=pkg_error_code.success) then
   rollback;
   return;
  end if;

  commit;

exception
  when others then
        rollback;
    v_result:=pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_up_add',sqlerrm,1);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_UP_DRAW
prompt ======================================
prompt
create or replace procedure fd_account.yx_p_manual_up_draw(v_up_channel_no    in  varchar2,    ---上游渠道编号
                                                v_bank_account_id  in  number,      ---实体账户编号
                                                v_amount           in  number,      ---加款金额
                                                v_create_user      in  varchar2,    ---创建人
                                                v_memo             in  varchar2,    ---备注
                                                v_result           out varchar2
                                                ) as

/*
     功能介绍:上游渠道人工扣款
     创建人:邓孝辉
     创建时间:2019/3/19
*/

l_account_id           number;
l_account_name         varchar2(32);
l_channel_name         varchar2(32);
l_up_company_id        number;
begin
  ---1.记录操作日志
    fd_p_write_handle_log('营销-上游渠道人工扣款',
                         v_create_user,
                         ('v_up_channel_no=' ||v_up_channel_no ||
                         'v_amount=' || v_amount));


  ---2. 检查上游渠道,账户及其关联信息
  v_result:=yx_f_manual_up_draw_check(v_up_channel_no,
                                     v_bank_account_id,
                                     v_amount,
                                     l_account_id,
                                     l_account_name,
                                     l_channel_name,
                                     l_up_company_id);

  if(v_result!=pkg_error_code.success) then
   rollback;
   return;
  end if;

  ---3. 上有渠道扣款(锁银行卡实体,账户信息)
  v_result:=yx_f_manual_up_draw(v_up_channel_no,
                               l_up_company_id,
                               l_account_id,
                               v_bank_account_id,
                               v_amount,
                               v_create_user,
                               v_memo,
                               l_account_name,
                               l_channel_name);

  if(v_result!=pkg_error_code.success) then
   rollback;
   return;
  end if;

  commit;

exception
  when others then
        rollback;
    v_result:=pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_up_add',sqlerrm,1);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_UP_INNER_TSFER
prompt =============================================
prompt
create or replace procedure fd_account.yx_p_manual_up_inner_tsfer(v_out_channel_no in varchar2, --转出账户
                                                       v_in_channel_no  in varchar2, --转入账户
                                                       v_amount         in number, --转出金额
                                                       v_hander_user    in varchar2, --操作人
                                                       v_memo           in varchar2, --备注
                                                       v_result         out varchar2) as

  /*
   创建者:邓孝辉
   创建时间:2019-04-30
   简介:上游余额内转
  */
  l_out_account_id number;
  l_in_account_id  number;
begin
  --1.校验转入转出渠道信息
  v_result := yx_f_manual_up_inner_check(v_out_channel_no,
                                         v_in_channel_no,
                                         v_amount,
                                         l_out_account_id,
                                         l_in_account_id);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --2.渠道内部转账
  v_result := yx_f_manual_up_inner_tsfer(v_out_channel_no,
                                         v_in_channel_no,
                                         v_amount,
                                         v_hander_user,
                                         v_memo,
                                         l_out_account_id,
                                         l_in_account_id);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  --3.记录日志操作
  fd_p_write_handle_log('上游渠道余额内部转账',
                        v_hander_user,
                        ('v_out_channel_no=' || v_out_channel_no ||
                        ',v_in_channel_no=' || v_in_channel_no ||
                        ',v_amount=' || v_amount));
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_up_inner_tsfer', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_UP_ISSUE_ADD
prompt ===========================================
prompt
create or replace procedure fd_account.yx_p_manual_up_issue_add(v_up_channel_no   in varchar2, ---上游渠道编号
                                                     v_bank_account_id in number, ---实体账户编号
                                                     v_service_fee     in number, ---手续费
                                                     v_amount          in number, ---加款金额
                                                     v_create_user     in varchar2, ---创建人
                                                     v_memo            in varchar2, ---备注
                                                     v_result          out varchar2) as

  -----------------------------------------------------
  --功能介绍:上游渠道人工发行加款
  --创建人:周荣省
  --创建时间:2019-06-18
  -----------------------------------------------------

  l_account_id    number;
  l_account_name  varchar2(32);
  l_channel_name  varchar2(32);
  l_up_company_id number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('营销-上游渠道人工发行加款',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        'v_amount=' || v_amount));

  ---2. 检查上游渠道,账户及其关联信息
  v_result := yx_f_manual_up_add_check(v_up_channel_no,
                                       v_bank_account_id,
                                       v_service_fee,
                                       v_amount,
                                       l_account_id,
                                       l_account_name,
                                       l_channel_name,
                                       l_up_company_id);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3. 上有渠道加款(锁银行卡实体,账户信息)
  v_result := yx_f_manual_up_issue_add(v_up_channel_no,
                                       l_up_company_id,
                                       l_account_id,
                                       v_bank_account_id,
                                       v_service_fee,
                                       v_amount,
                                       v_create_user,
                                       v_memo,
                                       l_account_name,
                                       l_channel_name);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_up_issue_add', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_UP_RV_CHANNEL
prompt ============================================
prompt
create or replace procedure fd_account.yx_p_manual_up_rv_channel(v_up_channel_no in varchar2, ---上游游渠道编号
                                                      v_up_account_id in number, ---上游支付账户编号
                                                      v_revise_type   in number, ---平账类型（1.余额平账 2.扣款平账 3.退款平账）
                                                      v_revise_amount in number, ---账户调整金额（可正、可负）
                                                      v_issue            in number, --发行类型，0：普通交易扣款，1：发行卡或优惠券扣款
                                                      v_create_user   in varchar2, ---操作人
                                                      v_memo          in varchar2, ---备注
                                                      v_result        out varchar2) as
  -----------------------------
  --功能：平账、上游手工渠道账户平账
  --创建人：周荣省
  --创建时间：2019-07-31
  -----------------------------
  l_fund_id number;
begin
  ---1.记录操作日志
  fd_p_write_handle_log('上游商家余额平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || v_up_account_id ||
                        ',v_revise_amount=' || v_revise_amount));

  ---2.检查渠道与金额是否正确
  v_result := yx_f_manual_up_rv_channel_ck(v_up_channel_no,
                                           v_up_account_id,
                                           v_revise_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.渠道账户平账
  v_result := yx_f_manual_up_rv_channel(v_up_channel_no,
                                        v_up_account_id,
                                        v_revise_type,
                                        v_revise_amount,
                                        v_issue,
                                        v_create_user,
                                        v_memo,
                                        l_fund_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_up_rv_channel', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_MANUAL_UP_RV_SERVICE
prompt ============================================
prompt
create or replace procedure fd_account.yx_p_manual_up_rv_service(v_channel_no    in    varchar2,
                                                      v_service_fee   in    number,
                                                      v_business_type in    number,
                                                      v_create_user   in    varchar2,
                                                      v_memo          in    varchar2,
                                                      v_result        out   varchar2) as

    /*
     创建人:邓孝辉
     创建时间:2019-05-06
     简介:营销-服务费平账
    */
    l_company_id               number;
    begin
      --1.检查渠道,金额信息
      v_result:=yx_f_manual_up_rev_serv_ck(v_channel_no,
                                           v_service_fee,
                                           l_company_id);
       if (v_result!=pkg_error_code.success) then
         rollback;
         return;
       end if;
      --2.服务费平账
      v_result:=yx_f_manual_up_rev_service(v_channel_no,
                                           l_company_id,
                                           v_business_type,
                                           v_service_fee,
                                           v_create_user,
                                           v_memo);
       if (v_result!=pkg_error_code.success) then
         rollback;
         return;
       end if;
        --3.记录里日志
    fd_p_write_handle_log('营销-服务费平账',
                          v_create_user,
                          ('v_channel_no=' || v_channel_no ||
                          ',v_service_fee=' || v_service_fee));
      commit;
      exception
        when others then
          rollback;
          v_result:=pkg_error_code.system_busy;
          fd_p_write_log('yx_p_manual_up_rv_service', sqlerrm, 1);
    end;
/

prompt
prompt Creating procedure YX_P_MANUAL_UP_RV_TRADE
prompt ==========================================
prompt
create or replace procedure fd_account.yx_p_manual_up_rv_trade(v_up_channel_no  in varchar2, ---上游渠道编号
                                                    v_up_draw_amount in number, ---上游扣款金额
                                                    v_up_real_amount in number, ---上游真实金额
                                                    v_business_type  in number, ---业务类型
                                                    v_create_user    in varchar2, ---操作人
                                                    v_memo           in varchar2, ---备注
                                                    v_result         out varchar2) as
/*
  创建人:邓孝辉
  创建时间:2019-05-05
  简介:上游交易平账
*/
  l_up_account_id number;
  l_up_company_id number;
begin


  ---1.检查上游渠道及账户
  v_result := yx_f_manual_up_rv_trade_ck(v_up_channel_no,
                                         v_up_draw_amount,
                                         v_up_real_amount,
                                         l_up_account_id,
                                         l_up_company_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---2.上游渠道交易平账
  v_result := yx_f_manual_up_rv_trade(v_up_channel_no,
                                      l_up_account_id,
                                      l_up_company_id,
                                      v_up_draw_amount,
                                      v_up_real_amount,
                                      v_business_type,
                                      v_create_user,
                                      v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3.记录操作日志
  fd_p_write_handle_log('营销-上游渠道交易平账',
                        v_create_user,
                        ('v_up_channel_no=' || v_up_channel_no ||
                        ',v_up_account_id=' || l_up_account_id));
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_manual_up_rv_trade', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_TRADE_AGENT_FUND
prompt ========================================
prompt
create or replace procedure fd_account.yx_p_trade_agent_fund(v_order_source    in number, --交易系统编号
                                                  v_down_channel_no in varchar2, --下游渠道编号
                                                  v_up_channel_no   in varchar2, --上游渠道编号
                                                  v_agent_id        in number, --代理人编号
                                                  v_business_type   in number, --业务类型
                                                  v_change_amount   in number, --代理人资金变动金额
                                                  v_order_time      in varchar2, --交易系统订单时间
                                                  v_trade_order_no  in varchar2, --交易系统订单编号
                                                  v_change_type     in number, --变动类型，2扣款，3退款
                                                  v_memo            in varchar2, --备注
                                                  v_result          out varchar2 --返回结果
                                                  ) as
  pragma autonomous_transaction; --自治事务
  ------------------------------------------------------
  --主要功能：同步代理人资金变动
  --创建人：周荣省
  --创建时间：2019-05-28
  ------------------------------------------------------
  l_yx_order_id      number; --记账系统订单号
  l_yx_up_fund_id    number; --上游资金变动编号
  l_yx_down_fund_id  number; --下游资金变动编号
  l_number           number;
  l_change_amount    number; --变动金额
  l_agent_balance    number; --代理人资金余额
  l_yx_business_type number; --上游业务类型编号
  l_up_channel_no    varchar2(32);
  l_down_channel_no  varchar2(32);
  l_business_type    number;

begin
  --1、获取记账系统业务类型
  l_yx_business_type := yx_f_trade_business_type_get(v_order_source,
                                                     v_business_type);
  --1、获取记账系统订单编号
  select t.yx_order_id, t.business_type
    into l_yx_order_id, l_business_type
    from yx_trade_order_main t
   where t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source;
  --1.1判断业务类型是否一致
  if l_business_type != l_yx_business_type then
    v_result := pkg_error_code.data_error;
    return;
  end if;
  --2、获取上游资金变动编号
  if v_change_type = 2 then
    select min(t.record_id)
      into l_yx_up_fund_id
      from yx_trade_up_fund t
     where t.yx_order_id = l_yx_order_id
       and t.change_type = 2;
  elsif v_change_type = 3 then
    select min(t.record_id)
      into l_yx_up_fund_id
      from yx_trade_down_fund t
     where t.yx_order_id = l_yx_order_id
       and t.change_type = 3;
  else
    v_result := pkg_error_code.data_error;
    return;
  end if;
  --2.1获取上下游渠道编号
  select t.down_channel_no, t.up_channel_no
    into l_down_channel_no, l_up_channel_no
    from yx_trade_up_fund t
   where t.yx_order_id = l_yx_order_id
     and rownum = 1;
  --3、检查是否存在代理人资金变动,一个订单编号只能存在一条扣款
  select count(1)
    into l_number
    from yx_trade_agent_fund t
   where t.yx_order_id = l_yx_order_id
     and t.change_type = pkg_agent_fund_change_type.debit_amount;

  if v_change_type = 2 then
    l_change_amount := v_change_amount;
    if l_number > 0 then
      --代理人资金变动存在
      v_result := pkg_yx_error_code.success;
      return;
    end if;
  else
    l_change_amount := -1 * v_change_amount;
    if l_number < 1 then
      --不存在扣款，不能退
      v_result := pkg_yx_error_code.debit_not_exists;
      return;
    end if;
    --判断是否已经退款
    select count(1)
      into l_number
      from yx_trade_agent_fund t
     where t.yx_order_id = l_yx_order_id
       and t.change_type = pkg_agent_fund_change_type.refund_amount;
    if l_number > 0 then
      v_result := pkg_yx_error_code.success;
      return;
    end if;
  end if;
  --4、修改代理人余额
  select count(1)
    into l_number
    from yx_base_agent t
   where t.agent_id = v_agent_id;
  if l_number > 0 then
    select t.balance
      into l_agent_balance
      from yx_base_agent t
     where t.agent_id = v_agent_id
       for update;
    update yx_base_agent t
       set t.balance = (l_agent_balance + l_change_amount)
     where t.agent_id = v_agent_id;
    if (sql%rowcount = 0) then
      v_result := pkg_error_code.data_error;
      return;
    end if;
    --3、添加代理人资金变动
    insert into yx_trade_agent_fund
      (record_id,
       up_fund_id,
       down_channel_no,
       up_channel_no,
       order_source,
       agent_id,
       change_amount,
       balance,
       change_type,
       change_time,
       business_type,
       yx_order_id,
       yx_trade_order_no)
    values
      (seq_yxtradeagentfund_auto_id.nextval,
       l_yx_up_fund_id,
       l_down_channel_no,
       l_up_channel_no,
       v_order_source,
       v_agent_id,
       abs(l_change_amount),
       (l_agent_balance + l_change_amount),
       v_change_type,
       sysdate,
       l_yx_business_type,
       l_yx_order_id,
       v_trade_order_no);
    --4.更新上游资金变动代理人信息
    --4.1更新代理人编号
    update yx_trade_up_fund t
       set t.agent_id = v_agent_id
     where t.yx_order_id = l_yx_order_id;
    --4.2更新代理费
    update yx_trade_up_fund t
       set t.down_agency_fee = abs(l_change_amount)
     where t.yx_order_id = l_yx_order_id
       and t.change_type = v_change_type
       and t.down_agency_fee = 0
       and rownum = 1;
  else
    v_result := pkg_error_code.data_error;
  end if;
  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_trade_agent_fund' || v_trade_order_no, sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_TRADE_DOWN_ORDER_PAY
prompt ============================================
prompt
create or replace procedure fd_account.yx_p_trade_down_order_pay(v_order_source        in number, --订单来源系统编号
                                                      v_down_channel_no     in varchar2, --下游渠道编号
                                                      v_agent_id            in varchar2, --代理人编号,会为0
                                                      v_trade_order_no      in varchar2, --外部系统交易订单号
                                                      v_ext_order_no        in varchar2, --外部系统下游的订单号
                                                      v_recharge_account_no in varchar2, --充值号码
                                                      v_business_type       in number, --业务类型
                                                      v_carrier_no          in varchar2, --运营商
                                                      v_province_no         in varchar2, --省份
                                                      v_city_no             in varchar2, --市
                                                      v_total_face          in number, --总面值
                                                      v_recharge_unit       in number, --充值量单位
                                                      v_order_time          in varchar2, --下单时间
                                                      v_pay_amount          in number, --用户支付金额,v_pay_amount=(v_change_amount+v_handling_fee)+v_income_amount
                                                      v_change_amount       in number, --变动金额
                                                      v_income_amount       in number, --收入金额
                                                      v_agency_fee          in number, --代理费
                                                      v_handling_fee        in number, --手续费
                                                      v_memo                in varchar2, --备注
                                                      v_result              out varchar2 --输出结果
                                                      ) as
  pragma autonomous_transaction; --自治事务
  --------------------------------------
  --主要功能：下游扣款，即订单支付
  --创建人：周荣省
  --创建时间：2019-03-18
  --------------------------------------
  l_yx_business_type number; --记账系统业务类型
begin
  --1、获取记账系统业务类型
  l_yx_business_type := yx_f_trade_business_type_get(v_order_source,
                                                     v_business_type);
  --1.1判断数据正确性
  if v_pay_amount != (v_change_amount + v_income_amount + v_handling_fee) then
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;
  --2、检查扣款是否成功
  v_result := yx_f_trade_down_draw_check(v_order_source, v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    if (v_result = pkg_error_code.data_repeat) then
      v_result := pkg_error_code.success;
    end if;
    rollback;
    return;
  end if;
  --3、检查订单金额
  v_result := yx_f_trade_down_amount_check(v_order_source,
                                           v_down_channel_no,
                                           v_pay_amount,
                                           v_agent_id,
                                           v_agency_fee);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --4、如果建立了历史库，在历史库中检查订单

  --5、检查订单是否存在，不存在则创建订单
  v_result := yx_f_trade_order_create(v_order_source,
                                      v_down_channel_no,
                                      v_agent_id,
                                      v_trade_order_no,
                                      v_ext_order_no,
                                      v_recharge_account_no,
                                      l_yx_business_type,
                                      v_carrier_no,
                                      v_province_no,
                                      v_city_no,
                                      v_total_face,
                                      v_recharge_unit,
                                      v_pay_amount,
                                      v_change_amount, --变动金额
                                      v_income_amount, --收入金额
                                      v_agency_fee,
                                      v_pay_amount - v_change_amount -
                                      v_income_amount, --手续费=用户支付-扣款金额-收入金额
                                      --v_success_face,
                                      v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --6、下游资金变动扣款（所订单，检查扣款记录是否存在，锁定账户，添加资金变动）
  v_result := yx_f_trade_down_order_fee_mus(v_order_source,
                                            v_down_channel_no,
                                            v_trade_order_no,
                                            v_ext_order_no,
                                            v_order_time,
                                            v_total_face,
                                            v_pay_amount,
                                            v_change_amount,
                                            v_income_amount,
                                            --v_agency_fee,
                                            v_pay_amount - v_change_amount -
                                            v_income_amount, --手续费=用户支付-扣款金额-收入金额
                                            v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_trade_down_order_fee_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_SYNC_AGENT_GROUP
prompt ======================================
prompt
create or replace procedure fd_account.yx_sync_agent_group(v_agent_id       in varchar2, --代理人编号（交易系统）
                                                v_agent_name     in varchar2, --代理人名称
                                                v_agent_type     in number, --代理人类型：0-代理人，1-代理企业
                                                v_group_agent    in number, --0:组合代理人，1：非组合代理人
                                                v_group_count    in number, --组合数量
                                                v_certificate_no in varchar2, --身份证/纳税识别号
                                                v_mobile         in varchar2, --手机号码
                                                v_province_no    in varchar2, --省份
                                                v_company_nature in number, --公司性质1:有限责任公司,2:股份有限公司,3:个体商户,4:合伙企业，代理人时传0
                                                v_taxpayer_size  in number, --纳税人规模1:一般纳税人,2小规模纳税人，代理人时传0
                                                v_status         in number, --状态
                                                v_channel_no     in varchar2, --下游渠道编号
                                                v_out_status     out number, --状态: 100-成功 200-失败
                                                v_out_id         out number --记账系统代理人id
                                                ) as
  pragma autonomous_transaction; --自治事务
  -------------------------------------
  --主要功能：同步代理人信息
  --创建人：周荣省
  --创建时间：2019-03-22
  -------------------------------------
  l_status     number;
  l_number     number;
  l_company_id number := 0;
  l_agent_id   number; --记账系统代理人id
begin
  l_status := v_status;
  if (l_status is not null and l_status <> 0) then
    l_status := 1;
  end if;
  --检查代理人
  select count(*)
    into l_number
    from yx_base_agent t
   where t.out_agent_id = v_agent_id
     and t.down_channel_no = v_channel_no;
  --获取公司编号
  select t.company_id
    into l_company_id
    from yx_base_down_channel t
   where t.channel_no = v_channel_no;
  if (l_number >= 1) then
    select t.agent_id
      into l_agent_id
      from yx_base_agent t
     where t.out_agent_id = v_agent_id
       and t.down_channel_no = v_channel_no;
    --代理人存在，修改
    update yx_base_agent t
       set t.agent_name      = v_agent_name,
           t.agent_type      = v_agent_type,
           t.certificate_no  = v_certificate_no,
           t.mobile          = v_mobile,
           t.province_no     = v_province_no,
           t.company_nature  = v_company_nature,
           t.company_id      = l_company_id,
           t.taxpayer_size   = v_taxpayer_size,
           t.status          = l_status,
           t.last_edit_user  = '_sys',
           t.last_edit_time  = sysdate,
           t.down_channel_no = v_channel_no
     where t.out_agent_id = v_agent_id
       and t.down_channel_no = v_channel_no;
    if (sql%rowcount >= 1) then
      v_out_status := 100;
      v_out_id     := l_agent_id;
    else
      v_out_status := 200;
    end if;
    commit;
    return;
  end if;
  --添加代理人
  select seq_yxbaseagent_auto_id.nextval into l_agent_id from dual;
  insert into yx_base_agent
    (agent_id,
     out_agent_id,
     agent_name,
     agent_type,
     certificate_no,
     mobile,
     province_no,
     company_nature,
     company_id,
     taxpayer_size,
     balance,
     status,
     created_user,
     created_time,
     down_channel_no,
     group_agent,
     group_count)
  values
    (l_agent_id,
     v_agent_id,
     v_agent_name,
     v_agent_type,
     v_certificate_no,
     v_mobile,
     v_province_no,
     v_company_nature,
     l_company_id,
     v_taxpayer_size,
     0,
     l_status,
     '_sys',
     sysdate,
     v_channel_no,
     v_group_agent,
     v_group_count);
  if (sql%rowcount >= 1) then
    v_out_status := 100;
    v_out_id     := l_agent_id;
  else
    v_out_status := 200;
  end if;
  commit;
exception
  when others then
    v_out_status := 200;
    rollback;
    fd_p_write_log('yx_sync_agent_info', sqlerrm, 200);
end;
/

prompt
prompt Creating procedure YX_P_TRADE_DOWN_ORDER_PAY1
prompt =============================================
prompt
create or replace procedure fd_account.yx_p_trade_down_order_pay1(v_order_source        in number, --订单来源系统编号
                                                       v_down_channel_no     in varchar2, --下游渠道编号
                                                       v_agent_count         in number, --含有的代理人数量
                                                       v_agent_id_list       in varchar2, --代理人编号组，编号之间用逗号隔开，如100,99
                                                       v_trade_order_no      in varchar2, --外部系统交易订单号
                                                       v_ext_order_no        in varchar2, --外部系统下游的订单号
                                                       v_recharge_account_no in varchar2, --充值号码
                                                       v_business_type       in number, --业务类型
                                                       v_carrier_no          in varchar2, --运营商
                                                       v_province_no         in varchar2, --省份
                                                       v_city_no             in varchar2, --市
                                                       v_total_face          in number, --总面值
                                                       v_recharge_unit       in number, --充值量单位
                                                       v_order_time          in varchar2, --下单时间
                                                       v_pay_amount          in number, --用户支付金额,v_pay_amount=(v_change_amount+v_handling_fee)+v_income_amount
                                                       v_change_amount       in number, --变动金额
                                                       v_income_amount       in number, --收入金额
                                                       v_agency_fee_list     in varchar2, --代理费组，与代理人编号对应
                                                       v_handling_fee        in number, --手续费
                                                       v_memo                in varchar2, --备注
                                                       v_result              out varchar2 --输出结果
                                                       ) as
  pragma autonomous_transaction; --自治事务
  --------------------------------------
  --主要功能：下游扣款，即订单支付
  --创建人：周荣省
  --创建时间：2019-03-18
  --------------------------------------
  l_yx_business_type number; --记账系统业务类型
  l_agent_id             varchar2(32); --代理人id
  l_agent_arr            t_Array; --代理人数组
  l_agent_fee_arr        t_Array; --代理费组
  l_out_agent_group      varchar2(32); -- 代理人编号重新组合
  l_out_agent_group_name varchar2(64); --代理人编号重新组合名称
  l_out_status           number;
  l_agency_fee           number; --代理费总和
begin
  --1、获取记账系统业务类型
  l_yx_business_type := yx_f_trade_business_type_get(v_order_source,
                                                     v_business_type);
  --1.1判断数据正确性
  if v_pay_amount != (v_change_amount + v_income_amount + v_handling_fee) then
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;
  --2、检查扣款是否成功
  v_result := yx_f_trade_down_draw_check(v_order_source, v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    if (v_result = pkg_error_code.data_repeat) then
      v_result := pkg_error_code.success;
    end if;
    rollback;
    return;
  end if;
  --2.1、检查代理人情况
  if v_agent_count = 1 then
    l_agent_id := v_agent_id_list;
  elsif v_agent_count > 1 then
    --多个代理人
    l_agent_arr := yx_f_Split(v_agent_id_list, ',');
    v_result    := yx_f_group_agent_solt(l_agent_arr,
                                         l_out_agent_group,
                                         l_out_agent_group_name);
    --判断代理人
    v_result := yx_f_group_agent(v_down_channel_no,
                                 v_agent_count,
                                 l_agent_arr,
                                 l_out_agent_group,
                                 l_agent_id);
    if v_result != pkg_yx_error_code.success then
      --组合代理人不存在，添加
      yx_sync_agent_group('ZH' || l_out_agent_group,
                          l_out_agent_group_name,
                          1,
                          0,
                          v_agent_count,
                          '-',
                          '-',
                          '*',
                          3,
                          2,
                          0,
                          v_down_channel_no,
                          l_out_status,
                          l_agent_id);
      if l_out_status != 100 then
        rollback;
        return;
      end if;
    end if;
  end if;
  --2.2计算代理费总和
  if v_agent_count = 1 then
    l_agency_fee := to_number(v_agency_fee_list);
  elsif v_agent_count > 1 then
    l_agent_fee_arr := yx_f_Split(v_agency_fee_list, ',');
    v_result        := yx_f_group_agent_fee(v_agent_count,
                                            l_agent_fee_arr,
                                            l_agency_fee);
  end if;
  --3、检查订单金额
  v_result := yx_f_trade_down_amount_check(v_order_source,
                                           v_down_channel_no,
                                           v_pay_amount,
                                           l_agent_id,
                                           l_agency_fee);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --4、如果建立了历史库，在历史库中检查订单

  --5、检查订单是否存在，不存在则创建订单
  v_result := yx_f_trade_order_create(v_order_source,
                                      v_down_channel_no,
                                      l_agent_id,
                                      v_trade_order_no,
                                      v_ext_order_no,
                                      v_recharge_account_no,
                                      l_yx_business_type,
                                      v_carrier_no,
                                      v_province_no,
                                      v_city_no,
                                      v_total_face,
                                      v_recharge_unit,
                                      v_pay_amount,
                                      v_change_amount, --变动金额
                                      v_income_amount, --收入金额
                                      l_agency_fee,
                                      v_pay_amount - v_change_amount -
                                      v_income_amount, --手续费=用户支付-扣款金额-收入金额
                                      --v_success_face,
                                      v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --6、下游资金变动扣款（所订单，检查扣款记录是否存在，锁定账户，添加资金变动）
  v_result := yx_f_trade_down_order_fee_mus(v_order_source,
                                            v_down_channel_no,
                                            v_trade_order_no,
                                            v_ext_order_no,
                                            v_order_time,
                                            v_total_face,
                                            v_pay_amount,
                                            v_change_amount,
                                            v_income_amount,
                                            --v_agency_fee,
                                            v_pay_amount - v_change_amount -
                                            v_income_amount, --手续费=用户支付-扣款金额-收入金额
                                            v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_trade_down_order_fee_pay', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_TRADE_DOWN_ORDER_REF
prompt ============================================
prompt
create or replace procedure fd_account.yx_p_trade_down_order_ref(v_order_source    in number, --订单来源系统编号
                                                      v_down_channel_no in varchar2, --下游渠道编号
                                                      v_trade_order_no  in varchar2, --交易系统订单编号
                                                      v_trade_refund_no in varchar2, --交易系统退款订单编号
                                                      v_refund_unit     in number, --退款单位
                                                      --v_order_amount    in number, --交易系统订单金额
                                                      v_refund_face   in number, --退款面值
                                                      v_refund_amount in number, --退款金额(用户支付金额)
                                                      --v_real_refund     in number, --真实退款
                                                      v_order_date in varchar2, --订单时间
                                                      --v_agency_fee      in number, --代理费
                                                      v_handling_fee  in number, --手续费
                                                      v_refund_income in number, --退收入金额
                                                      v_memo          in varchar2, --备注
                                                      v_result        out varchar2 --输出结果
                                                      ) as
  pragma autonomous_transaction; --自治事务
  -------------------------------------------------
  --主要功能：下游退款
  --创建人：周荣省
  --创建时间：2019-03-19
  -------------------------------------------------
begin
  --1、如果有历史数据表，需要获取历史数据表中的数据
  --2、下游订单退款
  v_result := yx_f_trade_down_fee_refund(v_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_trade_refund_no,
                                         v_refund_unit,
                                         --v_order_amount,
                                         v_refund_face,
                                         v_refund_amount,
                                         --v_real_refund,
                                         v_order_date,
                                         --v_agency_fee,
                                         v_handling_fee,
                                         v_refund_income,
                                         v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_trade_down_order_fee_ref', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_TRADE_DOWN_PAY_COUPON
prompt =============================================
prompt
create or replace procedure fd_account.yx_p_trade_down_pay_coupon(v_order_source        in number, --订单来源系统编号
                                                       v_down_channel_no     in varchar2, --下游渠道编号
                                                       v_agent_id            in varchar2, --代理人编号,会为0
                                                       v_trade_order_no      in varchar2, --外部系统交易订单号
                                                       v_ext_order_no        in varchar2, --外部系统下游的订单号
                                                       v_recharge_account_no in varchar2, --充值号码
                                                       v_business_type       in number, --业务类型
                                                       v_carrier_no          in varchar2, --运营商
                                                       v_province_no         in varchar2, --省份
                                                       v_city_no             in varchar2, --市
                                                       v_total_face          in number, --总面值
                                                       v_recharge_unit       in number, --充值量单位
                                                       v_order_time          in varchar2, --下单时间
                                                       v_pay_amount          in number, --用户支付金额,v_pay_amount=(v_change_amount+v_handling_fee)+v_income_amount
                                                       v_change_amount       in number, --变动金额
                                                       v_income_amount       in number, --额外收益金额
                                                       v_coupon_amount       in number, --优惠券金额
                                                       v_agency_fee          in number, --代理费0
                                                       v_handling_fee        in number, --手续费
                                                       v_issue_type          in number, --发行类型，0：普通交易扣款，1：发行卡或优惠券扣款
                                                       v_memo                in varchar2, --备注
                                                       v_result              out varchar2 --输出结果
                                                       ) as
  pragma autonomous_transaction; --自治事务
  --------------------------------------
  --主要功能：下游扣款，即订单支付，含优惠券
  --创建人：周荣省
  --创建时间：2019-05-28
  --------------------------------------
  l_yx_business_type number; --记账系统业务类型
begin
  --1、获取记账系统业务类型
  l_yx_business_type := yx_f_trade_business_type_get(v_order_source,
                                                     v_business_type);
  --1.1判断数据正确性
  if v_pay_amount != (v_change_amount + v_income_amount + v_handling_fee) then
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;
  --2、检查扣款是否成功
  v_result := yx_f_trade_down_draw_check(v_order_source, v_trade_order_no);
  if (v_result != pkg_error_code.success) then
    if (v_result = pkg_error_code.data_repeat) then
      v_result := pkg_error_code.success;
    end if;
    rollback;
    return;
  end if;
  --3、检查订单金额，针对普通交易扣款
  if v_issue_type = 0 then
    v_result := yx_f_trade_down_amount_check(v_order_source,
                                             v_down_channel_no,
                                             v_pay_amount,
                                             v_agent_id,
                                             v_agency_fee);
    if (v_result != pkg_error_code.success) then
      rollback;
      return;
    end if;
  end if;
  --4、如果建立了历史库，在历史库中检查订单

  --5、检查订单是否存在，不存在则创建订单
  v_result := yx_f_trade_order_create(v_order_source,
                                      v_down_channel_no,
                                      v_agent_id,
                                      v_trade_order_no,
                                      v_ext_order_no,
                                      v_recharge_account_no,
                                      l_yx_business_type,
                                      v_carrier_no,
                                      v_province_no,
                                      v_city_no,
                                      v_total_face,
                                      v_recharge_unit,
                                      v_pay_amount,
                                      v_change_amount, --变动金额
                                      v_income_amount, --收入金额
                                      v_agency_fee,
                                      v_pay_amount - v_change_amount -
                                      v_income_amount, --手续费=用户支付-扣款金额-收入金额
                                      --v_success_face,
                                      v_order_time,
                                      v_coupon_amount,
                                      v_issue_type);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --6、下游资金变动扣款（所订单，检查扣款记录是否存在，锁定账户，添加资金变动）
  v_result := yx_f_trade_down_order_fee_mus(v_order_source,
                                            v_down_channel_no,
                                            v_trade_order_no,
                                            v_ext_order_no,
                                            v_order_time,
                                            v_total_face,
                                            v_pay_amount,
                                            v_change_amount,
                                            v_income_amount,
                                            --v_agency_fee,
                                            v_pay_amount - v_change_amount -
                                            v_income_amount, --手续费=用户支付-扣款金额-收入金额
                                            v_memo,
                                            v_coupon_amount,
                                            v_issue_type);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_trade_down_pay_coupon', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_TRADE_DOWN_REF_COUPON
prompt =============================================
prompt
create or replace procedure fd_account.yx_p_trade_down_ref_coupon(v_order_source    in number, --订单来源系统编号
                                                       v_down_channel_no in varchar2, --下游渠道编号
                                                       v_trade_order_no  in varchar2, --交易系统订单编号
                                                       v_trade_refund_no in varchar2, --交易系统退款订单编号
                                                       v_refund_unit     in number, --退款单位
                                                       --v_order_amount    in number, --交易系统订单金额
                                                       v_refund_face   in number, --退款面值
                                                       v_refund_amount in number, --退款金额(用户支付金额)
                                                       --v_real_refund     in number, --真实退款
                                                       v_order_date in varchar2, --订单时间
                                                       --v_agency_fee      in number, --代理费
                                                       v_handling_fee  in number, --手续费
                                                       v_refund_income in number, --退额外收益金额
                                                       v_coupon_amount in number, --优惠券金额
                                                       v_issue_type    in number, --发行类型，0：普通交易退款，1：发行卡或优惠券退款
                                                       v_memo          in varchar2, --备注
                                                       v_result        out varchar2 --输出结果
                                                       ) as
  pragma autonomous_transaction; --自治事务
  -------------------------------------------------
  --主要功能：下游退款，含优惠券功能
  --创建人：周荣省
  --创建时间：2019-05-28
  -------------------------------------------------
begin
  --1、如果有历史数据表，需要获取历史数据表中的数据
  --2、下游订单退款
  v_result := yx_f_trade_down_fee_refund(v_order_source,
                                         v_down_channel_no,
                                         v_trade_order_no,
                                         v_trade_refund_no,
                                         v_refund_unit,
                                         --v_order_amount,
                                         v_refund_face,
                                         v_refund_amount,
                                         --v_real_refund,
                                         v_order_date,
                                         --v_agency_fee,
                                         v_handling_fee,
                                         v_refund_income,
                                         v_memo,
                                         v_coupon_amount,
                                         v_issue_type);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_trade_down_ref_coupon', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_TRADE_EXPENSE
prompt =====================================
prompt
create or replace procedure fd_account.yx_p_trade_expense(v_order_source     in number, --交易系统编号
                                               v_down_channel_no  in varchar2, --下游渠道编号
                                               v_up_channel_no    in varchar2, --上游渠道编号
                                               v_company_id       in number, --所属公司编号
                                               v_agent_id         in number, --代理人编号
                                               v_business_type    in number, --业务类型
                                               v_expense_amount   in number, --费用金额
                                               v_order_time       in varchar2, --交易系统订单时间
                                               v_out_change_time  in varchar2, --交易系统费用变动时间
                                               v_trade_order_no   in varchar2, --交易系统订单编号
                                               v_trade_expense_no in varchar2, --交易系统费用编号
                                               v_expense_type     in number, --费用类型：1、快递费，2、制券费,21：销券收益
                                               v_income_type      in number, --收入类型：1：支出，2：收入
                                               v_channel_type     in number, --费用所属渠道类型：1上游，2下游
                                               v_order_amount     in number, --订单金额
                                               v_memo             in varchar2, --备注
                                               v_result           out varchar2 --返回结果
                                               ) as
  pragma autonomous_transaction; --自治事务
  ------------------------------------------------------
  --主要功能：费用变动
  --创建人：周荣省
  --创建时间：2019-03-25
  ------------------------------------------------------
  l_yx_order_id      number; --记账系统订单号
  l_yx_business_type number; --记账系统业务类型
  l_account_id       number; --费用账户
  l_number           number;
  l_income_type      number; --费用类型
  l_channel_no       varchar2(32); --其它收入、支出渠道
  l_account_balance  number; --账户余额
  l_credit_amount    number; --授信金额
begin
  if v_channel_type = 1 then
    l_channel_no := v_up_channel_no;
  elsif v_channel_type = 2 then
    l_channel_no := v_down_channel_no;
  else
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;
  --1、获取记账系统业务类型
  l_yx_business_type := yx_f_trade_business_type_get(v_order_source,
                                                     v_business_type);
  --2、检查订单是否存在
  v_result := yx_f_trade_order_exist_check(v_order_source,
                                           v_down_channel_no,
                                           v_trade_order_no,
                                           l_yx_order_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --3、检查费用是否存在
  select count(1)
    into l_number
    from yx_trade_expense t
   where t.trade_expense_no = v_trade_expense_no
     and t.trade_order_no = v_trade_order_no
     and t.order_source = v_order_source
     and t.income_type = v_income_type
     and t.expense_type = v_expense_type;
  if l_number > 0 then
    rollback;
    v_result := pkg_error_code.success;
    return;
  end if;
  --4、获取费用账户
  select t.account_id
    into l_account_id
    from yx_three_party_account t
   where t.channel_no = l_channel_no
     and t.system_id = v_order_source
     and t.channel_type = v_channel_type
     and t.account_type = v_income_type;
  --4.1锁账户
  select t.balance, t.credit_amount
    into l_account_balance, l_credit_amount
    from yx_three_party_account t
   where t.account_id = l_account_id
     for update;
  --4.2支出账号判断余额（支出账号余额减少，收入账户余额增加）
  if v_income_type = 1 then
    if v_expense_amount > (l_account_balance + l_credit_amount) then
      v_result := pkg_error_code.balance_low;
      rollback;
      return;
    end if;
  end if;
  --4.3扣款
  if v_income_type = 1 then
    --支出
    l_account_balance := l_account_balance - v_expense_amount;
  else
    --收入
    l_account_balance := l_account_balance + v_expense_amount;
  end if;
  --4.4修改账户余额
  update yx_three_party_account t
     set t.balance = l_account_balance
   where t.account_id = l_account_id;

  --5、添加费用
  insert into yx_trade_expense
    (record_id,
     yx_order_id,
     trade_order_no,
     trade_expense_no,
     order_source,
     expense_type,
     down_channel_no,
     up_channel_no,
     agent_id,
     business_type,
     change_amount,
     balance,
     change_time,
     order_time,
     out_change_time,
     account_id,
     income_type,
     order_amount,
     memo)
  values
    (seq_yxtradeexpense_auto_id.nextval,
     l_yx_order_id,
     v_trade_order_no,
     v_trade_expense_no,
     v_order_source,
     v_expense_type,
     v_down_channel_no,
     v_up_channel_no,
     v_agent_id,
     l_yx_business_type,
     v_expense_amount,
     l_account_balance,
     sysdate,
     to_date(v_order_time, 'yyyy-mm-dd hh24:mi:ss'),
     to_date(v_out_change_time, 'yyyy-mm-dd hh24:mi:ss'),
     l_account_id,
     v_income_type,
     v_order_amount,
     v_memo);
  if (sql%rowcount = 0) then
    rollback;
    v_result := pkg_error_code.data_error;
    return;
  end if;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_sync_trade_expense' || v_trade_order_no, sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_TRADE_UP_ORDER_PAY
prompt ==========================================
prompt
create or replace procedure fd_account.yx_p_trade_up_order_pay(v_order_source        in number, --交易系统编号
                                                    v_down_channel_no     in varchar2, --下游渠道编号
                                                    v_up_channel_no       in varchar2, --上游渠道编号
                                                    v_trade_order_no      in varchar2, --外部交易订单号
                                                    v_trade_delivery_no   in varchar2, --外部发货编号
                                                    v_ext_order_no        in varchar2, --外部下游渠道记录的订单号
                                                    v_agent_id            in varchar2, --代理人编号，值可能为0
                                                    v_recharge_account_no in varchar2, --充值号码
                                                    v_business_type       in number, --业务类型
                                                    v_carrier_no          in varchar2, --运营商
                                                    v_province_no         in varchar2, --省份编号
                                                    v_city_no             in varchar2, --诚实编号
                                                    v_down_order_unit     in number, --下游订单规格
                                                    v_down_order_face     in number, --下游订单面值(元)
                                                    v_down_draw_unit      in number, --下游扣款规格(M)
                                                    v_down_draw_face      in number, --下游扣款面值(元)
                                                    v_down_draw_amount    in number, --下游订单扣款金额(用户支付金额)
                                                    v_down_real_amount    in number, --下游订单真实扣款金额
                                                    v_down_income_amount  in number, --下游收入金额
                                                    v_up_draw_unit        in number, --上游扣款规格(M)
                                                    v_up_draw_face        in number, --上游扣款面值(元)
                                                    v_up_draw_amount      in number, --上游扣款金额
                                                    v_up_real_amount      in number, --上游真实扣款金额
                                                    v_success_face        in number, --成功面值
                                                    v_order_time          in varchar2, --外部订单生成时间（yyyy-mm-dd hh24:mi:ss）
                                                    v_handling_fee        in number, --手续费
                                                    v_agency_fee          in number, --代理费
                                                    v_service_fee         in number, --上游服务费
                                                    v_expense_fee         in number, --费用 
                                                    v_expense_type        in number, --费用类型：1-快递费
                                                    v_memo                in varchar2, --备注信息
                                                    v_out_change_time     in varchar2, --外部上游扣款发生时间（yyyy-mm-dd hh24:mi:ss）
                                                    v_result              out varchar2 --返回结果
                                                    ) as
  pragma autonomous_transaction; --自治事务
  ----------------------------------
  --主要功能：上游扣款
  --创建人：周荣省
  --创建时间：2019-03-19
  --注：v_down_draw_amount=（v_down_real_amount+v_handling_fee）+v_down_income_amount
  --上下游扣款折扣必须相等即（v_down_real_amount+v_handling_fee）/v_down_draw_face=v_up_real_amount/v_up_draw_face
  ----------------------------------
  l_up_account_id    number; --上游账户编号
  l_yx_business_type number; --上游业务类型编号
begin
  --1、获取记账系统业务类型
  l_yx_business_type := yx_f_trade_business_type_get(v_order_source,
                                                     v_business_type);
  --1.1判断数据正确性
  if v_down_draw_amount !=
     (v_down_real_amount + v_down_income_amount + v_handling_fee) then
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;
  --2、检查上游渠道、账户及其关联情况
  v_result := yx_f_trade_pay_account_get(v_order_source,
                                         v_up_channel_no,
                                         l_up_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --2.1、检查代理人情况
  if ((v_agent_id is null) or (v_agent_id = '0')) then
    if (v_agency_fee > 0) then
      v_result := pkg_error_code.data_error;
      rollback;
      return;
    end if;
  end if;
  --3、若创建历史库，需获取历史库的订单
  --4、检查订单是否存在，不存在则创建订单
  v_result := yx_f_trade_order_create(v_order_source,
                                      v_down_channel_no,
                                      v_agent_id,
                                      v_trade_order_no,
                                      v_ext_order_no,
                                      v_recharge_account_no,
                                      l_yx_business_type,
                                      v_carrier_no,
                                      v_province_no,
                                      v_city_no,
                                      v_down_draw_face,
                                      v_down_draw_unit,
                                      v_down_draw_amount,
                                      v_down_real_amount,
                                      v_down_income_amount,
                                      v_agency_fee,
                                      v_handling_fee,
                                      --v_success_face,
                                      v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --5、检查上游扣款的订单面值
  /*v_result := yx_f_trade_order_face_check(v_trade_order_no,
                                          v_down_order_face,
                                          v_down_draw_face);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;*/
  --5.1扣款折扣一致检查，营销中心代售，上下游折扣一致
  if ((v_up_draw_amount / v_up_draw_face) !=
     ((v_down_real_amount + v_handling_fee) / v_down_draw_face)) then
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;

  --6、上游支付扣款
  v_result := yx_f_trade_up_order_minus(v_order_source,
                                        v_trade_order_no,
                                        v_trade_delivery_no,
                                        v_ext_order_no,
                                        v_up_channel_no,
                                        l_up_account_id,
                                        v_up_draw_unit,
                                        v_up_draw_face,
                                        v_up_draw_amount,
                                        v_up_real_amount,
                                        v_down_draw_unit,
                                        v_down_draw_face,
                                        v_down_draw_amount,
                                        v_down_real_amount,
                                        v_down_income_amount,
                                        v_agent_id,
                                        v_handling_fee,
                                        v_agency_fee,
                                        v_service_fee,
                                        v_order_time,
                                        v_out_change_time,
                                        v_carrier_no,
                                        v_province_no,
                                        v_memo);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_trade_up_order_pay' || v_trade_order_no,
                   sqlerrm,
                   1);
end;
/

prompt
prompt Creating procedure YX_P_TRADE_UP_ORDER_PAY1
prompt ===========================================
prompt
create or replace procedure fd_account.yx_p_trade_up_order_pay1(v_order_source        in number, --交易系统编号
                                                     v_down_channel_no     in varchar2, --下游渠道编号
                                                     v_up_channel_no       in varchar2, --上游渠道编号
                                                     v_trade_order_no      in varchar2, --外部交易订单号
                                                     v_trade_delivery_no   in varchar2, --外部发货编号
                                                     v_ext_order_no        in varchar2, --外部下游渠道记录的订单号
                                                     v_agent_count         in number, --含有的代理人数量
                                                     v_agent_id_list       in varchar2, --代理人编号组，编号之间用逗号隔开，如100,99
                                                     v_recharge_account_no in varchar2, --充值号码
                                                     v_business_type       in number, --业务类型
                                                     v_carrier_no          in varchar2, --运营商
                                                     v_province_no         in varchar2, --省份编号
                                                     v_city_no             in varchar2, --诚实编号
                                                     v_down_order_unit     in number, --下游订单规格
                                                     v_down_order_face     in number, --下游订单面值(元)
                                                     v_down_draw_unit      in number, --下游扣款规格(M)
                                                     v_down_draw_face      in number, --下游扣款面值(元)
                                                     v_down_draw_amount    in number, --下游订单扣款金额(用户支付金额)
                                                     v_down_real_amount    in number, --下游订单真实扣款金额
                                                     v_down_income_amount  in number, --下游收入金额
                                                     v_up_draw_unit        in number, --上游扣款规格(M)
                                                     v_up_draw_face        in number, --上游扣款面值(元)
                                                     v_up_draw_amount      in number, --上游扣款金额
                                                     v_up_real_amount      in number, --上游真实扣款金额
                                                     v_success_face        in number, --成功面值
                                                     v_order_time          in varchar2, --外部订单生成时间（yyyy-mm-dd hh24:mi:ss）
                                                     v_handling_fee        in number, --手续费
                                                     v_agency_fee_list     in varchar2, --代理费组，与代理人编号对应
                                                     v_service_fee         in number, --上游服务费
                                                     v_expense_fee         in number, --费用
                                                     v_expense_type        in number, --费用类型：1-快递费
                                                     v_memo                in varchar2, --备注信息
                                                     v_out_change_time     in varchar2, --外部上游扣款发生时间（yyyy-mm-dd hh24:mi:ss）
                                                     v_result              out varchar2 --返回结果
                                                     ) as
  pragma autonomous_transaction; --自治事务
  ----------------------------------
  --主要功能：上游扣款,多代理人专用
  --创建人：周荣省
  --创建时间：2019-05-22
  --注：v_down_draw_amount=（v_down_real_amount+v_handling_fee）+v_down_income_amount
  --上下游扣款折扣必须相等即（v_down_real_amount+v_handling_fee）/v_down_draw_face=v_up_real_amount/v_up_draw_face
  ----------------------------------
  l_up_account_id        number; --上游账户编号
  l_yx_business_type     number; --上游业务类型编号
  l_agent_id             varchar2(32); --代理人id
  l_agent_arr            t_Array; --代理人数组
  l_agent_fee_arr        t_Array; --代理费组
  l_out_agent_group      varchar2(32); -- 代理人编号重新组合
  l_out_agent_group_name varchar2(64); --代理人编号重新组合名称
  l_out_status           number;
  l_agency_fee           number; --代理费总和
begin
  --1、获取记账系统业务类型
  l_yx_business_type := yx_f_trade_business_type_get(v_order_source,
                                                     v_business_type);
  --1.1判断数据正确性
  if v_down_draw_amount !=
     (v_down_real_amount + v_down_income_amount + v_handling_fee) then
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;
  --2、检查上游渠道、账户及其关联情况
  v_result := yx_f_trade_pay_account_get(v_order_source,
                                         v_up_channel_no,
                                         l_up_account_id);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --2.1、检查代理人情况
  if v_agent_count = 1 then
    l_agent_id := v_agent_id_list;
  elsif v_agent_count > 1 then
    --多个代理人
    l_agent_arr := yx_f_Split(v_agent_id_list, ',');
    v_result    := yx_f_group_agent_solt(l_agent_arr,
                                         l_out_agent_group,
                                         l_out_agent_group_name);
    --判断代理人
    v_result := yx_f_group_agent(v_down_channel_no,
                                 v_agent_count,
                                 l_agent_arr,
                                 l_out_agent_group,
                                 l_agent_id);
    if v_result != pkg_yx_error_code.success then
      --组合代理人不存在，添加
      yx_sync_agent_group('ZH' || l_out_agent_group,
                          l_out_agent_group_name,
                          1,
                          0,
                          v_agent_count,
                          '-',
                          '-',
                          '*',
                          3,
                          2,
                          0,
                          v_down_channel_no,
                          l_out_status,
                          l_agent_id);
      if l_out_status != 100 then
        rollback;
        return;
      end if;
    end if;
  end if;
  --2.2计算代理费总和
  if v_agent_count = 1 then
    l_agency_fee := to_number(v_agency_fee_list);
  elsif v_agent_count > 1 then
    l_agent_fee_arr := yx_f_Split(v_agency_fee_list, ',');
    v_result        := yx_f_group_agent_fee(v_agent_count,
                                            l_agent_fee_arr,
                                            l_agency_fee);
  end if;
  if ((l_agent_id is null) or (l_agent_id = '0')) then
    if (l_agency_fee > 0) then
      v_result := pkg_error_code.data_error;
      rollback;
      return;
    end if;
  end if;
  --3、若创建历史库，需获取历史库的订单
  --4、检查订单是否存在，不存在则创建订单
  v_result := yx_f_trade_order_create(v_order_source,
                                      v_down_channel_no,
                                      l_agent_id,
                                      v_trade_order_no,
                                      v_ext_order_no,
                                      v_recharge_account_no,
                                      l_yx_business_type,
                                      v_carrier_no,
                                      v_province_no,
                                      v_city_no,
                                      v_down_draw_face,
                                      v_down_draw_unit,
                                      v_down_draw_amount,
                                      v_down_real_amount,
                                      v_down_income_amount,
                                      l_agency_fee,
                                      v_handling_fee,
                                      --v_success_face,
                                      v_order_time);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --5、检查上游扣款的订单面值
  v_result := yx_f_trade_order_face_check(v_trade_order_no,
                                          v_down_order_face,
                                          v_down_draw_face);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --5.1扣款折扣一致检查，营销中心代售，上下游折扣一致
  if ((v_up_draw_amount / v_up_draw_face) !=
     ((v_down_real_amount + v_handling_fee) / v_down_draw_face)) then
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;

  --6、上游支付扣款
  v_result := yx_f_trade_up_order_minus(v_order_source,
                                        v_trade_order_no,
                                        v_trade_delivery_no,
                                        v_ext_order_no,
                                        v_up_channel_no,
                                        l_up_account_id,
                                        v_up_draw_unit,
                                        v_up_draw_face,
                                        v_up_draw_amount,
                                        v_up_real_amount,
                                        v_down_draw_unit,
                                        v_down_draw_face,
                                        v_down_draw_amount,
                                        v_down_real_amount,
                                        v_down_income_amount,
                                        l_agent_id,
                                        v_handling_fee,
                                        l_agency_fee,
                                        v_service_fee,
                                        v_order_time,
                                        v_out_change_time,
                                        v_carrier_no,
                                        v_province_no,
                                        v_memo--,
                                        --v_agent_count,
                                        --l_agent_arr,
                                        --l_agent_fee_arr
                                        );
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_trade_up_order_pay' || v_trade_order_no,
                   sqlerrm,
                   1);
end;
/

prompt
prompt Creating procedure YX_P_TRADE_UP_ORDER_REF
prompt ==========================================
prompt
create or replace procedure fd_account.yx_p_trade_up_order_ref(v_order_source          in number, --外部系统编号
                                                    v_down_channel_no       in varchar2, --外部下游渠道编号
                                                    v_up_channel_no         in varchar2, --上游渠道编号
                                                    --v_agent_id              in varchar2, --代理人编号
                                                    v_trade_order_no        in varchar2, --外部交易订单号
                                                    v_trade_delivery_no     in varchar2, --外部发货订单号
                                                    v_ext_delivery_no       in varchar2, --扩展发货编号
                                                    v_trade_refund_no       in varchar2, --外部退款编号
                                                    v_business_type         in number, --业务类型
                                                    v_carrier_no            in varchar2, --运营商编号
                                                    v_province_no           in varchar2, --省份编号
                                                    v_up_refund_unit        in number, --上游退款规格(M)
                                                    v_up_refund_face        in number, --上游退款面值(元)
                                                    v_up_refund_amount      in number, --上游退款金额
                                                    v_up_refund_real_amount in number, --上游退款真实金额
                                                    v_order_time            in varchar2, --外部订单生成时间（yyyy-mm-dd hh24:mi:ss）
                                                    --v_handling_fee        in number, --手续费
                                                    --v_agency_fee          in number, --代理费
                                                    v_service_fee     in number, --上游服务费
                                                    v_memo            in varchar2, --备注信息
                                                    v_out_change_time in varchar2, --外部上游退款发生时间（yyyy-mm-dd hh24:mi:ss）
                                                    v_result          out varchar2) as
  pragma autonomous_transaction; --自治事务
  ------------------------------------------------------
  --主要功能：上游退款
  --创建人：周荣省
  --创建时间：2019-03-20
  ------------------------------------------------------
  l_yx_business_type number;
begin
  --1、获取记账系统业务类型
  l_yx_business_type := yx_f_trade_business_type_get(v_order_source,
                                                     v_business_type);
  --2、上游退款
  v_result := yx_f_trade_up_order_refund(v_order_source,
                                         v_down_channel_no,
                                         v_up_channel_no,
                                         --v_agent_id,
                                         v_trade_order_no,
                                         v_trade_delivery_no,
                                         v_ext_delivery_no,
                                         v_trade_refund_no,
                                         l_yx_business_type,
                                         v_carrier_no,
                                         v_province_no,
                                         v_up_refund_unit,
                                         v_up_refund_face,
                                         v_up_refund_amount,
                                         v_up_refund_real_amount,
                                         v_order_time,
                                         v_service_fee,
                                         v_memo,
                                         v_out_change_time);

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_trade_up_order_ref' || v_trade_order_no,
                   sqlerrm,
                   1);
end;
/

prompt
prompt Creating procedure YX_P_TRADE_UP_PAY_COUPON
prompt ===========================================
prompt
create or replace procedure fd_account.yx_p_trade_up_pay_coupon(v_order_source        in number, --交易系统编号
                                                     v_down_channel_no     in varchar2, --下游渠道编号
                                                     v_up_channel_no       in varchar2, --上游渠道编号
                                                     v_trade_order_no      in varchar2, --外部交易订单号
                                                     v_trade_delivery_no   in varchar2, --外部发货编号
                                                     v_ext_order_no        in varchar2, --外部下游渠道记录的订单号
                                                     v_agent_id            in varchar2, --代理人编号，值可能为0
                                                     v_recharge_account_no in varchar2, --充值号码
                                                     v_business_type       in number, --业务类型
                                                     v_carrier_no          in varchar2, --运营商
                                                     v_province_no         in varchar2, --省份编号
                                                     v_city_no             in varchar2, --诚实编号
                                                     v_down_order_unit     in number, --下游订单规格
                                                     v_down_order_face     in number, --下游订单面值(元)
                                                     v_down_draw_unit      in number, --下游扣款规格(M)
                                                     v_down_draw_face      in number, --下游扣款面值(元)
                                                     v_down_draw_amount    in number, --下游订单扣款金额(用户支付金额)
                                                     v_down_real_amount    in number, --下游订单真实扣款金额
                                                     v_down_income_amount  in number, --下游额外收益金额
                                                     v_up_draw_unit        in number, --上游扣款规格(M)
                                                     v_up_draw_face        in number, --上游扣款面值(元)
                                                     v_up_draw_amount      in number, --上游扣款金额
                                                     v_up_real_amount      in number, --上游真实扣款金额
                                                     v_success_face        in number, --成功面值
                                                     v_order_time          in varchar2, --外部订单生成时间（yyyy-mm-dd hh24:mi:ss）
                                                     v_handling_fee        in number, --手续费
                                                     v_agency_fee          in number, --代理费
                                                     v_service_fee         in number, --上游服务费
                                                     v_expense_fee         in number, --费用 
                                                     v_expense_type        in number, --费用类型：1-快递费
                                                     v_coupon_amount       in number, --优惠券金额
                                                     v_issue_type          in number, --发行类型，0：普通交易扣款，1：发行卡或优惠券扣款
                                                     v_memo                in varchar2, --备注信息
                                                     v_out_change_time     in varchar2, --外部上游扣款发生时间（yyyy-mm-dd hh24:mi:ss）
                                                     v_result              out varchar2 --返回结果
                                                     ) as
  pragma autonomous_transaction; --自治事务
  ----------------------------------
  --主要功能：上游扣款，含优惠券
  --创建人：周荣省
  --创建时间：2019-05-28
  --注：v_down_draw_amount=（v_down_real_amount+v_handling_fee）+v_down_income_amount
  --上下游扣款折扣必须相等即（v_down_real_amount+v_handling_fee）/v_down_draw_face=v_up_real_amount/v_up_draw_face
  ----------------------------------
  l_up_account_id    number; --上游账户编号
  l_yx_business_type number; --上游业务类型编号
begin
  if (v_issue_type != 0) and (v_issue_type != 1) then
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;
  --1、获取记账系统业务类型
  l_yx_business_type := yx_f_trade_business_type_get(v_order_source,
                                                     v_business_type);
  --1.1判断数据正确性
  if v_down_draw_amount !=
     (v_down_real_amount + v_down_income_amount + v_handling_fee) then
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;
  --2、检查上游渠道、账户及其关联情况
  if v_issue_type = 0 then
    v_result := yx_f_trade_pay_account_get(v_order_source,
                                           v_up_channel_no,
                                           l_up_account_id);
    if (v_result != pkg_error_code.success) then
      rollback;
      return;
    end if;
  else
    l_up_account_id := 0;
  end if;
  --2.1、检查代理人情况
  if ((v_agent_id is null) or (v_agent_id = '0')) then
    if (v_agency_fee > 0) then
      v_result := pkg_error_code.data_error;
      rollback;
      return;
    end if;
  end if;
  --3、若创建历史库，需获取历史库的订单
  --4、检查订单是否存在，不存在则创建订单
  v_result := yx_f_trade_order_create(v_order_source,
                                      v_down_channel_no,
                                      v_agent_id,
                                      v_trade_order_no,
                                      v_ext_order_no,
                                      v_recharge_account_no,
                                      l_yx_business_type,
                                      v_carrier_no,
                                      v_province_no,
                                      v_city_no,
                                      v_down_draw_face,
                                      v_down_draw_unit,
                                      v_down_draw_amount,
                                      v_down_real_amount,
                                      v_down_income_amount,
                                      v_agency_fee,
                                      v_handling_fee,
                                      --v_success_face,
                                      v_order_time,
                                      v_coupon_amount);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --5、检查上游扣款的订单面值
  /*v_result := yx_f_trade_order_face_check(v_trade_order_no,
                                          v_down_order_face,
                                          v_down_draw_face);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;*/
  --5.1扣款折扣一致检查，营销中心代售，上下游折扣一致
  if ((v_up_draw_amount / v_up_draw_face) !=
     ((v_down_draw_amount + v_coupon_amount) / v_down_draw_face)) and
     v_issue_type = 0 then
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;
  --5.2发行扣款只需检查面值一致
  if (v_up_draw_face != v_down_draw_face) and v_issue_type = 1 then
    v_result := pkg_error_code.data_error;
    rollback;
    return;
  end if;

  --6、上游支付扣款
  v_result := yx_f_trade_up_order_minus(v_order_source,
                                        v_trade_order_no,
                                        v_trade_delivery_no,
                                        v_ext_order_no,
                                        v_up_channel_no,
                                        l_up_account_id,
                                        v_up_draw_unit,
                                        v_up_draw_face,
                                        v_up_draw_amount,
                                        v_up_real_amount,
                                        v_down_draw_unit,
                                        v_down_draw_face,
                                        v_down_draw_amount,
                                        v_down_real_amount,
                                        v_down_income_amount,
                                        v_agent_id,
                                        v_handling_fee,
                                        v_agency_fee,
                                        v_service_fee,
                                        v_order_time,
                                        v_out_change_time,
                                        v_carrier_no,
                                        v_province_no,
                                        v_memo,
                                        v_coupon_amount,
                                        v_issue_type);
  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_trade_up_pay_coupon' || v_trade_order_no,
                   sqlerrm,
                   1);
end;
/

prompt
prompt Creating procedure YX_P_TRADE_UP_REF_COUPON
prompt ===========================================
prompt
create or replace procedure fd_account.yx_p_trade_up_ref_coupon(v_order_source    in number, --外部系统编号
                                                     v_down_channel_no in varchar2, --外部下游渠道编号
                                                     v_up_channel_no   in varchar2, --上游渠道编号
                                                     --v_agent_id              in varchar2, --代理人编号
                                                     v_trade_order_no        in varchar2, --外部交易订单号
                                                     v_trade_delivery_no     in varchar2, --外部发货订单号
                                                     v_ext_delivery_no       in varchar2, --扩展发货编号
                                                     v_trade_refund_no       in varchar2, --外部退款编号
                                                     v_business_type         in number, --业务类型
                                                     v_carrier_no            in varchar2, --运营商编号
                                                     v_province_no           in varchar2, --省份编号
                                                     v_up_refund_unit        in number, --上游退款规格(M)
                                                     v_up_refund_face        in number, --上游退款面值(元)
                                                     v_up_refund_amount      in number, --上游退款金额
                                                     v_up_refund_real_amount in number, --上游退款真实金额
                                                     v_order_time            in varchar2, --外部订单生成时间（yyyy-mm-dd hh24:mi:ss）
                                                     --v_handling_fee        in number, --手续费
                                                     --v_agency_fee          in number, --代理费
                                                     v_service_fee     in number, --上游服务费
                                                     v_coupon_amount   in number, --优惠券金额
                                                     v_issue_type      in number, --发行类型，0：普通交易退款，1：发行卡或优惠券退款
                                                     v_memo            in varchar2, --备注信息
                                                     v_out_change_time in varchar2, --外部上游退款发生时间（yyyy-mm-dd hh24:mi:ss）
                                                     v_result          out varchar2) as
  pragma autonomous_transaction; --自治事务
  ------------------------------------------------------
  --主要功能：上游退款，含优惠券
  --创建人：周荣省
  --创建时间：2019-05-28
  ------------------------------------------------------
  l_yx_business_type number;
begin
  --1、获取记账系统业务类型
  l_yx_business_type := yx_f_trade_business_type_get(v_order_source,
                                                     v_business_type);
  --2、上游退款
  v_result := yx_f_trade_up_order_refund(v_order_source,
                                         v_down_channel_no,
                                         v_up_channel_no,
                                         --v_agent_id,
                                         v_trade_order_no,
                                         v_trade_delivery_no,
                                         v_ext_delivery_no,
                                         v_trade_refund_no,
                                         l_yx_business_type,
                                         v_carrier_no,
                                         v_province_no,
                                         v_up_refund_unit,
                                         v_up_refund_face,
                                         v_up_refund_amount,
                                         v_up_refund_real_amount,
                                         v_order_time,
                                         v_service_fee,
                                         v_memo,
                                         v_out_change_time,
                                         v_coupon_amount,
                                         v_issue_type);

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_trade_up_ref_coupon' || v_trade_order_no,
                   sqlerrm,
                   1);
end;
/

prompt
prompt Creating procedure YX_P_UP_DRAW_SERVICE
prompt =======================================
prompt
create or replace procedure fd_account.yx_p_up_draw_service(v_channel_no      in varchar2, --渠道编号
                                                 v_bank_account_id in number, --银行账户
                                                 v_amount          in number, --服务费提现金额
                                                 v_handler_user    in varchar2, --操作人
                                                 v_memo            in varchar2, --备注
                                                 v_result          out varchar2) as

  /*
    创建人:邓孝辉
    创建时间:2019-05-02
    简介:服务费提现到银行
  */
  l_channel_name              varchar2(32);
  l_account_name              varchar2(32);
begin
  --1.渠道,银行账户,金额检查
  v_result := yx_f_up_draw_service_check(v_channel_no,
                                         v_bank_account_id,
                                         v_amount,
                                         l_channel_name,
                                         l_account_name);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --2.服务费提现
  v_result := yx_f_up_draw_service(v_channel_no,
                                   v_bank_account_id,
                                   v_amount,
                                   l_channel_name,
                                   l_account_name,
                                   v_handler_user,
                                   v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  
    ---3. 记录日志
  fd_p_write_handle_log('营销-服务费提现到银行',
                        v_handler_user,
                        ('v_channel_no=' || v_channel_no || ',v_amount=' ||
                        v_amount));
  
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_p_up_draw_service', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_P_UP_SERVICE_TSFER_BALANCE
prompt ================================================
prompt
create or replace procedure fd_account.yx_p_up_service_tsfer_balance(v_channel_no in varchar2, --渠道编号
                                                          v_amount     in number, --转换金额
                                                          v_handl_user in varchar2, --操作人
                                                          v_memo       in varchar2,
                                                          v_result     out varchar2) as

  /*
     创建人:邓孝辉
     创建时间:2019-05-02
     简介:服务费转余额
  */
  l_account_id number;
begin
  --1.检查渠道信息,金额
  v_result := yx_f_up_service_tsfer_check(v_channel_no,
                                          v_amount,
                                          l_account_id);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;
  --2.服务费转款
  v_result := yx_f_up_service_tsfer_balance(v_channel_no,
                                            l_account_id,
                                            v_amount,
                                            v_handl_user,
                                            v_memo);

  if (v_result != pkg_error_code.success) then
    rollback;
    return;
  end if;

  ---3. 记录日志
  fd_p_write_handle_log('营销-服务费转余额',
                        v_handl_user,
                        ('v_channel_no=' || v_channel_no || ',v_amount=' ||
                        v_amount));

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('yx_up_service_transfer_balance', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure YX_SYNC_AGENT_INFO
prompt =====================================
prompt
create or replace procedure fd_account.yx_sync_agent_info(v_agent_id       in varchar2, --代理人编号（交易系统）
                                               v_agent_name     in varchar2, --代理人名称
                                               v_agent_type     in number, --代理人类型：0-代理人，1-代理企业
                                               v_certificate_no in varchar2, --身份证/纳税识别号
                                               v_mobile         in varchar2, --手机号码
                                               v_province_no    in varchar2, --省份
                                               v_company_nature in number, --公司性质1:有限责任公司,2:股份有限公司,3:个体商户,4:合伙企业，代理人时传0
                                               v_taxpayer_size  in number, --纳税人规模1:一般纳税人,2小规模纳税人，代理人时传0
                                               v_status         in number, --状态
                                               v_channel_no     in varchar2, --下游渠道编号
                                               v_out_status     out number, --状态: 100-成功 200-失败
                                               v_out_id         out number --记账系统代理人id
                                               ) as
  pragma autonomous_transaction; --自治事务
  -------------------------------------
  --主要功能：同步代理人信息
  --创建人：周荣省
  --创建时间：2019-03-22
  -------------------------------------
  l_status     number;
  l_number     number;
  l_company_id number := 0;
  l_agent_id   number; --记账系统代理人id
begin
  l_status := v_status;
  if (l_status is not null and l_status <> 0) then
    l_status := 1;
  end if;
  --检查代理人
  select count(*)
    into l_number
    from yx_base_agent t
   where t.out_agent_id = v_agent_id
     and t.down_channel_no = v_channel_no;
  --获取公司编号
  select t.company_id
    into l_company_id
    from yx_base_down_channel t
   where t.channel_no = v_channel_no;
  if (l_number >= 1) then
    select t.agent_id
      into l_agent_id
      from yx_base_agent t
     where t.out_agent_id = v_agent_id
       and t.down_channel_no = v_channel_no;
    --代理人存在，修改
    update yx_base_agent t
       set t.agent_name      = v_agent_name,
           t.agent_type      = v_agent_type,
           t.certificate_no  = v_certificate_no,
           t.mobile          = v_mobile,
           t.province_no     = v_province_no,
           t.company_nature  = v_company_nature,
           t.company_id      = l_company_id,
           t.taxpayer_size   = v_taxpayer_size,
           t.status          = l_status,
           t.last_edit_user  = '_sys',
           t.last_edit_time  = sysdate,
           t.down_channel_no = v_channel_no
     where t.out_agent_id = v_agent_id
       and t.down_channel_no = v_channel_no;
    if (sql%rowcount >= 1) then
      v_out_status := 100;
      v_out_id     := l_agent_id;
    else
      v_out_status := 200;
    end if;
    commit;
    return;
  end if;
  --添加代理人
  select seq_yxbaseagent_auto_id.nextval into l_agent_id from dual;
  insert into yx_base_agent
    (agent_id,
     out_agent_id,
     agent_name,
     agent_type,
     certificate_no,
     mobile,
     province_no,
     company_nature,
     company_id,
     taxpayer_size,
     balance,
     status,
     created_user,
     created_time,
     down_channel_no)
  values
    (l_agent_id,
     v_agent_id,
     v_agent_name,
     v_agent_type,
     v_certificate_no,
     v_mobile,
     v_province_no,
     v_company_nature,
     l_company_id,
     v_taxpayer_size,
     0,
     l_status,
     '_sys',
     sysdate,
     v_channel_no);
  if (sql%rowcount >= 1) then
    v_out_status := 100;
    v_out_id     := l_agent_id;
  else
    v_out_status := 200;
  end if;
  commit;
exception
  when others then
    v_out_status := 200;
    rollback;
    fd_p_write_log('yx_sync_agent_info', sqlerrm, 200);
end;
/

prompt
prompt Creating procedure YX_SYNC_CHANNEL_INFO
prompt =======================================
prompt
create or replace procedure fd_account.yx_sync_channel_info(v_channel_no    in varchar2, --渠道编号
                                                 v_channel_name  in varchar2, --渠道名称
                                                 v_channel_type  in number, --渠道类型: 1-上游渠道 2-下游渠道
                                                 v_company_id    in number, --公司编号
                                                 v_status        in number, -- 渠道状态: 0-启用 1-禁用
                                                 v_system_no     in number, -- 系统编号
                                                 v_warn_balance  in number, --报警余额
                                                 v_commi_balance in number, --佣金余额
                                                 v_channel_class in number, --渠道类型1：自有渠道2：银行渠道3：行业渠道
                                                 v_out_status    out number -- 状态: 100-成功 200-失败
                                                 ) as
  ----------------------------------
  --主要功能：同步渠道信息
  --创建人：周荣省
  --创建时间：2019-03-21
  ----------------------------------
  l_number number;
  l_status number;
  l_reslut varchar2(32);
begin
  l_status := v_status;
  if (l_status is not null and l_status <> 0) then
    l_status := 1;
  end if;
  if (v_channel_type = 1) then
    --上游
    --判断渠道是否存在(要求不同渠道的渠道编号必须不相同）
    select count(*)
      into l_number
      from yx_base_up_channel t
     where t.channel_no = v_channel_no;
    if (l_number >= 1) then
      --渠道已经存在，修改
      update yx_base_up_channel t
         set t.channel_name   = v_channel_name,
             t.company_id     = v_company_id,
             t.status         = l_status,
             t.last_edit_user = 'sys',
             t.last_edit_time = sysdate
       where t.channel_no = v_channel_no
         and t.source_system_id = v_system_no;
      if (sql%rowcount >= 1) then
        v_out_status := 100;
      else
        v_out_status := 200;
      end if;
      commit;
      return;
    end if;
    --渠道不存在，添加
    l_number := seq_yxbaseupaccount_auto_id.nextval;
    --添加上游账户
    insert into yx_base_up_account
      (account_id,
       account_name,
       query_balance,
       inner_balance,
       created_user,
       created_time)
    values
      (l_number, v_channel_name || '支付', 0, 0, '_sys', sysdate);
    --添加上游渠道
    insert into yx_base_up_channel
      (channel_no,
       channel_name,
       company_id,
       source_system_id,
       warn_balance,
       commi_balance,
       account_id,
       status,
       created_user,
       created_time,
       service_balance)
    values
      (v_channel_no,
       v_channel_name,
       v_company_id,
       v_system_no,
       v_warn_balance,
       v_commi_balance,
       l_number,
       l_status,
       '_sys',
       sysdate,
       0);
  
    if (sql%rowcount >= 1) then
      v_out_status := 100;
    else
      v_out_status := 200;
    end if;
  else
    --下游
    --判断渠道是否存在
    select count(*)
      into l_number
      from yx_base_down_channel t
     where t.channel_no = v_channel_no;
    if (l_number >= 1) then
      --渠道已经存在，修改
      update yx_base_down_channel t
         set t.channel_name   = v_channel_name,
             t.company_id     = v_company_id,
             t.status         = l_status,
             t.last_edit_user = 'sys',
             t.last_edit_time = sysdate
       where t.channel_no = v_channel_no
         and t.source_system_id = v_system_no;
      if (sql%rowcount >= 1) then
        v_out_status := 100;
      else
        v_out_status := 200;
      end if;
      commit;
      return;
    end if;
    --渠道不存在，添加
    l_number := seq_yxbasedownaccount_auto_id.nextval;
    --添加下游账户
    insert into yx_base_down_account
      (account_id,
       account_name,
       query_balance,
       inner_balance,
       created_user,
       created_time)
    values
      (l_number, v_channel_name || '支付', 0, 0, '_sys', sysdate);
    --添加下游渠道
    insert into yx_base_down_channel
      (channel_no,
       channel_name,
       company_id,
       source_system_id,
       warn_balance,
       commi_balance,
       account_id,
       status,
       channel_class,
       created_user,
       created_time)
    values
      (v_channel_no,
       v_channel_name,
       v_company_id,
       v_system_no,
       v_warn_balance,
       v_commi_balance,
       l_number,
       l_status,
       v_channel_class,
       '_sys',
       sysdate);
  
    if (sql%rowcount >= 1) then
      v_out_status := 100;
    else
      v_out_status := 200;
    end if;
  end if;
  commit;
exception
  when others then
    v_out_status := 200;
    rollback;
    fd_p_write_log('yx_sync_channel_info', sqlerrm, 200);
end;
/

prompt
prompt Creating procedure ZHELEP_CAP_AMOUNT_ADD
prompt ========================================
prompt
create or replace procedure fd_account.zhelep_cap_amount_add(v_cap_account_id number,
                                                  v_amount         number,
                                                  v_edit_user      varchar2,
                                                  v_memo           varchar2,
                                                  v_result         out varchar2) as
  l_cap_balance number;
begin
  ---1.锁资产账户
  select t.balance
    into l_cap_balance
    from fd_base_company_account_cap t
   where t.account_id = v_cap_account_id
     for update;

  ---2.修改资产账户余额
  update fd_base_company_account_cap t
     set t.balance        = (l_cap_balance + v_amount),
         t.last_edit_user = v_edit_user,
         t.last_edit_time = sysdate
   where t.account_id = v_cap_account_id;

  ---3.添加资产账户资金变动
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     create_user)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_cap_account_id,
     v_amount,
     pkg_co_cap_fund_type.add_amount,
     (l_cap_balance + v_amount),
     sysdate,
     0,
     0,
     0,
     'yepz:' ||v_memo,
     v_edit_user);

  v_result := pkg_error_code.success;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELEP_SELF_AMOUNT_ADD
prompt =========================================
prompt
create or replace procedure fd_account.zhelep_self_amount_add(v_self_account_id number,
                                                   v_amount          number,
                                                   v_edit_user       varchar2,
                                                   v_edit_time       varchar2,
                                                   v_memo            varchar2,
                                                   v_result          out varchar2) as
  l_self_balance number;
begin
  ---1.锁资产账户
  select t.balance
    into l_self_balance
    from fd_base_company_account_self t
   where t.account_id = v_self_account_id
     for update;

  ---2.修改资产账户余额
  update fd_base_company_account_self t
     set t.balance       =
         (l_self_balance + v_amount),
         t.last_edit_user = v_edit_user,
         t.last_edit_time = to_date(v_edit_time, 'yyyy-mm-dd hh24:mi:ss')
   where t.account_id = v_self_account_id;

  ---3.添加资产账户资金变动
  insert into fd_trade_co_self_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     create_user)
  values
    (seq_trade_co_self_fund_id.nextval,
     v_self_account_id,
     v_amount,
     pkg_co_self_fund_type.add_amount,
     (l_self_balance + v_amount),
     sysdate,
     0,
     0,
     0,
     'yepz:' || v_memo,
     v_edit_user);

  v_result := pkg_error_code.success;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELP_BANK_AMOUNT_ADD
prompt ========================================
prompt
create or replace procedure fd_account.zhelp_bank_amount_add(v_bank_account_id number,
                                                  v_amount          number,
                                                  v_user            varchar2,
                                                  v_memo            varchar2,
                                                  v_result          out varchar2) as
  ------------银行单边账加款---------
  l_balance    number;
  l_company_id number;
begin
  ---1.锁银行账户
  select t.balance, t.company_id
    into l_balance, l_company_id
    from fd_bank_account_info t
   where t.account_id = v_bank_account_id
     for update;

  ---2.修改银行账户余额
  update fd_bank_account_info t
     set t.balance =
         (l_balance + v_amount)
   where t.account_id = v_bank_account_id;

  ---3.添加银行账户流水
  insert into fd_bank_cash_fund
    (record_id,
     account_id,
     adjust_id,
     company_id,
     change_amount,
     balance,
     change_time,
     created_user,
     change_type,
     use_type,
     has_adjust,
     remark)
  values
    (seq_bank_cash_fund_id.nextval,
     v_bank_account_id,
     0,
     l_company_id,
     v_amount,
     (l_balance + v_amount),
     sysdate,
     v_user,
     pkg_bank_fund_change_type.add_amount,
     pkg_bank_use_type.others_type,
     0,
     'yepz:' || v_memo);

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELP_BOND_PAY
prompt =================================
prompt
create or replace procedure fd_account.zhelp_bond_pay(v_account_id number,
                                           v_amount     number,
                                           v_memo       varchar2,
                                           v_result     out varchar2) as

  l_cap_balance number;
  -----------------辅助补录保证金加款单边账-------------------
begin
  ---1.锁账户
  select t.balance
    into l_cap_balance
    from fd_base_company_account_cap t
   where t.account_id = v_account_id
     for update;

  ---2.资产账户加款
  update fd_base_company_account_cap t
     set t.balance = (l_cap_balance + v_amount)
   where t.account_id = v_account_id;

  ---3.添加记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     bank_batch_id,
     memo,
     record_no,
     create_user)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_account_id,
     v_amount,
     pkg_co_cap_fund_type.add_amount,
     (l_cap_balance + v_amount),
     sysdate,
     0,
     0,
     0,
     'yepz:' ||v_memo,
     '-',
     'wanghj');

  v_result := pkg_error_code.success;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_DOWN
prompt ============================================
prompt
create or replace procedure fd_account.zreport_commi_profit_down(v_collect_date in varchar2 default null) as
  --------------------收集下游资金变动佣金利润信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160721000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type number := 0; --数据出现错误，统计类型为0
  l_wait_count      number := 0;
  l_start_time      date := sysdate;
  l_channel_name    varchar2(100);
  l_account_name    varchar2(100);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from fd_trade_up_fund t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then

    ---1.收集上游资金变动信息
    for item in (select m.down_company_id,
                        m.down_channel_no,
                        m.down_account_id,
                        m.business_type,
                        m.bill_type,
                        m.order_source,
                        (m.down_draw_unit + nvl(f.down_adjust_unit, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_unit, 0)) down_draw_unit,
                        (m.down_draw_face + nvl(f.down_adjust_face, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_face, 0)) down_draw_face,
                        (m.down_draw_amount + nvl(f.down_adjust_amount, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_amount, 0)) down_draw_amount,
                        (m.down_real_amount + nvl(f.down_adjust_real, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_real, 0)) down_real_amount,
                        m.settle_amount,
                        m.down_draw_unit_ref,
                        m.down_draw_face_ref,
                        m.down_draw_amount_ref,
                        m.down_real_amount_ref,
                        m.settle_amount_ref,
                        nvl(f.up_many_face, 0) up_many_face,
                        nvl(f.up_many_amount, 0) up_many_amount
                   from (select u.down_company_id,
                                u.down_channel_no,
                                u.down_account_id,
                                u.business_type,
                                u.bill_type,
                                max(u.order_source) order_source,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_unit) down_draw_unit,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_face) down_draw_face,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_amount) down_draw_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_real_amount) down_real_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           decode(u.down_company_id,
                                                  u.up_company_id,
                                                  u.up_real_amount,
                                                  decode(u.settle_amount,
                                                         0,
                                                         u.up_real_amount,
                                                         u.settle_amount)),
                                           0)) settle_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_unit) down_draw_unit_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_face) down_draw_face_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_amount) down_draw_amount_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_real_amount) down_real_amount_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           decode(u.down_company_id,
                                                  u.up_company_id,
                                                  u.up_real_amount,
                                                  decode(u.settle_amount,
                                                         0,
                                                         u.up_real_amount,
                                                         u.settle_amount)))) settle_amount_ref
                           from fd_trade_up_fund u
                          where u.change_time >= l_collect_date
                            and u.change_time < (l_collect_date + 1)
                            and (u.change_type =
                                pkg_up_fund_change_type.debit_amount or
                                u.change_type =
                                pkg_up_fund_change_type.refund_amount)
                          group by u.down_company_id,
                                   u.down_channel_no,
                                   u.down_account_id,
                                   u.business_type,
                                   u.bill_type) m
                   left join (select d.channel_no,
                                    d.account_id,
                                    d.business_type,
                                    d.bill_type,
                                    sum(d.down_adjust_face) down_adjust_face,
                                    sum(d.down_adjust_unit) down_adjust_unit,
                                    sum(d.down_adjust_amount) down_adjust_amount,
                                    sum(d.down_adjust_real) down_adjust_real,
                                    sum(d.up_many_face) up_many_face,
                                    sum(d.up_many_amount) up_many_amount
                               from fd_trade_up_fund_differ d
                              where d.record_date = l_collect_date
                              group by d.channel_no,
                                       d.account_id,
                                       d.business_type,
                                       d.bill_type) f on m.down_channel_no =
                                                         f.channel_no
                                                     and m.down_account_id =
                                                         f.account_id
                                                     and m.business_type =
                                                         f.business_type
                                                     and m.bill_type =
                                                         f.bill_type
                   left join (select r.channel_no,
                                    r.account_id,
                                    r.business_type,
                                    sum(r.to_front_face) to_front_face,
                                    sum(r.to_front_unit) to_front_unit,
                                    sum(r.to_front_amount) to_front_amount,
                                    sum(r.to_front_real) to_front_real
                               from fd_trade_up_fund_differ r
                              where r.record_date = l_collect_date
                              group by r.channel_no,
                                       r.account_id,
                                       r.business_type) fr on m.down_channel_no =
                                                              fr.channel_no
                                                          and m.down_account_id =
                                                              fr.account_id
                                                          and m.business_type =
                                                              fr.business_type) loop
      begin
        ---2.添加下游佣金利润数据
        if item.down_channel_no != '0' and item.down_account_id != 0 then
          --3.计算统计类型

          l_statistics_type := 0;
          if item.bill_type = pkg_bill_type.back then

            l_statistics_type := pkg_statistics_type.FlowBag;
          else
            --***从业务类型与分类表中获取分类***
            select t.statistics_type
              into l_statistics_type
              from fd_system_business_statis_map t
             where t.local_business_type = item.business_type
               and rownum <= 1;
          end if;

          ---4.获取渠道账户名称
          select t.channel_name
            into l_channel_name
            from fd_base_down_channel t
           where t.channel_no = item.down_channel_no;

          select t.account_name
            into l_account_name
            from fd_base_down_account t
           where t.account_id = item.down_account_id;

          --5.添加数据
          insert into fd_report_commi_profit_redo
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_unit,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits,
             service_fee,
             refund_total_unit,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             refund_profits,
             refund_service_fee,
             up_many_face,
             up_many_amount,
             snap_time,
             statistics_type,
             channel_name,
             account_name,
             channel_source_system)
          values
            (seq_report_commi_profit_id.nextval,
             item.down_company_id,
             item.down_channel_no,
             item.down_account_id,
             pkg_channel_type.down_channel,
             item.business_type,
             item.bill_type,
             item.down_draw_unit,
             item.down_draw_face,
             item.down_draw_amount,
             item.down_real_amount,
             (trunc(item.down_draw_amount, 2) -
             trunc(item.down_real_amount, 2)),
             (item.down_real_amount - item.settle_amount),
             0,
             item.down_draw_unit_ref,
             item.down_draw_face_ref,
             item.down_draw_amount_ref,
             item.down_real_amount_ref,
             (trunc(item.down_draw_amount_ref, 2) -
             trunc(item.down_real_amount_ref, 2)),
             (item.down_real_amount_ref - item.settle_amount_ref),
             0,
             item.up_many_face,
             item.up_many_amount,
             l_collect_date,
             l_statistics_type,
             l_channel_name,
             l_account_name,
             item.order_source);
        end if;

        commit;

      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_down', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');

    commit;
  end if;
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_down', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_SETTLE
prompt ==============================================
prompt
create or replace procedure fd_account.zreport_commi_profit_settle(v_collect_date in varchar2 default null) as
  --------------------收集上游资金变动结算信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160721000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type   number := 0; --数据出现错误，统计类型为0
  l_wait_count        number := 0;
  l_start_time        date := sysdate;
  l_down_company_name varchar2(128);
  l_up_company_name   varchar2(128);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from fd_trade_up_fund t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then

    ---1.收集上游资金变动信息
    for item in (select u.down_company_id,
                        u.up_company_id,
                        u.bill_type,
                        u.business_type,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   u.up_draw_unit,
                                   0)) draw_unit,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   u.up_draw_face,
                                   0)) draw_face,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount),
                                   0)) draw_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount),
                                   0)) real_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   u.up_draw_unit)) unit_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   u.up_draw_face)) face_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount))) amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount))) real_ref
                   from fd_trade_up_fund u
                  where u.change_time >= l_collect_date
                    and u.change_time < (l_collect_date + 1)
                    and u.down_company_id != u.up_company_id
                    and u.down_company_id != 0
                    and u.up_company_id != 0
                    and (u.change_type =
                        pkg_up_fund_change_type.debit_amount or
                        u.change_type =
                        pkg_up_fund_change_type.refund_amount)
                  group by u.down_company_id,
                           u.up_company_id,
                           u.bill_type,
                           u.business_type) loop
      begin

        --2.计算统计类型
        l_statistics_type := 0;
        if item.bill_type = pkg_bill_type.back then

          l_statistics_type := pkg_statistics_type.FlowBag;
        else
          --***从业务类型与分类表中获取分类***
          select t.statistics_type
            into l_statistics_type
            from fd_system_business_statis_map t
           where t.local_business_type = item.business_type
             and rownum <= 1;
        end if;

        ---3.获取公司名称
        select t.sort_name
          into l_down_company_name
          from fd_base_company_info t
         where t.company_id = item.down_company_id;

        select t.sort_name
          into l_up_company_name
          from fd_base_company_info t
         where t.company_id = item.up_company_id;

        ---4.添加作为下游渠道的结算信息
        insert into fd_report_commi_profit_redo
          (record_id,
           company_id,
           channel_no,
           account_id,
           channel_type,
           business_type,
           bill_type,
           total_unit,
           total_face,
           draw_amount,
           real_amount,
           commission,
           profits,
           service_fee,
           refund_total_unit,
           refund_total_face,
           refund_draw_amount,
           refund_real_amount,
           refund_commission,
           refund_profits,
           refund_service_fee,
           up_many_face,
           up_many_amount,
           snap_time,
           statistics_type,
           channel_name,
           account_name)
        values
          (seq_report_commi_profit_id.nextval,
           item.up_company_id,
           '-',
           item.down_company_id,
           pkg_channel_type.settle_down,
           item.business_type,
           item.bill_type,
           item.draw_unit,
           item.draw_face,
           item.draw_amount,
           item.real_amount,
           0,
           0,
           0,
           item.unit_ref,
           item.face_ref,
           item.amount_ref,
           item.real_ref,
           0,
           0,
           0,
           0,
           0,
           l_collect_date,
           l_statistics_type,
           l_down_company_name,
           l_down_company_name);

        ---5.添加作为上游渠道的结算信息
        insert into fd_report_commi_profit_redo
          (record_id,
           company_id,
           channel_no,
           account_id,
           channel_type,
           business_type,
           bill_type,
           total_unit,
           total_face,
           draw_amount,
           real_amount,
           commission,
           profits,
           service_fee,
           refund_total_unit,
           refund_total_face,
           refund_draw_amount,
           refund_real_amount,
           refund_commission,
           refund_profits,
           refund_service_fee,
           up_many_face,
           up_many_amount,
           snap_time,
           statistics_type,
           channel_name,
           account_name)
        values
          (seq_report_commi_profit_id.nextval,
           item.down_company_id,
           '-',
           item.up_company_id,
           pkg_channel_type.settle_up,
           item.business_type,
           item.bill_type,
           item.draw_unit,
           item.draw_face,
           item.draw_amount,
           item.real_amount,
           0,
           0,
           0,
           item.unit_ref,
           item.face_ref,
           item.amount_ref,
           item.real_ref,
           0,
           0,
           0,
           0,
           0,
           l_collect_date,
           l_statistics_type,
           l_up_company_name,
           l_up_company_name);

        commit;

      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_settle', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');

    commit;
  end if;
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_UP
prompt ==========================================
prompt
create or replace procedure fd_account.zreport_commi_profit_up(v_collect_date in varchar2 default null) as
  --------------------收集上游资金变动佣金利润信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160721000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type number := 0; --数据出现错误，统计类型为0
  l_wait_count      number := 0;
  l_start_time      date := sysdate;
  l_channel_name    varchar2(100);
  l_account_name    varchar2(100);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from fd_trade_up_fund t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then

    ---1.收集上游资金变动信息
    for item in (select u.up_company_id,
                        u.up_channel_no,
                        u.up_account_id,
                        u.business_type,
                        u.bill_type,
                        max(u.order_source) order_source,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_unit) up_draw_unit,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_face) up_draw_face,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_amount) up_draw_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_real_amount) up_real_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.down_company_id,
                                          u.up_company_id,
                                          decode(u.down_channel_no,
                                                 '0',
                                                 0,
                                                 u.up_real_amount), ---有交易平账的需要按0计算上游利润
                                          decode(u.settle_amount,
                                                 0,
                                                 u.up_real_amount,
                                                 u.settle_amount)),
                                   0)) settle_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_unit) up_draw_unit_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_face) up_draw_face_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_amount) up_draw_amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_real_amount) up_real_amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.down_company_id,
                                          u.up_company_id,
                                          u.up_real_amount,
                                          decode(u.settle_amount,
                                                 0,
                                                 u.up_real_amount,
                                                 u.settle_amount)))) settle_amount_ref
                   from fd_trade_up_fund u
                  where u.change_time >= l_collect_date
                    and u.change_time < (l_collect_date + 1)
                    and (u.change_type =
                        pkg_up_fund_change_type.debit_amount or
                        u.change_type =
                        pkg_up_fund_change_type.refund_amount)
                  group by u.up_company_id,
                           u.up_channel_no,
                           u.up_account_id,
                           u.business_type,
                           u.bill_type) loop
      begin
        ---2.添加下游佣金利润数据
        if item.up_channel_no != '0' and item.up_account_id != 0 then

          --3.计算统计类型
          l_statistics_type := 0;
          if item.bill_type = pkg_bill_type.back then

            l_statistics_type := pkg_statistics_type.FlowBag;
          else
            --***从业务类型与分类表中获取分类***
            select t.statistics_type
              into l_statistics_type
              from fd_system_business_statis_map t
             where t.local_business_type = item.business_type
               and rownum <= 1;
          end if;

          ---4.获取渠道账户名称
          select t.channel_name
            into l_channel_name
            from fd_base_up_channel t
           where t.channel_no = item.up_channel_no;

          select t.account_name
            into l_account_name
            from fd_base_up_account t
           where t.account_id = item.up_account_id;

          ---5.添加数据
          insert into fd_report_commi_profit_redo
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_unit,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits,
             service_fee,
             refund_total_unit,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             refund_profits,
             refund_service_fee,
             up_many_face,
             up_many_amount,
             snap_time,
             statistics_type,
             channel_name,
             account_name,
             channel_source_system)
          values
            (seq_report_commi_profit_id.nextval,
             item.up_company_id,
             item.up_channel_no,
             item.up_account_id,
             pkg_channel_type.up_channel,
             item.business_type,
             item.bill_type,
             item.up_draw_unit,
             item.up_draw_face,
             item.up_draw_amount,
             item.up_real_amount,
             (trunc(item.up_draw_amount, 2) - trunc(item.up_real_amount, 2)),
             (item.settle_amount - item.up_real_amount),
             0,
             item.up_draw_unit_ref,
             item.up_draw_face_ref,
             item.up_draw_amount_ref,
             item.up_real_amount_ref,
             (trunc(item.up_draw_amount_ref, 2) -
             trunc(item.up_real_amount_ref, 2)),
             (item.settle_amount_ref - item.up_real_amount_ref),
             0,
             0,
             0,
             l_collect_date,
             l_statistics_type,
             l_channel_name,
             l_account_name,
             item.order_source);
        end if;

        commit;

      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_up', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');

    commit;
  end if;
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_up', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure ZHELP_COMMI_PROFIT_ALL
prompt =========================================
prompt
create or replace procedure fd_account.zhelp_commi_profit_all(v_start_date in varchar2,
                                                   v_end_date   in varchar2) as

  l_collect_date date;
begin
  l_collect_date := to_date(v_start_date, 'yyyymmddhh24miss');
  loop
    zreport_commi_profit_down(to_char(l_collect_date, 'yyyymmddhh24miss'));
    zreport_commi_profit_up(to_char(l_collect_date, 'yyyymmddhh24miss'));
    zreport_commi_profit_settle(to_char(l_collect_date, 'yyyymmddhh24miss'));
    l_collect_date := l_collect_date + 1;
    exit when l_collect_date > to_date(v_end_date, 'yyyymmddhh24miss');
  end loop;
end;
/

prompt
prompt Creating procedure ZHELP_CO_RECV_ADD
prompt ====================================
prompt
create or replace procedure fd_account.zhelp_co_recv_add(v_account_id number,
                                              v_amount     number,
                                              v_memo       varchar2,
                                              v_result     out varchar2) as
  --------------收款账户对冲平账-------------
  l_balance      number;
  l_owe_company  number;
  l_recv_company number;
begin
  ---1.锁对冲的账户
  select t.balance, t.owe_company, t.recv_company
    into l_balance, l_owe_company, l_recv_company
    from fd_base_company_account_recv t
   where t.account_id = v_account_id
     for update;

  ---3.修改账户余额
  update fd_base_company_account_recv t
     set t.balance =
         (l_balance + v_amount)
   where t.account_id = v_account_id;

  ---4.添加平账记录
  insert into fd_trade_co_recv_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     handle_user,
     remark)
  values
    (seq_trade_co_recv_fund_id.nextval,
     v_account_id,
     v_amount,
     pkg_co_fund_recv_type.add_amount,
     (l_balance + v_amount),
     sysdate,
     0,
     0,
     0,
     'wanghj',
     'yepz:' || v_memo);

  v_result := pkg_error_code.success;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELP_CO_RECV_ADJUST
prompt =======================================
prompt
create or replace procedure fd_account.zhelp_co_recv_adjust(v_account_id_1 number,
                                                 v_account_id_2 number,
                                                 v_amount       number,
                                                 v_memo         varchar2,
                                                 v_result       out varchar2) as
  --------------收款账户对冲平账-------------
  l_balance_1      number;
  l_owe_company_1  number;
  l_recv_company_1 number;
  l_balance_2      number;
  l_owe_company_2  number;
  l_recv_company_2 number;
begin
  ---1.锁对冲的账户
  select t.balance, t.owe_company, t.recv_company
    into l_balance_1, l_owe_company_1, l_recv_company_1
    from fd_base_company_account_recv t
   where t.account_id = v_account_id_1
     for update;

  select t.balance, t.owe_company, t.recv_company
    into l_balance_2, l_owe_company_2, l_recv_company_2
    from fd_base_company_account_recv t
   where t.account_id = v_account_id_2
     for update;

  ---2.检查对冲账户
  if l_owe_company_1 != l_recv_company_2 or
     l_recv_company_1 != l_owe_company_2 then
    v_result := pkg_error_code.data_error;
    return;
  end if;

  ---3.修改账户余额
  update fd_base_company_account_recv t
     set t.balance = (l_balance_1 + v_amount)
   where t.account_id = v_account_id_1;

  update fd_base_company_account_recv t
     set t.balance = (l_balance_2 + v_amount)
   where t.account_id = v_account_id_2;

  ---4.添加平账记录
  insert into fd_trade_co_recv_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     handle_user,
     remark)
  values
    (seq_trade_co_recv_fund_id.nextval,
     v_account_id_1,
     v_amount,
     pkg_co_fund_recv_type.add_amount,
     (l_balance_1 + v_amount),
     sysdate,
     0,
     0,
     0,
     'wanghj',
     v_memo);

  insert into fd_trade_co_recv_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     handle_user,
     remark)
  values
    (seq_trade_co_recv_fund_id.nextval,
     v_account_id_2,
     v_amount,
     pkg_co_fund_recv_type.add_amount,
     (l_balance_2 + v_amount),
     sysdate,
     0,
     0,
     0,
     'wanghj',
     v_memo);

  v_result := pkg_error_code.success;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELP_DK_DOWN_CHANNEL_ADD
prompt ============================================
prompt
create or replace procedure fd_account.zhelp_dk_down_channel_add(v_down_channel_no varchar2,
                                                      v_down_account_id number,
                                                      v_add_amount      number,
                                                      v_user            varchar2,
                                                      v_memo            varchar2,
                                                      v_result          out varchar2) as
  ----------------下游渠道合并，渠道账户无关联加款--------------
  l_inner_balance number;
  l_trade_fund_id number;
begin
  ---1.锁账户
  select t.inner_balance
    into l_inner_balance
    from dk_base_down_account t
   where t.account_id = v_down_account_id
     for update;

  ---2.修改账户余额
  update dk_base_down_account t
     set t.inner_balance  = (l_inner_balance + v_add_amount),
         t.last_edit_user = v_user,
         t.last_edit_time = sysdate
   where t.account_id = v_down_account_id;

  ---3.下游手工记录添加
  select seq_trade_down_fund_id.nextval into l_trade_fund_id from dual;

  insert into dk_trade_down_settle
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo)
  values
    (l_trade_fund_id,
     v_down_channel_no,
     v_down_account_id,
     0,
     0,
     pkg_down_manual_change_type.add_amount,
     v_add_amount,
     sysdate,
     (l_inner_balance + v_add_amount),
     v_user,
     v_memo);

  ---4.下游资金变动添加
  insert into dk_trade_down_fund
    (record_id,
     dk_order_id,
     channel_no,
     account_id,
     change_type,
     change_amount,
     balance,
     memo)
  values
    (l_trade_fund_id,
     0,
     v_down_channel_no,
     v_down_account_id,
     pkg_down_fund_change_type.add_amount,
     v_add_amount,
     (l_inner_balance + v_add_amount),
     v_memo);

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELP_DK_DOWN_COMMI_ADD
prompt ==========================================
prompt
create or replace procedure fd_account.zhelp_dk_down_commi_add(v_channel_no varchar2,
                                                    v_add_amount number,
                                                    v_memo       varchar2,
                                                    v_result     out varchar2) as

  l_commi_balance number;
  l_company_id    number;
  l_channel_name  varchar2(100);
begin
  ---1.锁渠道佣金账户
  select t.commi_balance, t.channel_name, t.company_id
    into l_commi_balance, l_channel_name, l_company_id
    from dk_base_down_channel t
   where t.channel_no = v_channel_no
     for update;

  ---2.修改佣金期初余额
  update dk_base_down_channel t
     set t.commi_balance = (l_commi_balance + v_add_amount)
   where t.channel_no = v_channel_no;

  ---3.添加期初余额记录
  insert into dk_trade_commission_settle
    (report_id,
     channel_no,
     channel_type,
     commission,
     settle_month,
     settle_status,
     settle_user,
     settle_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     settle_type,
     commi_balance,
     memo)
  values
    (seq_trade_commission_settle_id.nextval,
     v_channel_no,
     2,
     v_add_amount,
     trunc(sysdate, 'mm'),
     0,
     'wanghj',
     sysdate,
     0,
     0,
     0,
     3, --佣金加款
     (l_commi_balance + v_add_amount),
     'yepz:' ||v_memo);

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELP_DOWN_COMMI_ADD
prompt =======================================
prompt
create or replace procedure fd_account.zhelp_down_commi_add(v_channel_no varchar2,
                                                 v_add_amount number,
                                                 v_memo       varchar2,
                                                 v_result     out varchar2) as

  l_commi_balance number;
  l_company_id    number;
  l_channel_name  varchar2(100);
begin
  ---1.锁渠道佣金账户
  select t.commi_balance, t.channel_name, t.company_id
    into l_commi_balance, l_channel_name, l_company_id
    from fd_base_down_channel t
   where t.channel_no = v_channel_no
     for update;

  ---2.修改佣金余额
  update fd_base_down_channel t
     set t.commi_balance =
         (l_commi_balance + v_add_amount)
   where t.channel_no = v_channel_no;

  ---3.添加余额记录
  insert into fd_trade_commission_settle
    (report_id,
     channel_no,
     channel_type,
     commission,
     settle_month,
     settle_status,
     settle_user,
     settle_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     settle_type,
     commi_balance,
     memo)
  values
    (seq_trade_commission_settle_id.nextval,
     v_channel_no,
     2,
     v_add_amount,
     trunc(sysdate, 'mm'),
     0,
     'wanghj',
     sysdate,
     0,
     0,
     0,
     3, --佣金加款
     (l_commi_balance + v_add_amount),
     'yepz:' || v_memo);

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELP_DOWN_COMMI_START_SET
prompt =============================================
prompt
create or replace procedure fd_account.zhelp_down_commi_start_set(v_channel_no        varchar2,
                                                       v_set_start_balance number,
                                                       v_sys_start_balance number,
                                                       v_memo              varchar2,
                                                       v_result            out varchar2) as
  -----------------------下游佣金6.1初始化金额修改----------------------
  ---一定要删除6.1原来的记录与6.1零点余额
  l_commi_balance number;
  l_channel_name  varchar2(100);
  l_company_id    number;
  v_start_differ  number;
begin
  ---1.求出当前要设置的佣金期初余额与系统期初余额差异
  v_start_differ := v_set_start_balance - v_sys_start_balance;

  ---2.锁渠道佣金账户
  select t.commi_balance, t.channel_name, t.company_id
    into l_commi_balance, l_channel_name, l_company_id
    from fd_base_down_channel t
   where t.channel_no = v_channel_no
     for update;

  ---3.修改佣金期初余额
  update fd_base_down_channel t
     set t.commi_balance = (l_commi_balance + v_start_differ)
   where t.channel_no = v_channel_no;

  ---4.添加期初余额记录
  insert into fd_trade_commission_settle
    (report_id,
     channel_no,
     channel_type,
     commission,
     settle_month,
     settle_status,
     settle_user,
     settle_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     settle_type,
     commi_balance,
     memo)
  values
    (seq_trade_commission_settle_id.nextval,
     v_channel_no,
     2,
     v_set_start_balance, ---期初佣金
     to_date('20160601', 'yyyymmdd'), --期初时间
     0,
     'wanghj',
     to_date('20160601', 'yyyymmdd'),
     0,
     0,
     0,
     3, --佣金加款
     v_set_start_balance,
     v_memo);

  ---5.修改渠道对应的所有佣金记录
  update fd_trade_commission_settle t
     set t.commi_balance = (t.commi_balance + v_start_differ)
   where t.channel_no = v_channel_no
     and t.settle_time > to_date('20160601', 'yyyymmdd');

  ---6.修改佣金零点余额
  update fd_report_zero_balance t
     set t.balance = (t.balance + v_start_differ)
   where t.record_date > to_date('20160601', 'yyyymmdd')
     and t.channel_no = v_channel_no
     and t.account_type = 10; ---上游佣金账户

  ---7.添加6.1零点余额
  insert into fd_report_zero_balance
    (record_id,
     record_date,
     created_time,
     account_type,
     account_id,
     channel_no,
     balance,
     account_name,
     channel_name,
     query_balance,
     channel_status,
     account_status,
     company_id,
     down_first_face,
     down_first_amount)
  values
    (seq_report_zero_balance_id.nextval,
     to_date('20160601', 'yyyymmdd'),
     to_date('20160602', 'yyyymmdd'),
     9,
     0,
     v_channel_no,
     v_set_start_balance,
     '-',
     l_channel_name,
     0,
     0,
     0,
     l_company_id,
     0,
     0);

  v_result := pkg_error_code.success;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELP_MANUAL_UP_RV_SETTLE
prompt ============================================
prompt
create or replace procedure fd_account.zhelp_manual_up_rv_settle(v_down_company_id in number, ---下游公司编号
                                                      v_up_company_id   in number, ---上游公司编号
                                                      v_up_channel_no   in varchar2, ---上游渠道
                                                      v_up_account_id   in number, ---上游账户
                                                      v_down_channel_no in varchar2, ---下游渠道
                                                      v_down_account_id in number, ---下游账户
                                                      v_business_type   in number, ---业务类型
                                                      v_bill_type       in number, ---交易类型，1前向，2后向
                                                      v_settle_amount   in number, ---结算金额
                                                      v_memo            in varchar2, ---备注
                                                      v_change_time     in varchar2 default null, ---记录变动时间
                                                      v_result          out varchar2) as
  --------------------公司间结算平账-----------------------
  l_change_date date := to_date(v_change_time, 'yyyymmddhh24miss');
begin
  ---1.获取平账时间
  if l_change_date is null then
    l_change_date := sysdate;
  end if;

  ---2.添加上游公司间结算平账记录
  insert into fd_trade_up_fund
    (record_id,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_amount,
     down_real_amount,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     balance,
     profits,
     down_commission,
     up_commission,
     settle_amount,
     settle_status,
     settle_time,
     memo)
  values
    (seq_trade_up_fund_id.nextval,
     v_down_channel_no,
     v_down_account_id,
     v_down_company_id,
     v_up_channel_no,
     v_up_account_id,
     v_up_company_id,
     0,
     0,
     0,
     0,
     l_change_date,
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     v_business_type,
     0,
     0,
     0,
     0,
     v_settle_amount,
     0,
     l_change_date,
     v_memo);

  v_result := pkg_error_code.success;
  commit;

exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
    fd_p_write_log('zhelp_manual_up_rv_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure ZHELP_TRADE_TIME_ALL_ADJUST
prompt ==============================================
prompt
create or replace procedure fd_account.zhelp_trade_time_all_adjust(v_down_channel_no varchar2,
                                                        v_up_channel_no   varchar2,
                                                        v_down_draw       number,
                                                        v_down_real       number,
                                                        v_up_draw         number,
                                                        v_up_real         number,
                                                        v_bill_type       number,
                                                        v_business_type   number,
                                                        v_memo            varchar2,
                                                        v_user            varchar2,
                                                        v_result          out varchar2) as
  --------------------包含上下游信息的上游交易记录平账，就是包含上游信息的时间差处理--------------------

  l_down_account_id number;
  l_down_company_id number;
  l_up_account_id   number;
  l_up_company_id   number;
  l_up_fund_id      number;
begin

  ---  JYSJC   作为查找记录标志
  ---公式：期初+加款-扣款-期末=交易时间差
  ---    :期初+加款-(扣款+交易时间差）-期末=0
  ---所以需要在上游资金变动中补上金额为“交易时间差”的扣款记录

  ---1.获取下游渠道账户公司信息
  select t.account_id, c.company_id
    into l_down_account_id, l_down_company_id
    from fd_base_down_account_map t
   inner join fd_base_down_channel c
      on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and rownum <= 1;

  ---2.获取上游渠道账户公司信息
  select t.account_id, c.company_id
    into l_up_account_id, l_up_company_id
    from fd_base_up_account_map t
   inner join fd_base_up_channel c
      on t.channel_no = c.channel_no
   where t.channel_no = v_up_channel_no
     and rownum <= 1;

  ---3.添加下游人工操作记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo,
     real_amount)
  values
    (seq_trade_down_fund_id.nextval,
     v_down_channel_no,
     l_down_account_id,
     0,
     0,
     pkg_down_manual_change_type.trade_revise,
     v_down_draw,
     sysdate,
     0,
     v_user,
     '消除时间差记录,不影响余额:' || v_memo,
     v_down_real);

  ---4.添加上游人工操作记录
  select seq_trade_up_fund_id.nextval into l_up_fund_id from dual;

  insert into fd_trade_up_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     manual_change_type,
     change_amount,
     change_time,
     balance,
     memo,
     create_user,
     has_adjust,
     real_amount)
  values
    (l_up_fund_id,
     v_up_channel_no,
     l_up_account_id,
     0,
     pkg_up_manual_change_type.trade_revise,
     v_up_draw,
     sysdate,
     0,
     '消除时间差记录,不影响余额:' || v_memo,
     v_user,
     0,
     v_up_real);

  ---5.补上游扣款中缺失的部分扣款内容
  insert into fd_trade_up_fund
    (record_id,
     trade_order_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_amount,
     down_real_amount,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     balance,
     memo)
  values
    (l_up_fund_id,
     'JYSJC' || to_char(sysdate, 'yyyymmddhh24miss'),
     v_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     v_up_channel_no,
     l_up_account_id,
     l_up_company_id,
     v_down_draw,
     v_down_real,
     v_up_draw,
     v_up_real,
     sysdate,
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     v_business_type,
     0,
     v_memo);

  if sql%rowcount != 1 then
    rollback;
    v_result := pkg_error_code.data_error;
    return;
  end if;

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELP_TRADE_TIME_DIFFER_ADJUST
prompt =================================================
prompt
create or replace procedure fd_account.zhelp_trade_time_differ_adjust(v_down_channel_no  varchar2,
                                                           v_add_debit_amount number,
                                                           v_bill_type        number,
                                                           v_business_type    number,
                                                           v_memo             varchar2,
                                                           v_result           out varchar2) as
  --------------------交易时间差平账，使交易时间差为0--------------------

  l_down_account_id number;
  l_down_company_id number;

begin

  ---  JYSJC   作为查找记录标志
  ---公式：期初+加款-扣款-期末=交易时间差
  ---    :期初+加款-(扣款+交易时间差）-期末=0
  ---所以需要在上游资金变动中补上金额为“交易时间差”的扣款记录

  ---下游扣款不退款情况，需要在上游资金变动补上“下游扣款金额”的扣款记录

  ---1.获取渠道账户公司信息
  select t.account_id, c.company_id
    into l_down_account_id, l_down_company_id
    from fd_base_down_account_map t
   inner join fd_base_down_channel c
      on t.channel_no = c.channel_no
   where t.channel_no = v_down_channel_no
     and rownum <= 1;

  ---2.添加消除时间差人工操作记录
  insert into fd_trade_down_manual
    (record_id,
     channel_no,
     account_id,
     adjust_id,
     has_adjust,
     add_type,
     change_amount,
     change_time,
     balance,
     create_user,
     memo,
     real_amount)
  values
    (seq_trade_down_fund_id.nextval,
     v_down_channel_no,
     l_down_account_id,
     0,
     0,
     pkg_down_manual_change_type.trade_revise,
     v_add_debit_amount,
     sysdate,
     0,
     '-',
     '消除时间差记录,不影响余额:' || v_memo,
     v_add_debit_amount);

  ---3.添加消除时间差扣款记录
  insert into fd_trade_up_fund
    (record_id,
     trade_order_no,
     down_channel_no,
     down_account_id,
     down_company_id,
     up_channel_no,
     up_account_id,
     up_company_id,
     down_draw_amount,
     down_real_amount,
     up_draw_amount,
     up_real_amount,
     change_time,
     change_type,
     bill_type,
     business_type,
     balance,
     memo)
  values
    (seq_trade_up_fund_id.nextval,
     'JYSJC' || to_char(sysdate, 'yyyymmddhh24miss'),
     v_down_channel_no,
     l_down_account_id,
     l_down_company_id,
     '0',
     0,
     l_down_company_id,
     v_add_debit_amount,
     v_add_debit_amount,
     0,
     0,
     sysdate,
     pkg_up_fund_change_type.debit_amount,
     v_bill_type,
     v_business_type,
     0,
     v_memo);

  if sql%rowcount != 1 then
    rollback;
    v_result := pkg_error_code.data_error;
    return;
  end if;

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELP_TRANSFER_REFUND_ADJUST
prompt ===============================================
prompt
create or replace procedure fd_account.zhelp_transfer_refund_adjust(v_account_id    number,
                                                         v_right_balance number,
                                                         v_sys_balance   number,
                                                         v_memo          varchar2,
                                                         v_result        out varchar2) as
  l_balance_differ number;
  l_cap_balance    number;
begin
  ---1.计算余额差异
  l_balance_differ := v_right_balance - v_sys_balance;

  ---2.锁转账退款账户
  select t.balance
    into l_cap_balance
    from fd_base_company_account_cap t
   where t.account_id = v_account_id
     and t.account_type in (8, 10)
     for update;

  ---3.转账退款账户加款
  update fd_base_company_account_cap t
     set t.balance =
         (l_cap_balance + l_balance_differ)
   where t.account_id = v_account_id;

  ---4.添加转账退款加款记录
  insert into fd_trade_co_cap_fund
    (change_id,
     account_id,
     change_amount,
     change_type,
     balance,
     change_time,
     adjust_id,
     has_adjust,
     memo,
     create_user)
  values
    (seq_trade_co_cap_fund_id.nextval,
     v_account_id,
     l_balance_differ,
     pkg_co_cap_fund_type.add_amount,
     (l_cap_balance + l_balance_differ),
     sysdate,
     0,
     0,
     'yepz:' || v_memo,
     'wanghj');

  v_result := pkg_error_code.success;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELP_UP_COMMI_ADD
prompt =====================================
prompt
create or replace procedure fd_account.zhelp_up_commi_add(v_channel_no varchar2,
                                               v_add_amount number,
                                               v_memo       varchar2,
                                               v_result     out varchar2) as

  l_commi_balance number;
  l_company_id    number;
  l_channel_name  varchar2(100);
begin
  ---1.锁渠道佣金账户
  select t.commi_balance, t.channel_name, t.company_id
    into l_commi_balance, l_channel_name, l_company_id
    from fd_base_up_channel t
   where t.channel_no = v_channel_no
     for update;

  ---2.修改佣金期初余额
  update fd_base_up_channel t
     set t.commi_balance = (l_commi_balance + v_add_amount)
   where t.channel_no = v_channel_no;

  ---3.添加期初余额记录
  insert into fd_trade_commission_settle
    (report_id,
     channel_no,
     channel_type,
     commission,
     settle_month,
     settle_status,
     settle_user,
     settle_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     settle_type,
     commi_balance,
     memo)
  values
    (seq_trade_commission_settle_id.nextval,
     v_channel_no,
     1,
     v_add_amount,
     trunc(sysdate, 'mm'),
     0,
     'wanghj',
     sysdate,
     0,
     0,
     0,
     3, --佣金加款
     (l_commi_balance + v_add_amount),
     'yepz:' ||v_memo);

  v_result := pkg_error_code.success;
  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZHELP_UP_COMMI_START_SET
prompt ===========================================
prompt
create or replace procedure fd_account.zhelp_up_commi_start_set(v_channel_no        varchar2,
                                                     v_set_start_balance number,
                                                     v_sys_start_balance number,
                                                     v_memo              varchar2,
                                                     v_result            out varchar2) as
  -----------------------上游佣金6.1初始化金额修改----------------------
  ---一定要删除6.1原来的记录与6.1零点余额
  l_commi_balance number;
  l_channel_name  varchar2(100);
  l_company_id    number;
  v_start_differ  number;
begin
  ---1.求出当前要设置的佣金期初余额与系统期初余额差异
  v_start_differ := v_set_start_balance - v_sys_start_balance;

  ---2.锁渠道佣金账户
  select t.commi_balance, t.channel_name, t.company_id
    into l_commi_balance, l_channel_name, l_company_id
    from fd_base_up_channel t
   where t.channel_no = v_channel_no
     for update;

  ---3.修改佣金期初余额
  update fd_base_up_channel t
     set t.commi_balance = (l_commi_balance + v_start_differ)
   where t.channel_no = v_channel_no;

  ---4.添加期初余额记录
  insert into fd_trade_commission_settle
    (report_id,
     channel_no,
     channel_type,
     commission,
     settle_month,
     settle_status,
     settle_user,
     settle_time,
     has_adjust,
     adjust_id,
     bank_batch_id,
     settle_type,
     commi_balance,
     memo)
  values
    (seq_trade_commission_settle_id.nextval,
     v_channel_no,
     1,
     v_set_start_balance, ---期初佣金
     to_date('20160601', 'yyyymmdd'), --期初时间
     0,
     'wanghj',
     to_date('20160601', 'yyyymmdd'),
     0,
     0,
     0,
     3, --佣金加款
     v_set_start_balance,
     v_memo);

  ---5.修改渠道对应的所有佣金记录
  update fd_trade_commission_settle t
     set t.commi_balance = (t.commi_balance + v_start_differ)
   where t.channel_no = v_channel_no
     and t.settle_time > to_date('20160601', 'yyyymmdd');

  ---6.修改佣金零点余额
  update fd_report_zero_balance t
     set t.balance = (t.balance + v_start_differ)
   where t.record_date > to_date('20160601', 'yyyymmdd')
     and t.channel_no = v_channel_no
     and t.account_type = 10; ---上游佣金账户

  ---7.添加6.1零点余额
  insert into fd_report_zero_balance
    (record_id,
     record_date,
     created_time,
     account_type,
     account_id,
     channel_no,
     balance,
     account_name,
     channel_name,
     query_balance,
     channel_status,
     account_status,
     company_id,
     down_first_face,
     down_first_amount)
  values
    (seq_report_zero_balance_id.nextval,
     to_date('20160601', 'yyyymmdd'),
     to_date('20160602', 'yyyymmdd'),
     10,
     0,
     v_channel_no,
     v_set_start_balance,
     '-',
     l_channel_name,
     0,
     0,
     0,
     l_company_id,
     0,
     0);

  v_result := pkg_error_code.success;

  commit;
exception
  when others then
    rollback;
    v_result := pkg_error_code.system_busy;
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_ALL
prompt ===========================================
prompt
create or replace procedure fd_account.zreport_commi_profit_all(v_start_date in varchar2,
                                                   v_end_date   in varchar2) as

  l_collect_date date;
begin
  l_collect_date := to_date(v_start_date, 'yyyymmddhh24miss');
  loop
    zreport_commi_profit_down(to_char(l_collect_date, 'yyyymmddhh24miss'));
    zreport_commi_profit_up(to_char(l_collect_date, 'yyyymmddhh24miss'));
    zreport_commi_profit_settle(to_char(l_collect_date, 'yyyymmddhh24miss'));
    l_collect_date := l_collect_date + 1;
    exit when l_collect_date > to_date(v_end_date, 'yyyymmddhh24miss');
  end loop;
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_DOWN_AB
prompt ===============================================
prompt
create or replace procedure fd_account.zreport_commi_profit_down_ab(v_collect_date in varchar2 default null) as
  --------------------收集下游资金变动佣金利润信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160602000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type number := 0; --数据出现错误，统计类型为0
  l_wait_count      number := 0;
  l_start_time      date := sysdate;
  l_channel_name    varchar2(100);
  l_account_name    varchar2(100);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  /*select count(1)
    into l_wait_count
    from up_fund_160818_23 t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then
  
    ---1.收集上游资金变动信息
    for item in (select m.down_company_id,
                        m.down_channel_no,
                        m.down_account_id,
                        m.business_type,
                        m.bill_type,
                        m.order_source,
                        (m.down_draw_unit + nvl(f.down_adjust_unit, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_unit, 0)) down_draw_unit,
                        (m.down_draw_face + nvl(f.down_adjust_face, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_face, 0)) down_draw_face,
                        (m.down_draw_amount + nvl(f.down_adjust_amount, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_amount, 0)) down_draw_amount,
                        (m.down_real_amount + nvl(f.down_adjust_real, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_real, 0)) down_real_amount,
                        m.settle_amount,
                        m.down_draw_unit_ref,
                        m.down_draw_face_ref,
                        m.down_draw_amount_ref,
                        m.down_real_amount_ref,
                        m.settle_amount_ref,
                        nvl(f.up_many_face, 0) up_many_face,
                        nvl(f.up_many_amount, 0) up_many_amount
                   from (select u.down_company_id,
                                u.down_channel_no,
                                u.down_account_id,
                                u.business_type,
                                u.bill_type,
                                max(u.order_source) order_source,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_unit) down_draw_unit,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_face) down_draw_face,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_amount) down_draw_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_real_amount) down_real_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           decode(u.down_company_id,
                                                  u.up_company_id,
                                                  u.up_real_amount,
                                                  decode(u.settle_amount,
                                                         0,
                                                         u.up_real_amount,
                                                         u.settle_amount)),
                                           0)) settle_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_unit) down_draw_unit_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_face) down_draw_face_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_amount) down_draw_amount_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_real_amount) down_real_amount_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           decode(u.down_company_id,
                                                  u.up_company_id,
                                                  u.up_real_amount,
                                                  decode(u.settle_amount,
                                                         0,
                                                         u.up_real_amount,
                                                         u.settle_amount)))) settle_amount_ref
                           from up_fund_160818_23 u
                          where u.change_time >= l_collect_date
                            and u.change_time < (l_collect_date + 1)
                            and (u.change_type =
                                pkg_up_fund_change_type.debit_amount or
                                u.change_type =
                                pkg_up_fund_change_type.refund_amount)
                          group by u.down_company_id,
                                   u.down_channel_no,
                                   u.down_account_id,
                                   u.business_type,
                                   u.bill_type) m
                   left join (select d.channel_no,
                                    d.account_id,
                                    d.business_type,
                                    d.bill_type,
                                    sum(d.down_adjust_face) down_adjust_face,
                                    sum(d.down_adjust_unit) down_adjust_unit,
                                    sum(d.down_adjust_amount) down_adjust_amount,
                                    sum(d.down_adjust_real) down_adjust_real,
                                    sum(d.up_many_face) up_many_face,
                                    sum(d.up_many_amount) up_many_amount
                               from fd_trade_up_fund_differ d
                              where d.record_date = l_collect_date
                              group by d.channel_no,
                                       d.account_id,
                                       d.business_type,
                                       d.bill_type) f on m.down_channel_no =
                                                         f.channel_no
                                                     and m.down_account_id =
                                                         f.account_id
                                                     and m.business_type =
                                                         f.business_type
                                                     and m.bill_type =
                                                         f.bill_type
                   left join (select r.channel_no,
                                    r.account_id,
                                    r.business_type,
                                    sum(r.to_front_face) to_front_face,
                                    sum(r.to_front_unit) to_front_unit,
                                    sum(r.to_front_amount) to_front_amount,
                                    sum(r.to_front_real) to_front_real
                               from fd_trade_up_fund_differ r
                              where r.record_date = l_collect_date
                              group by r.channel_no,
                                       r.account_id,
                                       r.business_type) fr on m.down_channel_no =
                                                              fr.channel_no
                                                          and m.down_account_id =
                                                              fr.account_id
                                                          and m.business_type =
                                                              fr.business_type) loop
      begin
        ---2.添加下游佣金利润数据
        if item.down_channel_no != '0' and item.down_account_id != 0 then
          --3.计算统计类型
          l_statistics_type := 0;
          if item.bill_type = pkg_bill_type.back then
          
            l_statistics_type := pkg_statistics_type.FlowBag;
          else
            --***从业务类型与分类表中获取分类***
            select t.statistics_type
              into l_statistics_type
              from fd_system_business_statis_map t
             where t.local_business_type = item.business_type
               and rownum <= 1;
          end if;
        
          ---4.获取渠道账户名称
          select t.channel_name
            into l_channel_name
            from fd_base_down_channel t
           where t.channel_no = item.down_channel_no;
        
          select t.account_name
            into l_account_name
            from fd_base_down_account t
           where t.account_id = item.down_account_id;
        
          --5.添加数据
          insert into fd_report_commi_profit_redo
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_unit,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits,
             service_fee,
             refund_total_unit,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             refund_profits,
             refund_service_fee,
             up_many_face,
             up_many_amount,
             snap_time,
             statistics_type,
             channel_name,
             account_name,
             channel_source_system)
          values
            (seq_report_commi_profit_id.nextval,
             item.down_company_id,
             item.down_channel_no,
             item.down_account_id,
             pkg_channel_type.down_channel,
             item.business_type,
             item.bill_type,
             item.down_draw_unit,
             item.down_draw_face,
             item.down_draw_amount,
             item.down_real_amount,
             (trunc(item.down_draw_amount, 2) -
             trunc(item.down_real_amount, 2)),
             (item.down_real_amount - item.settle_amount),
             0,
             item.down_draw_unit_ref,
             item.down_draw_face_ref,
             item.down_draw_amount_ref,
             item.down_real_amount_ref,
             (trunc(item.down_draw_amount_ref, 2) -
             trunc(item.down_real_amount_ref, 2)),
             (item.down_real_amount_ref - item.settle_amount_ref),
             0,
             item.up_many_face,
             item.up_many_amount,
             l_collect_date,
             l_statistics_type,
             l_channel_name,
             l_account_name,
             item.order_source);
        end if;
      
        commit;
      
      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_down', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');
  
    commit;
  end if;*/
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_down', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_DOWN_HS
prompt ===============================================
prompt
create or replace procedure fd_account.zreport_commi_profit_down_hs(v_collect_date in varchar2 default null) as
  --------------------收集下游资金变动佣金利润信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160602000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type number := 0; --数据出现错误，统计类型为0
  l_wait_count      number := 0;
  l_start_time      date := sysdate;
  l_channel_name    varchar2(100);
  l_account_name    varchar2(100);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from fd_trade_up_fund_hs t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then

    ---1.收集上游资金变动信息
    for item in (select m.down_company_id,
                        m.down_channel_no,
                        m.down_account_id,
                        m.business_type,
                        m.bill_type,
                        m.order_source,
                        (m.down_draw_unit + nvl(f.down_adjust_unit, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_unit, 0)) down_draw_unit,
                        (m.down_draw_face + nvl(f.down_adjust_face, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_face, 0)) down_draw_face,
                        (m.down_draw_amount + nvl(f.down_adjust_amount, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_amount, 0)) down_draw_amount,
                        (m.down_real_amount + nvl(f.down_adjust_real, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_real, 0)) down_real_amount,
                        m.settle_amount,
                        m.down_draw_unit_ref,
                        m.down_draw_face_ref,
                        m.down_draw_amount_ref,
                        m.down_real_amount_ref,
                        m.settle_amount_ref,
                        nvl(f.up_many_face, 0) up_many_face,
                        nvl(f.up_many_amount, 0) up_many_amount
                   from (select u.down_company_id,
                                u.down_channel_no,
                                u.down_account_id,
                                u.business_type,
                                u.bill_type,
                                max(u.order_source) order_source,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_unit) down_draw_unit,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_face) down_draw_face,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_amount) down_draw_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_real_amount) down_real_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           decode(u.down_company_id,
                                                  u.up_company_id,
                                                  u.up_real_amount,
                                                  decode(u.settle_amount,
                                                         0,
                                                         u.up_real_amount,
                                                         u.settle_amount)),
                                           0)) settle_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_unit) down_draw_unit_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_face) down_draw_face_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_amount) down_draw_amount_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_real_amount) down_real_amount_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           decode(u.down_company_id,
                                                  u.up_company_id,
                                                  u.up_real_amount,
                                                  decode(u.settle_amount,
                                                         0,
                                                         u.up_real_amount,
                                                         u.settle_amount)))) settle_amount_ref
                           from fd_trade_up_fund_hs u
                          where u.change_time >= l_collect_date
                            and u.change_time < (l_collect_date + 1)
                            and (u.change_type =
                                pkg_up_fund_change_type.debit_amount or
                                u.change_type =
                                pkg_up_fund_change_type.refund_amount)
                          group by u.down_company_id,
                                   u.down_channel_no,
                                   u.down_account_id,
                                   u.business_type,
                                   u.bill_type) m
                   left join (select d.channel_no,
                                    d.account_id,
                                    d.business_type,
                                    d.bill_type,
                                    sum(d.down_adjust_face) down_adjust_face,
                                    sum(d.down_adjust_unit) down_adjust_unit,
                                    sum(d.down_adjust_amount) down_adjust_amount,
                                    sum(d.down_adjust_real) down_adjust_real,
                                    sum(d.up_many_face) up_many_face,
                                    sum(d.up_many_amount) up_many_amount
                               from fd_trade_up_fund_differ d
                              where d.record_date = l_collect_date
                              group by d.channel_no,
                                       d.account_id,
                                       d.business_type,
                                       d.bill_type) f on m.down_channel_no =
                                                         f.channel_no
                                                     and m.down_account_id =
                                                         f.account_id
                                                     and m.business_type =
                                                         f.business_type
                                                     and m.bill_type =
                                                         f.bill_type
                   left join (select r.channel_no,
                                    r.account_id,
                                    r.business_type,
                                    sum(r.to_front_face) to_front_face,
                                    sum(r.to_front_unit) to_front_unit,
                                    sum(r.to_front_amount) to_front_amount,
                                    sum(r.to_front_real) to_front_real
                               from fd_trade_up_fund_differ r
                              where r.record_date = l_collect_date
                              group by r.channel_no,
                                       r.account_id,
                                       r.business_type) fr on m.down_channel_no =
                                                              fr.channel_no
                                                          and m.down_account_id =
                                                              fr.account_id
                                                          and m.business_type =
                                                              fr.business_type) loop
      begin
        ---2.添加下游佣金利润数据
        if item.down_channel_no != '0' and item.down_account_id != 0 then
          --3.计算统计类型
          l_statistics_type := 0;
          if item.bill_type = pkg_bill_type.back then

            l_statistics_type := pkg_statistics_type.FlowBag;
          else
            --***从业务类型与分类表中获取分类***
            select t.statistics_type
              into l_statistics_type
              from fd_system_business_statis_map t
             where t.local_business_type = item.business_type
               and rownum <= 1;
          end if;

          ---4.获取渠道账户名称
          select t.channel_name
            into l_channel_name
            from fd_base_down_channel t
           where t.channel_no = item.down_channel_no;

          select t.account_name
            into l_account_name
            from fd_base_down_account t
           where t.account_id = item.down_account_id;

          --5.添加数据
          insert into fd_report_commi_profit_redo
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_unit,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits,
             service_fee,
             refund_total_unit,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             refund_profits,
             refund_service_fee,
             up_many_face,
             up_many_amount,
             snap_time,
             statistics_type,
             channel_name,
             account_name,
             channel_source_system)
          values
            (seq_report_commi_profit_id.nextval,
             item.down_company_id,
             item.down_channel_no,
             item.down_account_id,
             pkg_channel_type.down_channel,
             item.business_type,
             item.bill_type,
             item.down_draw_unit,
             item.down_draw_face,
             item.down_draw_amount,
             item.down_real_amount,
             (trunc(item.down_draw_amount, 2) -
             trunc(item.down_real_amount, 2)),
             (item.down_real_amount - item.settle_amount),
             0,
             item.down_draw_unit_ref,
             item.down_draw_face_ref,
             item.down_draw_amount_ref,
             item.down_real_amount_ref,
             (trunc(item.down_draw_amount_ref, 2) -
             trunc(item.down_real_amount_ref, 2)),
             (item.down_real_amount_ref - item.settle_amount_ref),
             0,
             item.up_many_face,
             item.up_many_amount,
             l_collect_date,
             l_statistics_type,
             l_channel_name,
             l_account_name,
             item.order_source);
        end if;

        commit;

      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_down', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');

    commit;
  end if;
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_down', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_DOWN_JI
prompt ===============================================
prompt
create or replace procedure fd_account.zreport_commi_profit_down_ji(v_collect_date in varchar2 default null) as
  --------------------收集下游资金变动佣金利润信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160602000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type number := 0; --数据出现错误，统计类型为0
  l_wait_count      number := 0;
  l_start_time      date := sysdate;
  l_channel_name    varchar2(100);
  l_account_name    varchar2(100);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from fd_trade_up_fund_hs t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then

    ---1.收集上游资金变动信息
    for item in (select m.down_company_id,
                        m.down_channel_no,
                        m.down_account_id,
                        m.business_type,
                        m.bill_type,
                        m.order_source,
                        (m.down_draw_unit + nvl(f.down_adjust_unit, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_unit, 0)) down_draw_unit,
                        (m.down_draw_face + nvl(f.down_adjust_face, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_face, 0)) down_draw_face,
                        (m.down_draw_amount + nvl(f.down_adjust_amount, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_amount, 0)) down_draw_amount,
                        (m.down_real_amount + nvl(f.down_adjust_real, 0) +
                        decode(m.bill_type, 1, 1, -1) *
                        nvl(fr.to_front_real, 0)) down_real_amount,
                        m.settle_amount,
                        m.down_draw_unit_ref,
                        m.down_draw_face_ref,
                        m.down_draw_amount_ref,
                        m.down_real_amount_ref,
                        m.settle_amount_ref,
                        nvl(f.up_many_face, 0) up_many_face,
                        nvl(f.up_many_amount, 0) up_many_amount
                   from (select u.down_company_id,
                                u.down_channel_no,
                                u.down_account_id,
                                u.business_type,
                                u.bill_type,
                                max(u.order_source) order_source,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_unit) down_draw_unit,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_face) down_draw_face,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_draw_amount) down_draw_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           1,
                                           0) * u.down_real_amount) down_real_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           decode(u.down_company_id,
                                                  u.up_company_id,
                                                  u.up_real_amount,
                                                  decode(u.settle_amount,
                                                         0,
                                                         u.up_real_amount,
                                                         u.settle_amount)),
                                           0)) settle_amount,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_unit) down_draw_unit_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_face) down_draw_face_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_draw_amount) down_draw_amount_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           1) * u.down_real_amount) down_real_amount_ref,
                                sum(decode(u.change_type,
                                           pkg_up_fund_change_type.debit_amount,
                                           0,
                                           decode(u.down_company_id,
                                                  u.up_company_id,
                                                  u.up_real_amount,
                                                  decode(u.settle_amount,
                                                         0,
                                                         u.up_real_amount,
                                                         u.settle_amount)))) settle_amount_ref
                           from zreport_up_fund_join_hs u
                          where u.change_time >= l_collect_date
                            and u.change_time < (l_collect_date + 1)
                            and (u.change_type =
                                pkg_up_fund_change_type.debit_amount or
                                u.change_type =
                                pkg_up_fund_change_type.refund_amount)
                          group by u.down_company_id,
                                   u.down_channel_no,
                                   u.down_account_id,
                                   u.business_type,
                                   u.bill_type) m
                   left join (select d.channel_no,
                                    d.account_id,
                                    d.business_type,
                                    d.bill_type,
                                    sum(d.down_adjust_face) down_adjust_face,
                                    sum(d.down_adjust_unit) down_adjust_unit,
                                    sum(d.down_adjust_amount) down_adjust_amount,
                                    sum(d.down_adjust_real) down_adjust_real,
                                    sum(d.up_many_face) up_many_face,
                                    sum(d.up_many_amount) up_many_amount
                               from fd_trade_up_fund_differ d
                              where d.record_date = l_collect_date
                              group by d.channel_no,
                                       d.account_id,
                                       d.business_type,
                                       d.bill_type) f on m.down_channel_no =
                                                         f.channel_no
                                                     and m.down_account_id =
                                                         f.account_id
                                                     and m.business_type =
                                                         f.business_type
                                                     and m.bill_type =
                                                         f.bill_type
                   left join (select r.channel_no,
                                    r.account_id,
                                    r.business_type,
                                    sum(r.to_front_face) to_front_face,
                                    sum(r.to_front_unit) to_front_unit,
                                    sum(r.to_front_amount) to_front_amount,
                                    sum(r.to_front_real) to_front_real
                               from fd_trade_up_fund_differ r
                              where r.record_date = l_collect_date
                              group by r.channel_no,
                                       r.account_id,
                                       r.business_type) fr on m.down_channel_no =
                                                              fr.channel_no
                                                          and m.down_account_id =
                                                              fr.account_id
                                                          and m.business_type =
                                                              fr.business_type) loop
      begin
        ---2.添加下游佣金利润数据
        if item.down_channel_no != '0' and item.down_account_id != 0 then
          --3.计算统计类型
          l_statistics_type := 0;
          if item.bill_type = pkg_bill_type.back then

            l_statistics_type := pkg_statistics_type.FlowBag;
          else
            --***从业务类型与分类表中获取分类***
            select t.statistics_type
              into l_statistics_type
              from fd_system_business_statis_map t
             where t.local_business_type = item.business_type
               and rownum <= 1;
          end if;

          ---4.获取渠道账户名称
          select t.channel_name
            into l_channel_name
            from fd_base_down_channel t
           where t.channel_no = item.down_channel_no;

          select t.account_name
            into l_account_name
            from fd_base_down_account t
           where t.account_id = item.down_account_id;

          --5.添加数据
          insert into fd_report_commi_profit_redo
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_unit,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits,
             service_fee,
             refund_total_unit,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             refund_profits,
             refund_service_fee,
             up_many_face,
             up_many_amount,
             snap_time,
             statistics_type,
             channel_name,
             account_name,
             channel_source_system)
          values
            (seq_report_commi_profit_id.nextval,
             item.down_company_id,
             item.down_channel_no,
             item.down_account_id,
             pkg_channel_type.down_channel,
             item.business_type,
             item.bill_type,
             item.down_draw_unit,
             item.down_draw_face,
             item.down_draw_amount,
             item.down_real_amount,
             (trunc(item.down_draw_amount, 2) -
             trunc(item.down_real_amount, 2)),
             (item.down_real_amount - item.settle_amount),
             0,
             item.down_draw_unit_ref,
             item.down_draw_face_ref,
             item.down_draw_amount_ref,
             item.down_real_amount_ref,
             (trunc(item.down_draw_amount_ref, 2) -
             trunc(item.down_real_amount_ref, 2)),
             (item.down_real_amount_ref - item.settle_amount_ref),
             0,
             item.up_many_face,
             item.up_many_amount,
             l_collect_date,
             l_statistics_type,
             l_channel_name,
             l_account_name,
             item.order_source);
        end if;

        commit;

      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_down', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');

    commit;
  end if;
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_down', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_ST_AB
prompt =============================================
prompt
create or replace procedure fd_account.zreport_commi_profit_st_ab(v_collect_date in varchar2 default null) as
  --------------------收集上游资金变动结算信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160602000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type   number := 0; --数据出现错误，统计类型为0
  l_wait_count        number := 0;
  l_start_time        date := sysdate;
  l_down_company_name varchar2(128);
  l_up_company_name   varchar2(128);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  /*select count(1)
    into l_wait_count
    from up_fund_160818_23 t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then

    ---1.收集上游资金变动信息
    for item in (select u.down_company_id,
                        u.up_company_id,
                        u.bill_type,
                        u.business_type,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   u.up_draw_unit,
                                   0)) draw_unit,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   u.up_draw_face,
                                   0)) draw_face,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount),
                                   0)) draw_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount),
                                   0)) real_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   u.up_draw_unit)) unit_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   u.up_draw_face)) face_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount))) amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount))) real_ref
                   from up_fund_160818_23 u
                  where u.change_time >= l_collect_date
                    and u.change_time < (l_collect_date + 1)
                    and u.down_company_id != u.up_company_id
                    and u.down_company_id != 0
                    and u.up_company_id != 0
                    and (u.change_type =
                        pkg_up_fund_change_type.debit_amount or
                        u.change_type =
                        pkg_up_fund_change_type.refund_amount)
                  group by u.down_company_id,
                           u.up_company_id,
                           u.bill_type,
                           u.business_type) loop
      begin

        --2.计算统计类型
        l_statistics_type := 0;
        if item.bill_type = pkg_bill_type.back then

          l_statistics_type := pkg_statistics_type.FlowBag;
        else
          --***从业务类型与分类表中获取分类***
          select t.statistics_type
            into l_statistics_type
            from fd_system_business_statis_map t
           where t.local_business_type = item.business_type
             and rownum <= 1;
        end if;

        ---3.获取公司名称
        select t.sort_name
          into l_down_company_name
          from fd_base_company_info t
         where t.company_id = item.down_company_id;

        select t.sort_name
          into l_up_company_name
          from fd_base_company_info t
         where t.company_id = item.up_company_id;

        ---4.添加作为下游渠道的结算信息
        insert into fd_report_commi_profit_redo
          (record_id,
           company_id,
           channel_no,
           account_id,
           channel_type,
           business_type,
           bill_type,
           total_unit,
           total_face,
           draw_amount,
           real_amount,
           commission,
           profits,
           service_fee,
           refund_total_unit,
           refund_total_face,
           refund_draw_amount,
           refund_real_amount,
           refund_commission,
           refund_profits,
           refund_service_fee,
           up_many_face,
           up_many_amount,
           snap_time,
           statistics_type,
           channel_name,
           account_name)
        values
          (seq_report_commi_profit_id.nextval,
           item.up_company_id,
           '-',
           item.down_company_id,
           pkg_channel_type.settle_down,
           item.business_type,
           item.bill_type,
           item.draw_unit,
           item.draw_face,
           item.draw_amount,
           item.real_amount,
           0,
           0,
           0,
           item.unit_ref,
           item.face_ref,
           item.amount_ref,
           item.real_ref,
           0,
           0,
           0,
           0,
           0,
           l_collect_date,
           l_statistics_type,
           l_down_company_name,
           l_down_company_name);

        ---3.添加作为上游渠道的结算信息
        insert into fd_report_commi_profit_redo
          (record_id,
           company_id,
           channel_no,
           account_id,
           channel_type,
           business_type,
           bill_type,
           total_unit,
           total_face,
           draw_amount,
           real_amount,
           commission,
           profits,
           service_fee,
           refund_total_unit,
           refund_total_face,
           refund_draw_amount,
           refund_real_amount,
           refund_commission,
           refund_profits,
           refund_service_fee,
           up_many_face,
           up_many_amount,
           snap_time,
           statistics_type,
           channel_name,
           account_name)
        values
          (seq_report_commi_profit_id.nextval,
           item.down_company_id,
           '-',
           item.up_company_id,
           pkg_channel_type.settle_up,
           item.business_type,
           item.bill_type,
           item.draw_unit,
           item.draw_face,
           item.draw_amount,
           item.real_amount,
           0,
           0,
           0,
           item.unit_ref,
           item.face_ref,
           item.amount_ref,
           item.real_ref,
           0,
           0,
           0,
           0,
           0,
           l_collect_date,
           l_statistics_type,
           l_up_company_name,
           l_up_company_name);

        commit;

      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_settle', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');

    commit;
  end if;*/
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_ST_HS
prompt =============================================
prompt
create or replace procedure fd_account.zreport_commi_profit_st_hs(v_collect_date in varchar2 default null) as
  --------------------收集上游资金变动结算信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160602000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type   number := 0; --数据出现错误，统计类型为0
  l_wait_count        number := 0;
  l_start_time        date := sysdate;
  l_down_company_name varchar2(128);
  l_up_company_name   varchar2(128);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from fd_trade_up_fund_hs t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then

    ---1.收集上游资金变动信息
    for item in (select u.down_company_id,
                        u.up_company_id,
                        u.bill_type,
                        u.business_type,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   u.up_draw_unit,
                                   0)) draw_unit,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   u.up_draw_face,
                                   0)) draw_face,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount),
                                   0)) draw_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount),
                                   0)) real_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   u.up_draw_unit)) unit_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   u.up_draw_face)) face_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount))) amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount))) real_ref
                   from fd_trade_up_fund_hs u
                  where u.change_time >= l_collect_date
                    and u.change_time < (l_collect_date + 1)
                    and u.down_company_id != u.up_company_id
                    and u.down_company_id != 0
                    and u.up_company_id != 0
                    and (u.change_type =
                        pkg_up_fund_change_type.debit_amount or
                        u.change_type =
                        pkg_up_fund_change_type.refund_amount)
                  group by u.down_company_id,
                           u.up_company_id,
                           u.bill_type,
                           u.business_type) loop
      begin

        --2.计算统计类型
        l_statistics_type := 0;
        if item.bill_type = pkg_bill_type.back then

          l_statistics_type := pkg_statistics_type.FlowBag;
        else
          --***从业务类型与分类表中获取分类***
          select t.statistics_type
            into l_statistics_type
            from fd_system_business_statis_map t
           where t.local_business_type = item.business_type
             and rownum <= 1;
        end if;

        ---3.获取公司名称
        select t.sort_name
          into l_down_company_name
          from fd_base_company_info t
         where t.company_id = item.down_company_id;

        select t.sort_name
          into l_up_company_name
          from fd_base_company_info t
         where t.company_id = item.up_company_id;

        ---4.添加作为下游渠道的结算信息
        insert into fd_report_commi_profit_redo
          (record_id,
           company_id,
           channel_no,
           account_id,
           channel_type,
           business_type,
           bill_type,
           total_unit,
           total_face,
           draw_amount,
           real_amount,
           commission,
           profits,
           service_fee,
           refund_total_unit,
           refund_total_face,
           refund_draw_amount,
           refund_real_amount,
           refund_commission,
           refund_profits,
           refund_service_fee,
           up_many_face,
           up_many_amount,
           snap_time,
           statistics_type,
           channel_name,
           account_name)
        values
          (seq_report_commi_profit_id.nextval,
           item.up_company_id,
           '-',
           item.down_company_id,
           pkg_channel_type.settle_down,
           item.business_type,
           item.bill_type,
           item.draw_unit,
           item.draw_face,
           item.draw_amount,
           item.real_amount,
           0,
           0,
           0,
           item.unit_ref,
           item.face_ref,
           item.amount_ref,
           item.real_ref,
           0,
           0,
           0,
           0,
           0,
           l_collect_date,
           l_statistics_type,
           l_down_company_name,
           l_down_company_name);

        ---3.添加作为上游渠道的结算信息
        insert into fd_report_commi_profit_redo
          (record_id,
           company_id,
           channel_no,
           account_id,
           channel_type,
           business_type,
           bill_type,
           total_unit,
           total_face,
           draw_amount,
           real_amount,
           commission,
           profits,
           service_fee,
           refund_total_unit,
           refund_total_face,
           refund_draw_amount,
           refund_real_amount,
           refund_commission,
           refund_profits,
           refund_service_fee,
           up_many_face,
           up_many_amount,
           snap_time,
           statistics_type,
           channel_name,
           account_name)
        values
          (seq_report_commi_profit_id.nextval,
           item.down_company_id,
           '-',
           item.up_company_id,
           pkg_channel_type.settle_up,
           item.business_type,
           item.bill_type,
           item.draw_unit,
           item.draw_face,
           item.draw_amount,
           item.real_amount,
           0,
           0,
           0,
           item.unit_ref,
           item.face_ref,
           item.amount_ref,
           item.real_ref,
           0,
           0,
           0,
           0,
           0,
           l_collect_date,
           l_statistics_type,
           l_up_company_name,
           l_up_company_name);

        commit;

      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_settle', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');

    commit;
  end if;
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_ST_JI
prompt =============================================
prompt
create or replace procedure fd_account.zreport_commi_profit_st_ji(v_collect_date in varchar2 default null) as
  --------------------收集上游资金变动结算信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160602000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type   number := 0; --数据出现错误，统计类型为0
  l_wait_count        number := 0;
  l_start_time        date := sysdate;
  l_down_company_name varchar2(128);
  l_up_company_name   varchar2(128);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from fd_trade_up_fund_hs t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then
  
    ---1.收集上游资金变动信息
    for item in (select u.down_company_id,
                        u.up_company_id,
                        u.bill_type,
                        u.business_type,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   u.up_draw_unit,
                                   0)) draw_unit,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   u.up_draw_face,
                                   0)) draw_face,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount),
                                   0)) draw_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount),
                                   0)) real_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   u.up_draw_unit)) unit_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   u.up_draw_face)) face_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount))) amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.settle_amount,
                                          0,
                                          u.up_real_amount,
                                          u.settle_amount))) real_ref
                   from zreport_up_fund_join_hs u
                  where u.change_time >= l_collect_date
                    and u.change_time < (l_collect_date + 1)
                    and u.down_company_id != u.up_company_id
                    and u.down_company_id != 0
                    and u.up_company_id != 0
                    and (u.change_type =
                        pkg_up_fund_change_type.debit_amount or
                        u.change_type =
                        pkg_up_fund_change_type.refund_amount)
                  group by u.down_company_id,
                           u.up_company_id,
                           u.bill_type,
                           u.business_type) loop
      begin
      
        --2.计算统计类型
        l_statistics_type := 0;
        if item.bill_type = pkg_bill_type.back then
        
          l_statistics_type := pkg_statistics_type.FlowBag;
        else
          --***从业务类型与分类表中获取分类***
          select t.statistics_type
            into l_statistics_type
            from fd_system_business_statis_map t
           where t.local_business_type = item.business_type
             and rownum <= 1;
        end if;
      
        ---3.获取公司名称
        select t.sort_name
          into l_down_company_name
          from fd_base_company_info t
         where t.company_id = item.down_company_id;
      
        select t.sort_name
          into l_up_company_name
          from fd_base_company_info t
         where t.company_id = item.up_company_id;
      
        ---4.添加作为下游渠道的结算信息
        insert into fd_report_commi_profit_redo
          (record_id,
           company_id,
           channel_no,
           account_id,
           channel_type,
           business_type,
           bill_type,
           total_unit,
           total_face,
           draw_amount,
           real_amount,
           commission,
           profits,
           service_fee,
           refund_total_unit,
           refund_total_face,
           refund_draw_amount,
           refund_real_amount,
           refund_commission,
           refund_profits,
           refund_service_fee,
           up_many_face,
           up_many_amount,
           snap_time,
           statistics_type,
           channel_name,
           account_name)
        values
          (seq_report_commi_profit_id.nextval,
           item.up_company_id,
           '-',
           item.down_company_id,
           pkg_channel_type.settle_down,
           item.business_type,
           item.bill_type,
           item.draw_unit,
           item.draw_face,
           item.draw_amount,
           item.real_amount,
           0,
           0,
           0,
           item.unit_ref,
           item.face_ref,
           item.amount_ref,
           item.real_ref,
           0,
           0,
           0,
           0,
           0,
           l_collect_date,
           l_statistics_type,
           l_down_company_name,
           l_down_company_name);
      
        ---3.添加作为上游渠道的结算信息
        insert into fd_report_commi_profit_redo
          (record_id,
           company_id,
           channel_no,
           account_id,
           channel_type,
           business_type,
           bill_type,
           total_unit,
           total_face,
           draw_amount,
           real_amount,
           commission,
           profits,
           service_fee,
           refund_total_unit,
           refund_total_face,
           refund_draw_amount,
           refund_real_amount,
           refund_commission,
           refund_profits,
           refund_service_fee,
           up_many_face,
           up_many_amount,
           snap_time,
           statistics_type,
           channel_name,
           account_name)
        values
          (seq_report_commi_profit_id.nextval,
           item.down_company_id,
           '-',
           item.up_company_id,
           pkg_channel_type.settle_up,
           item.business_type,
           item.bill_type,
           item.draw_unit,
           item.draw_face,
           item.draw_amount,
           item.real_amount,
           0,
           0,
           0,
           item.unit_ref,
           item.face_ref,
           item.amount_ref,
           item.real_ref,
           0,
           0,
           0,
           0,
           0,
           l_collect_date,
           l_statistics_type,
           l_up_company_name,
           l_up_company_name);
      
        commit;
      
      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_settle', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');
  
    commit;
  end if;
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_settle', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_UP_AB
prompt =============================================
prompt
create or replace procedure fd_account.zreport_commi_profit_up_ab(v_collect_date in varchar2 default null) as
  --------------------收集上游资金变动佣金利润信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160602000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type number := 0; --数据出现错误，统计类型为0
  l_wait_count      number := 0;
  l_start_time      date := sysdate;
  l_channel_name    varchar2(100);
  l_account_name    varchar2(100);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  /*select count(1)
    into l_wait_count
    from up_fund_160818_23 t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then

    ---1.收集上游资金变动信息
    for item in (select u.up_company_id,
                        u.up_channel_no,
                        u.up_account_id,
                        u.business_type,
                        u.bill_type,
                        max(u.order_source) order_source,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_unit) up_draw_unit,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_face) up_draw_face,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_amount) up_draw_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_real_amount) up_real_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.down_company_id,
                                          u.up_company_id,
                                          u.up_real_amount,
                                          decode(u.settle_amount,
                                                 0,
                                                 u.up_real_amount,
                                                 u.settle_amount)),
                                   0)) settle_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_unit) up_draw_unit_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_face) up_draw_face_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_amount) up_draw_amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_real_amount) up_real_amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.down_company_id,
                                          u.up_company_id,
                                          u.up_real_amount,
                                          decode(u.settle_amount,
                                                 0,
                                                 u.up_real_amount,
                                                 u.settle_amount)))) settle_amount_ref
                   from up_fund_160818_23 u
                  where u.change_time >= l_collect_date
                    and u.change_time < (l_collect_date + 1)
                    and (u.change_type =
                        pkg_up_fund_change_type.debit_amount or
                        u.change_type =
                        pkg_up_fund_change_type.refund_amount)
                  group by u.up_company_id,
                           u.up_channel_no,
                           u.up_account_id,
                           u.business_type,
                           u.bill_type) loop
      begin
        ---2.添加下游佣金利润数据
        if item.up_channel_no != '0' and item.up_account_id != 0 then

          --3.计算统计类型
          l_statistics_type := 0;
          if item.bill_type = pkg_bill_type.back then

            l_statistics_type := pkg_statistics_type.FlowBag;
          else
            --***从业务类型与分类表中获取分类***
            select t.statistics_type
              into l_statistics_type
              from fd_system_business_statis_map t
             where t.local_business_type = item.business_type
               and rownum <= 1;
          end if;

          ---4.获取渠道账户名称
          select t.channel_name
            into l_channel_name
            from fd_base_up_channel t
           where t.channel_no = item.up_channel_no;

          select t.account_name
            into l_account_name
            from fd_base_up_account t
           where t.account_id = item.up_account_id;

          ---5.添加数据
          insert into fd_report_commi_profit_redo
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_unit,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits,
             service_fee,
             refund_total_unit,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             refund_profits,
             refund_service_fee,
             up_many_face,
             up_many_amount,
             snap_time,
             statistics_type,
             channel_name,
             account_name,
             channel_source_system)
          values
            (seq_report_commi_profit_id.nextval,
             item.up_company_id,
             item.up_channel_no,
             item.up_account_id,
             pkg_channel_type.up_channel,
             item.business_type,
             item.bill_type,
             item.up_draw_unit,
             item.up_draw_face,
             item.up_draw_amount,
             item.up_real_amount,
             (trunc(item.up_draw_amount, 2) - trunc(item.up_real_amount, 2)),
             (item.settle_amount - item.up_real_amount),
             0,
             item.up_draw_unit_ref,
             item.up_draw_face_ref,
             item.up_draw_amount_ref,
             item.up_real_amount_ref,
             (trunc(item.up_draw_amount_ref, 2) -
             trunc(item.up_real_amount_ref, 2)),
             (item.settle_amount_ref - item.up_real_amount_ref),
             0,
             0,
             0,
             l_collect_date,
             l_statistics_type,
             l_channel_name,
             l_account_name,
             item.order_source);
        end if;

        commit;

      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_up', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');

    commit;
  end if;*/
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_up', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_UP_HS
prompt =============================================
prompt
create or replace procedure fd_account.zreport_commi_profit_up_hs(v_collect_date in varchar2 default null) as
  --------------------收集上游资金变动佣金利润信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160602000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type number := 0; --数据出现错误，统计类型为0
  l_wait_count      number := 0;
  l_start_time      date := sysdate;
  l_channel_name    varchar2(100);
  l_account_name    varchar2(100);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from fd_trade_up_fund_hs t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then
  
    ---1.收集上游资金变动信息
    for item in (select u.up_company_id,
                        u.up_channel_no,
                        u.up_account_id,
                        u.business_type,
                        u.bill_type,
                        max(u.order_source) order_source,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_unit) up_draw_unit,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_face) up_draw_face,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_amount) up_draw_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_real_amount) up_real_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.down_company_id,
                                          u.up_company_id,
                                          u.up_real_amount,
                                          decode(u.settle_amount,
                                                 0,
                                                 u.up_real_amount,
                                                 u.settle_amount)),
                                   0)) settle_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_unit) up_draw_unit_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_face) up_draw_face_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_amount) up_draw_amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_real_amount) up_real_amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.down_company_id,
                                          u.up_company_id,
                                          u.up_real_amount,
                                          decode(u.settle_amount,
                                                 0,
                                                 u.up_real_amount,
                                                 u.settle_amount)))) settle_amount_ref
                   from fd_trade_up_fund_hs u
                  where u.change_time >= l_collect_date
                    and u.change_time < (l_collect_date + 1)
                    and (u.change_type =
                        pkg_up_fund_change_type.debit_amount or
                        u.change_type =
                        pkg_up_fund_change_type.refund_amount)
                  group by u.up_company_id,
                           u.up_channel_no,
                           u.up_account_id,
                           u.business_type,
                           u.bill_type) loop
      begin
        ---2.添加下游佣金利润数据
        if item.up_channel_no != '0' and item.up_account_id != 0 then
        
          --3.计算统计类型
          l_statistics_type := 0;
          if item.bill_type = pkg_bill_type.back then
          
            l_statistics_type := pkg_statistics_type.FlowBag;
          else
            --***从业务类型与分类表中获取分类***
            select t.statistics_type
              into l_statistics_type
              from fd_system_business_statis_map t
             where t.local_business_type = item.business_type
               and rownum <= 1;
          end if;
        
          ---4.获取渠道账户名称
          select t.channel_name
            into l_channel_name
            from fd_base_up_channel t
           where t.channel_no = item.up_channel_no;
        
          select t.account_name
            into l_account_name
            from fd_base_up_account t
           where t.account_id = item.up_account_id;
        
          ---5.添加数据
          insert into fd_report_commi_profit_redo
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_unit,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits,
             service_fee,
             refund_total_unit,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             refund_profits,
             refund_service_fee,
             up_many_face,
             up_many_amount,
             snap_time,
             statistics_type,
             channel_name,
             account_name,
             channel_source_system)
          values
            (seq_report_commi_profit_id.nextval,
             item.up_company_id,
             item.up_channel_no,
             item.up_account_id,
             pkg_channel_type.up_channel,
             item.business_type,
             item.bill_type,
             item.up_draw_unit,
             item.up_draw_face,
             item.up_draw_amount,
             item.up_real_amount,
             (trunc(item.up_draw_amount, 2) - trunc(item.up_real_amount, 2)),
             (item.settle_amount - item.up_real_amount),
             0,
             item.up_draw_unit_ref,
             item.up_draw_face_ref,
             item.up_draw_amount_ref,
             item.up_real_amount_ref,
             (trunc(item.up_draw_amount_ref, 2) -
             trunc(item.up_real_amount_ref, 2)),
             (item.settle_amount_ref - item.up_real_amount_ref),
             0,
             0,
             0,
             l_collect_date,
             l_statistics_type,
             l_channel_name,
             l_account_name,
             item.order_source);
        end if;
      
        commit;
      
      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_up', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');
  
    commit;
  end if;
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_up', sqlerrm, 1);
end;
/

prompt
prompt Creating procedure ZREPORT_COMMI_PROFIT_UP_JI
prompt =============================================
prompt
create or replace procedure fd_account.zreport_commi_profit_up_ji(v_collect_date in varchar2 default null) as
  --------------------收集上游资金变动佣金利润信息---------------------
  l_collect_date date := to_date(v_collect_date, 'yyyymmddhh24miss');
  --l_collect_date    date := trunc(to_date('20160602000000',
  --                                        'yyyymmddhh24miss')) - 1;
  l_statistics_type number := 0; --数据出现错误，统计类型为0
  l_wait_count      number := 0;
  l_start_time      date := sysdate;
  l_channel_name    varchar2(100);
  l_account_name    varchar2(100);
begin
  if l_collect_date is null then
    l_collect_date := trunc(sysdate) - 1;
  end if;

  ---0.未结算数据检查
  select count(1)
    into l_wait_count
    from fd_trade_up_fund_hs t
   where t.change_time >= l_collect_date
     and t.change_time < (l_collect_date + 1)
     and t.settle_status = pkg_settle_status.wait_settle
     and rownum <= 2;

  if l_wait_count = 0 then
  
    ---1.收集上游资金变动信息
    for item in (select u.up_company_id,
                        u.up_channel_no,
                        u.up_account_id,
                        u.business_type,
                        u.bill_type,
                        max(u.order_source) order_source,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_unit) up_draw_unit,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_face) up_draw_face,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_draw_amount) up_draw_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   1,
                                   0) * u.up_real_amount) up_real_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   decode(u.down_company_id,
                                          u.up_company_id,
                                          u.up_real_amount,
                                          decode(u.settle_amount,
                                                 0,
                                                 u.up_real_amount,
                                                 u.settle_amount)),
                                   0)) settle_amount,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_unit) up_draw_unit_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_face) up_draw_face_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_draw_amount) up_draw_amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   1) * u.up_real_amount) up_real_amount_ref,
                        sum(decode(u.change_type,
                                   pkg_up_fund_change_type.debit_amount,
                                   0,
                                   decode(u.down_company_id,
                                          u.up_company_id,
                                          u.up_real_amount,
                                          decode(u.settle_amount,
                                                 0,
                                                 u.up_real_amount,
                                                 u.settle_amount)))) settle_amount_ref
                   from zreport_up_fund_join_hs u
                  where u.change_time >= l_collect_date
                    and u.change_time < (l_collect_date + 1)
                    and (u.change_type =
                        pkg_up_fund_change_type.debit_amount or
                        u.change_type =
                        pkg_up_fund_change_type.refund_amount)
                  group by u.up_company_id,
                           u.up_channel_no,
                           u.up_account_id,
                           u.business_type,
                           u.bill_type) loop
      begin
        ---2.添加下游佣金利润数据
        if item.up_channel_no != '0' and item.up_account_id != 0 then
        
          --3.计算统计类型
          l_statistics_type := 0;
          if item.bill_type = pkg_bill_type.back then
          
            l_statistics_type := pkg_statistics_type.FlowBag;
          else
            --***从业务类型与分类表中获取分类***
            select t.statistics_type
              into l_statistics_type
              from fd_system_business_statis_map t
             where t.local_business_type = item.business_type
               and rownum <= 1;
          end if;
        
          ---4.获取渠道账户名称
          select t.channel_name
            into l_channel_name
            from fd_base_up_channel t
           where t.channel_no = item.up_channel_no;
        
          select t.account_name
            into l_account_name
            from fd_base_up_account t
           where t.account_id = item.up_account_id;
        
          ---5.添加数据
          insert into fd_report_commi_profit_redo
            (record_id,
             company_id,
             channel_no,
             account_id,
             channel_type,
             business_type,
             bill_type,
             total_unit,
             total_face,
             draw_amount,
             real_amount,
             commission,
             profits,
             service_fee,
             refund_total_unit,
             refund_total_face,
             refund_draw_amount,
             refund_real_amount,
             refund_commission,
             refund_profits,
             refund_service_fee,
             up_many_face,
             up_many_amount,
             snap_time,
             statistics_type,
             channel_name,
             account_name,
             channel_source_system)
          values
            (seq_report_commi_profit_id.nextval,
             item.up_company_id,
             item.up_channel_no,
             item.up_account_id,
             pkg_channel_type.up_channel,
             item.business_type,
             item.bill_type,
             item.up_draw_unit,
             item.up_draw_face,
             item.up_draw_amount,
             item.up_real_amount,
             (trunc(item.up_draw_amount, 2) - trunc(item.up_real_amount, 2)),
             (item.settle_amount - item.up_real_amount),
             0,
             item.up_draw_unit_ref,
             item.up_draw_face_ref,
             item.up_draw_amount_ref,
             item.up_real_amount_ref,
             (trunc(item.up_draw_amount_ref, 2) -
             trunc(item.up_real_amount_ref, 2)),
             (item.settle_amount_ref - item.up_real_amount_ref),
             0,
             0,
             0,
             l_collect_date,
             l_statistics_type,
             l_channel_name,
             l_account_name,
             item.order_source);
        end if;
      
        commit;
      
      exception
        when others then
          rollback;
          fd_p_write_log('fd_p_auto_commi_profit_up', sqlerrm, 1);
      end;
    end loop;
  else
    insert into fd_system_warn
      (warn_id,
       uniq_id,
       warn_level,
       warn_type,
       title,
       warn_date,
       content,
       sync_status,
       key_word)
    values
      (seq_system_warn_id.nextval,
       'co_settle_fail',
       5,
       pkg_warn_into_type.settle_warn,
       '公司间交易未进行结算',
       sysdate,
       '公司间交易未进行结算',
       pkg_balance_sync_status.wait,
       '交易未结算');
  
    commit;
  end if;
  fd_p_proc_log('fd_p_auto_commi_profit_down', l_start_time, 'T', '');
exception
  when others then
    rollback;
    fd_p_write_log('fd_p_auto_commi_profit_up', sqlerrm, 1);
end;
/


prompt Done
spool off
set define on
